// *** IR Dump After mlir::iree_compiler::IREE::SIP::MaterializeReflectionAttrsPass ***
func @predict(%arg0: tensor<1x28x28x1xf32>) -> tensor<1x10xf32> attributes {iree.module.export, iree.reflection = {abi = "sip", abiv = 1 : i32, f = "I15!B11!d1d28d28d1R9!B6!d1d10", fv = "1", sip = "I8!S5!k0_0R3!_0"}} {
  %0 = flow.variable.address @"__iree_flow___sm_node17__model.layer-1.kernel" : !iree.ptr<tensor<784x128xf32>>
  %1 = flow.variable.address @"__iree_flow___sm_node18__model.layer-1.bias" : !iree.ptr<tensor<128xf32>>
  %2 = flow.variable.address @"__iree_flow___sm_node24__model.layer-2.kernel" : !iree.ptr<tensor<128x10xf32>>
  %3 = flow.variable.address @"__iree_flow___sm_node25__model.layer-2.bias" : !iree.ptr<tensor<10xf32>>
  %4 = mhlo.constant dense<0.000000e+00> : tensor<1x128xf32>
  %5 = mhlo.constant dense<0xFF800000> : tensor<f32>
  %6 = mhlo.constant dense<0.000000e+00> : tensor<f32>
  %7 = flow.variable.load.indirect %3 : !iree.ptr<tensor<10xf32>> -> tensor<10xf32>
  %8 = flow.variable.load.indirect %2 : !iree.ptr<tensor<128x10xf32>> -> tensor<128x10xf32>
  %9 = flow.variable.load.indirect %1 : !iree.ptr<tensor<128xf32>> -> tensor<128xf32>
  %10 = flow.variable.load.indirect %0 : !iree.ptr<tensor<784x128xf32>> -> tensor<784x128xf32>
  %11 = "mhlo.reshape"(%arg0) : (tensor<1x28x28x1xf32>) -> tensor<1x784xf32>
  %12 = "mhlo.dot"(%11, %10) : (tensor<1x784xf32>, tensor<784x128xf32>) -> tensor<1x128xf32>
  %13 = "mhlo.broadcast_in_dim"(%9) {broadcast_dimensions = dense<1> : tensor<1xi64>} : (tensor<128xf32>) -> tensor<1x128xf32>
  %14 = mhlo.add %12, %13 : tensor<1x128xf32>
  %15 = mhlo.maximum %14, %4 : tensor<1x128xf32>
  %16 = "mhlo.dot"(%15, %8) : (tensor<1x128xf32>, tensor<128x10xf32>) -> tensor<1x10xf32>
  %17 = "mhlo.broadcast_in_dim"(%7) {broadcast_dimensions = dense<1> : tensor<1xi64>} : (tensor<10xf32>) -> tensor<1x10xf32>
  %18 = mhlo.add %16, %17 : tensor<1x10xf32>
  %19 = "mhlo.reduce"(%18, %5) ( {
  ^bb0(%arg1: tensor<f32>, %arg2: tensor<f32>):  // no predecessors
    %26 = mhlo.maximum %arg1, %arg2 : tensor<f32>
    "mhlo.return"(%26) : (tensor<f32>) -> ()
  }) {dimensions = dense<1> : tensor<1xi64>} : (tensor<1x10xf32>, tensor<f32>) -> tensor<1xf32>
  %20 = "mhlo.broadcast_in_dim"(%19) {broadcast_dimensions = dense<0> : tensor<1xi64>} : (tensor<1xf32>) -> tensor<1x10xf32>
  %21 = mhlo.subtract %18, %20 : tensor<1x10xf32>
  %22 = "mhlo.exponential"(%21) : (tensor<1x10xf32>) -> tensor<1x10xf32>
  %23 = "mhlo.reduce"(%22, %6) ( {
  ^bb0(%arg1: tensor<f32>, %arg2: tensor<f32>):  // no predecessors
    %26 = mhlo.add %arg1, %arg2 : tensor<f32>
    "mhlo.return"(%26) : (tensor<f32>) -> ()
  }) {dimensions = dense<1> : tensor<1xi64>} : (tensor<1x10xf32>, tensor<f32>) -> tensor<1xf32>
  %24 = "mhlo.broadcast_in_dim"(%23) {broadcast_dimensions = dense<0> : tensor<1xi64>} : (tensor<1xf32>) -> tensor<1x10xf32>
  %25 = mhlo.divide %22, %24 : tensor<1x10xf32>
  return %25 : tensor<1x10xf32>
}

// *** IR Dump After Canonicalizer ***
func @predict(%arg0: tensor<1x28x28x1xf32>) -> tensor<1x10xf32> attributes {iree.module.export, iree.reflection = {abi = "sip", abiv = 1 : i32, f = "I15!B11!d1d28d28d1R9!B6!d1d10", fv = "1", sip = "I8!S5!k0_0R3!_0"}} {
  %0 = mhlo.constant dense<0.000000e+00> : tensor<1x128xf32>
  %1 = mhlo.constant dense<0xFF800000> : tensor<f32>
  %2 = mhlo.constant dense<0.000000e+00> : tensor<f32>
  %cst = constant opaque<"_", "0xDEADBEEF"> : tensor<10xf32>
  %cst_0 = constant opaque<"_", "0xDEADBEEF"> : tensor<128x10xf32>
  %cst_1 = constant opaque<"_", "0xDEADBEEF"> : tensor<128xf32>
  %cst_2 = constant opaque<"_", "0xDEADBEEF"> : tensor<784x128xf32>
  %3 = "mhlo.reshape"(%arg0) : (tensor<1x28x28x1xf32>) -> tensor<1x784xf32>
  %4 = "mhlo.dot"(%3, %cst_2) : (tensor<1x784xf32>, tensor<784x128xf32>) -> tensor<1x128xf32>
  %5 = "mhlo.broadcast_in_dim"(%cst_1) {broadcast_dimensions = dense<1> : tensor<1xi64>} : (tensor<128xf32>) -> tensor<1x128xf32>
  %6 = mhlo.add %4, %5 : tensor<1x128xf32>
  %7 = mhlo.maximum %6, %0 : tensor<1x128xf32>
  %8 = "mhlo.dot"(%7, %cst_0) : (tensor<1x128xf32>, tensor<128x10xf32>) -> tensor<1x10xf32>
  %9 = "mhlo.broadcast_in_dim"(%cst) {broadcast_dimensions = dense<1> : tensor<1xi64>} : (tensor<10xf32>) -> tensor<1x10xf32>
  %10 = mhlo.add %8, %9 : tensor<1x10xf32>
  %11 = "mhlo.reduce"(%10, %1) ( {
  ^bb0(%arg1: tensor<f32>, %arg2: tensor<f32>):  // no predecessors
    %18 = mhlo.maximum %arg1, %arg2 : tensor<f32>
    "mhlo.return"(%18) : (tensor<f32>) -> ()
  }) {dimensions = dense<1> : tensor<1xi64>} : (tensor<1x10xf32>, tensor<f32>) -> tensor<1xf32>
  %12 = "mhlo.broadcast_in_dim"(%11) {broadcast_dimensions = dense<0> : tensor<1xi64>} : (tensor<1xf32>) -> tensor<1x10xf32>
  %13 = mhlo.subtract %10, %12 : tensor<1x10xf32>
  %14 = "mhlo.exponential"(%13) : (tensor<1x10xf32>) -> tensor<1x10xf32>
  %15 = "mhlo.reduce"(%14, %2) ( {
  ^bb0(%arg1: tensor<f32>, %arg2: tensor<f32>):  // no predecessors
    %18 = mhlo.add %arg1, %arg2 : tensor<f32>
    "mhlo.return"(%18) : (tensor<f32>) -> ()
  }) {dimensions = dense<1> : tensor<1xi64>} : (tensor<1x10xf32>, tensor<f32>) -> tensor<1xf32>
  %16 = "mhlo.broadcast_in_dim"(%15) {broadcast_dimensions = dense<0> : tensor<1xi64>} : (tensor<1xf32>) -> tensor<1x10xf32>
  %17 = mhlo.divide %14, %16 : tensor<1x10xf32>
  return %17 : tensor<1x10xf32>
}

// *** IR Dump After CSE ***
func @predict(%arg0: tensor<1x28x28x1xf32>) -> tensor<1x10xf32> attributes {iree.module.export, iree.reflection = {abi = "sip", abiv = 1 : i32, f = "I15!B11!d1d28d28d1R9!B6!d1d10", fv = "1", sip = "I8!S5!k0_0R3!_0"}} {
  %0 = mhlo.constant dense<0.000000e+00> : tensor<1x128xf32>
  %1 = mhlo.constant dense<0xFF800000> : tensor<f32>
  %2 = mhlo.constant dense<0.000000e+00> : tensor<f32>
  %cst = constant opaque<"_", "0xDEADBEEF"> : tensor<10xf32>
  %cst_0 = constant opaque<"_", "0xDEADBEEF"> : tensor<128x10xf32>
  %cst_1 = constant opaque<"_", "0xDEADBEEF"> : tensor<128xf32>
  %cst_2 = constant opaque<"_", "0xDEADBEEF"> : tensor<784x128xf32>
  %3 = "mhlo.reshape"(%arg0) : (tensor<1x28x28x1xf32>) -> tensor<1x784xf32>
  %4 = "mhlo.dot"(%3, %cst_2) : (tensor<1x784xf32>, tensor<784x128xf32>) -> tensor<1x128xf32>
  %5 = "mhlo.broadcast_in_dim"(%cst_1) {broadcast_dimensions = dense<1> : tensor<1xi64>} : (tensor<128xf32>) -> tensor<1x128xf32>
  %6 = mhlo.add %4, %5 : tensor<1x128xf32>
  %7 = mhlo.maximum %6, %0 : tensor<1x128xf32>
  %8 = "mhlo.dot"(%7, %cst_0) : (tensor<1x128xf32>, tensor<128x10xf32>) -> tensor<1x10xf32>
  %9 = "mhlo.broadcast_in_dim"(%cst) {broadcast_dimensions = dense<1> : tensor<1xi64>} : (tensor<10xf32>) -> tensor<1x10xf32>
  %10 = mhlo.add %8, %9 : tensor<1x10xf32>
  %11 = "mhlo.reduce"(%10, %1) ( {
  ^bb0(%arg1: tensor<f32>, %arg2: tensor<f32>):  // no predecessors
    %18 = mhlo.maximum %arg1, %arg2 : tensor<f32>
    "mhlo.return"(%18) : (tensor<f32>) -> ()
  }) {dimensions = dense<1> : tensor<1xi64>} : (tensor<1x10xf32>, tensor<f32>) -> tensor<1xf32>
  %12 = "mhlo.broadcast_in_dim"(%11) {broadcast_dimensions = dense<0> : tensor<1xi64>} : (tensor<1xf32>) -> tensor<1x10xf32>
  %13 = mhlo.subtract %10, %12 : tensor<1x10xf32>
  %14 = "mhlo.exponential"(%13) : (tensor<1x10xf32>) -> tensor<1x10xf32>
  %15 = "mhlo.reduce"(%14, %2) ( {
  ^bb0(%arg1: tensor<f32>, %arg2: tensor<f32>):  // no predecessors
    %18 = mhlo.add %arg1, %arg2 : tensor<f32>
    "mhlo.return"(%18) : (tensor<f32>) -> ()
  }) {dimensions = dense<1> : tensor<1xi64>} : (tensor<1x10xf32>, tensor<f32>) -> tensor<1xf32>
  %16 = "mhlo.broadcast_in_dim"(%15) {broadcast_dimensions = dense<0> : tensor<1xi64>} : (tensor<1xf32>) -> tensor<1x10xf32>
  %17 = mhlo.divide %14, %16 : tensor<1x10xf32>
  return %17 : tensor<1x10xf32>
}

// *** IR Dump After SymbolDCE ***
module  {
  func @predict(%arg0: tensor<1x28x28x1xf32>) -> tensor<1x10xf32> attributes {iree.module.export, iree.reflection = {abi = "sip", abiv = 1 : i32, f = "I15!B11!d1d28d28d1R9!B6!d1d10", fv = "1", sip = "I8!S5!k0_0R3!_0"}} {
    %0 = mhlo.constant dense<0.000000e+00> : tensor<1x128xf32>
    %1 = mhlo.constant dense<0xFF800000> : tensor<f32>
    %2 = mhlo.constant dense<0.000000e+00> : tensor<f32>
    %cst = constant opaque<"_", "0xDEADBEEF"> : tensor<10xf32>
    %cst_0 = constant opaque<"_", "0xDEADBEEF"> : tensor<128x10xf32>
    %cst_1 = constant opaque<"_", "0xDEADBEEF"> : tensor<128xf32>
    %cst_2 = constant opaque<"_", "0xDEADBEEF"> : tensor<784x128xf32>
    %3 = "mhlo.reshape"(%arg0) : (tensor<1x28x28x1xf32>) -> tensor<1x784xf32>
    %4 = "mhlo.dot"(%3, %cst_2) : (tensor<1x784xf32>, tensor<784x128xf32>) -> tensor<1x128xf32>
    %5 = "mhlo.broadcast_in_dim"(%cst_1) {broadcast_dimensions = dense<1> : tensor<1xi64>} : (tensor<128xf32>) -> tensor<1x128xf32>
    %6 = mhlo.add %4, %5 : tensor<1x128xf32>
    %7 = mhlo.maximum %6, %0 : tensor<1x128xf32>
    %8 = "mhlo.dot"(%7, %cst_0) : (tensor<1x128xf32>, tensor<128x10xf32>) -> tensor<1x10xf32>
    %9 = "mhlo.broadcast_in_dim"(%cst) {broadcast_dimensions = dense<1> : tensor<1xi64>} : (tensor<10xf32>) -> tensor<1x10xf32>
    %10 = mhlo.add %8, %9 : tensor<1x10xf32>
    %11 = "mhlo.reduce"(%10, %1) ( {
    ^bb0(%arg1: tensor<f32>, %arg2: tensor<f32>):  // no predecessors
      %18 = mhlo.maximum %arg1, %arg2 : tensor<f32>
      "mhlo.return"(%18) : (tensor<f32>) -> ()
    }) {dimensions = dense<1> : tensor<1xi64>} : (tensor<1x10xf32>, tensor<f32>) -> tensor<1xf32>
    %12 = "mhlo.broadcast_in_dim"(%11) {broadcast_dimensions = dense<0> : tensor<1xi64>} : (tensor<1xf32>) -> tensor<1x10xf32>
    %13 = mhlo.subtract %10, %12 : tensor<1x10xf32>
    %14 = "mhlo.exponential"(%13) : (tensor<1x10xf32>) -> tensor<1x10xf32>
    %15 = "mhlo.reduce"(%14, %2) ( {
    ^bb0(%arg1: tensor<f32>, %arg2: tensor<f32>):  // no predecessors
      %18 = mhlo.add %arg1, %arg2 : tensor<f32>
      "mhlo.return"(%18) : (tensor<f32>) -> ()
    }) {dimensions = dense<1> : tensor<1xi64>} : (tensor<1x10xf32>, tensor<f32>) -> tensor<1xf32>
    %16 = "mhlo.broadcast_in_dim"(%15) {broadcast_dimensions = dense<0> : tensor<1xi64>} : (tensor<1xf32>) -> tensor<1x10xf32>
    %17 = mhlo.divide %14, %16 : tensor<1x10xf32>
    return %17 : tensor<1x10xf32>
  }
}


// *** IR Dump After HLOToHLOPreprocessing ***
func @predict(%arg0: tensor<1x28x28x1xf32>) -> tensor<1x10xf32> attributes {iree.module.export, iree.reflection = {abi = "sip", abiv = 1 : i32, f = "I15!B11!d1d28d28d1R9!B6!d1d10", fv = "1", sip = "I8!S5!k0_0R3!_0"}} {
  %0 = mhlo.constant dense<0.000000e+00> : tensor<1x128xf32>
  %1 = mhlo.constant dense<0xFF800000> : tensor<f32>
  %2 = mhlo.constant dense<0.000000e+00> : tensor<f32>
  %cst = constant opaque<"_", "0xDEADBEEF"> : tensor<10xf32>
  %cst_0 = constant opaque<"_", "0xDEADBEEF"> : tensor<128x10xf32>
  %cst_1 = constant opaque<"_", "0xDEADBEEF"> : tensor<128xf32>
  %cst_2 = constant opaque<"_", "0xDEADBEEF"> : tensor<784x128xf32>
  %3 = "mhlo.reshape"(%arg0) : (tensor<1x28x28x1xf32>) -> tensor<1x784xf32>
  %4 = "mhlo.dot"(%3, %cst_2) : (tensor<1x784xf32>, tensor<784x128xf32>) -> tensor<1x128xf32>
  %5 = "mhlo.broadcast_in_dim"(%cst_1) {broadcast_dimensions = dense<1> : tensor<1xi64>} : (tensor<128xf32>) -> tensor<1x128xf32>
  %6 = mhlo.add %4, %5 : tensor<1x128xf32>
  %7 = mhlo.maximum %6, %0 : tensor<1x128xf32>
  %8 = "mhlo.dot"(%7, %cst_0) : (tensor<1x128xf32>, tensor<128x10xf32>) -> tensor<1x10xf32>
  %9 = "mhlo.broadcast_in_dim"(%cst) {broadcast_dimensions = dense<1> : tensor<1xi64>} : (tensor<10xf32>) -> tensor<1x10xf32>
  %10 = mhlo.add %8, %9 : tensor<1x10xf32>
  %11 = "mhlo.reduce"(%10, %1) ( {
  ^bb0(%arg1: tensor<f32>, %arg2: tensor<f32>):  // no predecessors
    %18 = mhlo.maximum %arg1, %arg2 : tensor<f32>
    "mhlo.return"(%18) : (tensor<f32>) -> ()
  }) {dimensions = dense<1> : tensor<1xi64>} : (tensor<1x10xf32>, tensor<f32>) -> tensor<1xf32>
  %12 = "mhlo.broadcast_in_dim"(%11) {broadcast_dimensions = dense<0> : tensor<1xi64>} : (tensor<1xf32>) -> tensor<1x10xf32>
  %13 = mhlo.subtract %10, %12 : tensor<1x10xf32>
  %14 = "mhlo.exponential"(%13) : (tensor<1x10xf32>) -> tensor<1x10xf32>
  %15 = "mhlo.reduce"(%14, %2) ( {
  ^bb0(%arg1: tensor<f32>, %arg2: tensor<f32>):  // no predecessors
    %18 = mhlo.add %arg1, %arg2 : tensor<f32>
    "mhlo.return"(%18) : (tensor<f32>) -> ()
  }) {dimensions = dense<1> : tensor<1xi64>} : (tensor<1x10xf32>, tensor<f32>) -> tensor<1xf32>
  %16 = "mhlo.broadcast_in_dim"(%15) {broadcast_dimensions = dense<0> : tensor<1xi64>} : (tensor<1xf32>) -> tensor<1x10xf32>
  %17 = mhlo.divide %14, %16 : tensor<1x10xf32>
  return %17 : tensor<1x10xf32>
}

// *** IR Dump After RemoveShapeConstraints ***
func @predict(%arg0: tensor<1x28x28x1xf32>) -> tensor<1x10xf32> attributes {iree.module.export, iree.reflection = {abi = "sip", abiv = 1 : i32, f = "I15!B11!d1d28d28d1R9!B6!d1d10", fv = "1", sip = "I8!S5!k0_0R3!_0"}} {
  %0 = mhlo.constant dense<0.000000e+00> : tensor<1x128xf32>
  %1 = mhlo.constant dense<0xFF800000> : tensor<f32>
  %2 = mhlo.constant dense<0.000000e+00> : tensor<f32>
  %cst = constant opaque<"_", "0xDEADBEEF"> : tensor<10xf32>
  %cst_0 = constant opaque<"_", "0xDEADBEEF"> : tensor<128x10xf32>
  %cst_1 = constant opaque<"_", "0xDEADBEEF"> : tensor<128xf32>
  %cst_2 = constant opaque<"_", "0xDEADBEEF"> : tensor<784x128xf32>
  %3 = "mhlo.reshape"(%arg0) : (tensor<1x28x28x1xf32>) -> tensor<1x784xf32>
  %4 = "mhlo.dot"(%3, %cst_2) : (tensor<1x784xf32>, tensor<784x128xf32>) -> tensor<1x128xf32>
  %5 = "mhlo.broadcast_in_dim"(%cst_1) {broadcast_dimensions = dense<1> : tensor<1xi64>} : (tensor<128xf32>) -> tensor<1x128xf32>
  %6 = mhlo.add %4, %5 : tensor<1x128xf32>
  %7 = mhlo.maximum %6, %0 : tensor<1x128xf32>
  %8 = "mhlo.dot"(%7, %cst_0) : (tensor<1x128xf32>, tensor<128x10xf32>) -> tensor<1x10xf32>
  %9 = "mhlo.broadcast_in_dim"(%cst) {broadcast_dimensions = dense<1> : tensor<1xi64>} : (tensor<10xf32>) -> tensor<1x10xf32>
  %10 = mhlo.add %8, %9 : tensor<1x10xf32>
  %11 = "mhlo.reduce"(%10, %1) ( {
  ^bb0(%arg1: tensor<f32>, %arg2: tensor<f32>):  // no predecessors
    %18 = mhlo.maximum %arg1, %arg2 : tensor<f32>
    "mhlo.return"(%18) : (tensor<f32>) -> ()
  }) {dimensions = dense<1> : tensor<1xi64>} : (tensor<1x10xf32>, tensor<f32>) -> tensor<1xf32>
  %12 = "mhlo.broadcast_in_dim"(%11) {broadcast_dimensions = dense<0> : tensor<1xi64>} : (tensor<1xf32>) -> tensor<1x10xf32>
  %13 = mhlo.subtract %10, %12 : tensor<1x10xf32>
  %14 = "mhlo.exponential"(%13) : (tensor<1x10xf32>) -> tensor<1x10xf32>
  %15 = "mhlo.reduce"(%14, %2) ( {
  ^bb0(%arg1: tensor<f32>, %arg2: tensor<f32>):  // no predecessors
    %18 = mhlo.add %arg1, %arg2 : tensor<f32>
    "mhlo.return"(%18) : (tensor<f32>) -> ()
  }) {dimensions = dense<1> : tensor<1xi64>} : (tensor<1x10xf32>, tensor<f32>) -> tensor<1xf32>
  %16 = "mhlo.broadcast_in_dim"(%15) {broadcast_dimensions = dense<0> : tensor<1xi64>} : (tensor<1xf32>) -> tensor<1x10xf32>
  %17 = mhlo.divide %14, %16 : tensor<1x10xf32>
  return %17 : tensor<1x10xf32>
}

// *** IR Dump After TosaToSCF ***
func @predict(%arg0: tensor<1x28x28x1xf32>) -> tensor<1x10xf32> attributes {iree.module.export, iree.reflection = {abi = "sip", abiv = 1 : i32, f = "I15!B11!d1d28d28d1R9!B6!d1d10", fv = "1", sip = "I8!S5!k0_0R3!_0"}} {
  %0 = mhlo.constant dense<0.000000e+00> : tensor<1x128xf32>
  %1 = mhlo.constant dense<0xFF800000> : tensor<f32>
  %2 = mhlo.constant dense<0.000000e+00> : tensor<f32>
  %cst = constant opaque<"_", "0xDEADBEEF"> : tensor<10xf32>
  %cst_0 = constant opaque<"_", "0xDEADBEEF"> : tensor<128x10xf32>
  %cst_1 = constant opaque<"_", "0xDEADBEEF"> : tensor<128xf32>
  %cst_2 = constant opaque<"_", "0xDEADBEEF"> : tensor<784x128xf32>
  %3 = "mhlo.reshape"(%arg0) : (tensor<1x28x28x1xf32>) -> tensor<1x784xf32>
  %4 = "mhlo.dot"(%3, %cst_2) : (tensor<1x784xf32>, tensor<784x128xf32>) -> tensor<1x128xf32>
  %5 = "mhlo.broadcast_in_dim"(%cst_1) {broadcast_dimensions = dense<1> : tensor<1xi64>} : (tensor<128xf32>) -> tensor<1x128xf32>
  %6 = mhlo.add %4, %5 : tensor<1x128xf32>
  %7 = mhlo.maximum %6, %0 : tensor<1x128xf32>
  %8 = "mhlo.dot"(%7, %cst_0) : (tensor<1x128xf32>, tensor<128x10xf32>) -> tensor<1x10xf32>
  %9 = "mhlo.broadcast_in_dim"(%cst) {broadcast_dimensions = dense<1> : tensor<1xi64>} : (tensor<10xf32>) -> tensor<1x10xf32>
  %10 = mhlo.add %8, %9 : tensor<1x10xf32>
  %11 = "mhlo.reduce"(%10, %1) ( {
  ^bb0(%arg1: tensor<f32>, %arg2: tensor<f32>):  // no predecessors
    %18 = mhlo.maximum %arg1, %arg2 : tensor<f32>
    "mhlo.return"(%18) : (tensor<f32>) -> ()
  }) {dimensions = dense<1> : tensor<1xi64>} : (tensor<1x10xf32>, tensor<f32>) -> tensor<1xf32>
  %12 = "mhlo.broadcast_in_dim"(%11) {broadcast_dimensions = dense<0> : tensor<1xi64>} : (tensor<1xf32>) -> tensor<1x10xf32>
  %13 = mhlo.subtract %10, %12 : tensor<1x10xf32>
  %14 = "mhlo.exponential"(%13) : (tensor<1x10xf32>) -> tensor<1x10xf32>
  %15 = "mhlo.reduce"(%14, %2) ( {
  ^bb0(%arg1: tensor<f32>, %arg2: tensor<f32>):  // no predecessors
    %18 = mhlo.add %arg1, %arg2 : tensor<f32>
    "mhlo.return"(%18) : (tensor<f32>) -> ()
  }) {dimensions = dense<1> : tensor<1xi64>} : (tensor<1x10xf32>, tensor<f32>) -> tensor<1xf32>
  %16 = "mhlo.broadcast_in_dim"(%15) {broadcast_dimensions = dense<0> : tensor<1xi64>} : (tensor<1xf32>) -> tensor<1x10xf32>
  %17 = mhlo.divide %14, %16 : tensor<1x10xf32>
  return %17 : tensor<1x10xf32>
}

// *** IR Dump After TosaToStandard ***
func @predict(%arg0: tensor<1x28x28x1xf32>) -> tensor<1x10xf32> attributes {iree.module.export, iree.reflection = {abi = "sip", abiv = 1 : i32, f = "I15!B11!d1d28d28d1R9!B6!d1d10", fv = "1", sip = "I8!S5!k0_0R3!_0"}} {
  %0 = mhlo.constant dense<0.000000e+00> : tensor<1x128xf32>
  %1 = mhlo.constant dense<0xFF800000> : tensor<f32>
  %2 = mhlo.constant dense<0.000000e+00> : tensor<f32>
  %cst = constant opaque<"_", "0xDEADBEEF"> : tensor<10xf32>
  %cst_0 = constant opaque<"_", "0xDEADBEEF"> : tensor<128x10xf32>
  %cst_1 = constant opaque<"_", "0xDEADBEEF"> : tensor<128xf32>
  %cst_2 = constant opaque<"_", "0xDEADBEEF"> : tensor<784x128xf32>
  %3 = "mhlo.reshape"(%arg0) : (tensor<1x28x28x1xf32>) -> tensor<1x784xf32>
  %4 = "mhlo.dot"(%3, %cst_2) : (tensor<1x784xf32>, tensor<784x128xf32>) -> tensor<1x128xf32>
  %5 = "mhlo.broadcast_in_dim"(%cst_1) {broadcast_dimensions = dense<1> : tensor<1xi64>} : (tensor<128xf32>) -> tensor<1x128xf32>
  %6 = mhlo.add %4, %5 : tensor<1x128xf32>
  %7 = mhlo.maximum %6, %0 : tensor<1x128xf32>
  %8 = "mhlo.dot"(%7, %cst_0) : (tensor<1x128xf32>, tensor<128x10xf32>) -> tensor<1x10xf32>
  %9 = "mhlo.broadcast_in_dim"(%cst) {broadcast_dimensions = dense<1> : tensor<1xi64>} : (tensor<10xf32>) -> tensor<1x10xf32>
  %10 = mhlo.add %8, %9 : tensor<1x10xf32>
  %11 = "mhlo.reduce"(%10, %1) ( {
  ^bb0(%arg1: tensor<f32>, %arg2: tensor<f32>):  // no predecessors
    %18 = mhlo.maximum %arg1, %arg2 : tensor<f32>
    "mhlo.return"(%18) : (tensor<f32>) -> ()
  }) {dimensions = dense<1> : tensor<1xi64>} : (tensor<1x10xf32>, tensor<f32>) -> tensor<1xf32>
  %12 = "mhlo.broadcast_in_dim"(%11) {broadcast_dimensions = dense<0> : tensor<1xi64>} : (tensor<1xf32>) -> tensor<1x10xf32>
  %13 = mhlo.subtract %10, %12 : tensor<1x10xf32>
  %14 = "mhlo.exponential"(%13) : (tensor<1x10xf32>) -> tensor<1x10xf32>
  %15 = "mhlo.reduce"(%14, %2) ( {
  ^bb0(%arg1: tensor<f32>, %arg2: tensor<f32>):  // no predecessors
    %18 = mhlo.add %arg1, %arg2 : tensor<f32>
    "mhlo.return"(%18) : (tensor<f32>) -> ()
  }) {dimensions = dense<1> : tensor<1xi64>} : (tensor<1x10xf32>, tensor<f32>) -> tensor<1xf32>
  %16 = "mhlo.broadcast_in_dim"(%15) {broadcast_dimensions = dense<0> : tensor<1xi64>} : (tensor<1xf32>) -> tensor<1x10xf32>
  %17 = mhlo.divide %14, %16 : tensor<1x10xf32>
  return %17 : tensor<1x10xf32>
}

// *** IR Dump After TosaToLinalgOnTensors ***
func @predict(%arg0: tensor<1x28x28x1xf32>) -> tensor<1x10xf32> attributes {iree.module.export, iree.reflection = {abi = "sip", abiv = 1 : i32, f = "I15!B11!d1d28d28d1R9!B6!d1d10", fv = "1", sip = "I8!S5!k0_0R3!_0"}} {
  %0 = mhlo.constant dense<0.000000e+00> : tensor<1x128xf32>
  %1 = mhlo.constant dense<0xFF800000> : tensor<f32>
  %2 = mhlo.constant dense<0.000000e+00> : tensor<f32>
  %cst = constant opaque<"_", "0xDEADBEEF"> : tensor<10xf32>
  %cst_0 = constant opaque<"_", "0xDEADBEEF"> : tensor<128x10xf32>
  %cst_1 = constant opaque<"_", "0xDEADBEEF"> : tensor<128xf32>
  %cst_2 = constant opaque<"_", "0xDEADBEEF"> : tensor<784x128xf32>
  %3 = "mhlo.reshape"(%arg0) : (tensor<1x28x28x1xf32>) -> tensor<1x784xf32>
  %4 = "mhlo.dot"(%3, %cst_2) : (tensor<1x784xf32>, tensor<784x128xf32>) -> tensor<1x128xf32>
  %5 = "mhlo.broadcast_in_dim"(%cst_1) {broadcast_dimensions = dense<1> : tensor<1xi64>} : (tensor<128xf32>) -> tensor<1x128xf32>
  %6 = mhlo.add %4, %5 : tensor<1x128xf32>
  %7 = mhlo.maximum %6, %0 : tensor<1x128xf32>
  %8 = "mhlo.dot"(%7, %cst_0) : (tensor<1x128xf32>, tensor<128x10xf32>) -> tensor<1x10xf32>
  %9 = "mhlo.broadcast_in_dim"(%cst) {broadcast_dimensions = dense<1> : tensor<1xi64>} : (tensor<10xf32>) -> tensor<1x10xf32>
  %10 = mhlo.add %8, %9 : tensor<1x10xf32>
  %11 = "mhlo.reduce"(%10, %1) ( {
  ^bb0(%arg1: tensor<f32>, %arg2: tensor<f32>):  // no predecessors
    %18 = mhlo.maximum %arg1, %arg2 : tensor<f32>
    "mhlo.return"(%18) : (tensor<f32>) -> ()
  }) {dimensions = dense<1> : tensor<1xi64>} : (tensor<1x10xf32>, tensor<f32>) -> tensor<1xf32>
  %12 = "mhlo.broadcast_in_dim"(%11) {broadcast_dimensions = dense<0> : tensor<1xi64>} : (tensor<1xf32>) -> tensor<1x10xf32>
  %13 = mhlo.subtract %10, %12 : tensor<1x10xf32>
  %14 = "mhlo.exponential"(%13) : (tensor<1x10xf32>) -> tensor<1x10xf32>
  %15 = "mhlo.reduce"(%14, %2) ( {
  ^bb0(%arg1: tensor<f32>, %arg2: tensor<f32>):  // no predecessors
    %18 = mhlo.add %arg1, %arg2 : tensor<f32>
    "mhlo.return"(%18) : (tensor<f32>) -> ()
  }) {dimensions = dense<1> : tensor<1xi64>} : (tensor<1x10xf32>, tensor<f32>) -> tensor<1xf32>
  %16 = "mhlo.broadcast_in_dim"(%15) {broadcast_dimensions = dense<0> : tensor<1xi64>} : (tensor<1xf32>) -> tensor<1x10xf32>
  %17 = mhlo.divide %14, %16 : tensor<1x10xf32>
  return %17 : tensor<1x10xf32>
}

// *** IR Dump After Canonicalizer ***
module  {
  func @predict(%arg0: tensor<1x28x28x1xf32>) -> tensor<1x10xf32> attributes {iree.module.export, iree.reflection = {abi = "sip", abiv = 1 : i32, f = "I15!B11!d1d28d28d1R9!B6!d1d10", fv = "1", sip = "I8!S5!k0_0R3!_0"}} {
    %0 = mhlo.constant dense<0.000000e+00> : tensor<1x128xf32>
    %1 = mhlo.constant dense<0xFF800000> : tensor<f32>
    %2 = mhlo.constant dense<0.000000e+00> : tensor<f32>
    %cst = constant opaque<"_", "0xDEADBEEF"> : tensor<10xf32>
    %cst_0 = constant opaque<"_", "0xDEADBEEF"> : tensor<128x10xf32>
    %cst_1 = constant opaque<"_", "0xDEADBEEF"> : tensor<128xf32>
    %cst_2 = constant opaque<"_", "0xDEADBEEF"> : tensor<784x128xf32>
    %3 = "mhlo.reshape"(%arg0) : (tensor<1x28x28x1xf32>) -> tensor<1x784xf32>
    %4 = "mhlo.dot"(%3, %cst_2) : (tensor<1x784xf32>, tensor<784x128xf32>) -> tensor<1x128xf32>
    %5 = "mhlo.broadcast_in_dim"(%cst_1) {broadcast_dimensions = dense<1> : tensor<1xi64>} : (tensor<128xf32>) -> tensor<1x128xf32>
    %6 = mhlo.add %4, %5 : tensor<1x128xf32>
    %7 = mhlo.maximum %6, %0 : tensor<1x128xf32>
    %8 = "mhlo.dot"(%7, %cst_0) : (tensor<1x128xf32>, tensor<128x10xf32>) -> tensor<1x10xf32>
    %9 = "mhlo.broadcast_in_dim"(%cst) {broadcast_dimensions = dense<1> : tensor<1xi64>} : (tensor<10xf32>) -> tensor<1x10xf32>
    %10 = mhlo.add %8, %9 : tensor<1x10xf32>
    %11 = "mhlo.reduce"(%10, %1) ( {
    ^bb0(%arg1: tensor<f32>, %arg2: tensor<f32>):  // no predecessors
      %18 = mhlo.maximum %arg1, %arg2 : tensor<f32>
      "mhlo.return"(%18) : (tensor<f32>) -> ()
    }) {dimensions = dense<1> : tensor<1xi64>} : (tensor<1x10xf32>, tensor<f32>) -> tensor<1xf32>
    %12 = "mhlo.broadcast_in_dim"(%11) {broadcast_dimensions = dense<0> : tensor<1xi64>} : (tensor<1xf32>) -> tensor<1x10xf32>
    %13 = mhlo.subtract %10, %12 : tensor<1x10xf32>
    %14 = "mhlo.exponential"(%13) : (tensor<1x10xf32>) -> tensor<1x10xf32>
    %15 = "mhlo.reduce"(%14, %2) ( {
    ^bb0(%arg1: tensor<f32>, %arg2: tensor<f32>):  // no predecessors
      %18 = mhlo.add %arg1, %arg2 : tensor<f32>
      "mhlo.return"(%18) : (tensor<f32>) -> ()
    }) {dimensions = dense<1> : tensor<1xi64>} : (tensor<1x10xf32>, tensor<f32>) -> tensor<1xf32>
    %16 = "mhlo.broadcast_in_dim"(%15) {broadcast_dimensions = dense<0> : tensor<1xi64>} : (tensor<1xf32>) -> tensor<1x10xf32>
    %17 = mhlo.divide %14, %16 : tensor<1x10xf32>
    return %17 : tensor<1x10xf32>
  }
}


// *** IR Dump After SCFToStandard ***
func @predict(%arg0: tensor<1x28x28x1xf32>) -> tensor<1x10xf32> attributes {iree.module.export, iree.reflection = {abi = "sip", abiv = 1 : i32, f = "I15!B11!d1d28d28d1R9!B6!d1d10", fv = "1", sip = "I8!S5!k0_0R3!_0"}} {
  %0 = mhlo.constant dense<0.000000e+00> : tensor<1x128xf32>
  %1 = mhlo.constant dense<0xFF800000> : tensor<f32>
  %2 = mhlo.constant dense<0.000000e+00> : tensor<f32>
  %cst = constant opaque<"_", "0xDEADBEEF"> : tensor<10xf32>
  %cst_0 = constant opaque<"_", "0xDEADBEEF"> : tensor<128x10xf32>
  %cst_1 = constant opaque<"_", "0xDEADBEEF"> : tensor<128xf32>
  %cst_2 = constant opaque<"_", "0xDEADBEEF"> : tensor<784x128xf32>
  %3 = "mhlo.reshape"(%arg0) : (tensor<1x28x28x1xf32>) -> tensor<1x784xf32>
  %4 = "mhlo.dot"(%3, %cst_2) : (tensor<1x784xf32>, tensor<784x128xf32>) -> tensor<1x128xf32>
  %5 = "mhlo.broadcast_in_dim"(%cst_1) {broadcast_dimensions = dense<1> : tensor<1xi64>} : (tensor<128xf32>) -> tensor<1x128xf32>
  %6 = mhlo.add %4, %5 : tensor<1x128xf32>
  %7 = mhlo.maximum %6, %0 : tensor<1x128xf32>
  %8 = "mhlo.dot"(%7, %cst_0) : (tensor<1x128xf32>, tensor<128x10xf32>) -> tensor<1x10xf32>
  %9 = "mhlo.broadcast_in_dim"(%cst) {broadcast_dimensions = dense<1> : tensor<1xi64>} : (tensor<10xf32>) -> tensor<1x10xf32>
  %10 = mhlo.add %8, %9 : tensor<1x10xf32>
  %11 = "mhlo.reduce"(%10, %1) ( {
  ^bb0(%arg1: tensor<f32>, %arg2: tensor<f32>):  // no predecessors
    %18 = mhlo.maximum %arg1, %arg2 : tensor<f32>
    "mhlo.return"(%18) : (tensor<f32>) -> ()
  }) {dimensions = dense<1> : tensor<1xi64>} : (tensor<1x10xf32>, tensor<f32>) -> tensor<1xf32>
  %12 = "mhlo.broadcast_in_dim"(%11) {broadcast_dimensions = dense<0> : tensor<1xi64>} : (tensor<1xf32>) -> tensor<1x10xf32>
  %13 = mhlo.subtract %10, %12 : tensor<1x10xf32>
  %14 = "mhlo.exponential"(%13) : (tensor<1x10xf32>) -> tensor<1x10xf32>
  %15 = "mhlo.reduce"(%14, %2) ( {
  ^bb0(%arg1: tensor<f32>, %arg2: tensor<f32>):  // no predecessors
    %18 = mhlo.add %arg1, %arg2 : tensor<f32>
    "mhlo.return"(%18) : (tensor<f32>) -> ()
  }) {dimensions = dense<1> : tensor<1xi64>} : (tensor<1x10xf32>, tensor<f32>) -> tensor<1xf32>
  %16 = "mhlo.broadcast_in_dim"(%15) {broadcast_dimensions = dense<0> : tensor<1xi64>} : (tensor<1xf32>) -> tensor<1x10xf32>
  %17 = mhlo.divide %14, %16 : tensor<1x10xf32>
  return %17 : tensor<1x10xf32>
}

// *** IR Dump After Canonicalizer ***
func @predict(%arg0: tensor<1x28x28x1xf32>) -> tensor<1x10xf32> attributes {iree.module.export, iree.reflection = {abi = "sip", abiv = 1 : i32, f = "I15!B11!d1d28d28d1R9!B6!d1d10", fv = "1", sip = "I8!S5!k0_0R3!_0"}} {
  %0 = mhlo.constant dense<0.000000e+00> : tensor<1x128xf32>
  %1 = mhlo.constant dense<0xFF800000> : tensor<f32>
  %2 = mhlo.constant dense<0.000000e+00> : tensor<f32>
  %cst = constant opaque<"_", "0xDEADBEEF"> : tensor<10xf32>
  %cst_0 = constant opaque<"_", "0xDEADBEEF"> : tensor<128x10xf32>
  %cst_1 = constant opaque<"_", "0xDEADBEEF"> : tensor<128xf32>
  %cst_2 = constant opaque<"_", "0xDEADBEEF"> : tensor<784x128xf32>
  %3 = "mhlo.reshape"(%arg0) : (tensor<1x28x28x1xf32>) -> tensor<1x784xf32>
  %4 = "mhlo.dot"(%3, %cst_2) : (tensor<1x784xf32>, tensor<784x128xf32>) -> tensor<1x128xf32>
  %5 = "mhlo.broadcast_in_dim"(%cst_1) {broadcast_dimensions = dense<1> : tensor<1xi64>} : (tensor<128xf32>) -> tensor<1x128xf32>
  %6 = mhlo.add %4, %5 : tensor<1x128xf32>
  %7 = mhlo.maximum %6, %0 : tensor<1x128xf32>
  %8 = "mhlo.dot"(%7, %cst_0) : (tensor<1x128xf32>, tensor<128x10xf32>) -> tensor<1x10xf32>
  %9 = "mhlo.broadcast_in_dim"(%cst) {broadcast_dimensions = dense<1> : tensor<1xi64>} : (tensor<10xf32>) -> tensor<1x10xf32>
  %10 = mhlo.add %8, %9 : tensor<1x10xf32>
  %11 = "mhlo.reduce"(%10, %1) ( {
  ^bb0(%arg1: tensor<f32>, %arg2: tensor<f32>):  // no predecessors
    %18 = mhlo.maximum %arg1, %arg2 : tensor<f32>
    "mhlo.return"(%18) : (tensor<f32>) -> ()
  }) {dimensions = dense<1> : tensor<1xi64>} : (tensor<1x10xf32>, tensor<f32>) -> tensor<1xf32>
  %12 = "mhlo.broadcast_in_dim"(%11) {broadcast_dimensions = dense<0> : tensor<1xi64>} : (tensor<1xf32>) -> tensor<1x10xf32>
  %13 = mhlo.subtract %10, %12 : tensor<1x10xf32>
  %14 = "mhlo.exponential"(%13) : (tensor<1x10xf32>) -> tensor<1x10xf32>
  %15 = "mhlo.reduce"(%14, %2) ( {
  ^bb0(%arg1: tensor<f32>, %arg2: tensor<f32>):  // no predecessors
    %18 = mhlo.add %arg1, %arg2 : tensor<f32>
    "mhlo.return"(%18) : (tensor<f32>) -> ()
  }) {dimensions = dense<1> : tensor<1xi64>} : (tensor<1x10xf32>, tensor<f32>) -> tensor<1xf32>
  %16 = "mhlo.broadcast_in_dim"(%15) {broadcast_dimensions = dense<0> : tensor<1xi64>} : (tensor<1xf32>) -> tensor<1x10xf32>
  %17 = mhlo.divide %14, %16 : tensor<1x10xf32>
  return %17 : tensor<1x10xf32>
}

// *** IR Dump After Inliner ***
module  {
  func @predict(%arg0: tensor<1x28x28x1xf32>) -> tensor<1x10xf32> attributes {iree.module.export, iree.reflection = {abi = "sip", abiv = 1 : i32, f = "I15!B11!d1d28d28d1R9!B6!d1d10", fv = "1", sip = "I8!S5!k0_0R3!_0"}} {
    %0 = mhlo.constant dense<0.000000e+00> : tensor<1x128xf32>
    %1 = mhlo.constant dense<0xFF800000> : tensor<f32>
    %2 = mhlo.constant dense<0.000000e+00> : tensor<f32>
    %cst = constant opaque<"_", "0xDEADBEEF"> : tensor<10xf32>
    %cst_0 = constant opaque<"_", "0xDEADBEEF"> : tensor<128x10xf32>
    %cst_1 = constant opaque<"_", "0xDEADBEEF"> : tensor<128xf32>
    %cst_2 = constant opaque<"_", "0xDEADBEEF"> : tensor<784x128xf32>
    %3 = "mhlo.reshape"(%arg0) : (tensor<1x28x28x1xf32>) -> tensor<1x784xf32>
    %4 = "mhlo.dot"(%3, %cst_2) : (tensor<1x784xf32>, tensor<784x128xf32>) -> tensor<1x128xf32>
    %5 = "mhlo.broadcast_in_dim"(%cst_1) {broadcast_dimensions = dense<1> : tensor<1xi64>} : (tensor<128xf32>) -> tensor<1x128xf32>
    %6 = mhlo.add %4, %5 : tensor<1x128xf32>
    %7 = mhlo.maximum %6, %0 : tensor<1x128xf32>
    %8 = "mhlo.dot"(%7, %cst_0) : (tensor<1x128xf32>, tensor<128x10xf32>) -> tensor<1x10xf32>
    %9 = "mhlo.broadcast_in_dim"(%cst) {broadcast_dimensions = dense<1> : tensor<1xi64>} : (tensor<10xf32>) -> tensor<1x10xf32>
    %10 = mhlo.add %8, %9 : tensor<1x10xf32>
    %11 = "mhlo.reduce"(%10, %1) ( {
    ^bb0(%arg1: tensor<f32>, %arg2: tensor<f32>):  // no predecessors
      %18 = mhlo.maximum %arg1, %arg2 : tensor<f32>
      "mhlo.return"(%18) : (tensor<f32>) -> ()
    }) {dimensions = dense<1> : tensor<1xi64>} : (tensor<1x10xf32>, tensor<f32>) -> tensor<1xf32>
    %12 = "mhlo.broadcast_in_dim"(%11) {broadcast_dimensions = dense<0> : tensor<1xi64>} : (tensor<1xf32>) -> tensor<1x10xf32>
    %13 = mhlo.subtract %10, %12 : tensor<1x10xf32>
    %14 = "mhlo.exponential"(%13) : (tensor<1x10xf32>) -> tensor<1x10xf32>
    %15 = "mhlo.reduce"(%14, %2) ( {
    ^bb0(%arg1: tensor<f32>, %arg2: tensor<f32>):  // no predecessors
      %18 = mhlo.add %arg1, %arg2 : tensor<f32>
      "mhlo.return"(%18) : (tensor<f32>) -> ()
    }) {dimensions = dense<1> : tensor<1xi64>} : (tensor<1x10xf32>, tensor<f32>) -> tensor<1xf32>
    %16 = "mhlo.broadcast_in_dim"(%15) {broadcast_dimensions = dense<0> : tensor<1xi64>} : (tensor<1xf32>) -> tensor<1x10xf32>
    %17 = mhlo.divide %14, %16 : tensor<1x10xf32>
    return %17 : tensor<1x10xf32>
  }
}


// *** IR Dump After mlir::iree_compiler::Shape::`anonymous-namespace'::ConvertShapeToShapex ***
module  {
  func @predict(%arg0: tensor<1x28x28x1xf32>) -> tensor<1x10xf32> attributes {iree.module.export, iree.reflection = {abi = "sip", abiv = 1 : i32, f = "I15!B11!d1d28d28d1R9!B6!d1d10", fv = "1", sip = "I8!S5!k0_0R3!_0"}} {
    %0 = mhlo.constant dense<0.000000e+00> : tensor<1x128xf32>
    %1 = mhlo.constant dense<0xFF800000> : tensor<f32>
    %2 = mhlo.constant dense<0.000000e+00> : tensor<f32>
    %cst = constant opaque<"_", "0xDEADBEEF"> : tensor<10xf32>
    %cst_0 = constant opaque<"_", "0xDEADBEEF"> : tensor<128x10xf32>
    %cst_1 = constant opaque<"_", "0xDEADBEEF"> : tensor<128xf32>
    %cst_2 = constant opaque<"_", "0xDEADBEEF"> : tensor<784x128xf32>
    %3 = "mhlo.reshape"(%arg0) : (tensor<1x28x28x1xf32>) -> tensor<1x784xf32>
    %4 = "mhlo.dot"(%3, %cst_2) : (tensor<1x784xf32>, tensor<784x128xf32>) -> tensor<1x128xf32>
    %5 = "mhlo.broadcast_in_dim"(%cst_1) {broadcast_dimensions = dense<1> : tensor<1xi64>} : (tensor<128xf32>) -> tensor<1x128xf32>
    %6 = mhlo.add %4, %5 : tensor<1x128xf32>
    %7 = mhlo.maximum %6, %0 : tensor<1x128xf32>
    %8 = "mhlo.dot"(%7, %cst_0) : (tensor<1x128xf32>, tensor<128x10xf32>) -> tensor<1x10xf32>
    %9 = "mhlo.broadcast_in_dim"(%cst) {broadcast_dimensions = dense<1> : tensor<1xi64>} : (tensor<10xf32>) -> tensor<1x10xf32>
    %10 = mhlo.add %8, %9 : tensor<1x10xf32>
    %11 = "mhlo.reduce"(%10, %1) ( {
    ^bb0(%arg1: tensor<f32>, %arg2: tensor<f32>):  // no predecessors
      %18 = mhlo.maximum %arg1, %arg2 : tensor<f32>
      "mhlo.return"(%18) : (tensor<f32>) -> ()
    }) {dimensions = dense<1> : tensor<1xi64>} : (tensor<1x10xf32>, tensor<f32>) -> tensor<1xf32>
    %12 = "mhlo.broadcast_in_dim"(%11) {broadcast_dimensions = dense<0> : tensor<1xi64>} : (tensor<1xf32>) -> tensor<1x10xf32>
    %13 = mhlo.subtract %10, %12 : tensor<1x10xf32>
    %14 = "mhlo.exponential"(%13) : (tensor<1x10xf32>) -> tensor<1x10xf32>
    %15 = "mhlo.reduce"(%14, %2) ( {
    ^bb0(%arg1: tensor<f32>, %arg2: tensor<f32>):  // no predecessors
      %18 = mhlo.add %arg1, %arg2 : tensor<f32>
      "mhlo.return"(%18) : (tensor<f32>) -> ()
    }) {dimensions = dense<1> : tensor<1xi64>} : (tensor<1x10xf32>, tensor<f32>) -> tensor<1xf32>
    %16 = "mhlo.broadcast_in_dim"(%15) {broadcast_dimensions = dense<0> : tensor<1xi64>} : (tensor<1xf32>) -> tensor<1x10xf32>
    %17 = mhlo.divide %14, %16 : tensor<1x10xf32>
    return %17 : tensor<1x10xf32>
  }
}


// *** IR Dump After Canonicalizer ***
func @predict(%arg0: tensor<1x28x28x1xf32>) -> tensor<1x10xf32> attributes {iree.module.export, iree.reflection = {abi = "sip", abiv = 1 : i32, f = "I15!B11!d1d28d28d1R9!B6!d1d10", fv = "1", sip = "I8!S5!k0_0R3!_0"}} {
  %0 = mhlo.constant dense<0.000000e+00> : tensor<1x128xf32>
  %1 = mhlo.constant dense<0xFF800000> : tensor<f32>
  %2 = mhlo.constant dense<0.000000e+00> : tensor<f32>
  %cst = constant opaque<"_", "0xDEADBEEF"> : tensor<10xf32>
  %cst_0 = constant opaque<"_", "0xDEADBEEF"> : tensor<128x10xf32>
  %cst_1 = constant opaque<"_", "0xDEADBEEF"> : tensor<128xf32>
  %cst_2 = constant opaque<"_", "0xDEADBEEF"> : tensor<784x128xf32>
  %3 = "mhlo.reshape"(%arg0) : (tensor<1x28x28x1xf32>) -> tensor<1x784xf32>
  %4 = "mhlo.dot"(%3, %cst_2) : (tensor<1x784xf32>, tensor<784x128xf32>) -> tensor<1x128xf32>
  %5 = "mhlo.broadcast_in_dim"(%cst_1) {broadcast_dimensions = dense<1> : tensor<1xi64>} : (tensor<128xf32>) -> tensor<1x128xf32>
  %6 = mhlo.add %4, %5 : tensor<1x128xf32>
  %7 = mhlo.maximum %6, %0 : tensor<1x128xf32>
  %8 = "mhlo.dot"(%7, %cst_0) : (tensor<1x128xf32>, tensor<128x10xf32>) -> tensor<1x10xf32>
  %9 = "mhlo.broadcast_in_dim"(%cst) {broadcast_dimensions = dense<1> : tensor<1xi64>} : (tensor<10xf32>) -> tensor<1x10xf32>
  %10 = mhlo.add %8, %9 : tensor<1x10xf32>
  %11 = "mhlo.reduce"(%10, %1) ( {
  ^bb0(%arg1: tensor<f32>, %arg2: tensor<f32>):  // no predecessors
    %18 = mhlo.maximum %arg1, %arg2 : tensor<f32>
    "mhlo.return"(%18) : (tensor<f32>) -> ()
  }) {dimensions = dense<1> : tensor<1xi64>} : (tensor<1x10xf32>, tensor<f32>) -> tensor<1xf32>
  %12 = "mhlo.broadcast_in_dim"(%11) {broadcast_dimensions = dense<0> : tensor<1xi64>} : (tensor<1xf32>) -> tensor<1x10xf32>
  %13 = mhlo.subtract %10, %12 : tensor<1x10xf32>
  %14 = "mhlo.exponential"(%13) : (tensor<1x10xf32>) -> tensor<1x10xf32>
  %15 = "mhlo.reduce"(%14, %2) ( {
  ^bb0(%arg1: tensor<f32>, %arg2: tensor<f32>):  // no predecessors
    %18 = mhlo.add %arg1, %arg2 : tensor<f32>
    "mhlo.return"(%18) : (tensor<f32>) -> ()
  }) {dimensions = dense<1> : tensor<1xi64>} : (tensor<1x10xf32>, tensor<f32>) -> tensor<1xf32>
  %16 = "mhlo.broadcast_in_dim"(%15) {broadcast_dimensions = dense<0> : tensor<1xi64>} : (tensor<1xf32>) -> tensor<1x10xf32>
  %17 = mhlo.divide %14, %16 : tensor<1x10xf32>
  return %17 : tensor<1x10xf32>
}

// *** IR Dump After CSE ***
func @predict(%arg0: tensor<1x28x28x1xf32>) -> tensor<1x10xf32> attributes {iree.module.export, iree.reflection = {abi = "sip", abiv = 1 : i32, f = "I15!B11!d1d28d28d1R9!B6!d1d10", fv = "1", sip = "I8!S5!k0_0R3!_0"}} {
  %0 = mhlo.constant dense<0.000000e+00> : tensor<1x128xf32>
  %1 = mhlo.constant dense<0xFF800000> : tensor<f32>
  %2 = mhlo.constant dense<0.000000e+00> : tensor<f32>
  %cst = constant opaque<"_", "0xDEADBEEF"> : tensor<10xf32>
  %cst_0 = constant opaque<"_", "0xDEADBEEF"> : tensor<128x10xf32>
  %cst_1 = constant opaque<"_", "0xDEADBEEF"> : tensor<128xf32>
  %cst_2 = constant opaque<"_", "0xDEADBEEF"> : tensor<784x128xf32>
  %3 = "mhlo.reshape"(%arg0) : (tensor<1x28x28x1xf32>) -> tensor<1x784xf32>
  %4 = "mhlo.dot"(%3, %cst_2) : (tensor<1x784xf32>, tensor<784x128xf32>) -> tensor<1x128xf32>
  %5 = "mhlo.broadcast_in_dim"(%cst_1) {broadcast_dimensions = dense<1> : tensor<1xi64>} : (tensor<128xf32>) -> tensor<1x128xf32>
  %6 = mhlo.add %4, %5 : tensor<1x128xf32>
  %7 = mhlo.maximum %6, %0 : tensor<1x128xf32>
  %8 = "mhlo.dot"(%7, %cst_0) : (tensor<1x128xf32>, tensor<128x10xf32>) -> tensor<1x10xf32>
  %9 = "mhlo.broadcast_in_dim"(%cst) {broadcast_dimensions = dense<1> : tensor<1xi64>} : (tensor<10xf32>) -> tensor<1x10xf32>
  %10 = mhlo.add %8, %9 : tensor<1x10xf32>
  %11 = "mhlo.reduce"(%10, %1) ( {
  ^bb0(%arg1: tensor<f32>, %arg2: tensor<f32>):  // no predecessors
    %18 = mhlo.maximum %arg1, %arg2 : tensor<f32>
    "mhlo.return"(%18) : (tensor<f32>) -> ()
  }) {dimensions = dense<1> : tensor<1xi64>} : (tensor<1x10xf32>, tensor<f32>) -> tensor<1xf32>
  %12 = "mhlo.broadcast_in_dim"(%11) {broadcast_dimensions = dense<0> : tensor<1xi64>} : (tensor<1xf32>) -> tensor<1x10xf32>
  %13 = mhlo.subtract %10, %12 : tensor<1x10xf32>
  %14 = "mhlo.exponential"(%13) : (tensor<1x10xf32>) -> tensor<1x10xf32>
  %15 = "mhlo.reduce"(%14, %2) ( {
  ^bb0(%arg1: tensor<f32>, %arg2: tensor<f32>):  // no predecessors
    %18 = mhlo.add %arg1, %arg2 : tensor<f32>
    "mhlo.return"(%18) : (tensor<f32>) -> ()
  }) {dimensions = dense<1> : tensor<1xi64>} : (tensor<1x10xf32>, tensor<f32>) -> tensor<1xf32>
  %16 = "mhlo.broadcast_in_dim"(%15) {broadcast_dimensions = dense<0> : tensor<1xi64>} : (tensor<1xf32>) -> tensor<1x10xf32>
  %17 = mhlo.divide %14, %16 : tensor<1x10xf32>
  return %17 : tensor<1x10xf32>
}

// *** IR Dump After LegalizeInputTypes ***
module  {
  func @predict(%arg0: tensor<1x28x28x1xf32>) -> tensor<1x10xf32> attributes {iree.module.export, iree.reflection = {abi = "sip", abiv = 1 : i32, f = "I15!B11!d1d28d28d1R9!B6!d1d10", fv = "1", sip = "I8!S5!k0_0R3!_0"}} {
    %0 = mhlo.constant dense<0.000000e+00> : tensor<1x128xf32>
    %1 = mhlo.constant dense<0xFF800000> : tensor<f32>
    %2 = mhlo.constant dense<0.000000e+00> : tensor<f32>
    %cst = constant opaque<"_", "0xDEADBEEF"> : tensor<10xf32>
    %cst_0 = constant opaque<"_", "0xDEADBEEF"> : tensor<128x10xf32>
    %cst_1 = constant opaque<"_", "0xDEADBEEF"> : tensor<128xf32>
    %cst_2 = constant opaque<"_", "0xDEADBEEF"> : tensor<784x128xf32>
    %3 = "mhlo.reshape"(%arg0) : (tensor<1x28x28x1xf32>) -> tensor<1x784xf32>
    %4 = "mhlo.dot"(%3, %cst_2) : (tensor<1x784xf32>, tensor<784x128xf32>) -> tensor<1x128xf32>
    %5 = "mhlo.broadcast_in_dim"(%cst_1) {broadcast_dimensions = dense<1> : tensor<1xi64>} : (tensor<128xf32>) -> tensor<1x128xf32>
    %6 = mhlo.add %4, %5 : tensor<1x128xf32>
    %7 = mhlo.maximum %6, %0 : tensor<1x128xf32>
    %8 = "mhlo.dot"(%7, %cst_0) : (tensor<1x128xf32>, tensor<128x10xf32>) -> tensor<1x10xf32>
    %9 = "mhlo.broadcast_in_dim"(%cst) {broadcast_dimensions = dense<1> : tensor<1xi64>} : (tensor<10xf32>) -> tensor<1x10xf32>
    %10 = mhlo.add %8, %9 : tensor<1x10xf32>
    %11 = "mhlo.reduce"(%10, %1) ( {
    ^bb0(%arg1: tensor<f32>, %arg2: tensor<f32>):  // no predecessors
      %18 = mhlo.maximum %arg1, %arg2 : tensor<f32>
      "mhlo.return"(%18) : (tensor<f32>) -> ()
    }) {dimensions = dense<1> : tensor<1xi64>} : (tensor<1x10xf32>, tensor<f32>) -> tensor<1xf32>
    %12 = "mhlo.broadcast_in_dim"(%11) {broadcast_dimensions = dense<0> : tensor<1xi64>} : (tensor<1xf32>) -> tensor<1x10xf32>
    %13 = mhlo.subtract %10, %12 : tensor<1x10xf32>
    %14 = "mhlo.exponential"(%13) : (tensor<1x10xf32>) -> tensor<1x10xf32>
    %15 = "mhlo.reduce"(%14, %2) ( {
    ^bb0(%arg1: tensor<f32>, %arg2: tensor<f32>):  // no predecessors
      %18 = mhlo.add %arg1, %arg2 : tensor<f32>
      "mhlo.return"(%18) : (tensor<f32>) -> ()
    }) {dimensions = dense<1> : tensor<1xi64>} : (tensor<1x10xf32>, tensor<f32>) -> tensor<1xf32>
    %16 = "mhlo.broadcast_in_dim"(%15) {broadcast_dimensions = dense<0> : tensor<1xi64>} : (tensor<1xf32>) -> tensor<1x10xf32>
    %17 = mhlo.divide %14, %16 : tensor<1x10xf32>
    return %17 : tensor<1x10xf32>
  }
}


// *** IR Dump After ExpandVariableDynamicDims ***
module  {
  func @predict(%arg0: tensor<1x28x28x1xf32>) -> tensor<1x10xf32> attributes {iree.module.export, iree.reflection = {abi = "sip", abiv = 1 : i32, f = "I15!B11!d1d28d28d1R9!B6!d1d10", fv = "1", sip = "I8!S5!k0_0R3!_0"}} {
    %0 = mhlo.constant dense<0.000000e+00> : tensor<1x128xf32>
    %1 = mhlo.constant dense<0xFF800000> : tensor<f32>
    %2 = mhlo.constant dense<0.000000e+00> : tensor<f32>
    %cst = constant opaque<"_", "0xDEADBEEF"> : tensor<10xf32>
    %cst_0 = constant opaque<"_", "0xDEADBEEF"> : tensor<128x10xf32>
    %cst_1 = constant opaque<"_", "0xDEADBEEF"> : tensor<128xf32>
    %cst_2 = constant opaque<"_", "0xDEADBEEF"> : tensor<784x128xf32>
    %3 = "mhlo.reshape"(%arg0) : (tensor<1x28x28x1xf32>) -> tensor<1x784xf32>
    %4 = "mhlo.dot"(%3, %cst_2) : (tensor<1x784xf32>, tensor<784x128xf32>) -> tensor<1x128xf32>
    %5 = "mhlo.broadcast_in_dim"(%cst_1) {broadcast_dimensions = dense<1> : tensor<1xi64>} : (tensor<128xf32>) -> tensor<1x128xf32>
    %6 = mhlo.add %4, %5 : tensor<1x128xf32>
    %7 = mhlo.maximum %6, %0 : tensor<1x128xf32>
    %8 = "mhlo.dot"(%7, %cst_0) : (tensor<1x128xf32>, tensor<128x10xf32>) -> tensor<1x10xf32>
    %9 = "mhlo.broadcast_in_dim"(%cst) {broadcast_dimensions = dense<1> : tensor<1xi64>} : (tensor<10xf32>) -> tensor<1x10xf32>
    %10 = mhlo.add %8, %9 : tensor<1x10xf32>
    %11 = "mhlo.reduce"(%10, %1) ( {
    ^bb0(%arg1: tensor<f32>, %arg2: tensor<f32>):  // no predecessors
      %18 = mhlo.maximum %arg1, %arg2 : tensor<f32>
      "mhlo.return"(%18) : (tensor<f32>) -> ()
    }) {dimensions = dense<1> : tensor<1xi64>} : (tensor<1x10xf32>, tensor<f32>) -> tensor<1xf32>
    %12 = "mhlo.broadcast_in_dim"(%11) {broadcast_dimensions = dense<0> : tensor<1xi64>} : (tensor<1xf32>) -> tensor<1x10xf32>
    %13 = mhlo.subtract %10, %12 : tensor<1x10xf32>
    %14 = "mhlo.exponential"(%13) : (tensor<1x10xf32>) -> tensor<1x10xf32>
    %15 = "mhlo.reduce"(%14, %2) ( {
    ^bb0(%arg1: tensor<f32>, %arg2: tensor<f32>):  // no predecessors
      %18 = mhlo.add %arg1, %arg2 : tensor<f32>
      "mhlo.return"(%18) : (tensor<f32>) -> ()
    }) {dimensions = dense<1> : tensor<1xi64>} : (tensor<1x10xf32>, tensor<f32>) -> tensor<1xf32>
    %16 = "mhlo.broadcast_in_dim"(%15) {broadcast_dimensions = dense<0> : tensor<1xi64>} : (tensor<1xf32>) -> tensor<1x10xf32>
    %17 = mhlo.divide %14, %16 : tensor<1x10xf32>
    return %17 : tensor<1x10xf32>
  }
}


// *** IR Dump After mlir::iree_compiler::Shape::`anonymous-namespace'::ExpandFunctionDynamicDimsPass ***
func @predict(%arg0: tensor<1x28x28x1xf32>) -> tensor<1x10xf32> attributes {iree.module.export, iree.reflection = {abi = "sip", abiv = 1 : i32, f = "I15!B11!d1d28d28d1R9!B6!d1d10", fv = "1", sip = "I8!S5!k0_0R3!_0"}} {
  %0 = mhlo.constant dense<0.000000e+00> : tensor<1x128xf32>
  %1 = mhlo.constant dense<0xFF800000> : tensor<f32>
  %2 = mhlo.constant dense<0.000000e+00> : tensor<f32>
  %cst = constant opaque<"_", "0xDEADBEEF"> : tensor<10xf32>
  %cst_0 = constant opaque<"_", "0xDEADBEEF"> : tensor<128x10xf32>
  %cst_1 = constant opaque<"_", "0xDEADBEEF"> : tensor<128xf32>
  %cst_2 = constant opaque<"_", "0xDEADBEEF"> : tensor<784x128xf32>
  %3 = "mhlo.reshape"(%arg0) : (tensor<1x28x28x1xf32>) -> tensor<1x784xf32>
  %4 = "mhlo.dot"(%3, %cst_2) : (tensor<1x784xf32>, tensor<784x128xf32>) -> tensor<1x128xf32>
  %5 = "mhlo.broadcast_in_dim"(%cst_1) {broadcast_dimensions = dense<1> : tensor<1xi64>} : (tensor<128xf32>) -> tensor<1x128xf32>
  %6 = mhlo.add %4, %5 : tensor<1x128xf32>
  %7 = mhlo.maximum %6, %0 : tensor<1x128xf32>
  %8 = "mhlo.dot"(%7, %cst_0) : (tensor<1x128xf32>, tensor<128x10xf32>) -> tensor<1x10xf32>
  %9 = "mhlo.broadcast_in_dim"(%cst) {broadcast_dimensions = dense<1> : tensor<1xi64>} : (tensor<10xf32>) -> tensor<1x10xf32>
  %10 = mhlo.add %8, %9 : tensor<1x10xf32>
  %11 = "mhlo.reduce"(%10, %1) ( {
  ^bb0(%arg1: tensor<f32>, %arg2: tensor<f32>):  // no predecessors
    %18 = mhlo.maximum %arg1, %arg2 : tensor<f32>
    "mhlo.return"(%18) : (tensor<f32>) -> ()
  }) {dimensions = dense<1> : tensor<1xi64>} : (tensor<1x10xf32>, tensor<f32>) -> tensor<1xf32>
  %12 = "mhlo.broadcast_in_dim"(%11) {broadcast_dimensions = dense<0> : tensor<1xi64>} : (tensor<1xf32>) -> tensor<1x10xf32>
  %13 = mhlo.subtract %10, %12 : tensor<1x10xf32>
  %14 = "mhlo.exponential"(%13) : (tensor<1x10xf32>) -> tensor<1x10xf32>
  %15 = "mhlo.reduce"(%14, %2) ( {
  ^bb0(%arg1: tensor<f32>, %arg2: tensor<f32>):  // no predecessors
    %18 = mhlo.add %arg1, %arg2 : tensor<f32>
    "mhlo.return"(%18) : (tensor<f32>) -> ()
  }) {dimensions = dense<1> : tensor<1xi64>} : (tensor<1x10xf32>, tensor<f32>) -> tensor<1xf32>
  %16 = "mhlo.broadcast_in_dim"(%15) {broadcast_dimensions = dense<0> : tensor<1xi64>} : (tensor<1xf32>) -> tensor<1x10xf32>
  %17 = mhlo.divide %14, %16 : tensor<1x10xf32>
  return %17 : tensor<1x10xf32>
}

// *** IR Dump After mlir::iree_compiler::Shape::`anonymous-namespace'::TieDynamicShapesPass ***
func @predict(%arg0: tensor<1x28x28x1xf32>) -> tensor<1x10xf32> attributes {iree.module.export, iree.reflection = {abi = "sip", abiv = 1 : i32, f = "I15!B11!d1d28d28d1R9!B6!d1d10", fv = "1", sip = "I8!S5!k0_0R3!_0"}} {
  %0 = mhlo.constant dense<0.000000e+00> : tensor<1x128xf32>
  %1 = mhlo.constant dense<0xFF800000> : tensor<f32>
  %2 = mhlo.constant dense<0.000000e+00> : tensor<f32>
  %cst = constant opaque<"_", "0xDEADBEEF"> : tensor<10xf32>
  %cst_0 = constant opaque<"_", "0xDEADBEEF"> : tensor<128x10xf32>
  %cst_1 = constant opaque<"_", "0xDEADBEEF"> : tensor<128xf32>
  %cst_2 = constant opaque<"_", "0xDEADBEEF"> : tensor<784x128xf32>
  %3 = "mhlo.reshape"(%arg0) : (tensor<1x28x28x1xf32>) -> tensor<1x784xf32>
  %4 = "mhlo.dot"(%3, %cst_2) : (tensor<1x784xf32>, tensor<784x128xf32>) -> tensor<1x128xf32>
  %5 = "mhlo.broadcast_in_dim"(%cst_1) {broadcast_dimensions = dense<1> : tensor<1xi64>} : (tensor<128xf32>) -> tensor<1x128xf32>
  %6 = mhlo.add %4, %5 : tensor<1x128xf32>
  %7 = mhlo.maximum %6, %0 : tensor<1x128xf32>
  %8 = "mhlo.dot"(%7, %cst_0) : (tensor<1x128xf32>, tensor<128x10xf32>) -> tensor<1x10xf32>
  %9 = "mhlo.broadcast_in_dim"(%cst) {broadcast_dimensions = dense<1> : tensor<1xi64>} : (tensor<10xf32>) -> tensor<1x10xf32>
  %10 = mhlo.add %8, %9 : tensor<1x10xf32>
  %11 = "mhlo.reduce"(%10, %1) ( {
  ^bb0(%arg1: tensor<f32>, %arg2: tensor<f32>):  // no predecessors
    %18 = mhlo.maximum %arg1, %arg2 : tensor<f32>
    "mhlo.return"(%18) : (tensor<f32>) -> ()
  }) {dimensions = dense<1> : tensor<1xi64>} : (tensor<1x10xf32>, tensor<f32>) -> tensor<1xf32>
  %12 = "mhlo.broadcast_in_dim"(%11) {broadcast_dimensions = dense<0> : tensor<1xi64>} : (tensor<1xf32>) -> tensor<1x10xf32>
  %13 = mhlo.subtract %10, %12 : tensor<1x10xf32>
  %14 = "mhlo.exponential"(%13) : (tensor<1x10xf32>) -> tensor<1x10xf32>
  %15 = "mhlo.reduce"(%14, %2) ( {
  ^bb0(%arg1: tensor<f32>, %arg2: tensor<f32>):  // no predecessors
    %18 = mhlo.add %arg1, %arg2 : tensor<f32>
    "mhlo.return"(%18) : (tensor<f32>) -> ()
  }) {dimensions = dense<1> : tensor<1xi64>} : (tensor<1x10xf32>, tensor<f32>) -> tensor<1xf32>
  %16 = "mhlo.broadcast_in_dim"(%15) {broadcast_dimensions = dense<0> : tensor<1xi64>} : (tensor<1xf32>) -> tensor<1x10xf32>
  %17 = mhlo.divide %14, %16 : tensor<1x10xf32>
  return %17 : tensor<1x10xf32>
}

// *** IR Dump After mlir::iree_compiler::Shape::`anonymous-namespace'::MaterializeShapeCalculationsPass ***
func @predict(%arg0: tensor<1x28x28x1xf32>) -> tensor<1x10xf32> attributes {iree.module.export, iree.reflection = {abi = "sip", abiv = 1 : i32, f = "I15!B11!d1d28d28d1R9!B6!d1d10", fv = "1", sip = "I8!S5!k0_0R3!_0"}} {
  %0 = mhlo.constant dense<0.000000e+00> : tensor<1x128xf32>
  %1 = mhlo.constant dense<0xFF800000> : tensor<f32>
  %2 = mhlo.constant dense<0.000000e+00> : tensor<f32>
  %cst = constant opaque<"_", "0xDEADBEEF"> : tensor<10xf32>
  %cst_0 = constant opaque<"_", "0xDEADBEEF"> : tensor<128x10xf32>
  %cst_1 = constant opaque<"_", "0xDEADBEEF"> : tensor<128xf32>
  %cst_2 = constant opaque<"_", "0xDEADBEEF"> : tensor<784x128xf32>
  %3 = "mhlo.reshape"(%arg0) : (tensor<1x28x28x1xf32>) -> tensor<1x784xf32>
  %4 = "mhlo.dot"(%3, %cst_2) : (tensor<1x784xf32>, tensor<784x128xf32>) -> tensor<1x128xf32>
  %5 = "mhlo.broadcast_in_dim"(%cst_1) {broadcast_dimensions = dense<1> : tensor<1xi64>} : (tensor<128xf32>) -> tensor<1x128xf32>
  %6 = mhlo.add %4, %5 : tensor<1x128xf32>
  %7 = mhlo.maximum %6, %0 : tensor<1x128xf32>
  %8 = "mhlo.dot"(%7, %cst_0) : (tensor<1x128xf32>, tensor<128x10xf32>) -> tensor<1x10xf32>
  %9 = "mhlo.broadcast_in_dim"(%cst) {broadcast_dimensions = dense<1> : tensor<1xi64>} : (tensor<10xf32>) -> tensor<1x10xf32>
  %10 = mhlo.add %8, %9 : tensor<1x10xf32>
  %11 = "mhlo.reduce"(%10, %1) ( {
  ^bb0(%arg1: tensor<f32>, %arg2: tensor<f32>):  // no predecessors
    %18 = mhlo.maximum %arg1, %arg2 : tensor<f32>
    "mhlo.return"(%18) : (tensor<f32>) -> ()
  }) {dimensions = dense<1> : tensor<1xi64>} : (tensor<1x10xf32>, tensor<f32>) -> tensor<1xf32>
  %12 = "mhlo.broadcast_in_dim"(%11) {broadcast_dimensions = dense<0> : tensor<1xi64>} : (tensor<1xf32>) -> tensor<1x10xf32>
  %13 = mhlo.subtract %10, %12 : tensor<1x10xf32>
  %14 = "mhlo.exponential"(%13) : (tensor<1x10xf32>) -> tensor<1x10xf32>
  %15 = "mhlo.reduce"(%14, %2) ( {
  ^bb0(%arg1: tensor<f32>, %arg2: tensor<f32>):  // no predecessors
    %18 = mhlo.add %arg1, %arg2 : tensor<f32>
    "mhlo.return"(%18) : (tensor<f32>) -> ()
  }) {dimensions = dense<1> : tensor<1xi64>} : (tensor<1x10xf32>, tensor<f32>) -> tensor<1xf32>
  %16 = "mhlo.broadcast_in_dim"(%15) {broadcast_dimensions = dense<0> : tensor<1xi64>} : (tensor<1xf32>) -> tensor<1x10xf32>
  %17 = mhlo.divide %14, %16 : tensor<1x10xf32>
  return %17 : tensor<1x10xf32>
}

// *** IR Dump After mlir::iree_compiler::Shape::`anonymous-namespace'::HoistShapeCalculations ***
func @predict(%arg0: tensor<1x28x28x1xf32>) -> tensor<1x10xf32> attributes {iree.module.export, iree.reflection = {abi = "sip", abiv = 1 : i32, f = "I15!B11!d1d28d28d1R9!B6!d1d10", fv = "1", sip = "I8!S5!k0_0R3!_0"}} {
  %0 = mhlo.constant dense<0.000000e+00> : tensor<1x128xf32>
  %1 = mhlo.constant dense<0xFF800000> : tensor<f32>
  %2 = mhlo.constant dense<0.000000e+00> : tensor<f32>
  %cst = constant opaque<"_", "0xDEADBEEF"> : tensor<10xf32>
  %cst_0 = constant opaque<"_", "0xDEADBEEF"> : tensor<128x10xf32>
  %cst_1 = constant opaque<"_", "0xDEADBEEF"> : tensor<128xf32>
  %cst_2 = constant opaque<"_", "0xDEADBEEF"> : tensor<784x128xf32>
  %3 = "mhlo.reshape"(%arg0) : (tensor<1x28x28x1xf32>) -> tensor<1x784xf32>
  %4 = "mhlo.dot"(%3, %cst_2) : (tensor<1x784xf32>, tensor<784x128xf32>) -> tensor<1x128xf32>
  %5 = "mhlo.broadcast_in_dim"(%cst_1) {broadcast_dimensions = dense<1> : tensor<1xi64>} : (tensor<128xf32>) -> tensor<1x128xf32>
  %6 = mhlo.add %4, %5 : tensor<1x128xf32>
  %7 = mhlo.maximum %6, %0 : tensor<1x128xf32>
  %8 = "mhlo.dot"(%7, %cst_0) : (tensor<1x128xf32>, tensor<128x10xf32>) -> tensor<1x10xf32>
  %9 = "mhlo.broadcast_in_dim"(%cst) {broadcast_dimensions = dense<1> : tensor<1xi64>} : (tensor<10xf32>) -> tensor<1x10xf32>
  %10 = mhlo.add %8, %9 : tensor<1x10xf32>
  %11 = "mhlo.reduce"(%10, %1) ( {
  ^bb0(%arg1: tensor<f32>, %arg2: tensor<f32>):  // no predecessors
    %18 = mhlo.maximum %arg1, %arg2 : tensor<f32>
    "mhlo.return"(%18) : (tensor<f32>) -> ()
  }) {dimensions = dense<1> : tensor<1xi64>} : (tensor<1x10xf32>, tensor<f32>) -> tensor<1xf32>
  %12 = "mhlo.broadcast_in_dim"(%11) {broadcast_dimensions = dense<0> : tensor<1xi64>} : (tensor<1xf32>) -> tensor<1x10xf32>
  %13 = mhlo.subtract %10, %12 : tensor<1x10xf32>
  %14 = "mhlo.exponential"(%13) : (tensor<1x10xf32>) -> tensor<1x10xf32>
  %15 = "mhlo.reduce"(%14, %2) ( {
  ^bb0(%arg1: tensor<f32>, %arg2: tensor<f32>):  // no predecessors
    %18 = mhlo.add %arg1, %arg2 : tensor<f32>
    "mhlo.return"(%18) : (tensor<f32>) -> ()
  }) {dimensions = dense<1> : tensor<1xi64>} : (tensor<1x10xf32>, tensor<f32>) -> tensor<1xf32>
  %16 = "mhlo.broadcast_in_dim"(%15) {broadcast_dimensions = dense<0> : tensor<1xi64>} : (tensor<1xf32>) -> tensor<1x10xf32>
  %17 = mhlo.divide %14, %16 : tensor<1x10xf32>
  return %17 : tensor<1x10xf32>
}

// *** IR Dump After PrePartitioningConversion ***
func @predict(%arg0: tensor<1x28x28x1xf32>) -> tensor<1x10xf32> attributes {iree.module.export, iree.reflection = {abi = "sip", abiv = 1 : i32, f = "I15!B11!d1d28d28d1R9!B6!d1d10", fv = "1", sip = "I8!S5!k0_0R3!_0"}} {
  %cst = constant dense<0.000000e+00> : tensor<1x128xf32>
  %cst_0 = constant dense<0xFF800000> : tensor<f32>
  %cst_1 = constant dense<0.000000e+00> : tensor<f32>
  %cst_2 = constant opaque<"_", "0xDEADBEEF"> : tensor<10xf32>
  %cst_3 = constant opaque<"_", "0xDEADBEEF"> : tensor<128x10xf32>
  %cst_4 = constant opaque<"_", "0xDEADBEEF"> : tensor<128xf32>
  %cst_5 = constant opaque<"_", "0xDEADBEEF"> : tensor<784x128xf32>
  %0 = "mhlo.reshape"(%arg0) : (tensor<1x28x28x1xf32>) -> tensor<1x784xf32>
  %1 = "mhlo.dot"(%0, %cst_5) : (tensor<1x784xf32>, tensor<784x128xf32>) -> tensor<1x128xf32>
  %2 = "mhlo.broadcast_in_dim"(%cst_4) {broadcast_dimensions = dense<1> : tensor<1xi64>} : (tensor<128xf32>) -> tensor<1x128xf32>
  %3 = mhlo.add %1, %2 : tensor<1x128xf32>
  %4 = mhlo.maximum %3, %cst : tensor<1x128xf32>
  %5 = "mhlo.dot"(%4, %cst_3) : (tensor<1x128xf32>, tensor<128x10xf32>) -> tensor<1x10xf32>
  %6 = "mhlo.broadcast_in_dim"(%cst_2) {broadcast_dimensions = dense<1> : tensor<1xi64>} : (tensor<10xf32>) -> tensor<1x10xf32>
  %7 = mhlo.add %5, %6 : tensor<1x10xf32>
  %8 = "mhlo.reduce"(%7, %cst_0) ( {
  ^bb0(%arg1: tensor<f32>, %arg2: tensor<f32>):  // no predecessors
    %15 = mhlo.maximum %arg1, %arg2 : tensor<f32>
    "mhlo.return"(%15) : (tensor<f32>) -> ()
  }) {dimensions = dense<1> : tensor<1xi64>} : (tensor<1x10xf32>, tensor<f32>) -> tensor<1xf32>
  %9 = "mhlo.broadcast_in_dim"(%8) {broadcast_dimensions = dense<0> : tensor<1xi64>} : (tensor<1xf32>) -> tensor<1x10xf32>
  %10 = mhlo.subtract %7, %9 : tensor<1x10xf32>
  %11 = "mhlo.exponential"(%10) : (tensor<1x10xf32>) -> tensor<1x10xf32>
  %12 = "mhlo.reduce"(%11, %cst_1) ( {
  ^bb0(%arg1: tensor<f32>, %arg2: tensor<f32>):  // no predecessors
    %15 = mhlo.add %arg1, %arg2 : tensor<f32>
    "mhlo.return"(%15) : (tensor<f32>) -> ()
  }) {dimensions = dense<1> : tensor<1xi64>} : (tensor<1x10xf32>, tensor<f32>) -> tensor<1xf32>
  %13 = "mhlo.broadcast_in_dim"(%12) {broadcast_dimensions = dense<0> : tensor<1xi64>} : (tensor<1xf32>) -> tensor<1x10xf32>
  %14 = mhlo.divide %11, %13 : tensor<1x10xf32>
  return %14 : tensor<1x10xf32>
}

// *** IR Dump After Canonicalizer ***
func @predict(%arg0: tensor<1x28x28x1xf32>) -> tensor<1x10xf32> attributes {iree.module.export, iree.reflection = {abi = "sip", abiv = 1 : i32, f = "I15!B11!d1d28d28d1R9!B6!d1d10", fv = "1", sip = "I8!S5!k0_0R3!_0"}} {
  %cst = constant dense<0.000000e+00> : tensor<1x128xf32>
  %cst_0 = constant dense<0xFF800000> : tensor<f32>
  %cst_1 = constant dense<0.000000e+00> : tensor<f32>
  %cst_2 = constant opaque<"_", "0xDEADBEEF"> : tensor<10xf32>
  %cst_3 = constant opaque<"_", "0xDEADBEEF"> : tensor<128x10xf32>
  %cst_4 = constant opaque<"_", "0xDEADBEEF"> : tensor<128xf32>
  %cst_5 = constant opaque<"_", "0xDEADBEEF"> : tensor<784x128xf32>
  %0 = "mhlo.reshape"(%arg0) : (tensor<1x28x28x1xf32>) -> tensor<1x784xf32>
  %1 = "mhlo.dot"(%0, %cst_5) : (tensor<1x784xf32>, tensor<784x128xf32>) -> tensor<1x128xf32>
  %2 = "mhlo.broadcast_in_dim"(%cst_4) {broadcast_dimensions = dense<1> : tensor<1xi64>} : (tensor<128xf32>) -> tensor<1x128xf32>
  %3 = mhlo.add %1, %2 : tensor<1x128xf32>
  %4 = mhlo.maximum %3, %cst : tensor<1x128xf32>
  %5 = "mhlo.dot"(%4, %cst_3) : (tensor<1x128xf32>, tensor<128x10xf32>) -> tensor<1x10xf32>
  %6 = "mhlo.broadcast_in_dim"(%cst_2) {broadcast_dimensions = dense<1> : tensor<1xi64>} : (tensor<10xf32>) -> tensor<1x10xf32>
  %7 = mhlo.add %5, %6 : tensor<1x10xf32>
  %8 = "mhlo.reduce"(%7, %cst_0) ( {
  ^bb0(%arg1: tensor<f32>, %arg2: tensor<f32>):  // no predecessors
    %15 = mhlo.maximum %arg1, %arg2 : tensor<f32>
    "mhlo.return"(%15) : (tensor<f32>) -> ()
  }) {dimensions = dense<1> : tensor<1xi64>} : (tensor<1x10xf32>, tensor<f32>) -> tensor<1xf32>
  %9 = "mhlo.broadcast_in_dim"(%8) {broadcast_dimensions = dense<0> : tensor<1xi64>} : (tensor<1xf32>) -> tensor<1x10xf32>
  %10 = mhlo.subtract %7, %9 : tensor<1x10xf32>
  %11 = "mhlo.exponential"(%10) : (tensor<1x10xf32>) -> tensor<1x10xf32>
  %12 = "mhlo.reduce"(%11, %cst_1) ( {
  ^bb0(%arg1: tensor<f32>, %arg2: tensor<f32>):  // no predecessors
    %15 = mhlo.add %arg1, %arg2 : tensor<f32>
    "mhlo.return"(%15) : (tensor<f32>) -> ()
  }) {dimensions = dense<1> : tensor<1xi64>} : (tensor<1x10xf32>, tensor<f32>) -> tensor<1xf32>
  %13 = "mhlo.broadcast_in_dim"(%12) {broadcast_dimensions = dense<0> : tensor<1xi64>} : (tensor<1xf32>) -> tensor<1x10xf32>
  %14 = mhlo.divide %11, %13 : tensor<1x10xf32>
  return %14 : tensor<1x10xf32>
}

// *** IR Dump After mlir::iree_compiler::`anonymous-namespace'::ConvertHLOToLinalgOnTensorsPass ***
func @predict(%arg0: tensor<1x28x28x1xf32>) -> tensor<1x10xf32> attributes {iree.module.export, iree.reflection = {abi = "sip", abiv = 1 : i32, f = "I15!B11!d1d28d28d1R9!B6!d1d10", fv = "1", sip = "I8!S5!k0_0R3!_0"}} {
  %cst = constant dense<0.000000e+00> : tensor<1x128xf32>
  %cst_0 = constant dense<0xFF800000> : tensor<f32>
  %cst_1 = constant dense<0.000000e+00> : tensor<f32>
  %cst_2 = constant opaque<"_", "0xDEADBEEF"> : tensor<10xf32>
  %cst_3 = constant opaque<"_", "0xDEADBEEF"> : tensor<128x10xf32>
  %cst_4 = constant opaque<"_", "0xDEADBEEF"> : tensor<128xf32>
  %cst_5 = constant opaque<"_", "0xDEADBEEF"> : tensor<784x128xf32>
  %0 = linalg.tensor_reshape %arg0 [[0], [1, 2, 3]] : tensor<1x28x28x1xf32> into tensor<1x784xf32>
  %cst_6 = constant 0.000000e+00 : f32
  %1 = linalg.init_tensor [1, 128] : tensor<1x128xf32>
  %2 = linalg.fill(%1, %cst_6) : tensor<1x128xf32>, f32 -> tensor<1x128xf32> 
  %3 = linalg.matmul ins(%0, %cst_5 : tensor<1x784xf32>, tensor<784x128xf32>) outs(%2 : tensor<1x128xf32>) -> tensor<1x128xf32>
  %4 = linalg.init_tensor [1, 128] : tensor<1x128xf32>
  %5 = linalg.generic {indexing_maps = [affine_map<(d0, d1) -> (d1)>, affine_map<(d0, d1) -> (d0, d1)>], iterator_types = ["parallel", "parallel"]} ins(%cst_4 : tensor<128xf32>) outs(%4 : tensor<1x128xf32>) {
  ^bb0(%arg1: f32, %arg2: f32):  // no predecessors
    linalg.yield %arg1 : f32
  } -> tensor<1x128xf32>
  %6 = linalg.init_tensor [1, 128] : tensor<1x128xf32>
  %7 = linalg.generic {indexing_maps = [affine_map<(d0, d1) -> (d0, d1)>, affine_map<(d0, d1) -> (d0, d1)>, affine_map<(d0, d1) -> (d0, d1)>], iterator_types = ["parallel", "parallel"]} ins(%3, %5 : tensor<1x128xf32>, tensor<1x128xf32>) outs(%6 : tensor<1x128xf32>) {
  ^bb0(%arg1: f32, %arg2: f32, %arg3: f32):  // no predecessors
    %33 = addf %arg1, %arg2 : f32
    linalg.yield %33 : f32
  } -> tensor<1x128xf32>
  %8 = linalg.init_tensor [1, 128] : tensor<1x128xf32>
  %9 = linalg.generic {indexing_maps = [affine_map<(d0, d1) -> (d0, d1)>, affine_map<(d0, d1) -> (d0, d1)>, affine_map<(d0, d1) -> (d0, d1)>], iterator_types = ["parallel", "parallel"]} ins(%7, %cst : tensor<1x128xf32>, tensor<1x128xf32>) outs(%8 : tensor<1x128xf32>) {
  ^bb0(%arg1: f32, %arg2: f32, %arg3: f32):  // no predecessors
    %33 = cmpf ogt, %arg1, %arg2 : f32
    %34 = select %33, %arg1, %arg2 : f32
    %35 = cmpf uno, %arg1, %arg2 : f32
    %cst_10 = constant 0x7FC00000 : f32
    %36 = select %35, %cst_10, %34 : f32
    linalg.yield %36 : f32
  } -> tensor<1x128xf32>
  %cst_7 = constant 0.000000e+00 : f32
  %10 = linalg.init_tensor [1, 10] : tensor<1x10xf32>
  %11 = linalg.fill(%10, %cst_7) : tensor<1x10xf32>, f32 -> tensor<1x10xf32> 
  %12 = linalg.matmul ins(%9, %cst_3 : tensor<1x128xf32>, tensor<128x10xf32>) outs(%11 : tensor<1x10xf32>) -> tensor<1x10xf32>
  %13 = linalg.init_tensor [1, 10] : tensor<1x10xf32>
  %14 = linalg.generic {indexing_maps = [affine_map<(d0, d1) -> (d1)>, affine_map<(d0, d1) -> (d0, d1)>], iterator_types = ["parallel", "parallel"]} ins(%cst_2 : tensor<10xf32>) outs(%13 : tensor<1x10xf32>) {
  ^bb0(%arg1: f32, %arg2: f32):  // no predecessors
    linalg.yield %arg1 : f32
  } -> tensor<1x10xf32>
  %15 = linalg.init_tensor [1, 10] : tensor<1x10xf32>
  %16 = linalg.generic {indexing_maps = [affine_map<(d0, d1) -> (d0, d1)>, affine_map<(d0, d1) -> (d0, d1)>, affine_map<(d0, d1) -> (d0, d1)>], iterator_types = ["parallel", "parallel"]} ins(%12, %14 : tensor<1x10xf32>, tensor<1x10xf32>) outs(%15 : tensor<1x10xf32>) {
  ^bb0(%arg1: f32, %arg2: f32, %arg3: f32):  // no predecessors
    %33 = addf %arg1, %arg2 : f32
    linalg.yield %33 : f32
  } -> tensor<1x10xf32>
  %cst_8 = constant 0xFF800000 : f32
  %17 = linalg.init_tensor [1] : tensor<1xf32>
  %18 = linalg.fill(%17, %cst_8) : tensor<1xf32>, f32 -> tensor<1xf32> 
  %19 = linalg.generic {indexing_maps = [affine_map<(d0, d1) -> (d0, d1)>, affine_map<(d0, d1) -> (d0)>], iterator_types = ["parallel", "reduction"]} ins(%16 : tensor<1x10xf32>) outs(%18 : tensor<1xf32>) {
  ^bb0(%arg1: f32, %arg2: f32):  // no predecessors
    %33 = cmpf ogt, %arg1, %arg2 : f32
    %34 = select %33, %arg1, %arg2 : f32
    %35 = cmpf uno, %arg1, %arg2 : f32
    %cst_10 = constant 0x7FC00000 : f32
    %36 = select %35, %cst_10, %34 : f32
    linalg.yield %36 : f32
  } -> tensor<1xf32>
  %20 = linalg.init_tensor [1, 10] : tensor<1x10xf32>
  %21 = linalg.generic {indexing_maps = [affine_map<(d0, d1) -> (d0)>, affine_map<(d0, d1) -> (d0, d1)>], iterator_types = ["parallel", "parallel"]} ins(%19 : tensor<1xf32>) outs(%20 : tensor<1x10xf32>) {
  ^bb0(%arg1: f32, %arg2: f32):  // no predecessors
    linalg.yield %arg1 : f32
  } -> tensor<1x10xf32>
  %22 = linalg.init_tensor [1, 10] : tensor<1x10xf32>
  %23 = linalg.generic {indexing_maps = [affine_map<(d0, d1) -> (d0, d1)>, affine_map<(d0, d1) -> (d0, d1)>, affine_map<(d0, d1) -> (d0, d1)>], iterator_types = ["parallel", "parallel"]} ins(%16, %21 : tensor<1x10xf32>, tensor<1x10xf32>) outs(%22 : tensor<1x10xf32>) {
  ^bb0(%arg1: f32, %arg2: f32, %arg3: f32):  // no predecessors
    %33 = subf %arg1, %arg2 : f32
    linalg.yield %33 : f32
  } -> tensor<1x10xf32>
  %24 = linalg.init_tensor [1, 10] : tensor<1x10xf32>
  %25 = linalg.generic {indexing_maps = [affine_map<(d0, d1) -> (d0, d1)>, affine_map<(d0, d1) -> (d0, d1)>], iterator_types = ["parallel", "parallel"]} ins(%23 : tensor<1x10xf32>) outs(%24 : tensor<1x10xf32>) {
  ^bb0(%arg1: f32, %arg2: f32):  // no predecessors
    %33 = math.exp %arg1 : f32
    linalg.yield %33 : f32
  } -> tensor<1x10xf32>
  %cst_9 = constant 0.000000e+00 : f32
  %26 = linalg.init_tensor [1] : tensor<1xf32>
  %27 = linalg.fill(%26, %cst_9) : tensor<1xf32>, f32 -> tensor<1xf32> 
  %28 = linalg.generic {indexing_maps = [affine_map<(d0, d1) -> (d0, d1)>, affine_map<(d0, d1) -> (d0)>], iterator_types = ["parallel", "reduction"]} ins(%25 : tensor<1x10xf32>) outs(%27 : tensor<1xf32>) {
  ^bb0(%arg1: f32, %arg2: f32):  // no predecessors
    %33 = addf %arg1, %arg2 : f32
    linalg.yield %33 : f32
  } -> tensor<1xf32>
  %29 = linalg.init_tensor [1, 10] : tensor<1x10xf32>
  %30 = linalg.generic {indexing_maps = [affine_map<(d0, d1) -> (d0)>, affine_map<(d0, d1) -> (d0, d1)>], iterator_types = ["parallel", "parallel"]} ins(%28 : tensor<1xf32>) outs(%29 : tensor<1x10xf32>) {
  ^bb0(%arg1: f32, %arg2: f32):  // no predecessors
    linalg.yield %arg1 : f32
  } -> tensor<1x10xf32>
  %31 = linalg.init_tensor [1, 10] : tensor<1x10xf32>
  %32 = linalg.generic {indexing_maps = [affine_map<(d0, d1) -> (d0, d1)>, affine_map<(d0, d1) -> (d0, d1)>, affine_map<(d0, d1) -> (d0, d1)>], iterator_types = ["parallel", "parallel"]} ins(%25, %30 : tensor<1x10xf32>, tensor<1x10xf32>) outs(%31 : tensor<1x10xf32>) {
  ^bb0(%arg1: f32, %arg2: f32, %arg3: f32):  // no predecessors
    %33 = divf %arg1, %arg2 : f32
    linalg.yield %33 : f32
  } -> tensor<1x10xf32>
  return %32 : tensor<1x10xf32>
}

// *** IR Dump After mlir::iree_compiler::`anonymous-namespace'::Convert1x1ConvToMatmulPass ***
func @predict(%arg0: tensor<1x28x28x1xf32>) -> tensor<1x10xf32> attributes {iree.module.export, iree.reflection = {abi = "sip", abiv = 1 : i32, f = "I15!B11!d1d28d28d1R9!B6!d1d10", fv = "1", sip = "I8!S5!k0_0R3!_0"}} {
  %cst = constant dense<0.000000e+00> : tensor<1x128xf32>
  %cst_0 = constant opaque<"_", "0xDEADBEEF"> : tensor<10xf32>
  %cst_1 = constant opaque<"_", "0xDEADBEEF"> : tensor<128x10xf32>
  %cst_2 = constant opaque<"_", "0xDEADBEEF"> : tensor<128xf32>
  %cst_3 = constant opaque<"_", "0xDEADBEEF"> : tensor<784x128xf32>
  %cst_4 = constant 0xFF800000 : f32
  %cst_5 = constant 0x7FC00000 : f32
  %cst_6 = constant 0.000000e+00 : f32
  %0 = linalg.tensor_reshape %arg0 [[0], [1, 2, 3]] : tensor<1x28x28x1xf32> into tensor<1x784xf32>
  %1 = linalg.init_tensor [1, 128] : tensor<1x128xf32>
  %2 = linalg.fill(%1, %cst_6) : tensor<1x128xf32>, f32 -> tensor<1x128xf32> 
  %3 = linalg.matmul ins(%0, %cst_3 : tensor<1x784xf32>, tensor<784x128xf32>) outs(%2 : tensor<1x128xf32>) -> tensor<1x128xf32>
  %4 = linalg.init_tensor [1, 128] : tensor<1x128xf32>
  %5 = linalg.generic {indexing_maps = [affine_map<(d0, d1) -> (d1)>, affine_map<(d0, d1) -> (d0, d1)>], iterator_types = ["parallel", "parallel"]} ins(%cst_2 : tensor<128xf32>) outs(%4 : tensor<1x128xf32>) {
  ^bb0(%arg1: f32, %arg2: f32):  // no predecessors
    linalg.yield %arg1 : f32
  } -> tensor<1x128xf32>
  %6 = linalg.init_tensor [1, 128] : tensor<1x128xf32>
  %7 = linalg.generic {indexing_maps = [affine_map<(d0, d1) -> (d0, d1)>, affine_map<(d0, d1) -> (d0, d1)>, affine_map<(d0, d1) -> (d0, d1)>], iterator_types = ["parallel", "parallel"]} ins(%3, %5 : tensor<1x128xf32>, tensor<1x128xf32>) outs(%6 : tensor<1x128xf32>) {
  ^bb0(%arg1: f32, %arg2: f32, %arg3: f32):  // no predecessors
    %33 = addf %arg1, %arg2 : f32
    linalg.yield %33 : f32
  } -> tensor<1x128xf32>
  %8 = linalg.init_tensor [1, 128] : tensor<1x128xf32>
  %9 = linalg.generic {indexing_maps = [affine_map<(d0, d1) -> (d0, d1)>, affine_map<(d0, d1) -> (d0, d1)>, affine_map<(d0, d1) -> (d0, d1)>], iterator_types = ["parallel", "parallel"]} ins(%7, %cst : tensor<1x128xf32>, tensor<1x128xf32>) outs(%8 : tensor<1x128xf32>) {
  ^bb0(%arg1: f32, %arg2: f32, %arg3: f32):  // no predecessors
    %33 = cmpf ogt, %arg1, %arg2 : f32
    %34 = select %33, %arg1, %arg2 : f32
    %35 = cmpf uno, %arg1, %arg2 : f32
    %36 = select %35, %cst_5, %34 : f32
    linalg.yield %36 : f32
  } -> tensor<1x128xf32>
  %10 = linalg.init_tensor [1, 10] : tensor<1x10xf32>
  %11 = linalg.fill(%10, %cst_6) : tensor<1x10xf32>, f32 -> tensor<1x10xf32> 
  %12 = linalg.matmul ins(%9, %cst_1 : tensor<1x128xf32>, tensor<128x10xf32>) outs(%11 : tensor<1x10xf32>) -> tensor<1x10xf32>
  %13 = linalg.init_tensor [1, 10] : tensor<1x10xf32>
  %14 = linalg.generic {indexing_maps = [affine_map<(d0, d1) -> (d1)>, affine_map<(d0, d1) -> (d0, d1)>], iterator_types = ["parallel", "parallel"]} ins(%cst_0 : tensor<10xf32>) outs(%13 : tensor<1x10xf32>) {
  ^bb0(%arg1: f32, %arg2: f32):  // no predecessors
    linalg.yield %arg1 : f32
  } -> tensor<1x10xf32>
  %15 = linalg.init_tensor [1, 10] : tensor<1x10xf32>
  %16 = linalg.generic {indexing_maps = [affine_map<(d0, d1) -> (d0, d1)>, affine_map<(d0, d1) -> (d0, d1)>, affine_map<(d0, d1) -> (d0, d1)>], iterator_types = ["parallel", "parallel"]} ins(%12, %14 : tensor<1x10xf32>, tensor<1x10xf32>) outs(%15 : tensor<1x10xf32>) {
  ^bb0(%arg1: f32, %arg2: f32, %arg3: f32):  // no predecessors
    %33 = addf %arg1, %arg2 : f32
    linalg.yield %33 : f32
  } -> tensor<1x10xf32>
  %17 = linalg.init_tensor [1] : tensor<1xf32>
  %18 = linalg.fill(%17, %cst_4) : tensor<1xf32>, f32 -> tensor<1xf32> 
  %19 = linalg.generic {indexing_maps = [affine_map<(d0, d1) -> (d0, d1)>, affine_map<(d0, d1) -> (d0)>], iterator_types = ["parallel", "reduction"]} ins(%16 : tensor<1x10xf32>) outs(%18 : tensor<1xf32>) {
  ^bb0(%arg1: f32, %arg2: f32):  // no predecessors
    %33 = cmpf ogt, %arg1, %arg2 : f32
    %34 = select %33, %arg1, %arg2 : f32
    %35 = cmpf uno, %arg1, %arg2 : f32
    %36 = select %35, %cst_5, %34 : f32
    linalg.yield %36 : f32
  } -> tensor<1xf32>
  %20 = linalg.init_tensor [1, 10] : tensor<1x10xf32>
  %21 = linalg.generic {indexing_maps = [affine_map<(d0, d1) -> (d0)>, affine_map<(d0, d1) -> (d0, d1)>], iterator_types = ["parallel", "parallel"]} ins(%19 : tensor<1xf32>) outs(%20 : tensor<1x10xf32>) {
  ^bb0(%arg1: f32, %arg2: f32):  // no predecessors
    linalg.yield %arg1 : f32
  } -> tensor<1x10xf32>
  %22 = linalg.init_tensor [1, 10] : tensor<1x10xf32>
  %23 = linalg.generic {indexing_maps = [affine_map<(d0, d1) -> (d0, d1)>, affine_map<(d0, d1) -> (d0, d1)>, affine_map<(d0, d1) -> (d0, d1)>], iterator_types = ["parallel", "parallel"]} ins(%16, %21 : tensor<1x10xf32>, tensor<1x10xf32>) outs(%22 : tensor<1x10xf32>) {
  ^bb0(%arg1: f32, %arg2: f32, %arg3: f32):  // no predecessors
    %33 = subf %arg1, %arg2 : f32
    linalg.yield %33 : f32
  } -> tensor<1x10xf32>
  %24 = linalg.init_tensor [1, 10] : tensor<1x10xf32>
  %25 = linalg.generic {indexing_maps = [affine_map<(d0, d1) -> (d0, d1)>, affine_map<(d0, d1) -> (d0, d1)>], iterator_types = ["parallel", "parallel"]} ins(%23 : tensor<1x10xf32>) outs(%24 : tensor<1x10xf32>) {
  ^bb0(%arg1: f32, %arg2: f32):  // no predecessors
    %33 = math.exp %arg1 : f32
    linalg.yield %33 : f32
  } -> tensor<1x10xf32>
  %26 = linalg.init_tensor [1] : tensor<1xf32>
  %27 = linalg.fill(%26, %cst_6) : tensor<1xf32>, f32 -> tensor<1xf32> 
  %28 = linalg.generic {indexing_maps = [affine_map<(d0, d1) -> (d0, d1)>, affine_map<(d0, d1) -> (d0)>], iterator_types = ["parallel", "reduction"]} ins(%25 : tensor<1x10xf32>) outs(%27 : tensor<1xf32>) {
  ^bb0(%arg1: f32, %arg2: f32):  // no predecessors
    %33 = addf %arg1, %arg2 : f32
    linalg.yield %33 : f32
  } -> tensor<1xf32>
  %29 = linalg.init_tensor [1, 10] : tensor<1x10xf32>
  %30 = linalg.generic {indexing_maps = [affine_map<(d0, d1) -> (d0)>, affine_map<(d0, d1) -> (d0, d1)>], iterator_types = ["parallel", "parallel"]} ins(%28 : tensor<1xf32>) outs(%29 : tensor<1x10xf32>) {
  ^bb0(%arg1: f32, %arg2: f32):  // no predecessors
    linalg.yield %arg1 : f32
  } -> tensor<1x10xf32>
  %31 = linalg.init_tensor [1, 10] : tensor<1x10xf32>
  %32 = linalg.generic {indexing_maps = [affine_map<(d0, d1) -> (d0, d1)>, affine_map<(d0, d1) -> (d0, d1)>, affine_map<(d0, d1) -> (d0, d1)>], iterator_types = ["parallel", "parallel"]} ins(%25, %30 : tensor<1x10xf32>, tensor<1x10xf32>) outs(%31 : tensor<1x10xf32>) {
  ^bb0(%arg1: f32, %arg2: f32, %arg3: f32):  // no predecessors
    %33 = divf %arg1, %arg2 : f32
    linalg.yield %33 : f32
  } -> tensor<1x10xf32>
  return %32 : tensor<1x10xf32>
}

// *** IR Dump After ConvertElementwiseToLinalg ***
func @predict(%arg0: tensor<1x28x28x1xf32>) -> tensor<1x10xf32> attributes {iree.module.export, iree.reflection = {abi = "sip", abiv = 1 : i32, f = "I15!B11!d1d28d28d1R9!B6!d1d10", fv = "1", sip = "I8!S5!k0_0R3!_0"}} {
  %cst = constant dense<0.000000e+00> : tensor<1x128xf32>
  %cst_0 = constant opaque<"_", "0xDEADBEEF"> : tensor<10xf32>
  %cst_1 = constant opaque<"_", "0xDEADBEEF"> : tensor<128x10xf32>
  %cst_2 = constant opaque<"_", "0xDEADBEEF"> : tensor<128xf32>
  %cst_3 = constant opaque<"_", "0xDEADBEEF"> : tensor<784x128xf32>
  %cst_4 = constant 0xFF800000 : f32
  %cst_5 = constant 0x7FC00000 : f32
  %cst_6 = constant 0.000000e+00 : f32
  %0 = linalg.tensor_reshape %arg0 [[0], [1, 2, 3]] : tensor<1x28x28x1xf32> into tensor<1x784xf32>
  %1 = linalg.init_tensor [1, 128] : tensor<1x128xf32>
  %2 = linalg.fill(%1, %cst_6) : tensor<1x128xf32>, f32 -> tensor<1x128xf32> 
  %3 = linalg.matmul ins(%0, %cst_3 : tensor<1x784xf32>, tensor<784x128xf32>) outs(%2 : tensor<1x128xf32>) -> tensor<1x128xf32>
  %4 = linalg.init_tensor [1, 128] : tensor<1x128xf32>
  %5 = linalg.generic {indexing_maps = [affine_map<(d0, d1) -> (d1)>, affine_map<(d0, d1) -> (d0, d1)>], iterator_types = ["parallel", "parallel"]} ins(%cst_2 : tensor<128xf32>) outs(%4 : tensor<1x128xf32>) {
  ^bb0(%arg1: f32, %arg2: f32):  // no predecessors
    linalg.yield %arg1 : f32
  } -> tensor<1x128xf32>
  %6 = linalg.init_tensor [1, 128] : tensor<1x128xf32>
  %7 = linalg.generic {indexing_maps = [affine_map<(d0, d1) -> (d0, d1)>, affine_map<(d0, d1) -> (d0, d1)>, affine_map<(d0, d1) -> (d0, d1)>], iterator_types = ["parallel", "parallel"]} ins(%3, %5 : tensor<1x128xf32>, tensor<1x128xf32>) outs(%6 : tensor<1x128xf32>) {
  ^bb0(%arg1: f32, %arg2: f32, %arg3: f32):  // no predecessors
    %33 = addf %arg1, %arg2 : f32
    linalg.yield %33 : f32
  } -> tensor<1x128xf32>
  %8 = linalg.init_tensor [1, 128] : tensor<1x128xf32>
  %9 = linalg.generic {indexing_maps = [affine_map<(d0, d1) -> (d0, d1)>, affine_map<(d0, d1) -> (d0, d1)>, affine_map<(d0, d1) -> (d0, d1)>], iterator_types = ["parallel", "parallel"]} ins(%7, %cst : tensor<1x128xf32>, tensor<1x128xf32>) outs(%8 : tensor<1x128xf32>) {
  ^bb0(%arg1: f32, %arg2: f32, %arg3: f32):  // no predecessors
    %33 = cmpf ogt, %arg1, %arg2 : f32
    %34 = select %33, %arg1, %arg2 : f32
    %35 = cmpf uno, %arg1, %arg2 : f32
    %36 = select %35, %cst_5, %34 : f32
    linalg.yield %36 : f32
  } -> tensor<1x128xf32>
  %10 = linalg.init_tensor [1, 10] : tensor<1x10xf32>
  %11 = linalg.fill(%10, %cst_6) : tensor<1x10xf32>, f32 -> tensor<1x10xf32> 
  %12 = linalg.matmul ins(%9, %cst_1 : tensor<1x128xf32>, tensor<128x10xf32>) outs(%11 : tensor<1x10xf32>) -> tensor<1x10xf32>
  %13 = linalg.init_tensor [1, 10] : tensor<1x10xf32>
  %14 = linalg.generic {indexing_maps = [affine_map<(d0, d1) -> (d1)>, affine_map<(d0, d1) -> (d0, d1)>], iterator_types = ["parallel", "parallel"]} ins(%cst_0 : tensor<10xf32>) outs(%13 : tensor<1x10xf32>) {
  ^bb0(%arg1: f32, %arg2: f32):  // no predecessors
    linalg.yield %arg1 : f32
  } -> tensor<1x10xf32>
  %15 = linalg.init_tensor [1, 10] : tensor<1x10xf32>
  %16 = linalg.generic {indexing_maps = [affine_map<(d0, d1) -> (d0, d1)>, affine_map<(d0, d1) -> (d0, d1)>, affine_map<(d0, d1) -> (d0, d1)>], iterator_types = ["parallel", "parallel"]} ins(%12, %14 : tensor<1x10xf32>, tensor<1x10xf32>) outs(%15 : tensor<1x10xf32>) {
  ^bb0(%arg1: f32, %arg2: f32, %arg3: f32):  // no predecessors
    %33 = addf %arg1, %arg2 : f32
    linalg.yield %33 : f32
  } -> tensor<1x10xf32>
  %17 = linalg.init_tensor [1] : tensor<1xf32>
  %18 = linalg.fill(%17, %cst_4) : tensor<1xf32>, f32 -> tensor<1xf32> 
  %19 = linalg.generic {indexing_maps = [affine_map<(d0, d1) -> (d0, d1)>, affine_map<(d0, d1) -> (d0)>], iterator_types = ["parallel", "reduction"]} ins(%16 : tensor<1x10xf32>) outs(%18 : tensor<1xf32>) {
  ^bb0(%arg1: f32, %arg2: f32):  // no predecessors
    %33 = cmpf ogt, %arg1, %arg2 : f32
    %34 = select %33, %arg1, %arg2 : f32
    %35 = cmpf uno, %arg1, %arg2 : f32
    %36 = select %35, %cst_5, %34 : f32
    linalg.yield %36 : f32
  } -> tensor<1xf32>
  %20 = linalg.init_tensor [1, 10] : tensor<1x10xf32>
  %21 = linalg.generic {indexing_maps = [affine_map<(d0, d1) -> (d0)>, affine_map<(d0, d1) -> (d0, d1)>], iterator_types = ["parallel", "parallel"]} ins(%19 : tensor<1xf32>) outs(%20 : tensor<1x10xf32>) {
  ^bb0(%arg1: f32, %arg2: f32):  // no predecessors
    linalg.yield %arg1 : f32
  } -> tensor<1x10xf32>
  %22 = linalg.init_tensor [1, 10] : tensor<1x10xf32>
  %23 = linalg.generic {indexing_maps = [affine_map<(d0, d1) -> (d0, d1)>, affine_map<(d0, d1) -> (d0, d1)>, affine_map<(d0, d1) -> (d0, d1)>], iterator_types = ["parallel", "parallel"]} ins(%16, %21 : tensor<1x10xf32>, tensor<1x10xf32>) outs(%22 : tensor<1x10xf32>) {
  ^bb0(%arg1: f32, %arg2: f32, %arg3: f32):  // no predecessors
    %33 = subf %arg1, %arg2 : f32
    linalg.yield %33 : f32
  } -> tensor<1x10xf32>
  %24 = linalg.init_tensor [1, 10] : tensor<1x10xf32>
  %25 = linalg.generic {indexing_maps = [affine_map<(d0, d1) -> (d0, d1)>, affine_map<(d0, d1) -> (d0, d1)>], iterator_types = ["parallel", "parallel"]} ins(%23 : tensor<1x10xf32>) outs(%24 : tensor<1x10xf32>) {
  ^bb0(%arg1: f32, %arg2: f32):  // no predecessors
    %33 = math.exp %arg1 : f32
    linalg.yield %33 : f32
  } -> tensor<1x10xf32>
  %26 = linalg.init_tensor [1] : tensor<1xf32>
  %27 = linalg.fill(%26, %cst_6) : tensor<1xf32>, f32 -> tensor<1xf32> 
  %28 = linalg.generic {indexing_maps = [affine_map<(d0, d1) -> (d0, d1)>, affine_map<(d0, d1) -> (d0)>], iterator_types = ["parallel", "reduction"]} ins(%25 : tensor<1x10xf32>) outs(%27 : tensor<1xf32>) {
  ^bb0(%arg1: f32, %arg2: f32):  // no predecessors
    %33 = addf %arg1, %arg2 : f32
    linalg.yield %33 : f32
  } -> tensor<1xf32>
  %29 = linalg.init_tensor [1, 10] : tensor<1x10xf32>
  %30 = linalg.generic {indexing_maps = [affine_map<(d0, d1) -> (d0)>, affine_map<(d0, d1) -> (d0, d1)>], iterator_types = ["parallel", "parallel"]} ins(%28 : tensor<1xf32>) outs(%29 : tensor<1x10xf32>) {
  ^bb0(%arg1: f32, %arg2: f32):  // no predecessors
    linalg.yield %arg1 : f32
  } -> tensor<1x10xf32>
  %31 = linalg.init_tensor [1, 10] : tensor<1x10xf32>
  %32 = linalg.generic {indexing_maps = [affine_map<(d0, d1) -> (d0, d1)>, affine_map<(d0, d1) -> (d0, d1)>, affine_map<(d0, d1) -> (d0, d1)>], iterator_types = ["parallel", "parallel"]} ins(%25, %30 : tensor<1x10xf32>, tensor<1x10xf32>) outs(%31 : tensor<1x10xf32>) {
  ^bb0(%arg1: f32, %arg2: f32, %arg3: f32):  // no predecessors
    %33 = divf %arg1, %arg2 : f32
    linalg.yield %33 : f32
  } -> tensor<1x10xf32>
  return %32 : tensor<1x10xf32>
}

// *** IR Dump After LinalgFoldUnitExtentDims ***
func @predict(%arg0: tensor<1x28x28x1xf32>) -> tensor<1x10xf32> attributes {iree.module.export, iree.reflection = {abi = "sip", abiv = 1 : i32, f = "I15!B11!d1d28d28d1R9!B6!d1d10", fv = "1", sip = "I8!S5!k0_0R3!_0"}} {
  %cst = constant opaque<"_", "0xDEADBEEF"> : tensor<10xf32>
  %cst_0 = constant opaque<"_", "0xDEADBEEF"> : tensor<128x10xf32>
  %cst_1 = constant dense<0.000000e+00> : tensor<128xf32>
  %cst_2 = constant opaque<"_", "0xDEADBEEF"> : tensor<128xf32>
  %cst_3 = constant opaque<"_", "0xDEADBEEF"> : tensor<784x128xf32>
  %cst_4 = constant 0xFF800000 : f32
  %cst_5 = constant 0x7FC00000 : f32
  %cst_6 = constant 0.000000e+00 : f32
  %0 = linalg.tensor_reshape %arg0 [[0], [1, 2, 3]] : tensor<1x28x28x1xf32> into tensor<1x784xf32>
  %1 = linalg.init_tensor [1, 128] : tensor<1x128xf32>
  %2 = linalg.fill(%1, %cst_6) : tensor<1x128xf32>, f32 -> tensor<1x128xf32> 
  %3 = linalg.matmul ins(%0, %cst_3 : tensor<1x784xf32>, tensor<784x128xf32>) outs(%2 : tensor<1x128xf32>) -> tensor<1x128xf32>
  %4 = linalg.init_tensor [128] : tensor<128xf32>
  %5 = linalg.generic {indexing_maps = [affine_map<(d0) -> (d0)>, affine_map<(d0) -> (d0)>], iterator_types = ["parallel"]} ins(%cst_2 : tensor<128xf32>) outs(%4 : tensor<128xf32>) {
  ^bb0(%arg1: f32, %arg2: f32):  // no predecessors
    linalg.yield %arg1 : f32
  } -> tensor<128xf32>
  %6 = linalg.tensor_reshape %3 [[0, 1]] : tensor<1x128xf32> into tensor<128xf32>
  %7 = linalg.init_tensor [128] : tensor<128xf32>
  %8 = linalg.generic {indexing_maps = [affine_map<(d0) -> (d0)>, affine_map<(d0) -> (d0)>, affine_map<(d0) -> (d0)>], iterator_types = ["parallel"]} ins(%6, %5 : tensor<128xf32>, tensor<128xf32>) outs(%7 : tensor<128xf32>) {
  ^bb0(%arg1: f32, %arg2: f32, %arg3: f32):  // no predecessors
    %37 = addf %arg1, %arg2 : f32
    linalg.yield %37 : f32
  } -> tensor<128xf32>
  %9 = linalg.init_tensor [128] : tensor<128xf32>
  %10 = linalg.generic {indexing_maps = [affine_map<(d0) -> (d0)>, affine_map<(d0) -> (d0)>, affine_map<(d0) -> (d0)>], iterator_types = ["parallel"]} ins(%8, %cst_1 : tensor<128xf32>, tensor<128xf32>) outs(%9 : tensor<128xf32>) {
  ^bb0(%arg1: f32, %arg2: f32, %arg3: f32):  // no predecessors
    %37 = cmpf ogt, %arg1, %arg2 : f32
    %38 = select %37, %arg1, %arg2 : f32
    %39 = cmpf uno, %arg1, %arg2 : f32
    %40 = select %39, %cst_5, %38 : f32
    linalg.yield %40 : f32
  } -> tensor<128xf32>
  %11 = linalg.tensor_reshape %10 [[0, 1]] : tensor<128xf32> into tensor<1x128xf32>
  %12 = linalg.init_tensor [1, 10] : tensor<1x10xf32>
  %13 = linalg.fill(%12, %cst_6) : tensor<1x10xf32>, f32 -> tensor<1x10xf32> 
  %14 = linalg.matmul ins(%11, %cst_0 : tensor<1x128xf32>, tensor<128x10xf32>) outs(%13 : tensor<1x10xf32>) -> tensor<1x10xf32>
  %15 = linalg.init_tensor [10] : tensor<10xf32>
  %16 = linalg.generic {indexing_maps = [affine_map<(d0) -> (d0)>, affine_map<(d0) -> (d0)>], iterator_types = ["parallel"]} ins(%cst : tensor<10xf32>) outs(%15 : tensor<10xf32>) {
  ^bb0(%arg1: f32, %arg2: f32):  // no predecessors
    linalg.yield %arg1 : f32
  } -> tensor<10xf32>
  %17 = linalg.tensor_reshape %14 [[0, 1]] : tensor<1x10xf32> into tensor<10xf32>
  %18 = linalg.init_tensor [10] : tensor<10xf32>
  %19 = linalg.generic {indexing_maps = [affine_map<(d0) -> (d0)>, affine_map<(d0) -> (d0)>, affine_map<(d0) -> (d0)>], iterator_types = ["parallel"]} ins(%17, %16 : tensor<10xf32>, tensor<10xf32>) outs(%18 : tensor<10xf32>) {
  ^bb0(%arg1: f32, %arg2: f32, %arg3: f32):  // no predecessors
    %37 = addf %arg1, %arg2 : f32
    linalg.yield %37 : f32
  } -> tensor<10xf32>
  %20 = linalg.init_tensor [] : tensor<f32>
  %21 = linalg.fill(%20, %cst_4) : tensor<f32>, f32 -> tensor<f32> 
  %22 = linalg.generic {indexing_maps = [affine_map<(d0) -> (d0)>, affine_map<(d0) -> ()>], iterator_types = ["reduction"]} ins(%19 : tensor<10xf32>) outs(%21 : tensor<f32>) {
  ^bb0(%arg1: f32, %arg2: f32):  // no predecessors
    %37 = cmpf ogt, %arg1, %arg2 : f32
    %38 = select %37, %arg1, %arg2 : f32
    %39 = cmpf uno, %arg1, %arg2 : f32
    %40 = select %39, %cst_5, %38 : f32
    linalg.yield %40 : f32
  } -> tensor<f32>
  %23 = linalg.init_tensor [10] : tensor<10xf32>
  %24 = linalg.generic {indexing_maps = [affine_map<(d0) -> ()>, affine_map<(d0) -> (d0)>], iterator_types = ["parallel"]} ins(%22 : tensor<f32>) outs(%23 : tensor<10xf32>) {
  ^bb0(%arg1: f32, %arg2: f32):  // no predecessors
    linalg.yield %arg1 : f32
  } -> tensor<10xf32>
  %25 = linalg.init_tensor [10] : tensor<10xf32>
  %26 = linalg.generic {indexing_maps = [affine_map<(d0) -> (d0)>, affine_map<(d0) -> (d0)>, affine_map<(d0) -> (d0)>], iterator_types = ["parallel"]} ins(%19, %24 : tensor<10xf32>, tensor<10xf32>) outs(%25 : tensor<10xf32>) {
  ^bb0(%arg1: f32, %arg2: f32, %arg3: f32):  // no predecessors
    %37 = subf %arg1, %arg2 : f32
    linalg.yield %37 : f32
  } -> tensor<10xf32>
  %27 = linalg.init_tensor [10] : tensor<10xf32>
  %28 = linalg.generic {indexing_maps = [affine_map<(d0) -> (d0)>, affine_map<(d0) -> (d0)>], iterator_types = ["parallel"]} ins(%26 : tensor<10xf32>) outs(%27 : tensor<10xf32>) {
  ^bb0(%arg1: f32, %arg2: f32):  // no predecessors
    %37 = math.exp %arg1 : f32
    linalg.yield %37 : f32
  } -> tensor<10xf32>
  %29 = linalg.init_tensor [] : tensor<f32>
  %30 = linalg.fill(%29, %cst_6) : tensor<f32>, f32 -> tensor<f32> 
  %31 = linalg.generic {indexing_maps = [affine_map<(d0) -> (d0)>, affine_map<(d0) -> ()>], iterator_types = ["reduction"]} ins(%28 : tensor<10xf32>) outs(%30 : tensor<f32>) {
  ^bb0(%arg1: f32, %arg2: f32):  // no predecessors
    %37 = addf %arg1, %arg2 : f32
    linalg.yield %37 : f32
  } -> tensor<f32>
  %32 = linalg.init_tensor [10] : tensor<10xf32>
  %33 = linalg.generic {indexing_maps = [affine_map<(d0) -> ()>, affine_map<(d0) -> (d0)>], iterator_types = ["parallel"]} ins(%31 : tensor<f32>) outs(%32 : tensor<10xf32>) {
  ^bb0(%arg1: f32, %arg2: f32):  // no predecessors
    linalg.yield %arg1 : f32
  } -> tensor<10xf32>
  %34 = linalg.init_tensor [10] : tensor<10xf32>
  %35 = linalg.generic {indexing_maps = [affine_map<(d0) -> (d0)>, affine_map<(d0) -> (d0)>, affine_map<(d0) -> (d0)>], iterator_types = ["parallel"]} ins(%28, %33 : tensor<10xf32>, tensor<10xf32>) outs(%34 : tensor<10xf32>) {
  ^bb0(%arg1: f32, %arg2: f32, %arg3: f32):  // no predecessors
    %37 = divf %arg1, %arg2 : f32
    linalg.yield %37 : f32
  } -> tensor<10xf32>
  %36 = linalg.tensor_reshape %35 [[0, 1]] : tensor<10xf32> into tensor<1x10xf32>
  return %36 : tensor<1x10xf32>
}

// *** IR Dump After Canonicalizer ***
func @predict(%arg0: tensor<1x28x28x1xf32>) -> tensor<1x10xf32> attributes {iree.module.export, iree.reflection = {abi = "sip", abiv = 1 : i32, f = "I15!B11!d1d28d28d1R9!B6!d1d10", fv = "1", sip = "I8!S5!k0_0R3!_0"}} {
  %cst = constant opaque<"_", "0xDEADBEEF"> : tensor<10xf32>
  %cst_0 = constant opaque<"_", "0xDEADBEEF"> : tensor<128x10xf32>
  %cst_1 = constant dense<0.000000e+00> : tensor<128xf32>
  %cst_2 = constant opaque<"_", "0xDEADBEEF"> : tensor<128xf32>
  %cst_3 = constant opaque<"_", "0xDEADBEEF"> : tensor<784x128xf32>
  %cst_4 = constant 0xFF800000 : f32
  %cst_5 = constant 0x7FC00000 : f32
  %cst_6 = constant 0.000000e+00 : f32
  %0 = linalg.tensor_reshape %arg0 [[0], [1, 2, 3]] : tensor<1x28x28x1xf32> into tensor<1x784xf32>
  %1 = linalg.init_tensor [1, 128] : tensor<1x128xf32>
  %2 = linalg.fill(%1, %cst_6) : tensor<1x128xf32>, f32 -> tensor<1x128xf32> 
  %3 = linalg.matmul ins(%0, %cst_3 : tensor<1x784xf32>, tensor<784x128xf32>) outs(%2 : tensor<1x128xf32>) -> tensor<1x128xf32>
  %4 = linalg.tensor_reshape %3 [[0, 1]] : tensor<1x128xf32> into tensor<128xf32>
  %5 = linalg.init_tensor [128] : tensor<128xf32>
  %6 = linalg.generic {indexing_maps = [affine_map<(d0) -> (d0)>, affine_map<(d0) -> (d0)>, affine_map<(d0) -> (d0)>], iterator_types = ["parallel"]} ins(%4, %cst_2 : tensor<128xf32>, tensor<128xf32>) outs(%5 : tensor<128xf32>) {
  ^bb0(%arg1: f32, %arg2: f32, %arg3: f32):  // no predecessors
    %33 = addf %arg1, %arg2 : f32
    linalg.yield %33 : f32
  } -> tensor<128xf32>
  %7 = linalg.init_tensor [128] : tensor<128xf32>
  %8 = linalg.generic {indexing_maps = [affine_map<(d0) -> (d0)>, affine_map<(d0) -> (d0)>, affine_map<(d0) -> (d0)>], iterator_types = ["parallel"]} ins(%6, %cst_1 : tensor<128xf32>, tensor<128xf32>) outs(%7 : tensor<128xf32>) {
  ^bb0(%arg1: f32, %arg2: f32, %arg3: f32):  // no predecessors
    %33 = cmpf ogt, %arg1, %arg2 : f32
    %34 = select %33, %arg1, %arg2 : f32
    %35 = cmpf uno, %arg1, %arg2 : f32
    %36 = select %35, %cst_5, %34 : f32
    linalg.yield %36 : f32
  } -> tensor<128xf32>
  %9 = linalg.tensor_reshape %8 [[0, 1]] : tensor<128xf32> into tensor<1x128xf32>
  %10 = linalg.init_tensor [1, 10] : tensor<1x10xf32>
  %11 = linalg.fill(%10, %cst_6) : tensor<1x10xf32>, f32 -> tensor<1x10xf32> 
  %12 = linalg.matmul ins(%9, %cst_0 : tensor<1x128xf32>, tensor<128x10xf32>) outs(%11 : tensor<1x10xf32>) -> tensor<1x10xf32>
  %13 = linalg.tensor_reshape %12 [[0, 1]] : tensor<1x10xf32> into tensor<10xf32>
  %14 = linalg.init_tensor [10] : tensor<10xf32>
  %15 = linalg.generic {indexing_maps = [affine_map<(d0) -> (d0)>, affine_map<(d0) -> (d0)>, affine_map<(d0) -> (d0)>], iterator_types = ["parallel"]} ins(%13, %cst : tensor<10xf32>, tensor<10xf32>) outs(%14 : tensor<10xf32>) {
  ^bb0(%arg1: f32, %arg2: f32, %arg3: f32):  // no predecessors
    %33 = addf %arg1, %arg2 : f32
    linalg.yield %33 : f32
  } -> tensor<10xf32>
  %16 = linalg.init_tensor [] : tensor<f32>
  %17 = linalg.fill(%16, %cst_4) : tensor<f32>, f32 -> tensor<f32> 
  %18 = linalg.generic {indexing_maps = [affine_map<(d0) -> (d0)>, affine_map<(d0) -> ()>], iterator_types = ["reduction"]} ins(%15 : tensor<10xf32>) outs(%17 : tensor<f32>) {
  ^bb0(%arg1: f32, %arg2: f32):  // no predecessors
    %33 = cmpf ogt, %arg1, %arg2 : f32
    %34 = select %33, %arg1, %arg2 : f32
    %35 = cmpf uno, %arg1, %arg2 : f32
    %36 = select %35, %cst_5, %34 : f32
    linalg.yield %36 : f32
  } -> tensor<f32>
  %19 = linalg.init_tensor [10] : tensor<10xf32>
  %20 = linalg.generic {indexing_maps = [affine_map<(d0) -> ()>, affine_map<(d0) -> (d0)>], iterator_types = ["parallel"]} ins(%18 : tensor<f32>) outs(%19 : tensor<10xf32>) {
  ^bb0(%arg1: f32, %arg2: f32):  // no predecessors
    linalg.yield %arg1 : f32
  } -> tensor<10xf32>
  %21 = linalg.init_tensor [10] : tensor<10xf32>
  %22 = linalg.generic {indexing_maps = [affine_map<(d0) -> (d0)>, affine_map<(d0) -> (d0)>, affine_map<(d0) -> (d0)>], iterator_types = ["parallel"]} ins(%15, %20 : tensor<10xf32>, tensor<10xf32>) outs(%21 : tensor<10xf32>) {
  ^bb0(%arg1: f32, %arg2: f32, %arg3: f32):  // no predecessors
    %33 = subf %arg1, %arg2 : f32
    linalg.yield %33 : f32
  } -> tensor<10xf32>
  %23 = linalg.init_tensor [10] : tensor<10xf32>
  %24 = linalg.generic {indexing_maps = [affine_map<(d0) -> (d0)>, affine_map<(d0) -> (d0)>], iterator_types = ["parallel"]} ins(%22 : tensor<10xf32>) outs(%23 : tensor<10xf32>) {
  ^bb0(%arg1: f32, %arg2: f32):  // no predecessors
    %33 = math.exp %arg1 : f32
    linalg.yield %33 : f32
  } -> tensor<10xf32>
  %25 = linalg.init_tensor [] : tensor<f32>
  %26 = linalg.fill(%25, %cst_6) : tensor<f32>, f32 -> tensor<f32> 
  %27 = linalg.generic {indexing_maps = [affine_map<(d0) -> (d0)>, affine_map<(d0) -> ()>], iterator_types = ["reduction"]} ins(%24 : tensor<10xf32>) outs(%26 : tensor<f32>) {
  ^bb0(%arg1: f32, %arg2: f32):  // no predecessors
    %33 = addf %arg1, %arg2 : f32
    linalg.yield %33 : f32
  } -> tensor<f32>
  %28 = linalg.init_tensor [10] : tensor<10xf32>
  %29 = linalg.generic {indexing_maps = [affine_map<(d0) -> ()>, affine_map<(d0) -> (d0)>], iterator_types = ["parallel"]} ins(%27 : tensor<f32>) outs(%28 : tensor<10xf32>) {
  ^bb0(%arg1: f32, %arg2: f32):  // no predecessors
    linalg.yield %arg1 : f32
  } -> tensor<10xf32>
  %30 = linalg.init_tensor [10] : tensor<10xf32>
  %31 = linalg.generic {indexing_maps = [affine_map<(d0) -> (d0)>, affine_map<(d0) -> (d0)>, affine_map<(d0) -> (d0)>], iterator_types = ["parallel"]} ins(%24, %29 : tensor<10xf32>, tensor<10xf32>) outs(%30 : tensor<10xf32>) {
  ^bb0(%arg1: f32, %arg2: f32, %arg3: f32):  // no predecessors
    %33 = divf %arg1, %arg2 : f32
    linalg.yield %33 : f32
  } -> tensor<10xf32>
  %32 = linalg.tensor_reshape %31 [[0, 1]] : tensor<10xf32> into tensor<1x10xf32>
  return %32 : tensor<1x10xf32>
}

// *** IR Dump After mlir::iree_compiler::`anonymous-namespace'::FusionOfTensorOpsPass ***
func @predict(%arg0: tensor<1x28x28x1xf32>) -> tensor<1x10xf32> attributes {iree.module.export, iree.reflection = {abi = "sip", abiv = 1 : i32, f = "I15!B11!d1d28d28d1R9!B6!d1d10", fv = "1", sip = "I8!S5!k0_0R3!_0"}} {
  %cst = constant opaque<"_", "0xDEADBEEF"> : tensor<128x10xf32>
  %cst_0 = constant opaque<"_", "0xDEADBEEF"> : tensor<784x128xf32>
  %cst_1 = constant 0xFF800000 : f32
  %cst_2 = constant 0x7FC00000 : f32
  %cst_3 = constant 0.000000e+00 : f32
  %cst_4 = constant opaque<"_", "0xDEADBEEF"> : tensor<1x128xf32>
  %cst_5 = constant opaque<"_", "0xDEADBEEF"> : tensor<1x10xf32>
  %0 = linalg.tensor_reshape %arg0 [[0], [1, 2, 3]] : tensor<1x28x28x1xf32> into tensor<1x784xf32>
  %1 = linalg.init_tensor [1, 128] : tensor<1x128xf32>
  %2 = linalg.fill(%1, %cst_3) : tensor<1x128xf32>, f32 -> tensor<1x128xf32> 
  %3 = linalg.matmul ins(%0, %cst_0 : tensor<1x784xf32>, tensor<784x128xf32>) outs(%2 : tensor<1x128xf32>) -> tensor<1x128xf32>
  %4 = linalg.init_tensor [1, 128] : tensor<1x128xf32>
  %5 = linalg.generic {indexing_maps = [affine_map<(d0, d1) -> (d0, d1)>, affine_map<(d0, d1) -> (d0, d1)>, affine_map<(d0, d1) -> (d0, d1)>], iterator_types = ["parallel", "parallel"]} ins(%3, %cst_4 : tensor<1x128xf32>, tensor<1x128xf32>) outs(%4 : tensor<1x128xf32>) {
  ^bb0(%arg1: f32, %arg2: f32, %arg3: f32):  // no predecessors
    %21 = addf %arg1, %arg2 : f32
    %22 = cmpf ogt, %21, %cst_3 : f32
    %23 = select %22, %21, %cst_3 : f32
    %24 = cmpf uno, %21, %cst_3 : f32
    %25 = select %24, %cst_2, %23 : f32
    linalg.yield %25 : f32
  } -> tensor<1x128xf32>
  %6 = linalg.init_tensor [1, 10] : tensor<1x10xf32>
  %7 = linalg.fill(%6, %cst_3) : tensor<1x10xf32>, f32 -> tensor<1x10xf32> 
  %8 = linalg.matmul ins(%5, %cst : tensor<1x128xf32>, tensor<128x10xf32>) outs(%7 : tensor<1x10xf32>) -> tensor<1x10xf32>
  %9 = linalg.init_tensor [10] : tensor<10xf32>
  %10 = linalg.generic {indexing_maps = [affine_map<(d0, d1) -> (d0, d1)>, affine_map<(d0, d1) -> (d0, d1)>, affine_map<(d0, d1) -> (d1)>], iterator_types = ["parallel", "parallel"]} ins(%8, %cst_5 : tensor<1x10xf32>, tensor<1x10xf32>) outs(%9 : tensor<10xf32>) {
  ^bb0(%arg1: f32, %arg2: f32, %arg3: f32):  // no predecessors
    %21 = addf %arg1, %arg2 : f32
    linalg.yield %21 : f32
  } -> tensor<10xf32>
  %11 = linalg.init_tensor [] : tensor<f32>
  %12 = linalg.fill(%11, %cst_1) : tensor<f32>, f32 -> tensor<f32> 
  %13 = linalg.generic {indexing_maps = [affine_map<(d0) -> (d0)>, affine_map<(d0) -> ()>], iterator_types = ["reduction"]} ins(%10 : tensor<10xf32>) outs(%12 : tensor<f32>) {
  ^bb0(%arg1: f32, %arg2: f32):  // no predecessors
    %21 = cmpf ogt, %arg1, %arg2 : f32
    %22 = select %21, %arg1, %arg2 : f32
    %23 = cmpf uno, %arg1, %arg2 : f32
    %24 = select %23, %cst_2, %22 : f32
    linalg.yield %24 : f32
  } -> tensor<f32>
  %14 = linalg.init_tensor [10] : tensor<10xf32>
  %15 = linalg.generic {indexing_maps = [affine_map<(d0, d1) -> (d0, d1)>, affine_map<(d0, d1) -> (d0, d1)>, affine_map<(d0, d1) -> ()>, affine_map<(d0, d1) -> (d1)>], iterator_types = ["parallel", "parallel"]} ins(%8, %cst_5, %13 : tensor<1x10xf32>, tensor<1x10xf32>, tensor<f32>) outs(%14 : tensor<10xf32>) {
  ^bb0(%arg1: f32, %arg2: f32, %arg3: f32, %arg4: f32):  // no predecessors
    %21 = addf %arg1, %arg2 : f32
    %22 = subf %21, %arg3 : f32
    %23 = math.exp %22 : f32
    linalg.yield %23 : f32
  } -> tensor<10xf32>
  %16 = linalg.init_tensor [] : tensor<f32>
  %17 = linalg.fill(%16, %cst_3) : tensor<f32>, f32 -> tensor<f32> 
  %18 = linalg.generic {indexing_maps = [affine_map<(d0) -> (d0)>, affine_map<(d0) -> ()>], iterator_types = ["reduction"]} ins(%15 : tensor<10xf32>) outs(%17 : tensor<f32>) {
  ^bb0(%arg1: f32, %arg2: f32):  // no predecessors
    %21 = addf %arg1, %arg2 : f32
    linalg.yield %21 : f32
  } -> tensor<f32>
  %19 = linalg.init_tensor [1, 10] : tensor<1x10xf32>
  %20 = linalg.generic {indexing_maps = [affine_map<(d0, d1) -> (d0, d1)>, affine_map<(d0, d1) -> (d0, d1)>, affine_map<(d0, d1) -> ()>, affine_map<(d0, d1) -> ()>, affine_map<(d0, d1) -> (d0, d1)>], iterator_types = ["parallel", "parallel"]} ins(%8, %cst_5, %13, %18 : tensor<1x10xf32>, tensor<1x10xf32>, tensor<f32>, tensor<f32>) outs(%19 : tensor<1x10xf32>) {
  ^bb0(%arg1: f32, %arg2: f32, %arg3: f32, %arg4: f32, %arg5: f32):  // no predecessors
    %21 = addf %arg1, %arg2 : f32
    %22 = subf %21, %arg3 : f32
    %23 = math.exp %22 : f32
    %24 = divf %23, %arg4 : f32
    linalg.yield %24 : f32
  } -> tensor<1x10xf32>
  return %20 : tensor<1x10xf32>
}

// *** IR Dump After ConvertToFlowTensorOps ***
func @predict(%arg0: tensor<1x28x28x1xf32>) -> tensor<1x10xf32> attributes {iree.module.export, iree.reflection = {abi = "sip", abiv = 1 : i32, f = "I15!B11!d1d28d28d1R9!B6!d1d10", fv = "1", sip = "I8!S5!k0_0R3!_0"}} {
  %cst = constant opaque<"_", "0xDEADBEEF"> : tensor<128x10xf32>
  %cst_0 = constant opaque<"_", "0xDEADBEEF"> : tensor<784x128xf32>
  %cst_1 = constant 0xFF800000 : f32
  %cst_2 = constant 0x7FC00000 : f32
  %cst_3 = constant 0.000000e+00 : f32
  %cst_4 = constant opaque<"_", "0xDEADBEEF"> : tensor<1x128xf32>
  %cst_5 = constant opaque<"_", "0xDEADBEEF"> : tensor<1x10xf32>
  %0 = flow.tensor.reshape %arg0 : tensor<1x28x28x1xf32> -> tensor<1x784xf32>
  %1 = linalg.init_tensor [1, 128] : tensor<1x128xf32>
  %2 = linalg.fill(%1, %cst_3) : tensor<1x128xf32>, f32 -> tensor<1x128xf32> 
  %3 = linalg.matmul ins(%0, %cst_0 : tensor<1x784xf32>, tensor<784x128xf32>) outs(%2 : tensor<1x128xf32>) -> tensor<1x128xf32>
  %4 = linalg.init_tensor [1, 128] : tensor<1x128xf32>
  %5 = linalg.generic {indexing_maps = [affine_map<(d0, d1) -> (d0, d1)>, affine_map<(d0, d1) -> (d0, d1)>, affine_map<(d0, d1) -> (d0, d1)>], iterator_types = ["parallel", "parallel"]} ins(%3, %cst_4 : tensor<1x128xf32>, tensor<1x128xf32>) outs(%4 : tensor<1x128xf32>) {
  ^bb0(%arg1: f32, %arg2: f32, %arg3: f32):  // no predecessors
    %21 = addf %arg1, %arg2 : f32
    %22 = cmpf ogt, %21, %cst_3 : f32
    %23 = select %22, %21, %cst_3 : f32
    %24 = cmpf uno, %21, %cst_3 : f32
    %25 = select %24, %cst_2, %23 : f32
    linalg.yield %25 : f32
  } -> tensor<1x128xf32>
  %6 = linalg.init_tensor [1, 10] : tensor<1x10xf32>
  %7 = linalg.fill(%6, %cst_3) : tensor<1x10xf32>, f32 -> tensor<1x10xf32> 
  %8 = linalg.matmul ins(%5, %cst : tensor<1x128xf32>, tensor<128x10xf32>) outs(%7 : tensor<1x10xf32>) -> tensor<1x10xf32>
  %9 = linalg.init_tensor [10] : tensor<10xf32>
  %10 = linalg.generic {indexing_maps = [affine_map<(d0, d1) -> (d0, d1)>, affine_map<(d0, d1) -> (d0, d1)>, affine_map<(d0, d1) -> (d1)>], iterator_types = ["parallel", "parallel"]} ins(%8, %cst_5 : tensor<1x10xf32>, tensor<1x10xf32>) outs(%9 : tensor<10xf32>) {
  ^bb0(%arg1: f32, %arg2: f32, %arg3: f32):  // no predecessors
    %21 = addf %arg1, %arg2 : f32
    linalg.yield %21 : f32
  } -> tensor<10xf32>
  %11 = linalg.init_tensor [] : tensor<f32>
  %12 = linalg.fill(%11, %cst_1) : tensor<f32>, f32 -> tensor<f32> 
  %13 = linalg.generic {indexing_maps = [affine_map<(d0) -> (d0)>, affine_map<(d0) -> ()>], iterator_types = ["reduction"]} ins(%10 : tensor<10xf32>) outs(%12 : tensor<f32>) {
  ^bb0(%arg1: f32, %arg2: f32):  // no predecessors
    %21 = cmpf ogt, %arg1, %arg2 : f32
    %22 = select %21, %arg1, %arg2 : f32
    %23 = cmpf uno, %arg1, %arg2 : f32
    %24 = select %23, %cst_2, %22 : f32
    linalg.yield %24 : f32
  } -> tensor<f32>
  %14 = linalg.init_tensor [10] : tensor<10xf32>
  %15 = linalg.generic {indexing_maps = [affine_map<(d0, d1) -> (d0, d1)>, affine_map<(d0, d1) -> (d0, d1)>, affine_map<(d0, d1) -> ()>, affine_map<(d0, d1) -> (d1)>], iterator_types = ["parallel", "parallel"]} ins(%8, %cst_5, %13 : tensor<1x10xf32>, tensor<1x10xf32>, tensor<f32>) outs(%14 : tensor<10xf32>) {
  ^bb0(%arg1: f32, %arg2: f32, %arg3: f32, %arg4: f32):  // no predecessors
    %21 = addf %arg1, %arg2 : f32
    %22 = subf %21, %arg3 : f32
    %23 = math.exp %22 : f32
    linalg.yield %23 : f32
  } -> tensor<10xf32>
  %16 = linalg.init_tensor [] : tensor<f32>
  %17 = linalg.fill(%16, %cst_3) : tensor<f32>, f32 -> tensor<f32> 
  %18 = linalg.generic {indexing_maps = [affine_map<(d0) -> (d0)>, affine_map<(d0) -> ()>], iterator_types = ["reduction"]} ins(%15 : tensor<10xf32>) outs(%17 : tensor<f32>) {
  ^bb0(%arg1: f32, %arg2: f32):  // no predecessors
    %21 = addf %arg1, %arg2 : f32
    linalg.yield %21 : f32
  } -> tensor<f32>
  %19 = linalg.init_tensor [1, 10] : tensor<1x10xf32>
  %20 = linalg.generic {indexing_maps = [affine_map<(d0, d1) -> (d0, d1)>, affine_map<(d0, d1) -> (d0, d1)>, affine_map<(d0, d1) -> ()>, affine_map<(d0, d1) -> ()>, affine_map<(d0, d1) -> (d0, d1)>], iterator_types = ["parallel", "parallel"]} ins(%8, %cst_5, %13, %18 : tensor<1x10xf32>, tensor<1x10xf32>, tensor<f32>, tensor<f32>) outs(%19 : tensor<1x10xf32>) {
  ^bb0(%arg1: f32, %arg2: f32, %arg3: f32, %arg4: f32, %arg5: f32):  // no predecessors
    %21 = addf %arg1, %arg2 : f32
    %22 = subf %21, %arg3 : f32
    %23 = math.exp %22 : f32
    %24 = divf %23, %arg4 : f32
    linalg.yield %24 : f32
  } -> tensor<1x10xf32>
  return %20 : tensor<1x10xf32>
}

// *** IR Dump After CSE ***
func @predict(%arg0: tensor<1x28x28x1xf32>) -> tensor<1x10xf32> attributes {iree.module.export, iree.reflection = {abi = "sip", abiv = 1 : i32, f = "I15!B11!d1d28d28d1R9!B6!d1d10", fv = "1", sip = "I8!S5!k0_0R3!_0"}} {
  %cst = constant opaque<"_", "0xDEADBEEF"> : tensor<128x10xf32>
  %cst_0 = constant opaque<"_", "0xDEADBEEF"> : tensor<784x128xf32>
  %cst_1 = constant 0xFF800000 : f32
  %cst_2 = constant 0x7FC00000 : f32
  %cst_3 = constant 0.000000e+00 : f32
  %cst_4 = constant opaque<"_", "0xDEADBEEF"> : tensor<1x128xf32>
  %cst_5 = constant opaque<"_", "0xDEADBEEF"> : tensor<1x10xf32>
  %0 = flow.tensor.reshape %arg0 : tensor<1x28x28x1xf32> -> tensor<1x784xf32>
  %1 = linalg.init_tensor [1, 128] : tensor<1x128xf32>
  %2 = linalg.fill(%1, %cst_3) : tensor<1x128xf32>, f32 -> tensor<1x128xf32> 
  %3 = linalg.matmul ins(%0, %cst_0 : tensor<1x784xf32>, tensor<784x128xf32>) outs(%2 : tensor<1x128xf32>) -> tensor<1x128xf32>
  %4 = linalg.generic {indexing_maps = [affine_map<(d0, d1) -> (d0, d1)>, affine_map<(d0, d1) -> (d0, d1)>, affine_map<(d0, d1) -> (d0, d1)>], iterator_types = ["parallel", "parallel"]} ins(%3, %cst_4 : tensor<1x128xf32>, tensor<1x128xf32>) outs(%1 : tensor<1x128xf32>) {
  ^bb0(%arg1: f32, %arg2: f32, %arg3: f32):  // no predecessors
    %17 = addf %arg1, %arg2 : f32
    %18 = cmpf ogt, %17, %cst_3 : f32
    %19 = select %18, %17, %cst_3 : f32
    %20 = cmpf uno, %17, %cst_3 : f32
    %21 = select %20, %cst_2, %19 : f32
    linalg.yield %21 : f32
  } -> tensor<1x128xf32>
  %5 = linalg.init_tensor [1, 10] : tensor<1x10xf32>
  %6 = linalg.fill(%5, %cst_3) : tensor<1x10xf32>, f32 -> tensor<1x10xf32> 
  %7 = linalg.matmul ins(%4, %cst : tensor<1x128xf32>, tensor<128x10xf32>) outs(%6 : tensor<1x10xf32>) -> tensor<1x10xf32>
  %8 = linalg.init_tensor [10] : tensor<10xf32>
  %9 = linalg.generic {indexing_maps = [affine_map<(d0, d1) -> (d0, d1)>, affine_map<(d0, d1) -> (d0, d1)>, affine_map<(d0, d1) -> (d1)>], iterator_types = ["parallel", "parallel"]} ins(%7, %cst_5 : tensor<1x10xf32>, tensor<1x10xf32>) outs(%8 : tensor<10xf32>) {
  ^bb0(%arg1: f32, %arg2: f32, %arg3: f32):  // no predecessors
    %17 = addf %arg1, %arg2 : f32
    linalg.yield %17 : f32
  } -> tensor<10xf32>
  %10 = linalg.init_tensor [] : tensor<f32>
  %11 = linalg.fill(%10, %cst_1) : tensor<f32>, f32 -> tensor<f32> 
  %12 = linalg.generic {indexing_maps = [affine_map<(d0) -> (d0)>, affine_map<(d0) -> ()>], iterator_types = ["reduction"]} ins(%9 : tensor<10xf32>) outs(%11 : tensor<f32>) {
  ^bb0(%arg1: f32, %arg2: f32):  // no predecessors
    %17 = cmpf ogt, %arg1, %arg2 : f32
    %18 = select %17, %arg1, %arg2 : f32
    %19 = cmpf uno, %arg1, %arg2 : f32
    %20 = select %19, %cst_2, %18 : f32
    linalg.yield %20 : f32
  } -> tensor<f32>
  %13 = linalg.generic {indexing_maps = [affine_map<(d0, d1) -> (d0, d1)>, affine_map<(d0, d1) -> (d0, d1)>, affine_map<(d0, d1) -> ()>, affine_map<(d0, d1) -> (d1)>], iterator_types = ["parallel", "parallel"]} ins(%7, %cst_5, %12 : tensor<1x10xf32>, tensor<1x10xf32>, tensor<f32>) outs(%8 : tensor<10xf32>) {
  ^bb0(%arg1: f32, %arg2: f32, %arg3: f32, %arg4: f32):  // no predecessors
    %17 = addf %arg1, %arg2 : f32
    %18 = subf %17, %arg3 : f32
    %19 = math.exp %18 : f32
    linalg.yield %19 : f32
  } -> tensor<10xf32>
  %14 = linalg.fill(%10, %cst_3) : tensor<f32>, f32 -> tensor<f32> 
  %15 = linalg.generic {indexing_maps = [affine_map<(d0) -> (d0)>, affine_map<(d0) -> ()>], iterator_types = ["reduction"]} ins(%13 : tensor<10xf32>) outs(%14 : tensor<f32>) {
  ^bb0(%arg1: f32, %arg2: f32):  // no predecessors
    %17 = addf %arg1, %arg2 : f32
    linalg.yield %17 : f32
  } -> tensor<f32>
  %16 = linalg.generic {indexing_maps = [affine_map<(d0, d1) -> (d0, d1)>, affine_map<(d0, d1) -> (d0, d1)>, affine_map<(d0, d1) -> ()>, affine_map<(d0, d1) -> ()>, affine_map<(d0, d1) -> (d0, d1)>], iterator_types = ["parallel", "parallel"]} ins(%7, %cst_5, %12, %15 : tensor<1x10xf32>, tensor<1x10xf32>, tensor<f32>, tensor<f32>) outs(%5 : tensor<1x10xf32>) {
  ^bb0(%arg1: f32, %arg2: f32, %arg3: f32, %arg4: f32, %arg5: f32):  // no predecessors
    %17 = addf %arg1, %arg2 : f32
    %18 = subf %17, %arg3 : f32
    %19 = math.exp %18 : f32
    %20 = divf %19, %arg4 : f32
    linalg.yield %20 : f32
  } -> tensor<1x10xf32>
  return %16 : tensor<1x10xf32>
}

// *** IR Dump After DispatchLinalgOnTensors ***
func @predict(%arg0: tensor<1x28x28x1xf32>) -> tensor<1x10xf32> attributes {iree.module.export, iree.reflection = {abi = "sip", abiv = 1 : i32, f = "I15!B11!d1d28d28d1R9!B6!d1d10", fv = "1", sip = "I8!S5!k0_0R3!_0"}} {
  %cst = constant opaque<"_", "0xDEADBEEF"> : tensor<128x10xf32>
  %cst_0 = constant opaque<"_", "0xDEADBEEF"> : tensor<784x128xf32>
  %cst_1 = constant opaque<"_", "0xDEADBEEF"> : tensor<1x128xf32>
  %cst_2 = constant opaque<"_", "0xDEADBEEF"> : tensor<1x10xf32>
  %c128 = constant 128 : index
  %c10 = constant 10 : index
  %c1 = constant 1 : index
  %0 = flow.tensor.reshape %arg0 : tensor<1x28x28x1xf32> -> tensor<1x784xf32>
  %1 = flow.dispatch.workgroups[%c128, %c1, %c1](%0, %cst_0) : (tensor<1x784xf32>, tensor<784x128xf32>) -> tensor<1x128xf32> =
      (%arg1: !flow.dispatch.tensor<readonly:1x784xf32>, %arg2: !flow.dispatch.tensor<readonly:784x128xf32>, %arg3: !flow.dispatch.tensor<writeonly:1x128xf32>) {
    %cst_3 = constant 0.000000e+00 : f32
    %c1_4 = constant 1 : index
    %c128_5 = constant 128 : index
    %9 = linalg.init_tensor [1, 128] : tensor<1x128xf32>
    %workgroup_size_0 = flow.dispatch.workgroup.size[0] : index
    %workgroup_size_1 = flow.dispatch.workgroup.size[1] : index
    %workgroup_id_0 = flow.dispatch.workgroup.id[0] : index
    %workgroup_count_0 = flow.dispatch.workgroup.count[0] : index
    %workgroup_id_1 = flow.dispatch.workgroup.id[1] : index
    %workgroup_count_1 = flow.dispatch.workgroup.count[1] : index
    %10 = affine.apply affine_map<()[s0, s1] -> (s0 * s1)>()[%workgroup_id_1, %workgroup_size_1]
    %11 = affine.apply affine_map<()[s0, s1] -> (s0 * s1)>()[%workgroup_count_1, %workgroup_size_1]
    scf.for %arg4 = %10 to %c1_4 step %11 {
      %12 = affine.apply affine_map<()[s0, s1] -> (s0 * s1)>()[%workgroup_id_0, %workgroup_size_0]
      %13 = affine.apply affine_map<()[s0, s1] -> (s0 * s1)>()[%workgroup_count_0, %workgroup_size_0]
      scf.for %arg5 = %12 to %c128_5 step %13 {
        %14 = affine.min affine_map<(d0, d1) -> (d1, -d0 + 1)>(%arg4, %workgroup_size_1)
        %15 = flow.dispatch.tensor.load %arg1, offsets = [%arg4, 0], sizes = [%14, 784], strides = [1, 1] : !flow.dispatch.tensor<readonly:1x784xf32> -> tensor<?x784xf32>
        %16 = affine.min affine_map<(d0, d1) -> (d1, -d0 + 128)>(%arg5, %workgroup_size_0)
        %17 = flow.dispatch.tensor.load %arg2, offsets = [0, %arg5], sizes = [784, %16], strides = [1, 1] : !flow.dispatch.tensor<readonly:784x128xf32> -> tensor<784x?xf32>
        %18 = affine.min affine_map<(d0, d1) -> (d1, -d0 + 1)>(%arg4, %workgroup_size_1)
        %19 = affine.min affine_map<(d0, d1) -> (d1, -d0 + 128)>(%arg5, %workgroup_size_0)
        %20 = affine.min affine_map<(d0, d1) -> (-d0 + 1, d1)>(%arg4, %workgroup_size_1)
        %21 = affine.min affine_map<(d0, d1) -> (-d0 + 128, d1)>(%arg5, %workgroup_size_0)
        %22 = subtensor %9[%arg4, %arg5] [%20, %21] [1, 1] : tensor<1x128xf32> to tensor<?x?xf32>
        %23 = linalg.fill(%22, %cst_3) : tensor<?x?xf32>, f32 -> tensor<?x?xf32> 
        %24 = linalg.matmul {__internal_linalg_transform__ = "workgroup"} ins(%15, %17 : tensor<?x784xf32>, tensor<784x?xf32>) outs(%23 : tensor<?x?xf32>) -> tensor<?x?xf32>
        flow.dispatch.tensor.store %24, %arg3, offsets = [%arg4, %arg5], sizes = [%18, %19], strides = [1, 1] : tensor<?x?xf32> -> !flow.dispatch.tensor<writeonly:1x128xf32>
      }
    }
    flow.return
  }
  %2 = flow.dispatch.workgroups[%c128, %c1, %c1](%1, %cst_1) : (tensor<1x128xf32>, tensor<1x128xf32>) -> tensor<1x128xf32> =
      (%arg1: !flow.dispatch.tensor<readonly:1x128xf32>, %arg2: !flow.dispatch.tensor<readonly:1x128xf32>, %arg3: !flow.dispatch.tensor<writeonly:1x128xf32>) {
    %cst_3 = constant 0x7FC00000 : f32
    %cst_4 = constant 0.000000e+00 : f32
    %c1_5 = constant 1 : index
    %c128_6 = constant 128 : index
    %9 = linalg.init_tensor [1, 128] : tensor<1x128xf32>
    %workgroup_size_0 = flow.dispatch.workgroup.size[0] : index
    %workgroup_size_1 = flow.dispatch.workgroup.size[1] : index
    %workgroup_id_0 = flow.dispatch.workgroup.id[0] : index
    %workgroup_count_0 = flow.dispatch.workgroup.count[0] : index
    %workgroup_id_1 = flow.dispatch.workgroup.id[1] : index
    %workgroup_count_1 = flow.dispatch.workgroup.count[1] : index
    %10 = affine.apply affine_map<()[s0, s1] -> (s0 * s1)>()[%workgroup_id_1, %workgroup_size_1]
    %11 = affine.apply affine_map<()[s0, s1] -> (s0 * s1)>()[%workgroup_count_1, %workgroup_size_1]
    scf.for %arg4 = %10 to %c1_5 step %11 {
      %12 = affine.apply affine_map<()[s0, s1] -> (s0 * s1)>()[%workgroup_id_0, %workgroup_size_0]
      %13 = affine.apply affine_map<()[s0, s1] -> (s0 * s1)>()[%workgroup_count_0, %workgroup_size_0]
      scf.for %arg5 = %12 to %c128_6 step %13 {
        %14 = affine.min affine_map<(d0, d1) -> (d1, -d0 + 1)>(%arg4, %workgroup_size_1)
        %15 = affine.min affine_map<(d0, d1) -> (d1, -d0 + 128)>(%arg5, %workgroup_size_0)
        %16 = flow.dispatch.tensor.load %arg1, offsets = [%arg4, %arg5], sizes = [%14, %15], strides = [1, 1] : !flow.dispatch.tensor<readonly:1x128xf32> -> tensor<?x?xf32>
        %17 = affine.min affine_map<(d0, d1) -> (d1, -d0 + 1)>(%arg4, %workgroup_size_1)
        %18 = affine.min affine_map<(d0, d1) -> (d1, -d0 + 128)>(%arg5, %workgroup_size_0)
        %19 = flow.dispatch.tensor.load %arg2, offsets = [%arg4, %arg5], sizes = [%17, %18], strides = [1, 1] : !flow.dispatch.tensor<readonly:1x128xf32> -> tensor<?x?xf32>
        %20 = affine.min affine_map<(d0, d1) -> (d1, -d0 + 1)>(%arg4, %workgroup_size_1)
        %21 = affine.min affine_map<(d0, d1) -> (d1, -d0 + 128)>(%arg5, %workgroup_size_0)
        %22 = subtensor %9[%arg4, %arg5] [%20, %21] [1, 1] : tensor<1x128xf32> to tensor<?x?xf32>
        %23 = linalg.generic {indexing_maps = [affine_map<(d0, d1) -> (d0, d1)>, affine_map<(d0, d1) -> (d0, d1)>, affine_map<(d0, d1) -> (d0, d1)>], iterator_types = ["parallel", "parallel"]} ins(%16, %19 : tensor<?x?xf32>, tensor<?x?xf32>) outs(%22 : tensor<?x?xf32>) attrs =  {__internal_linalg_transform__ = "workgroup"} {
        ^bb0(%arg6: f32, %arg7: f32, %arg8: f32):  // no predecessors
          %24 = addf %arg6, %arg7 : f32
          %25 = cmpf ogt, %24, %cst_4 : f32
          %26 = select %25, %24, %cst_4 : f32
          %27 = cmpf uno, %24, %cst_4 : f32
          %28 = select %27, %cst_3, %26 : f32
          linalg.yield %28 : f32
        } -> tensor<?x?xf32>
        flow.dispatch.tensor.store %23, %arg3, offsets = [%arg4, %arg5], sizes = [%20, %21], strides = [1, 1] : tensor<?x?xf32> -> !flow.dispatch.tensor<writeonly:1x128xf32>
      }
    }
    flow.return
  }
  %3 = flow.dispatch.workgroups[%c10, %c1, %c1](%2, %cst) : (tensor<1x128xf32>, tensor<128x10xf32>) -> tensor<1x10xf32> =
      (%arg1: !flow.dispatch.tensor<readonly:1x128xf32>, %arg2: !flow.dispatch.tensor<readonly:128x10xf32>, %arg3: !flow.dispatch.tensor<writeonly:1x10xf32>) {
    %cst_3 = constant 0.000000e+00 : f32
    %c1_4 = constant 1 : index
    %c10_5 = constant 10 : index
    %9 = linalg.init_tensor [1, 10] : tensor<1x10xf32>
    %workgroup_size_0 = flow.dispatch.workgroup.size[0] : index
    %workgroup_size_1 = flow.dispatch.workgroup.size[1] : index
    %workgroup_id_0 = flow.dispatch.workgroup.id[0] : index
    %workgroup_count_0 = flow.dispatch.workgroup.count[0] : index
    %workgroup_id_1 = flow.dispatch.workgroup.id[1] : index
    %workgroup_count_1 = flow.dispatch.workgroup.count[1] : index
    %10 = affine.apply affine_map<()[s0, s1] -> (s0 * s1)>()[%workgroup_id_1, %workgroup_size_1]
    %11 = affine.apply affine_map<()[s0, s1] -> (s0 * s1)>()[%workgroup_count_1, %workgroup_size_1]
    scf.for %arg4 = %10 to %c1_4 step %11 {
      %12 = affine.apply affine_map<()[s0, s1] -> (s0 * s1)>()[%workgroup_id_0, %workgroup_size_0]
      %13 = affine.apply affine_map<()[s0, s1] -> (s0 * s1)>()[%workgroup_count_0, %workgroup_size_0]
      scf.for %arg5 = %12 to %c10_5 step %13 {
        %14 = affine.min affine_map<(d0, d1) -> (d1, -d0 + 1)>(%arg4, %workgroup_size_1)
        %15 = flow.dispatch.tensor.load %arg1, offsets = [%arg4, 0], sizes = [%14, 128], strides = [1, 1] : !flow.dispatch.tensor<readonly:1x128xf32> -> tensor<?x128xf32>
        %16 = affine.min affine_map<(d0, d1) -> (d1, -d0 + 10)>(%arg5, %workgroup_size_0)
        %17 = flow.dispatch.tensor.load %arg2, offsets = [0, %arg5], sizes = [128, %16], strides = [1, 1] : !flow.dispatch.tensor<readonly:128x10xf32> -> tensor<128x?xf32>
        %18 = affine.min affine_map<(d0, d1) -> (d1, -d0 + 1)>(%arg4, %workgroup_size_1)
        %19 = affine.min affine_map<(d0, d1) -> (d1, -d0 + 10)>(%arg5, %workgroup_size_0)
        %20 = affine.min affine_map<(d0, d1) -> (-d0 + 1, d1)>(%arg4, %workgroup_size_1)
        %21 = affine.min affine_map<(d0, d1) -> (-d0 + 10, d1)>(%arg5, %workgroup_size_0)
        %22 = subtensor %9[%arg4, %arg5] [%20, %21] [1, 1] : tensor<1x10xf32> to tensor<?x?xf32>
        %23 = linalg.fill(%22, %cst_3) : tensor<?x?xf32>, f32 -> tensor<?x?xf32> 
        %24 = linalg.matmul {__internal_linalg_transform__ = "workgroup"} ins(%15, %17 : tensor<?x128xf32>, tensor<128x?xf32>) outs(%23 : tensor<?x?xf32>) -> tensor<?x?xf32>
        flow.dispatch.tensor.store %24, %arg3, offsets = [%arg4, %arg5], sizes = [%18, %19], strides = [1, 1] : tensor<?x?xf32> -> !flow.dispatch.tensor<writeonly:1x10xf32>
      }
    }
    flow.return
  }
  %4 = flow.dispatch.workgroups[%c10, %c1, %c1](%3, %cst_2) : (tensor<1x10xf32>, tensor<1x10xf32>) -> tensor<10xf32> =
      (%arg1: !flow.dispatch.tensor<readonly:1x10xf32>, %arg2: !flow.dispatch.tensor<readonly:1x10xf32>, %arg3: !flow.dispatch.tensor<writeonly:10xf32>) {
    %c1_3 = constant 1 : index
    %c10_4 = constant 10 : index
    %9 = linalg.init_tensor [10] : tensor<10xf32>
    %workgroup_size_0 = flow.dispatch.workgroup.size[0] : index
    %workgroup_size_1 = flow.dispatch.workgroup.size[1] : index
    %workgroup_id_0 = flow.dispatch.workgroup.id[0] : index
    %workgroup_count_0 = flow.dispatch.workgroup.count[0] : index
    %workgroup_id_1 = flow.dispatch.workgroup.id[1] : index
    %workgroup_count_1 = flow.dispatch.workgroup.count[1] : index
    %10 = affine.apply affine_map<()[s0, s1] -> (s0 * s1)>()[%workgroup_id_1, %workgroup_size_1]
    %11 = affine.apply affine_map<()[s0, s1] -> (s0 * s1)>()[%workgroup_count_1, %workgroup_size_1]
    scf.for %arg4 = %10 to %c1_3 step %11 {
      %12 = affine.apply affine_map<()[s0, s1] -> (s0 * s1)>()[%workgroup_id_0, %workgroup_size_0]
      %13 = affine.apply affine_map<()[s0, s1] -> (s0 * s1)>()[%workgroup_count_0, %workgroup_size_0]
      scf.for %arg5 = %12 to %c10_4 step %13 {
        %14 = affine.min affine_map<(d0, d1) -> (d1, -d0 + 1)>(%arg4, %workgroup_size_1)
        %15 = affine.min affine_map<(d0, d1) -> (d1, -d0 + 10)>(%arg5, %workgroup_size_0)
        %16 = flow.dispatch.tensor.load %arg1, offsets = [%arg4, %arg5], sizes = [%14, %15], strides = [1, 1] : !flow.dispatch.tensor<readonly:1x10xf32> -> tensor<?x?xf32>
        %17 = affine.min affine_map<(d0, d1) -> (d1, -d0 + 1)>(%arg4, %workgroup_size_1)
        %18 = affine.min affine_map<(d0, d1) -> (d1, -d0 + 10)>(%arg5, %workgroup_size_0)
        %19 = flow.dispatch.tensor.load %arg2, offsets = [%arg4, %arg5], sizes = [%17, %18], strides = [1, 1] : !flow.dispatch.tensor<readonly:1x10xf32> -> tensor<?x?xf32>
        %20 = affine.min affine_map<(d0, d1) -> (d1, -d0 + 10)>(%arg5, %workgroup_size_0)
        %21 = subtensor %9[%arg5] [%20] [1] : tensor<10xf32> to tensor<?xf32>
        %22 = linalg.generic {indexing_maps = [affine_map<(d0, d1) -> (d0, d1)>, affine_map<(d0, d1) -> (d0, d1)>, affine_map<(d0, d1) -> (d1)>], iterator_types = ["parallel", "parallel"]} ins(%16, %19 : tensor<?x?xf32>, tensor<?x?xf32>) outs(%21 : tensor<?xf32>) attrs =  {__internal_linalg_transform__ = "workgroup"} {
        ^bb0(%arg6: f32, %arg7: f32, %arg8: f32):  // no predecessors
          %23 = addf %arg6, %arg7 : f32
          linalg.yield %23 : f32
        } -> tensor<?xf32>
        flow.dispatch.tensor.store %22, %arg3, offsets = [%arg5], sizes = [%20], strides = [1] : tensor<?xf32> -> !flow.dispatch.tensor<writeonly:10xf32>
      }
    }
    flow.return
  }
  %5 = flow.dispatch.workgroups[%c1, %c1, %c1](%4) : (tensor<10xf32>) -> tensor<f32> =
      (%arg1: !flow.dispatch.tensor<readonly:10xf32>, %arg2: !flow.dispatch.tensor<writeonly:f32>) {
    %cst_3 = constant 0x7FC00000 : f32
    %cst_4 = constant 0xFF800000 : f32
    %9 = flow.dispatch.tensor.load %arg1, offsets = [], sizes = [], strides = [] : !flow.dispatch.tensor<readonly:10xf32> -> tensor<10xf32>
    %10 = linalg.init_tensor [] : tensor<f32>
    %11 = linalg.fill(%10, %cst_4) : tensor<f32>, f32 -> tensor<f32> 
    %12 = linalg.generic {indexing_maps = [affine_map<(d0) -> (d0)>, affine_map<(d0) -> ()>], iterator_types = ["reduction"]} ins(%9 : tensor<10xf32>) outs(%11 : tensor<f32>) {
    ^bb0(%arg3: f32, %arg4: f32):  // no predecessors
      %13 = cmpf ogt, %arg3, %arg4 : f32
      %14 = select %13, %arg3, %arg4 : f32
      %15 = cmpf uno, %arg3, %arg4 : f32
      %16 = select %15, %cst_3, %14 : f32
      linalg.yield %16 : f32
    } -> tensor<f32>
    flow.dispatch.tensor.store %12, %arg2, offsets = [], sizes = [], strides = [] : tensor<f32> -> !flow.dispatch.tensor<writeonly:f32>
    flow.return
  }
  %6 = flow.dispatch.workgroups[%c10, %c1, %c1](%3, %cst_2, %5) : (tensor<1x10xf32>, tensor<1x10xf32>, tensor<f32>) -> tensor<10xf32> =
      (%arg1: !flow.dispatch.tensor<readonly:1x10xf32>, %arg2: !flow.dispatch.tensor<readonly:1x10xf32>, %arg3: !flow.dispatch.tensor<readonly:f32>, %arg4: !flow.dispatch.tensor<writeonly:10xf32>) {
    %c1_3 = constant 1 : index
    %c10_4 = constant 10 : index
    %9 = flow.dispatch.tensor.load %arg3, offsets = [], sizes = [], strides = [] : !flow.dispatch.tensor<readonly:f32> -> tensor<f32>
    %10 = linalg.init_tensor [10] : tensor<10xf32>
    %workgroup_size_0 = flow.dispatch.workgroup.size[0] : index
    %workgroup_size_1 = flow.dispatch.workgroup.size[1] : index
    %workgroup_id_0 = flow.dispatch.workgroup.id[0] : index
    %workgroup_count_0 = flow.dispatch.workgroup.count[0] : index
    %workgroup_id_1 = flow.dispatch.workgroup.id[1] : index
    %workgroup_count_1 = flow.dispatch.workgroup.count[1] : index
    %11 = affine.apply affine_map<()[s0, s1] -> (s0 * s1)>()[%workgroup_id_1, %workgroup_size_1]
    %12 = affine.apply affine_map<()[s0, s1] -> (s0 * s1)>()[%workgroup_count_1, %workgroup_size_1]
    scf.for %arg5 = %11 to %c1_3 step %12 {
      %13 = affine.apply affine_map<()[s0, s1] -> (s0 * s1)>()[%workgroup_id_0, %workgroup_size_0]
      %14 = affine.apply affine_map<()[s0, s1] -> (s0 * s1)>()[%workgroup_count_0, %workgroup_size_0]
      scf.for %arg6 = %13 to %c10_4 step %14 {
        %15 = affine.min affine_map<(d0, d1) -> (d1, -d0 + 1)>(%arg5, %workgroup_size_1)
        %16 = affine.min affine_map<(d0, d1) -> (d1, -d0 + 10)>(%arg6, %workgroup_size_0)
        %17 = flow.dispatch.tensor.load %arg1, offsets = [%arg5, %arg6], sizes = [%15, %16], strides = [1, 1] : !flow.dispatch.tensor<readonly:1x10xf32> -> tensor<?x?xf32>
        %18 = affine.min affine_map<(d0, d1) -> (d1, -d0 + 1)>(%arg5, %workgroup_size_1)
        %19 = affine.min affine_map<(d0, d1) -> (d1, -d0 + 10)>(%arg6, %workgroup_size_0)
        %20 = flow.dispatch.tensor.load %arg2, offsets = [%arg5, %arg6], sizes = [%18, %19], strides = [1, 1] : !flow.dispatch.tensor<readonly:1x10xf32> -> tensor<?x?xf32>
        %21 = affine.min affine_map<(d0, d1) -> (d1, -d0 + 10)>(%arg6, %workgroup_size_0)
        %22 = subtensor %10[%arg6] [%21] [1] : tensor<10xf32> to tensor<?xf32>
        %23 = linalg.generic {indexing_maps = [affine_map<(d0, d1) -> (d0, d1)>, affine_map<(d0, d1) -> (d0, d1)>, affine_map<(d0, d1) -> ()>, affine_map<(d0, d1) -> (d1)>], iterator_types = ["parallel", "parallel"]} ins(%17, %20, %9 : tensor<?x?xf32>, tensor<?x?xf32>, tensor<f32>) outs(%22 : tensor<?xf32>) attrs =  {__internal_linalg_transform__ = "workgroup"} {
        ^bb0(%arg7: f32, %arg8: f32, %arg9: f32, %arg10: f32):  // no predecessors
          %24 = addf %arg7, %arg8 : f32
          %25 = subf %24, %arg9 : f32
          %26 = math.exp %25 : f32
          linalg.yield %26 : f32
        } -> tensor<?xf32>
        flow.dispatch.tensor.store %23, %arg4, offsets = [%arg6], sizes = [%21], strides = [1] : tensor<?xf32> -> !flow.dispatch.tensor<writeonly:10xf32>
      }
    }
    flow.return
  }
  %7 = flow.dispatch.workgroups[%c1, %c1, %c1](%6) : (tensor<10xf32>) -> tensor<f32> =
      (%arg1: !flow.dispatch.tensor<readonly:10xf32>, %arg2: !flow.dispatch.tensor<writeonly:f32>) {
    %cst_3 = constant 0.000000e+00 : f32
    %9 = flow.dispatch.tensor.load %arg1, offsets = [], sizes = [], strides = [] : !flow.dispatch.tensor<readonly:10xf32> -> tensor<10xf32>
    %10 = linalg.init_tensor [] : tensor<f32>
    %11 = linalg.fill(%10, %cst_3) : tensor<f32>, f32 -> tensor<f32> 
    %12 = linalg.generic {indexing_maps = [affine_map<(d0) -> (d0)>, affine_map<(d0) -> ()>], iterator_types = ["reduction"]} ins(%9 : tensor<10xf32>) outs(%11 : tensor<f32>) {
    ^bb0(%arg3: f32, %arg4: f32):  // no predecessors
      %13 = addf %arg3, %arg4 : f32
      linalg.yield %13 : f32
    } -> tensor<f32>
    flow.dispatch.tensor.store %12, %arg2, offsets = [], sizes = [], strides = [] : tensor<f32> -> !flow.dispatch.tensor<writeonly:f32>
    flow.return
  }
  %8 = flow.dispatch.workgroups[%c10, %c1, %c1](%3, %cst_2, %5, %7) : (tensor<1x10xf32>, tensor<1x10xf32>, tensor<f32>, tensor<f32>) -> tensor<1x10xf32> =
      (%arg1: !flow.dispatch.tensor<readonly:1x10xf32>, %arg2: !flow.dispatch.tensor<readonly:1x10xf32>, %arg3: !flow.dispatch.tensor<readonly:f32>, %arg4: !flow.dispatch.tensor<readonly:f32>, %arg5: !flow.dispatch.tensor<writeonly:1x10xf32>) {
    %c1_3 = constant 1 : index
    %c10_4 = constant 10 : index
    %9 = flow.dispatch.tensor.load %arg3, offsets = [], sizes = [], strides = [] : !flow.dispatch.tensor<readonly:f32> -> tensor<f32>
    %10 = flow.dispatch.tensor.load %arg4, offsets = [], sizes = [], strides = [] : !flow.dispatch.tensor<readonly:f32> -> tensor<f32>
    %11 = linalg.init_tensor [1, 10] : tensor<1x10xf32>
    %workgroup_size_0 = flow.dispatch.workgroup.size[0] : index
    %workgroup_size_1 = flow.dispatch.workgroup.size[1] : index
    %workgroup_id_0 = flow.dispatch.workgroup.id[0] : index
    %workgroup_count_0 = flow.dispatch.workgroup.count[0] : index
    %workgroup_id_1 = flow.dispatch.workgroup.id[1] : index
    %workgroup_count_1 = flow.dispatch.workgroup.count[1] : index
    %12 = affine.apply affine_map<()[s0, s1] -> (s0 * s1)>()[%workgroup_id_1, %workgroup_size_1]
    %13 = affine.apply affine_map<()[s0, s1] -> (s0 * s1)>()[%workgroup_count_1, %workgroup_size_1]
    scf.for %arg6 = %12 to %c1_3 step %13 {
      %14 = affine.apply affine_map<()[s0, s1] -> (s0 * s1)>()[%workgroup_id_0, %workgroup_size_0]
      %15 = affine.apply affine_map<()[s0, s1] -> (s0 * s1)>()[%workgroup_count_0, %workgroup_size_0]
      scf.for %arg7 = %14 to %c10_4 step %15 {
        %16 = affine.min affine_map<(d0, d1) -> (d1, -d0 + 1)>(%arg6, %workgroup_size_1)
        %17 = affine.min affine_map<(d0, d1) -> (d1, -d0 + 10)>(%arg7, %workgroup_size_0)
        %18 = flow.dispatch.tensor.load %arg1, offsets = [%arg6, %arg7], sizes = [%16, %17], strides = [1, 1] : !flow.dispatch.tensor<readonly:1x10xf32> -> tensor<?x?xf32>
        %19 = affine.min affine_map<(d0, d1) -> (d1, -d0 + 1)>(%arg6, %workgroup_size_1)
        %20 = affine.min affine_map<(d0, d1) -> (d1, -d0 + 10)>(%arg7, %workgroup_size_0)
        %21 = flow.dispatch.tensor.load %arg2, offsets = [%arg6, %arg7], sizes = [%19, %20], strides = [1, 1] : !flow.dispatch.tensor<readonly:1x10xf32> -> tensor<?x?xf32>
        %22 = affine.min affine_map<(d0, d1) -> (d1, -d0 + 1)>(%arg6, %workgroup_size_1)
        %23 = affine.min affine_map<(d0, d1) -> (d1, -d0 + 10)>(%arg7, %workgroup_size_0)
        %24 = subtensor %11[%arg6, %arg7] [%22, %23] [1, 1] : tensor<1x10xf32> to tensor<?x?xf32>
        %25 = linalg.generic {indexing_maps = [affine_map<(d0, d1) -> (d0, d1)>, affine_map<(d0, d1) -> (d0, d1)>, affine_map<(d0, d1) -> ()>, affine_map<(d0, d1) -> ()>, affine_map<(d0, d1) -> (d0, d1)>], iterator_types = ["parallel", "parallel"]} ins(%18, %21, %9, %10 : tensor<?x?xf32>, tensor<?x?xf32>, tensor<f32>, tensor<f32>) outs(%24 : tensor<?x?xf32>) attrs =  {__internal_linalg_transform__ = "workgroup"} {
        ^bb0(%arg8: f32, %arg9: f32, %arg10: f32, %arg11: f32, %arg12: f32):  // no predecessors
          %26 = addf %arg8, %arg9 : f32
          %27 = subf %26, %arg10 : f32
          %28 = math.exp %27 : f32
          %29 = divf %28, %arg11 : f32
          linalg.yield %29 : f32
        } -> tensor<?x?xf32>
        flow.dispatch.tensor.store %25, %arg5, offsets = [%arg6, %arg7], sizes = [%22, %23], strides = [1, 1] : tensor<?x?xf32> -> !flow.dispatch.tensor<writeonly:1x10xf32>
      }
    }
    flow.return
  }
  return %8 : tensor<1x10xf32>
}

// *** IR Dump After Canonicalizer ***
func @predict(%arg0: tensor<1x28x28x1xf32>) -> tensor<1x10xf32> attributes {iree.module.export, iree.reflection = {abi = "sip", abiv = 1 : i32, f = "I15!B11!d1d28d28d1R9!B6!d1d10", fv = "1", sip = "I8!S5!k0_0R3!_0"}} {
  %cst = constant opaque<"_", "0xDEADBEEF"> : tensor<128x10xf32>
  %cst_0 = constant opaque<"_", "0xDEADBEEF"> : tensor<784x128xf32>
  %cst_1 = constant opaque<"_", "0xDEADBEEF"> : tensor<1x128xf32>
  %c128 = constant 128 : index
  %c10 = constant 10 : index
  %c1 = constant 1 : index
  %0 = flow.tensor.reshape %arg0 : tensor<1x28x28x1xf32> -> tensor<1x784xf32>
  %1 = flow.dispatch.workgroups[%c128, %c1, %c1](%0, %cst_0) : (tensor<1x784xf32>, tensor<784x128xf32>) -> tensor<1x128xf32> =
      (%arg1: !flow.dispatch.tensor<readonly:1x784xf32>, %arg2: !flow.dispatch.tensor<readonly:784x128xf32>, %arg3: !flow.dispatch.tensor<writeonly:1x128xf32>) {
    %cst_2 = constant 0.000000e+00 : f32
    %c1_3 = constant 1 : index
    %c128_4 = constant 128 : index
    %workgroup_size_0 = flow.dispatch.workgroup.size[0] : index
    %workgroup_size_1 = flow.dispatch.workgroup.size[1] : index
    %workgroup_id_0 = flow.dispatch.workgroup.id[0] : index
    %workgroup_count_0 = flow.dispatch.workgroup.count[0] : index
    %workgroup_id_1 = flow.dispatch.workgroup.id[1] : index
    %workgroup_count_1 = flow.dispatch.workgroup.count[1] : index
    %9 = affine.apply affine_map<()[s0, s1] -> (s0 * s1)>()[%workgroup_id_1, %workgroup_size_1]
    %10 = affine.apply affine_map<()[s0, s1] -> (s0 * s1)>()[%workgroup_count_1, %workgroup_size_1]
    scf.for %arg4 = %9 to %c1_3 step %10 {
      %11 = affine.apply affine_map<()[s0, s1] -> (s0 * s1)>()[%workgroup_id_0, %workgroup_size_0]
      %12 = affine.apply affine_map<()[s0, s1] -> (s0 * s1)>()[%workgroup_count_0, %workgroup_size_0]
      scf.for %arg5 = %11 to %c128_4 step %12 {
        %13 = affine.min affine_map<(d0, d1) -> (d1, -d0 + 1)>(%arg4, %workgroup_size_1)
        %14 = flow.dispatch.tensor.load %arg1, offsets = [%arg4, 0], sizes = [%13, 784], strides = [1, 1] : !flow.dispatch.tensor<readonly:1x784xf32> -> tensor<?x784xf32>
        %15 = affine.min affine_map<(d0, d1) -> (d1, -d0 + 128)>(%arg5, %workgroup_size_0)
        %16 = flow.dispatch.tensor.load %arg2, offsets = [0, %arg5], sizes = [784, %15], strides = [1, 1] : !flow.dispatch.tensor<readonly:784x128xf32> -> tensor<784x?xf32>
        %17 = affine.min affine_map<(d0, d1) -> (d1, -d0 + 1)>(%arg4, %workgroup_size_1)
        %18 = affine.min affine_map<(d0, d1) -> (d1, -d0 + 128)>(%arg5, %workgroup_size_0)
        %19 = affine.min affine_map<(d0, d1) -> (-d0 + 1, d1)>(%arg4, %workgroup_size_1)
        %20 = affine.min affine_map<(d0, d1) -> (-d0 + 128, d1)>(%arg5, %workgroup_size_0)
        %21 = linalg.init_tensor [%19, %20] : tensor<?x?xf32>
        %22 = linalg.fill(%21, %cst_2) : tensor<?x?xf32>, f32 -> tensor<?x?xf32> 
        %23 = linalg.matmul {__internal_linalg_transform__ = "workgroup"} ins(%14, %16 : tensor<?x784xf32>, tensor<784x?xf32>) outs(%22 : tensor<?x?xf32>) -> tensor<?x?xf32>
        flow.dispatch.tensor.store %23, %arg3, offsets = [%arg4, %arg5], sizes = [%17, %18], strides = [1, 1] : tensor<?x?xf32> -> !flow.dispatch.tensor<writeonly:1x128xf32>
      }
    }
    flow.return
  }
  %2 = flow.dispatch.workgroups[%c128, %c1, %c1](%1, %cst_1) : (tensor<1x128xf32>, tensor<1x128xf32>) -> tensor<1x128xf32> =
      (%arg1: !flow.dispatch.tensor<readonly:1x128xf32>, %arg2: !flow.dispatch.tensor<readonly:1x128xf32>, %arg3: !flow.dispatch.tensor<writeonly:1x128xf32>) {
    %cst_2 = constant 0x7FC00000 : f32
    %cst_3 = constant 0.000000e+00 : f32
    %c1_4 = constant 1 : index
    %c128_5 = constant 128 : index
    %workgroup_size_0 = flow.dispatch.workgroup.size[0] : index
    %workgroup_size_1 = flow.dispatch.workgroup.size[1] : index
    %workgroup_id_0 = flow.dispatch.workgroup.id[0] : index
    %workgroup_count_0 = flow.dispatch.workgroup.count[0] : index
    %workgroup_id_1 = flow.dispatch.workgroup.id[1] : index
    %workgroup_count_1 = flow.dispatch.workgroup.count[1] : index
    %9 = affine.apply affine_map<()[s0, s1] -> (s0 * s1)>()[%workgroup_id_1, %workgroup_size_1]
    %10 = affine.apply affine_map<()[s0, s1] -> (s0 * s1)>()[%workgroup_count_1, %workgroup_size_1]
    scf.for %arg4 = %9 to %c1_4 step %10 {
      %11 = affine.apply affine_map<()[s0, s1] -> (s0 * s1)>()[%workgroup_id_0, %workgroup_size_0]
      %12 = affine.apply affine_map<()[s0, s1] -> (s0 * s1)>()[%workgroup_count_0, %workgroup_size_0]
      scf.for %arg5 = %11 to %c128_5 step %12 {
        %13 = affine.min affine_map<(d0, d1) -> (d1, -d0 + 1)>(%arg4, %workgroup_size_1)
        %14 = affine.min affine_map<(d0, d1) -> (d1, -d0 + 128)>(%arg5, %workgroup_size_0)
        %15 = flow.dispatch.tensor.load %arg1, offsets = [%arg4, %arg5], sizes = [%13, %14], strides = [1, 1] : !flow.dispatch.tensor<readonly:1x128xf32> -> tensor<?x?xf32>
        %16 = affine.min affine_map<(d0, d1) -> (d1, -d0 + 1)>(%arg4, %workgroup_size_1)
        %17 = affine.min affine_map<(d0, d1) -> (d1, -d0 + 128)>(%arg5, %workgroup_size_0)
        %18 = flow.dispatch.tensor.load %arg2, offsets = [%arg4, %arg5], sizes = [%16, %17], strides = [1, 1] : !flow.dispatch.tensor<readonly:1x128xf32> -> tensor<?x?xf32>
        %19 = affine.min affine_map<(d0, d1) -> (d1, -d0 + 1)>(%arg4, %workgroup_size_1)
        %20 = affine.min affine_map<(d0, d1) -> (d1, -d0 + 128)>(%arg5, %workgroup_size_0)
        %21 = linalg.init_tensor [%19, %20] : tensor<?x?xf32>
        %22 = linalg.generic {indexing_maps = [affine_map<(d0, d1) -> (d0, d1)>, affine_map<(d0, d1) -> (d0, d1)>, affine_map<(d0, d1) -> (d0, d1)>], iterator_types = ["parallel", "parallel"]} ins(%15, %18 : tensor<?x?xf32>, tensor<?x?xf32>) outs(%21 : tensor<?x?xf32>) attrs =  {__internal_linalg_transform__ = "workgroup"} {
        ^bb0(%arg6: f32, %arg7: f32, %arg8: f32):  // no predecessors
          %23 = addf %arg6, %arg7 : f32
          %24 = cmpf ogt, %23, %cst_3 : f32
          %25 = select %24, %23, %cst_3 : f32
          %26 = cmpf uno, %23, %cst_3 : f32
          %27 = select %26, %cst_2, %25 : f32
          linalg.yield %27 : f32
        } -> tensor<?x?xf32>
        flow.dispatch.tensor.store %22, %arg3, offsets = [%arg4, %arg5], sizes = [%19, %20], strides = [1, 1] : tensor<?x?xf32> -> !flow.dispatch.tensor<writeonly:1x128xf32>
      }
    }
    flow.return
  }
  %3 = flow.dispatch.workgroups[%c10, %c1, %c1](%2, %cst) : (tensor<1x128xf32>, tensor<128x10xf32>) -> tensor<1x10xf32> =
      (%arg1: !flow.dispatch.tensor<readonly:1x128xf32>, %arg2: !flow.dispatch.tensor<readonly:128x10xf32>, %arg3: !flow.dispatch.tensor<writeonly:1x10xf32>) {
    %cst_2 = constant 0.000000e+00 : f32
    %c1_3 = constant 1 : index
    %c10_4 = constant 10 : index
    %workgroup_size_0 = flow.dispatch.workgroup.size[0] : index
    %workgroup_size_1 = flow.dispatch.workgroup.size[1] : index
    %workgroup_id_0 = flow.dispatch.workgroup.id[0] : index
    %workgroup_count_0 = flow.dispatch.workgroup.count[0] : index
    %workgroup_id_1 = flow.dispatch.workgroup.id[1] : index
    %workgroup_count_1 = flow.dispatch.workgroup.count[1] : index
    %9 = affine.apply affine_map<()[s0, s1] -> (s0 * s1)>()[%workgroup_id_1, %workgroup_size_1]
    %10 = affine.apply affine_map<()[s0, s1] -> (s0 * s1)>()[%workgroup_count_1, %workgroup_size_1]
    scf.for %arg4 = %9 to %c1_3 step %10 {
      %11 = affine.apply affine_map<()[s0, s1] -> (s0 * s1)>()[%workgroup_id_0, %workgroup_size_0]
      %12 = affine.apply affine_map<()[s0, s1] -> (s0 * s1)>()[%workgroup_count_0, %workgroup_size_0]
      scf.for %arg5 = %11 to %c10_4 step %12 {
        %13 = affine.min affine_map<(d0, d1) -> (d1, -d0 + 1)>(%arg4, %workgroup_size_1)
        %14 = flow.dispatch.tensor.load %arg1, offsets = [%arg4, 0], sizes = [%13, 128], strides = [1, 1] : !flow.dispatch.tensor<readonly:1x128xf32> -> tensor<?x128xf32>
        %15 = affine.min affine_map<(d0, d1) -> (d1, -d0 + 10)>(%arg5, %workgroup_size_0)
        %16 = flow.dispatch.tensor.load %arg2, offsets = [0, %arg5], sizes = [128, %15], strides = [1, 1] : !flow.dispatch.tensor<readonly:128x10xf32> -> tensor<128x?xf32>
        %17 = affine.min affine_map<(d0, d1) -> (d1, -d0 + 1)>(%arg4, %workgroup_size_1)
        %18 = affine.min affine_map<(d0, d1) -> (d1, -d0 + 10)>(%arg5, %workgroup_size_0)
        %19 = affine.min affine_map<(d0, d1) -> (-d0 + 1, d1)>(%arg4, %workgroup_size_1)
        %20 = affine.min affine_map<(d0, d1) -> (-d0 + 10, d1)>(%arg5, %workgroup_size_0)
        %21 = linalg.init_tensor [%19, %20] : tensor<?x?xf32>
        %22 = linalg.fill(%21, %cst_2) : tensor<?x?xf32>, f32 -> tensor<?x?xf32> 
        %23 = linalg.matmul {__internal_linalg_transform__ = "workgroup"} ins(%14, %16 : tensor<?x128xf32>, tensor<128x?xf32>) outs(%22 : tensor<?x?xf32>) -> tensor<?x?xf32>
        flow.dispatch.tensor.store %23, %arg3, offsets = [%arg4, %arg5], sizes = [%17, %18], strides = [1, 1] : tensor<?x?xf32> -> !flow.dispatch.tensor<writeonly:1x10xf32>
      }
    }
    flow.return
  }
  %4 = flow.dispatch.workgroups[%c10, %c1, %c1](%3) : (tensor<1x10xf32>) -> tensor<10xf32> =
      (%arg1: !flow.dispatch.tensor<readonly:1x10xf32>, %arg2: !flow.dispatch.tensor<writeonly:10xf32>) {
    %cst_2 = constant opaque<"_", "0xDEADBEEF"> : tensor<1x10xf32>
    %c1_3 = constant 1 : index
    %c10_4 = constant 10 : index
    %workgroup_size_0 = flow.dispatch.workgroup.size[0] : index
    %workgroup_size_1 = flow.dispatch.workgroup.size[1] : index
    %workgroup_id_0 = flow.dispatch.workgroup.id[0] : index
    %workgroup_count_0 = flow.dispatch.workgroup.count[0] : index
    %workgroup_id_1 = flow.dispatch.workgroup.id[1] : index
    %workgroup_count_1 = flow.dispatch.workgroup.count[1] : index
    %9 = affine.apply affine_map<()[s0, s1] -> (s0 * s1)>()[%workgroup_id_1, %workgroup_size_1]
    %10 = affine.apply affine_map<()[s0, s1] -> (s0 * s1)>()[%workgroup_count_1, %workgroup_size_1]
    scf.for %arg3 = %9 to %c1_3 step %10 {
      %11 = affine.apply affine_map<()[s0, s1] -> (s0 * s1)>()[%workgroup_id_0, %workgroup_size_0]
      %12 = affine.apply affine_map<()[s0, s1] -> (s0 * s1)>()[%workgroup_count_0, %workgroup_size_0]
      scf.for %arg4 = %11 to %c10_4 step %12 {
        %13 = affine.min affine_map<(d0, d1) -> (d1, -d0 + 1)>(%arg3, %workgroup_size_1)
        %14 = affine.min affine_map<(d0, d1) -> (d1, -d0 + 10)>(%arg4, %workgroup_size_0)
        %15 = flow.dispatch.tensor.load %arg1, offsets = [%arg3, %arg4], sizes = [%13, %14], strides = [1, 1] : !flow.dispatch.tensor<readonly:1x10xf32> -> tensor<?x?xf32>
        %16 = affine.min affine_map<(d0, d1) -> (d1, -d0 + 1)>(%arg3, %workgroup_size_1)
        %17 = affine.min affine_map<(d0, d1) -> (d1, -d0 + 10)>(%arg4, %workgroup_size_0)
        %18 = subtensor %cst_2[%arg3, %arg4] [%16, %17] [1, 1] : tensor<1x10xf32> to tensor<?x?xf32>
        %19 = affine.min affine_map<(d0, d1) -> (d1, -d0 + 10)>(%arg4, %workgroup_size_0)
        %20 = linalg.init_tensor [%19] : tensor<?xf32>
        %21 = linalg.generic {indexing_maps = [affine_map<(d0, d1) -> (d0, d1)>, affine_map<(d0, d1) -> (d0, d1)>, affine_map<(d0, d1) -> (d1)>], iterator_types = ["parallel", "parallel"]} ins(%15, %18 : tensor<?x?xf32>, tensor<?x?xf32>) outs(%20 : tensor<?xf32>) attrs =  {__internal_linalg_transform__ = "workgroup"} {
        ^bb0(%arg5: f32, %arg6: f32, %arg7: f32):  // no predecessors
          %22 = addf %arg5, %arg6 : f32
          linalg.yield %22 : f32
        } -> tensor<?xf32>
        flow.dispatch.tensor.store %21, %arg2, offsets = [%arg4], sizes = [%19], strides = [1] : tensor<?xf32> -> !flow.dispatch.tensor<writeonly:10xf32>
      }
    }
    flow.return
  }
  %5 = flow.dispatch.workgroups[%c1, %c1, %c1](%4) : (tensor<10xf32>) -> tensor<f32> =
      (%arg1: !flow.dispatch.tensor<readonly:10xf32>, %arg2: !flow.dispatch.tensor<writeonly:f32>) {
    %cst_2 = constant 0x7FC00000 : f32
    %cst_3 = constant 0xFF800000 : f32
    %9 = flow.dispatch.tensor.load %arg1, offsets = [], sizes = [], strides = [] : !flow.dispatch.tensor<readonly:10xf32> -> tensor<10xf32>
    %10 = linalg.init_tensor [] : tensor<f32>
    %11 = linalg.fill(%10, %cst_3) : tensor<f32>, f32 -> tensor<f32> 
    %12 = linalg.generic {indexing_maps = [affine_map<(d0) -> (d0)>, affine_map<(d0) -> ()>], iterator_types = ["reduction"]} ins(%9 : tensor<10xf32>) outs(%11 : tensor<f32>) {
    ^bb0(%arg3: f32, %arg4: f32):  // no predecessors
      %13 = cmpf ogt, %arg3, %arg4 : f32
      %14 = select %13, %arg3, %arg4 : f32
      %15 = cmpf uno, %arg3, %arg4 : f32
      %16 = select %15, %cst_2, %14 : f32
      linalg.yield %16 : f32
    } -> tensor<f32>
    flow.dispatch.tensor.store %12, %arg2, offsets = [], sizes = [], strides = [] : tensor<f32> -> !flow.dispatch.tensor<writeonly:f32>
    flow.return
  }
  %6 = flow.dispatch.workgroups[%c10, %c1, %c1](%3, %5) : (tensor<1x10xf32>, tensor<f32>) -> tensor<10xf32> =
      (%arg1: !flow.dispatch.tensor<readonly:1x10xf32>, %arg2: !flow.dispatch.tensor<readonly:f32>, %arg3: !flow.dispatch.tensor<writeonly:10xf32>) {
    %cst_2 = constant opaque<"_", "0xDEADBEEF"> : tensor<1x10xf32>
    %c1_3 = constant 1 : index
    %c10_4 = constant 10 : index
    %9 = flow.dispatch.tensor.load %arg2, offsets = [], sizes = [], strides = [] : !flow.dispatch.tensor<readonly:f32> -> tensor<f32>
    %workgroup_size_0 = flow.dispatch.workgroup.size[0] : index
    %workgroup_size_1 = flow.dispatch.workgroup.size[1] : index
    %workgroup_id_0 = flow.dispatch.workgroup.id[0] : index
    %workgroup_count_0 = flow.dispatch.workgroup.count[0] : index
    %workgroup_id_1 = flow.dispatch.workgroup.id[1] : index
    %workgroup_count_1 = flow.dispatch.workgroup.count[1] : index
    %10 = affine.apply affine_map<()[s0, s1] -> (s0 * s1)>()[%workgroup_id_1, %workgroup_size_1]
    %11 = affine.apply affine_map<()[s0, s1] -> (s0 * s1)>()[%workgroup_count_1, %workgroup_size_1]
    scf.for %arg4 = %10 to %c1_3 step %11 {
      %12 = affine.apply affine_map<()[s0, s1] -> (s0 * s1)>()[%workgroup_id_0, %workgroup_size_0]
      %13 = affine.apply affine_map<()[s0, s1] -> (s0 * s1)>()[%workgroup_count_0, %workgroup_size_0]
      scf.for %arg5 = %12 to %c10_4 step %13 {
        %14 = affine.min affine_map<(d0, d1) -> (d1, -d0 + 1)>(%arg4, %workgroup_size_1)
        %15 = affine.min affine_map<(d0, d1) -> (d1, -d0 + 10)>(%arg5, %workgroup_size_0)
        %16 = flow.dispatch.tensor.load %arg1, offsets = [%arg4, %arg5], sizes = [%14, %15], strides = [1, 1] : !flow.dispatch.tensor<readonly:1x10xf32> -> tensor<?x?xf32>
        %17 = affine.min affine_map<(d0, d1) -> (d1, -d0 + 1)>(%arg4, %workgroup_size_1)
        %18 = affine.min affine_map<(d0, d1) -> (d1, -d0 + 10)>(%arg5, %workgroup_size_0)
        %19 = subtensor %cst_2[%arg4, %arg5] [%17, %18] [1, 1] : tensor<1x10xf32> to tensor<?x?xf32>
        %20 = affine.min affine_map<(d0, d1) -> (d1, -d0 + 10)>(%arg5, %workgroup_size_0)
        %21 = linalg.init_tensor [%20] : tensor<?xf32>
        %22 = linalg.generic {indexing_maps = [affine_map<(d0, d1) -> (d0, d1)>, affine_map<(d0, d1) -> (d0, d1)>, affine_map<(d0, d1) -> ()>, affine_map<(d0, d1) -> (d1)>], iterator_types = ["parallel", "parallel"]} ins(%16, %19, %9 : tensor<?x?xf32>, tensor<?x?xf32>, tensor<f32>) outs(%21 : tensor<?xf32>) attrs =  {__internal_linalg_transform__ = "workgroup"} {
        ^bb0(%arg6: f32, %arg7: f32, %arg8: f32, %arg9: f32):  // no predecessors
          %23 = addf %arg6, %arg7 : f32
          %24 = subf %23, %arg8 : f32
          %25 = math.exp %24 : f32
          linalg.yield %25 : f32
        } -> tensor<?xf32>
        flow.dispatch.tensor.store %22, %arg3, offsets = [%arg5], sizes = [%20], strides = [1] : tensor<?xf32> -> !flow.dispatch.tensor<writeonly:10xf32>
      }
    }
    flow.return
  }
  %7 = flow.dispatch.workgroups[%c1, %c1, %c1](%6) : (tensor<10xf32>) -> tensor<f32> =
      (%arg1: !flow.dispatch.tensor<readonly:10xf32>, %arg2: !flow.dispatch.tensor<writeonly:f32>) {
    %cst_2 = constant 0.000000e+00 : f32
    %9 = flow.dispatch.tensor.load %arg1, offsets = [], sizes = [], strides = [] : !flow.dispatch.tensor<readonly:10xf32> -> tensor<10xf32>
    %10 = linalg.init_tensor [] : tensor<f32>
    %11 = linalg.fill(%10, %cst_2) : tensor<f32>, f32 -> tensor<f32> 
    %12 = linalg.generic {indexing_maps = [affine_map<(d0) -> (d0)>, affine_map<(d0) -> ()>], iterator_types = ["reduction"]} ins(%9 : tensor<10xf32>) outs(%11 : tensor<f32>) {
    ^bb0(%arg3: f32, %arg4: f32):  // no predecessors
      %13 = addf %arg3, %arg4 : f32
      linalg.yield %13 : f32
    } -> tensor<f32>
    flow.dispatch.tensor.store %12, %arg2, offsets = [], sizes = [], strides = [] : tensor<f32> -> !flow.dispatch.tensor<writeonly:f32>
    flow.return
  }
  %8 = flow.dispatch.workgroups[%c10, %c1, %c1](%3, %5, %7) : (tensor<1x10xf32>, tensor<f32>, tensor<f32>) -> tensor<1x10xf32> =
      (%arg1: !flow.dispatch.tensor<readonly:1x10xf32>, %arg2: !flow.dispatch.tensor<readonly:f32>, %arg3: !flow.dispatch.tensor<readonly:f32>, %arg4: !flow.dispatch.tensor<writeonly:1x10xf32>) {
    %cst_2 = constant opaque<"_", "0xDEADBEEF"> : tensor<1x10xf32>
    %c1_3 = constant 1 : index
    %c10_4 = constant 10 : index
    %9 = flow.dispatch.tensor.load %arg2, offsets = [], sizes = [], strides = [] : !flow.dispatch.tensor<readonly:f32> -> tensor<f32>
    %10 = flow.dispatch.tensor.load %arg3, offsets = [], sizes = [], strides = [] : !flow.dispatch.tensor<readonly:f32> -> tensor<f32>
    %workgroup_size_0 = flow.dispatch.workgroup.size[0] : index
    %workgroup_size_1 = flow.dispatch.workgroup.size[1] : index
    %workgroup_id_0 = flow.dispatch.workgroup.id[0] : index
    %workgroup_count_0 = flow.dispatch.workgroup.count[0] : index
    %workgroup_id_1 = flow.dispatch.workgroup.id[1] : index
    %workgroup_count_1 = flow.dispatch.workgroup.count[1] : index
    %11 = affine.apply affine_map<()[s0, s1] -> (s0 * s1)>()[%workgroup_id_1, %workgroup_size_1]
    %12 = affine.apply affine_map<()[s0, s1] -> (s0 * s1)>()[%workgroup_count_1, %workgroup_size_1]
    scf.for %arg5 = %11 to %c1_3 step %12 {
      %13 = affine.apply affine_map<()[s0, s1] -> (s0 * s1)>()[%workgroup_id_0, %workgroup_size_0]
      %14 = affine.apply affine_map<()[s0, s1] -> (s0 * s1)>()[%workgroup_count_0, %workgroup_size_0]
      scf.for %arg6 = %13 to %c10_4 step %14 {
        %15 = affine.min affine_map<(d0, d1) -> (d1, -d0 + 1)>(%arg5, %workgroup_size_1)
        %16 = affine.min affine_map<(d0, d1) -> (d1, -d0 + 10)>(%arg6, %workgroup_size_0)
        %17 = flow.dispatch.tensor.load %arg1, offsets = [%arg5, %arg6], sizes = [%15, %16], strides = [1, 1] : !flow.dispatch.tensor<readonly:1x10xf32> -> tensor<?x?xf32>
        %18 = affine.min affine_map<(d0, d1) -> (d1, -d0 + 1)>(%arg5, %workgroup_size_1)
        %19 = affine.min affine_map<(d0, d1) -> (d1, -d0 + 10)>(%arg6, %workgroup_size_0)
        %20 = subtensor %cst_2[%arg5, %arg6] [%18, %19] [1, 1] : tensor<1x10xf32> to tensor<?x?xf32>
        %21 = affine.min affine_map<(d0, d1) -> (d1, -d0 + 1)>(%arg5, %workgroup_size_1)
        %22 = affine.min affine_map<(d0, d1) -> (d1, -d0 + 10)>(%arg6, %workgroup_size_0)
        %23 = linalg.init_tensor [%21, %22] : tensor<?x?xf32>
        %24 = linalg.generic {indexing_maps = [affine_map<(d0, d1) -> (d0, d1)>, affine_map<(d0, d1) -> (d0, d1)>, affine_map<(d0, d1) -> ()>, affine_map<(d0, d1) -> ()>, affine_map<(d0, d1) -> (d0, d1)>], iterator_types = ["parallel", "parallel"]} ins(%17, %20, %9, %10 : tensor<?x?xf32>, tensor<?x?xf32>, tensor<f32>, tensor<f32>) outs(%23 : tensor<?x?xf32>) attrs =  {__internal_linalg_transform__ = "workgroup"} {
        ^bb0(%arg7: f32, %arg8: f32, %arg9: f32, %arg10: f32, %arg11: f32):  // no predecessors
          %25 = addf %arg7, %arg8 : f32
          %26 = subf %25, %arg9 : f32
          %27 = math.exp %26 : f32
          %28 = divf %27, %arg10 : f32
          linalg.yield %28 : f32
        } -> tensor<?x?xf32>
        flow.dispatch.tensor.store %24, %arg4, offsets = [%arg5, %arg6], sizes = [%21, %22], strides = [1, 1] : tensor<?x?xf32> -> !flow.dispatch.tensor<writeonly:1x10xf32>
      }
    }
    flow.return
  }
  return %8 : tensor<1x10xf32>
}

// *** IR Dump After OutlineDispatchRegions ***
#map0 = affine_map<()[s0, s1] -> (s0 * s1)>
#map1 = affine_map<(d0, d1) -> (d1, -d0 + 1)>
#map2 = affine_map<(d0, d1) -> (d1, -d0 + 128)>
#map3 = affine_map<(d0, d1) -> (-d0 + 1, d1)>
#map4 = affine_map<(d0, d1) -> (-d0 + 128, d1)>
#map5 = affine_map<(d0, d1) -> (d0, d1)>
#map6 = affine_map<(d0, d1) -> (d1, -d0 + 10)>
#map7 = affine_map<(d0, d1) -> (-d0 + 10, d1)>
#map8 = affine_map<(d0, d1) -> (d1)>
#map9 = affine_map<(d0) -> (d0)>
#map10 = affine_map<(d0) -> ()>
#map11 = affine_map<(d0, d1) -> ()>
module  {
  flow.executable @predict_dispatch_0 attributes {sym_visibility = "private"} {
    flow.dispatch.entry @predict_dispatch_0 attributes {workgroup_rank = 3 : index}
    module  {
      func @predict_dispatch_0(%arg0: !flow.dispatch.tensor<readonly:1x784xf32>, %arg1: !flow.dispatch.tensor<readonly:784x128xf32>, %arg2: !flow.dispatch.tensor<writeonly:1x128xf32>) {
        %cst = constant 0.000000e+00 : f32
        %c1 = constant 1 : index
        %c128 = constant 128 : index
        %workgroup_size_0 = flow.dispatch.workgroup.size[0] : index
        %workgroup_size_1 = flow.dispatch.workgroup.size[1] : index
        %workgroup_id_0 = flow.dispatch.workgroup.id[0] : index
        %workgroup_count_0 = flow.dispatch.workgroup.count[0] : index
        %workgroup_id_1 = flow.dispatch.workgroup.id[1] : index
        %workgroup_count_1 = flow.dispatch.workgroup.count[1] : index
        %0 = affine.apply #map0()[%workgroup_id_1, %workgroup_size_1]
        %1 = affine.apply #map0()[%workgroup_count_1, %workgroup_size_1]
        scf.for %arg3 = %0 to %c1 step %1 {
          %2 = affine.apply #map0()[%workgroup_id_0, %workgroup_size_0]
          %3 = affine.apply #map0()[%workgroup_count_0, %workgroup_size_0]
          scf.for %arg4 = %2 to %c128 step %3 {
            %4 = affine.min #map1(%arg3, %workgroup_size_1)
            %5 = flow.dispatch.tensor.load %arg0, offsets = [%arg3, 0], sizes = [%4, 784], strides = [1, 1] : !flow.dispatch.tensor<readonly:1x784xf32> -> tensor<?x784xf32>
            %6 = affine.min #map2(%arg4, %workgroup_size_0)
            %7 = flow.dispatch.tensor.load %arg1, offsets = [0, %arg4], sizes = [784, %6], strides = [1, 1] : !flow.dispatch.tensor<readonly:784x128xf32> -> tensor<784x?xf32>
            %8 = affine.min #map1(%arg3, %workgroup_size_1)
            %9 = affine.min #map2(%arg4, %workgroup_size_0)
            %10 = affine.min #map3(%arg3, %workgroup_size_1)
            %11 = affine.min #map4(%arg4, %workgroup_size_0)
            %12 = linalg.init_tensor [%10, %11] : tensor<?x?xf32>
            %13 = linalg.fill(%12, %cst) : tensor<?x?xf32>, f32 -> tensor<?x?xf32> 
            %14 = linalg.matmul {__internal_linalg_transform__ = "workgroup"} ins(%5, %7 : tensor<?x784xf32>, tensor<784x?xf32>) outs(%13 : tensor<?x?xf32>) -> tensor<?x?xf32>
            flow.dispatch.tensor.store %14, %arg2, offsets = [%arg3, %arg4], sizes = [%8, %9], strides = [1, 1] : tensor<?x?xf32> -> !flow.dispatch.tensor<writeonly:1x128xf32>
          }
        }
        return
      }
    }
  }
  flow.executable @predict_dispatch_1 attributes {sym_visibility = "private"} {
    flow.dispatch.entry @predict_dispatch_1 attributes {workgroup_rank = 3 : index}
    module  {
      func @predict_dispatch_1(%arg0: !flow.dispatch.tensor<readonly:1x128xf32>, %arg1: !flow.dispatch.tensor<readonly:1x128xf32>, %arg2: !flow.dispatch.tensor<writeonly:1x128xf32>) {
        %cst = constant 0x7FC00000 : f32
        %cst_0 = constant 0.000000e+00 : f32
        %c1 = constant 1 : index
        %c128 = constant 128 : index
        %workgroup_size_0 = flow.dispatch.workgroup.size[0] : index
        %workgroup_size_1 = flow.dispatch.workgroup.size[1] : index
        %workgroup_id_0 = flow.dispatch.workgroup.id[0] : index
        %workgroup_count_0 = flow.dispatch.workgroup.count[0] : index
        %workgroup_id_1 = flow.dispatch.workgroup.id[1] : index
        %workgroup_count_1 = flow.dispatch.workgroup.count[1] : index
        %0 = affine.apply #map0()[%workgroup_id_1, %workgroup_size_1]
        %1 = affine.apply #map0()[%workgroup_count_1, %workgroup_size_1]
        scf.for %arg3 = %0 to %c1 step %1 {
          %2 = affine.apply #map0()[%workgroup_id_0, %workgroup_size_0]
          %3 = affine.apply #map0()[%workgroup_count_0, %workgroup_size_0]
          scf.for %arg4 = %2 to %c128 step %3 {
            %4 = affine.min #map1(%arg3, %workgroup_size_1)
            %5 = affine.min #map2(%arg4, %workgroup_size_0)
            %6 = flow.dispatch.tensor.load %arg0, offsets = [%arg3, %arg4], sizes = [%4, %5], strides = [1, 1] : !flow.dispatch.tensor<readonly:1x128xf32> -> tensor<?x?xf32>
            %7 = affine.min #map1(%arg3, %workgroup_size_1)
            %8 = affine.min #map2(%arg4, %workgroup_size_0)
            %9 = flow.dispatch.tensor.load %arg1, offsets = [%arg3, %arg4], sizes = [%7, %8], strides = [1, 1] : !flow.dispatch.tensor<readonly:1x128xf32> -> tensor<?x?xf32>
            %10 = affine.min #map1(%arg3, %workgroup_size_1)
            %11 = affine.min #map2(%arg4, %workgroup_size_0)
            %12 = linalg.init_tensor [%10, %11] : tensor<?x?xf32>
            %13 = linalg.generic {indexing_maps = [#map5, #map5, #map5], iterator_types = ["parallel", "parallel"]} ins(%6, %9 : tensor<?x?xf32>, tensor<?x?xf32>) outs(%12 : tensor<?x?xf32>) attrs =  {__internal_linalg_transform__ = "workgroup"} {
            ^bb0(%arg5: f32, %arg6: f32, %arg7: f32):  // no predecessors
              %14 = addf %arg5, %arg6 : f32
              %15 = cmpf ogt, %14, %cst_0 : f32
              %16 = select %15, %14, %cst_0 : f32
              %17 = cmpf uno, %14, %cst_0 : f32
              %18 = select %17, %cst, %16 : f32
              linalg.yield %18 : f32
            } -> tensor<?x?xf32>
            flow.dispatch.tensor.store %13, %arg2, offsets = [%arg3, %arg4], sizes = [%10, %11], strides = [1, 1] : tensor<?x?xf32> -> !flow.dispatch.tensor<writeonly:1x128xf32>
          }
        }
        return
      }
    }
  }
  flow.executable @predict_dispatch_2 attributes {sym_visibility = "private"} {
    flow.dispatch.entry @predict_dispatch_2 attributes {workgroup_rank = 3 : index}
    module  {
      func @predict_dispatch_2(%arg0: !flow.dispatch.tensor<readonly:1x128xf32>, %arg1: !flow.dispatch.tensor<readonly:128x10xf32>, %arg2: !flow.dispatch.tensor<writeonly:1x10xf32>) {
        %cst = constant 0.000000e+00 : f32
        %c1 = constant 1 : index
        %c10 = constant 10 : index
        %workgroup_size_0 = flow.dispatch.workgroup.size[0] : index
        %workgroup_size_1 = flow.dispatch.workgroup.size[1] : index
        %workgroup_id_0 = flow.dispatch.workgroup.id[0] : index
        %workgroup_count_0 = flow.dispatch.workgroup.count[0] : index
        %workgroup_id_1 = flow.dispatch.workgroup.id[1] : index
        %workgroup_count_1 = flow.dispatch.workgroup.count[1] : index
        %0 = affine.apply #map0()[%workgroup_id_1, %workgroup_size_1]
        %1 = affine.apply #map0()[%workgroup_count_1, %workgroup_size_1]
        scf.for %arg3 = %0 to %c1 step %1 {
          %2 = affine.apply #map0()[%workgroup_id_0, %workgroup_size_0]
          %3 = affine.apply #map0()[%workgroup_count_0, %workgroup_size_0]
          scf.for %arg4 = %2 to %c10 step %3 {
            %4 = affine.min #map1(%arg3, %workgroup_size_1)
            %5 = flow.dispatch.tensor.load %arg0, offsets = [%arg3, 0], sizes = [%4, 128], strides = [1, 1] : !flow.dispatch.tensor<readonly:1x128xf32> -> tensor<?x128xf32>
            %6 = affine.min #map6(%arg4, %workgroup_size_0)
            %7 = flow.dispatch.tensor.load %arg1, offsets = [0, %arg4], sizes = [128, %6], strides = [1, 1] : !flow.dispatch.tensor<readonly:128x10xf32> -> tensor<128x?xf32>
            %8 = affine.min #map1(%arg3, %workgroup_size_1)
            %9 = affine.min #map6(%arg4, %workgroup_size_0)
            %10 = affine.min #map3(%arg3, %workgroup_size_1)
            %11 = affine.min #map7(%arg4, %workgroup_size_0)
            %12 = linalg.init_tensor [%10, %11] : tensor<?x?xf32>
            %13 = linalg.fill(%12, %cst) : tensor<?x?xf32>, f32 -> tensor<?x?xf32> 
            %14 = linalg.matmul {__internal_linalg_transform__ = "workgroup"} ins(%5, %7 : tensor<?x128xf32>, tensor<128x?xf32>) outs(%13 : tensor<?x?xf32>) -> tensor<?x?xf32>
            flow.dispatch.tensor.store %14, %arg2, offsets = [%arg3, %arg4], sizes = [%8, %9], strides = [1, 1] : tensor<?x?xf32> -> !flow.dispatch.tensor<writeonly:1x10xf32>
          }
        }
        return
      }
    }
  }
  flow.executable @predict_dispatch_3 attributes {sym_visibility = "private"} {
    flow.dispatch.entry @predict_dispatch_3 attributes {workgroup_rank = 3 : index}
    module  {
      func @predict_dispatch_3(%arg0: !flow.dispatch.tensor<readonly:1x10xf32>, %arg1: !flow.dispatch.tensor<writeonly:10xf32>) {
        %cst = constant opaque<"_", "0xDEADBEEF"> : tensor<1x10xf32>
        %c1 = constant 1 : index
        %c10 = constant 10 : index
        %workgroup_size_0 = flow.dispatch.workgroup.size[0] : index
        %workgroup_size_1 = flow.dispatch.workgroup.size[1] : index
        %workgroup_id_0 = flow.dispatch.workgroup.id[0] : index
        %workgroup_count_0 = flow.dispatch.workgroup.count[0] : index
        %workgroup_id_1 = flow.dispatch.workgroup.id[1] : index
        %workgroup_count_1 = flow.dispatch.workgroup.count[1] : index
        %0 = affine.apply #map0()[%workgroup_id_1, %workgroup_size_1]
        %1 = affine.apply #map0()[%workgroup_count_1, %workgroup_size_1]
        scf.for %arg2 = %0 to %c1 step %1 {
          %2 = affine.apply #map0()[%workgroup_id_0, %workgroup_size_0]
          %3 = affine.apply #map0()[%workgroup_count_0, %workgroup_size_0]
          scf.for %arg3 = %2 to %c10 step %3 {
            %4 = affine.min #map1(%arg2, %workgroup_size_1)
            %5 = affine.min #map6(%arg3, %workgroup_size_0)
            %6 = flow.dispatch.tensor.load %arg0, offsets = [%arg2, %arg3], sizes = [%4, %5], strides = [1, 1] : !flow.dispatch.tensor<readonly:1x10xf32> -> tensor<?x?xf32>
            %7 = affine.min #map1(%arg2, %workgroup_size_1)
            %8 = affine.min #map6(%arg3, %workgroup_size_0)
            %9 = subtensor %cst[%arg2, %arg3] [%7, %8] [1, 1] : tensor<1x10xf32> to tensor<?x?xf32>
            %10 = affine.min #map6(%arg3, %workgroup_size_0)
            %11 = linalg.init_tensor [%10] : tensor<?xf32>
            %12 = linalg.generic {indexing_maps = [#map5, #map5, #map8], iterator_types = ["parallel", "parallel"]} ins(%6, %9 : tensor<?x?xf32>, tensor<?x?xf32>) outs(%11 : tensor<?xf32>) attrs =  {__internal_linalg_transform__ = "workgroup"} {
            ^bb0(%arg4: f32, %arg5: f32, %arg6: f32):  // no predecessors
              %13 = addf %arg4, %arg5 : f32
              linalg.yield %13 : f32
            } -> tensor<?xf32>
            flow.dispatch.tensor.store %12, %arg1, offsets = [%arg3], sizes = [%10], strides = [1] : tensor<?xf32> -> !flow.dispatch.tensor<writeonly:10xf32>
          }
        }
        return
      }
    }
  }
  flow.executable @predict_dispatch_4 attributes {sym_visibility = "private"} {
    flow.dispatch.entry @predict_dispatch_4 attributes {workgroup_rank = 3 : index}
    module  {
      func @predict_dispatch_4(%arg0: !flow.dispatch.tensor<readonly:10xf32>, %arg1: !flow.dispatch.tensor<writeonly:f32>) {
        %cst = constant 0x7FC00000 : f32
        %cst_0 = constant 0xFF800000 : f32
        %0 = flow.dispatch.tensor.load %arg0, offsets = [], sizes = [], strides = [] : !flow.dispatch.tensor<readonly:10xf32> -> tensor<10xf32>
        %1 = linalg.init_tensor [] : tensor<f32>
        %2 = linalg.fill(%1, %cst_0) : tensor<f32>, f32 -> tensor<f32> 
        %3 = linalg.generic {indexing_maps = [#map9, #map10], iterator_types = ["reduction"]} ins(%0 : tensor<10xf32>) outs(%2 : tensor<f32>) {
        ^bb0(%arg2: f32, %arg3: f32):  // no predecessors
          %4 = cmpf ogt, %arg2, %arg3 : f32
          %5 = select %4, %arg2, %arg3 : f32
          %6 = cmpf uno, %arg2, %arg3 : f32
          %7 = select %6, %cst, %5 : f32
          linalg.yield %7 : f32
        } -> tensor<f32>
        flow.dispatch.tensor.store %3, %arg1, offsets = [], sizes = [], strides = [] : tensor<f32> -> !flow.dispatch.tensor<writeonly:f32>
        return
      }
    }
  }
  flow.executable @predict_dispatch_5 attributes {sym_visibility = "private"} {
    flow.dispatch.entry @predict_dispatch_5 attributes {workgroup_rank = 3 : index}
    module  {
      func @predict_dispatch_5(%arg0: !flow.dispatch.tensor<readonly:1x10xf32>, %arg1: !flow.dispatch.tensor<readonly:f32>, %arg2: !flow.dispatch.tensor<writeonly:10xf32>) {
        %cst = constant opaque<"_", "0xDEADBEEF"> : tensor<1x10xf32>
        %c1 = constant 1 : index
        %c10 = constant 10 : index
        %0 = flow.dispatch.tensor.load %arg1, offsets = [], sizes = [], strides = [] : !flow.dispatch.tensor<readonly:f32> -> tensor<f32>
        %workgroup_size_0 = flow.dispatch.workgroup.size[0] : index
        %workgroup_size_1 = flow.dispatch.workgroup.size[1] : index
        %workgroup_id_0 = flow.dispatch.workgroup.id[0] : index
        %workgroup_count_0 = flow.dispatch.workgroup.count[0] : index
        %workgroup_id_1 = flow.dispatch.workgroup.id[1] : index
        %workgroup_count_1 = flow.dispatch.workgroup.count[1] : index
        %1 = affine.apply #map0()[%workgroup_id_1, %workgroup_size_1]
        %2 = affine.apply #map0()[%workgroup_count_1, %workgroup_size_1]
        scf.for %arg3 = %1 to %c1 step %2 {
          %3 = affine.apply #map0()[%workgroup_id_0, %workgroup_size_0]
          %4 = affine.apply #map0()[%workgroup_count_0, %workgroup_size_0]
          scf.for %arg4 = %3 to %c10 step %4 {
            %5 = affine.min #map1(%arg3, %workgroup_size_1)
            %6 = affine.min #map6(%arg4, %workgroup_size_0)
            %7 = flow.dispatch.tensor.load %arg0, offsets = [%arg3, %arg4], sizes = [%5, %6], strides = [1, 1] : !flow.dispatch.tensor<readonly:1x10xf32> -> tensor<?x?xf32>
            %8 = affine.min #map1(%arg3, %workgroup_size_1)
            %9 = affine.min #map6(%arg4, %workgroup_size_0)
            %10 = subtensor %cst[%arg3, %arg4] [%8, %9] [1, 1] : tensor<1x10xf32> to tensor<?x?xf32>
            %11 = affine.min #map6(%arg4, %workgroup_size_0)
            %12 = linalg.init_tensor [%11] : tensor<?xf32>
            %13 = linalg.generic {indexing_maps = [#map5, #map5, #map11, #map8], iterator_types = ["parallel", "parallel"]} ins(%7, %10, %0 : tensor<?x?xf32>, tensor<?x?xf32>, tensor<f32>) outs(%12 : tensor<?xf32>) attrs =  {__internal_linalg_transform__ = "workgroup"} {
            ^bb0(%arg5: f32, %arg6: f32, %arg7: f32, %arg8: f32):  // no predecessors
              %14 = addf %arg5, %arg6 : f32
              %15 = subf %14, %arg7 : f32
              %16 = math.exp %15 : f32
              linalg.yield %16 : f32
            } -> tensor<?xf32>
            flow.dispatch.tensor.store %13, %arg2, offsets = [%arg4], sizes = [%11], strides = [1] : tensor<?xf32> -> !flow.dispatch.tensor<writeonly:10xf32>
          }
        }
        return
      }
    }
  }
  flow.executable @predict_dispatch_6 attributes {sym_visibility = "private"} {
    flow.dispatch.entry @predict_dispatch_6 attributes {workgroup_rank = 3 : index}
    module  {
      func @predict_dispatch_6(%arg0: !flow.dispatch.tensor<readonly:10xf32>, %arg1: !flow.dispatch.tensor<writeonly:f32>) {
        %cst = constant 0.000000e+00 : f32
        %0 = flow.dispatch.tensor.load %arg0, offsets = [], sizes = [], strides = [] : !flow.dispatch.tensor<readonly:10xf32> -> tensor<10xf32>
        %1 = linalg.init_tensor [] : tensor<f32>
        %2 = linalg.fill(%1, %cst) : tensor<f32>, f32 -> tensor<f32> 
        %3 = linalg.generic {indexing_maps = [#map9, #map10], iterator_types = ["reduction"]} ins(%0 : tensor<10xf32>) outs(%2 : tensor<f32>) {
        ^bb0(%arg2: f32, %arg3: f32):  // no predecessors
          %4 = addf %arg2, %arg3 : f32
          linalg.yield %4 : f32
        } -> tensor<f32>
        flow.dispatch.tensor.store %3, %arg1, offsets = [], sizes = [], strides = [] : tensor<f32> -> !flow.dispatch.tensor<writeonly:f32>
        return
      }
    }
  }
  flow.executable @predict_dispatch_7 attributes {sym_visibility = "private"} {
    flow.dispatch.entry @predict_dispatch_7 attributes {workgroup_rank = 3 : index}
    module  {
      func @predict_dispatch_7(%arg0: !flow.dispatch.tensor<readonly:1x10xf32>, %arg1: !flow.dispatch.tensor<readonly:f32>, %arg2: !flow.dispatch.tensor<readonly:f32>, %arg3: !flow.dispatch.tensor<writeonly:1x10xf32>) {
        %cst = constant opaque<"_", "0xDEADBEEF"> : tensor<1x10xf32>
        %c1 = constant 1 : index
        %c10 = constant 10 : index
        %0 = flow.dispatch.tensor.load %arg1, offsets = [], sizes = [], strides = [] : !flow.dispatch.tensor<readonly:f32> -> tensor<f32>
        %1 = flow.dispatch.tensor.load %arg2, offsets = [], sizes = [], strides = [] : !flow.dispatch.tensor<readonly:f32> -> tensor<f32>
        %workgroup_size_0 = flow.dispatch.workgroup.size[0] : index
        %workgroup_size_1 = flow.dispatch.workgroup.size[1] : index
        %workgroup_id_0 = flow.dispatch.workgroup.id[0] : index
        %workgroup_count_0 = flow.dispatch.workgroup.count[0] : index
        %workgroup_id_1 = flow.dispatch.workgroup.id[1] : index
        %workgroup_count_1 = flow.dispatch.workgroup.count[1] : index
        %2 = affine.apply #map0()[%workgroup_id_1, %workgroup_size_1]
        %3 = affine.apply #map0()[%workgroup_count_1, %workgroup_size_1]
        scf.for %arg4 = %2 to %c1 step %3 {
          %4 = affine.apply #map0()[%workgroup_id_0, %workgroup_size_0]
          %5 = affine.apply #map0()[%workgroup_count_0, %workgroup_size_0]
          scf.for %arg5 = %4 to %c10 step %5 {
            %6 = affine.min #map1(%arg4, %workgroup_size_1)
            %7 = affine.min #map6(%arg5, %workgroup_size_0)
            %8 = flow.dispatch.tensor.load %arg0, offsets = [%arg4, %arg5], sizes = [%6, %7], strides = [1, 1] : !flow.dispatch.tensor<readonly:1x10xf32> -> tensor<?x?xf32>
            %9 = affine.min #map1(%arg4, %workgroup_size_1)
            %10 = affine.min #map6(%arg5, %workgroup_size_0)
            %11 = subtensor %cst[%arg4, %arg5] [%9, %10] [1, 1] : tensor<1x10xf32> to tensor<?x?xf32>
            %12 = affine.min #map1(%arg4, %workgroup_size_1)
            %13 = affine.min #map6(%arg5, %workgroup_size_0)
            %14 = linalg.init_tensor [%12, %13] : tensor<?x?xf32>
            %15 = linalg.generic {indexing_maps = [#map5, #map5, #map11, #map11, #map5], iterator_types = ["parallel", "parallel"]} ins(%8, %11, %0, %1 : tensor<?x?xf32>, tensor<?x?xf32>, tensor<f32>, tensor<f32>) outs(%14 : tensor<?x?xf32>) attrs =  {__internal_linalg_transform__ = "workgroup"} {
            ^bb0(%arg6: f32, %arg7: f32, %arg8: f32, %arg9: f32, %arg10: f32):  // no predecessors
              %16 = addf %arg6, %arg7 : f32
              %17 = subf %16, %arg8 : f32
              %18 = math.exp %17 : f32
              %19 = divf %18, %arg9 : f32
              linalg.yield %19 : f32
            } -> tensor<?x?xf32>
            flow.dispatch.tensor.store %15, %arg3, offsets = [%arg4, %arg5], sizes = [%12, %13], strides = [1, 1] : tensor<?x?xf32> -> !flow.dispatch.tensor<writeonly:1x10xf32>
          }
        }
        return
      }
    }
  }
  func @predict(%arg0: tensor<1x28x28x1xf32>) -> tensor<1x10xf32> attributes {iree.module.export, iree.reflection = {abi = "sip", abiv = 1 : i32, f = "I15!B11!d1d28d28d1R9!B6!d1d10", fv = "1", sip = "I8!S5!k0_0R3!_0"}} {
    %cst = constant opaque<"_", "0xDEADBEEF"> : tensor<128x10xf32>
    %cst_0 = constant opaque<"_", "0xDEADBEEF"> : tensor<784x128xf32>
    %cst_1 = constant opaque<"_", "0xDEADBEEF"> : tensor<1x128xf32>
    %c128 = constant 128 : index
    %c10 = constant 10 : index
    %c1 = constant 1 : index
    %0 = flow.tensor.reshape %arg0 : tensor<1x28x28x1xf32> -> tensor<1x784xf32>
    %1 = flow.dispatch @predict_dispatch_0::@predict_dispatch_0[%c128, %c1, %c1](%0, %cst_0) : (tensor<1x784xf32>, tensor<784x128xf32>) -> tensor<1x128xf32>
    %2 = flow.dispatch @predict_dispatch_1::@predict_dispatch_1[%c128, %c1, %c1](%1, %cst_1) : (tensor<1x128xf32>, tensor<1x128xf32>) -> tensor<1x128xf32>
    %3 = flow.dispatch @predict_dispatch_2::@predict_dispatch_2[%c10, %c1, %c1](%2, %cst) : (tensor<1x128xf32>, tensor<128x10xf32>) -> tensor<1x10xf32>
    %4 = flow.dispatch @predict_dispatch_3::@predict_dispatch_3[%c10, %c1, %c1](%3) : (tensor<1x10xf32>) -> tensor<10xf32>
    %5 = flow.dispatch @predict_dispatch_4::@predict_dispatch_4[%c1, %c1, %c1](%4) : (tensor<10xf32>) -> tensor<f32>
    %6 = flow.dispatch @predict_dispatch_5::@predict_dispatch_5[%c10, %c1, %c1](%3, %5) : (tensor<1x10xf32>, tensor<f32>) -> tensor<10xf32>
    %7 = flow.dispatch @predict_dispatch_6::@predict_dispatch_6[%c1, %c1, %c1](%6) : (tensor<10xf32>) -> tensor<f32>
    %8 = flow.dispatch @predict_dispatch_7::@predict_dispatch_7[%c10, %c1, %c1](%3, %5, %7) : (tensor<1x10xf32>, tensor<f32>, tensor<f32>) -> tensor<1x10xf32>
    return %8 : tensor<1x10xf32>
  }
}


// *** IR Dump After Canonicalizer ***
func @predict(%arg0: tensor<1x28x28x1xf32>) -> tensor<1x10xf32> attributes {iree.module.export, iree.reflection = {abi = "sip", abiv = 1 : i32, f = "I15!B11!d1d28d28d1R9!B6!d1d10", fv = "1", sip = "I8!S5!k0_0R3!_0"}} {
  %cst = constant opaque<"_", "0xDEADBEEF"> : tensor<128x10xf32>
  %cst_0 = constant opaque<"_", "0xDEADBEEF"> : tensor<784x128xf32>
  %cst_1 = constant opaque<"_", "0xDEADBEEF"> : tensor<1x128xf32>
  %c128 = constant 128 : index
  %c10 = constant 10 : index
  %c1 = constant 1 : index
  %0 = flow.tensor.reshape %arg0 : tensor<1x28x28x1xf32> -> tensor<1x784xf32>
  %1 = flow.dispatch @predict_dispatch_0::@predict_dispatch_0[%c128, %c1, %c1](%0, %cst_0) : (tensor<1x784xf32>, tensor<784x128xf32>) -> tensor<1x128xf32>
  %2 = flow.dispatch @predict_dispatch_1::@predict_dispatch_1[%c128, %c1, %c1](%1, %cst_1) : (tensor<1x128xf32>, tensor<1x128xf32>) -> tensor<1x128xf32>
  %3 = flow.dispatch @predict_dispatch_2::@predict_dispatch_2[%c10, %c1, %c1](%2, %cst) : (tensor<1x128xf32>, tensor<128x10xf32>) -> tensor<1x10xf32>
  %4 = flow.dispatch @predict_dispatch_3::@predict_dispatch_3[%c10, %c1, %c1](%3) : (tensor<1x10xf32>) -> tensor<10xf32>
  %5 = flow.dispatch @predict_dispatch_4::@predict_dispatch_4[%c1, %c1, %c1](%4) : (tensor<10xf32>) -> tensor<f32>
  %6 = flow.dispatch @predict_dispatch_5::@predict_dispatch_5[%c10, %c1, %c1](%3, %5) : (tensor<1x10xf32>, tensor<f32>) -> tensor<10xf32>
  %7 = flow.dispatch @predict_dispatch_6::@predict_dispatch_6[%c1, %c1, %c1](%6) : (tensor<10xf32>) -> tensor<f32>
  %8 = flow.dispatch @predict_dispatch_7::@predict_dispatch_7[%c10, %c1, %c1](%3, %5, %7) : (tensor<1x10xf32>, tensor<f32>, tensor<f32>) -> tensor<1x10xf32>
  return %8 : tensor<1x10xf32>
}

// *** IR Dump After DeduplicateExecutables ***
#map0 = affine_map<()[s0, s1] -> (s0 * s1)>
#map1 = affine_map<(d0, d1) -> (d1, -d0 + 1)>
#map2 = affine_map<(d0, d1) -> (d1, -d0 + 128)>
#map3 = affine_map<(d0, d1) -> (-d0 + 1, d1)>
#map4 = affine_map<(d0, d1) -> (-d0 + 128, d1)>
#map5 = affine_map<(d0, d1) -> (d0, d1)>
#map6 = affine_map<(d0, d1) -> (d1, -d0 + 10)>
#map7 = affine_map<(d0, d1) -> (-d0 + 10, d1)>
#map8 = affine_map<(d0, d1) -> (d1)>
#map9 = affine_map<(d0) -> (d0)>
#map10 = affine_map<(d0) -> ()>
#map11 = affine_map<(d0, d1) -> ()>
module  {
  flow.executable @predict_dispatch_0 attributes {sym_visibility = "private"} {
    flow.dispatch.entry @predict_dispatch_0 attributes {workgroup_rank = 3 : index}
    module  {
      func @predict_dispatch_0(%arg0: !flow.dispatch.tensor<readonly:1x784xf32>, %arg1: !flow.dispatch.tensor<readonly:784x128xf32>, %arg2: !flow.dispatch.tensor<writeonly:1x128xf32>) {
        %cst = constant 0.000000e+00 : f32
        %c1 = constant 1 : index
        %c128 = constant 128 : index
        %workgroup_size_0 = flow.dispatch.workgroup.size[0] : index
        %workgroup_size_1 = flow.dispatch.workgroup.size[1] : index
        %workgroup_id_0 = flow.dispatch.workgroup.id[0] : index
        %workgroup_count_0 = flow.dispatch.workgroup.count[0] : index
        %workgroup_id_1 = flow.dispatch.workgroup.id[1] : index
        %workgroup_count_1 = flow.dispatch.workgroup.count[1] : index
        %0 = affine.apply #map0()[%workgroup_id_1, %workgroup_size_1]
        %1 = affine.apply #map0()[%workgroup_count_1, %workgroup_size_1]
        scf.for %arg3 = %0 to %c1 step %1 {
          %2 = affine.apply #map0()[%workgroup_id_0, %workgroup_size_0]
          %3 = affine.apply #map0()[%workgroup_count_0, %workgroup_size_0]
          scf.for %arg4 = %2 to %c128 step %3 {
            %4 = affine.min #map1(%arg3, %workgroup_size_1)
            %5 = flow.dispatch.tensor.load %arg0, offsets = [%arg3, 0], sizes = [%4, 784], strides = [1, 1] : !flow.dispatch.tensor<readonly:1x784xf32> -> tensor<?x784xf32>
            %6 = affine.min #map2(%arg4, %workgroup_size_0)
            %7 = flow.dispatch.tensor.load %arg1, offsets = [0, %arg4], sizes = [784, %6], strides = [1, 1] : !flow.dispatch.tensor<readonly:784x128xf32> -> tensor<784x?xf32>
            %8 = affine.min #map1(%arg3, %workgroup_size_1)
            %9 = affine.min #map2(%arg4, %workgroup_size_0)
            %10 = affine.min #map3(%arg3, %workgroup_size_1)
            %11 = affine.min #map4(%arg4, %workgroup_size_0)
            %12 = linalg.init_tensor [%10, %11] : tensor<?x?xf32>
            %13 = linalg.fill(%12, %cst) : tensor<?x?xf32>, f32 -> tensor<?x?xf32> 
            %14 = linalg.matmul {__internal_linalg_transform__ = "workgroup"} ins(%5, %7 : tensor<?x784xf32>, tensor<784x?xf32>) outs(%13 : tensor<?x?xf32>) -> tensor<?x?xf32>
            flow.dispatch.tensor.store %14, %arg2, offsets = [%arg3, %arg4], sizes = [%8, %9], strides = [1, 1] : tensor<?x?xf32> -> !flow.dispatch.tensor<writeonly:1x128xf32>
          }
        }
        return
      }
    }
  }
  flow.executable @predict_dispatch_1 attributes {sym_visibility = "private"} {
    flow.dispatch.entry @predict_dispatch_1 attributes {workgroup_rank = 3 : index}
    module  {
      func @predict_dispatch_1(%arg0: !flow.dispatch.tensor<readonly:1x128xf32>, %arg1: !flow.dispatch.tensor<readonly:1x128xf32>, %arg2: !flow.dispatch.tensor<writeonly:1x128xf32>) {
        %cst = constant 0x7FC00000 : f32
        %cst_0 = constant 0.000000e+00 : f32
        %c1 = constant 1 : index
        %c128 = constant 128 : index
        %workgroup_size_0 = flow.dispatch.workgroup.size[0] : index
        %workgroup_size_1 = flow.dispatch.workgroup.size[1] : index
        %workgroup_id_0 = flow.dispatch.workgroup.id[0] : index
        %workgroup_count_0 = flow.dispatch.workgroup.count[0] : index
        %workgroup_id_1 = flow.dispatch.workgroup.id[1] : index
        %workgroup_count_1 = flow.dispatch.workgroup.count[1] : index
        %0 = affine.apply #map0()[%workgroup_id_1, %workgroup_size_1]
        %1 = affine.apply #map0()[%workgroup_count_1, %workgroup_size_1]
        scf.for %arg3 = %0 to %c1 step %1 {
          %2 = affine.apply #map0()[%workgroup_id_0, %workgroup_size_0]
          %3 = affine.apply #map0()[%workgroup_count_0, %workgroup_size_0]
          scf.for %arg4 = %2 to %c128 step %3 {
            %4 = affine.min #map1(%arg3, %workgroup_size_1)
            %5 = affine.min #map2(%arg4, %workgroup_size_0)
            %6 = flow.dispatch.tensor.load %arg0, offsets = [%arg3, %arg4], sizes = [%4, %5], strides = [1, 1] : !flow.dispatch.tensor<readonly:1x128xf32> -> tensor<?x?xf32>
            %7 = affine.min #map1(%arg3, %workgroup_size_1)
            %8 = affine.min #map2(%arg4, %workgroup_size_0)
            %9 = flow.dispatch.tensor.load %arg1, offsets = [%arg3, %arg4], sizes = [%7, %8], strides = [1, 1] : !flow.dispatch.tensor<readonly:1x128xf32> -> tensor<?x?xf32>
            %10 = affine.min #map1(%arg3, %workgroup_size_1)
            %11 = affine.min #map2(%arg4, %workgroup_size_0)
            %12 = linalg.init_tensor [%10, %11] : tensor<?x?xf32>
            %13 = linalg.generic {indexing_maps = [#map5, #map5, #map5], iterator_types = ["parallel", "parallel"]} ins(%6, %9 : tensor<?x?xf32>, tensor<?x?xf32>) outs(%12 : tensor<?x?xf32>) attrs =  {__internal_linalg_transform__ = "workgroup"} {
            ^bb0(%arg5: f32, %arg6: f32, %arg7: f32):  // no predecessors
              %14 = addf %arg5, %arg6 : f32
              %15 = cmpf ogt, %14, %cst_0 : f32
              %16 = select %15, %14, %cst_0 : f32
              %17 = cmpf uno, %14, %cst_0 : f32
              %18 = select %17, %cst, %16 : f32
              linalg.yield %18 : f32
            } -> tensor<?x?xf32>
            flow.dispatch.tensor.store %13, %arg2, offsets = [%arg3, %arg4], sizes = [%10, %11], strides = [1, 1] : tensor<?x?xf32> -> !flow.dispatch.tensor<writeonly:1x128xf32>
          }
        }
        return
      }
    }
  }
  flow.executable @predict_dispatch_2 attributes {sym_visibility = "private"} {
    flow.dispatch.entry @predict_dispatch_2 attributes {workgroup_rank = 3 : index}
    module  {
      func @predict_dispatch_2(%arg0: !flow.dispatch.tensor<readonly:1x128xf32>, %arg1: !flow.dispatch.tensor<readonly:128x10xf32>, %arg2: !flow.dispatch.tensor<writeonly:1x10xf32>) {
        %cst = constant 0.000000e+00 : f32
        %c1 = constant 1 : index
        %c10 = constant 10 : index
        %workgroup_size_0 = flow.dispatch.workgroup.size[0] : index
        %workgroup_size_1 = flow.dispatch.workgroup.size[1] : index
        %workgroup_id_0 = flow.dispatch.workgroup.id[0] : index
        %workgroup_count_0 = flow.dispatch.workgroup.count[0] : index
        %workgroup_id_1 = flow.dispatch.workgroup.id[1] : index
        %workgroup_count_1 = flow.dispatch.workgroup.count[1] : index
        %0 = affine.apply #map0()[%workgroup_id_1, %workgroup_size_1]
        %1 = affine.apply #map0()[%workgroup_count_1, %workgroup_size_1]
        scf.for %arg3 = %0 to %c1 step %1 {
          %2 = affine.apply #map0()[%workgroup_id_0, %workgroup_size_0]
          %3 = affine.apply #map0()[%workgroup_count_0, %workgroup_size_0]
          scf.for %arg4 = %2 to %c10 step %3 {
            %4 = affine.min #map1(%arg3, %workgroup_size_1)
            %5 = flow.dispatch.tensor.load %arg0, offsets = [%arg3, 0], sizes = [%4, 128], strides = [1, 1] : !flow.dispatch.tensor<readonly:1x128xf32> -> tensor<?x128xf32>
            %6 = affine.min #map6(%arg4, %workgroup_size_0)
            %7 = flow.dispatch.tensor.load %arg1, offsets = [0, %arg4], sizes = [128, %6], strides = [1, 1] : !flow.dispatch.tensor<readonly:128x10xf32> -> tensor<128x?xf32>
            %8 = affine.min #map1(%arg3, %workgroup_size_1)
            %9 = affine.min #map6(%arg4, %workgroup_size_0)
            %10 = affine.min #map3(%arg3, %workgroup_size_1)
            %11 = affine.min #map7(%arg4, %workgroup_size_0)
            %12 = linalg.init_tensor [%10, %11] : tensor<?x?xf32>
            %13 = linalg.fill(%12, %cst) : tensor<?x?xf32>, f32 -> tensor<?x?xf32> 
            %14 = linalg.matmul {__internal_linalg_transform__ = "workgroup"} ins(%5, %7 : tensor<?x128xf32>, tensor<128x?xf32>) outs(%13 : tensor<?x?xf32>) -> tensor<?x?xf32>
            flow.dispatch.tensor.store %14, %arg2, offsets = [%arg3, %arg4], sizes = [%8, %9], strides = [1, 1] : tensor<?x?xf32> -> !flow.dispatch.tensor<writeonly:1x10xf32>
          }
        }
        return
      }
    }
  }
  flow.executable @predict_dispatch_3 attributes {sym_visibility = "private"} {
    flow.dispatch.entry @predict_dispatch_3 attributes {workgroup_rank = 3 : index}
    module  {
      func @predict_dispatch_3(%arg0: !flow.dispatch.tensor<readonly:1x10xf32>, %arg1: !flow.dispatch.tensor<writeonly:10xf32>) {
        %cst = constant opaque<"_", "0xDEADBEEF"> : tensor<1x10xf32>
        %c1 = constant 1 : index
        %c10 = constant 10 : index
        %workgroup_size_0 = flow.dispatch.workgroup.size[0] : index
        %workgroup_size_1 = flow.dispatch.workgroup.size[1] : index
        %workgroup_id_0 = flow.dispatch.workgroup.id[0] : index
        %workgroup_count_0 = flow.dispatch.workgroup.count[0] : index
        %workgroup_id_1 = flow.dispatch.workgroup.id[1] : index
        %workgroup_count_1 = flow.dispatch.workgroup.count[1] : index
        %0 = affine.apply #map0()[%workgroup_id_1, %workgroup_size_1]
        %1 = affine.apply #map0()[%workgroup_count_1, %workgroup_size_1]
        scf.for %arg2 = %0 to %c1 step %1 {
          %2 = affine.apply #map0()[%workgroup_id_0, %workgroup_size_0]
          %3 = affine.apply #map0()[%workgroup_count_0, %workgroup_size_0]
          scf.for %arg3 = %2 to %c10 step %3 {
            %4 = affine.min #map1(%arg2, %workgroup_size_1)
            %5 = affine.min #map6(%arg3, %workgroup_size_0)
            %6 = flow.dispatch.tensor.load %arg0, offsets = [%arg2, %arg3], sizes = [%4, %5], strides = [1, 1] : !flow.dispatch.tensor<readonly:1x10xf32> -> tensor<?x?xf32>
            %7 = affine.min #map1(%arg2, %workgroup_size_1)
            %8 = affine.min #map6(%arg3, %workgroup_size_0)
            %9 = subtensor %cst[%arg2, %arg3] [%7, %8] [1, 1] : tensor<1x10xf32> to tensor<?x?xf32>
            %10 = affine.min #map6(%arg3, %workgroup_size_0)
            %11 = linalg.init_tensor [%10] : tensor<?xf32>
            %12 = linalg.generic {indexing_maps = [#map5, #map5, #map8], iterator_types = ["parallel", "parallel"]} ins(%6, %9 : tensor<?x?xf32>, tensor<?x?xf32>) outs(%11 : tensor<?xf32>) attrs =  {__internal_linalg_transform__ = "workgroup"} {
            ^bb0(%arg4: f32, %arg5: f32, %arg6: f32):  // no predecessors
              %13 = addf %arg4, %arg5 : f32
              linalg.yield %13 : f32
            } -> tensor<?xf32>
            flow.dispatch.tensor.store %12, %arg1, offsets = [%arg3], sizes = [%10], strides = [1] : tensor<?xf32> -> !flow.dispatch.tensor<writeonly:10xf32>
          }
        }
        return
      }
    }
  }
  flow.executable @predict_dispatch_4 attributes {sym_visibility = "private"} {
    flow.dispatch.entry @predict_dispatch_4 attributes {workgroup_rank = 3 : index}
    module  {
      func @predict_dispatch_4(%arg0: !flow.dispatch.tensor<readonly:10xf32>, %arg1: !flow.dispatch.tensor<writeonly:f32>) {
        %cst = constant 0x7FC00000 : f32
        %cst_0 = constant 0xFF800000 : f32
        %0 = flow.dispatch.tensor.load %arg0, offsets = [], sizes = [], strides = [] : !flow.dispatch.tensor<readonly:10xf32> -> tensor<10xf32>
        %1 = linalg.init_tensor [] : tensor<f32>
        %2 = linalg.fill(%1, %cst_0) : tensor<f32>, f32 -> tensor<f32> 
        %3 = linalg.generic {indexing_maps = [#map9, #map10], iterator_types = ["reduction"]} ins(%0 : tensor<10xf32>) outs(%2 : tensor<f32>) {
        ^bb0(%arg2: f32, %arg3: f32):  // no predecessors
          %4 = cmpf ogt, %arg2, %arg3 : f32
          %5 = select %4, %arg2, %arg3 : f32
          %6 = cmpf uno, %arg2, %arg3 : f32
          %7 = select %6, %cst, %5 : f32
          linalg.yield %7 : f32
        } -> tensor<f32>
        flow.dispatch.tensor.store %3, %arg1, offsets = [], sizes = [], strides = [] : tensor<f32> -> !flow.dispatch.tensor<writeonly:f32>
        return
      }
    }
  }
  flow.executable @predict_dispatch_5 attributes {sym_visibility = "private"} {
    flow.dispatch.entry @predict_dispatch_5 attributes {workgroup_rank = 3 : index}
    module  {
      func @predict_dispatch_5(%arg0: !flow.dispatch.tensor<readonly:1x10xf32>, %arg1: !flow.dispatch.tensor<readonly:f32>, %arg2: !flow.dispatch.tensor<writeonly:10xf32>) {
        %cst = constant opaque<"_", "0xDEADBEEF"> : tensor<1x10xf32>
        %c1 = constant 1 : index
        %c10 = constant 10 : index
        %0 = flow.dispatch.tensor.load %arg1, offsets = [], sizes = [], strides = [] : !flow.dispatch.tensor<readonly:f32> -> tensor<f32>
        %workgroup_size_0 = flow.dispatch.workgroup.size[0] : index
        %workgroup_size_1 = flow.dispatch.workgroup.size[1] : index
        %workgroup_id_0 = flow.dispatch.workgroup.id[0] : index
        %workgroup_count_0 = flow.dispatch.workgroup.count[0] : index
        %workgroup_id_1 = flow.dispatch.workgroup.id[1] : index
        %workgroup_count_1 = flow.dispatch.workgroup.count[1] : index
        %1 = affine.apply #map0()[%workgroup_id_1, %workgroup_size_1]
        %2 = affine.apply #map0()[%workgroup_count_1, %workgroup_size_1]
        scf.for %arg3 = %1 to %c1 step %2 {
          %3 = affine.apply #map0()[%workgroup_id_0, %workgroup_size_0]
          %4 = affine.apply #map0()[%workgroup_count_0, %workgroup_size_0]
          scf.for %arg4 = %3 to %c10 step %4 {
            %5 = affine.min #map1(%arg3, %workgroup_size_1)
            %6 = affine.min #map6(%arg4, %workgroup_size_0)
            %7 = flow.dispatch.tensor.load %arg0, offsets = [%arg3, %arg4], sizes = [%5, %6], strides = [1, 1] : !flow.dispatch.tensor<readonly:1x10xf32> -> tensor<?x?xf32>
            %8 = affine.min #map1(%arg3, %workgroup_size_1)
            %9 = affine.min #map6(%arg4, %workgroup_size_0)
            %10 = subtensor %cst[%arg3, %arg4] [%8, %9] [1, 1] : tensor<1x10xf32> to tensor<?x?xf32>
            %11 = affine.min #map6(%arg4, %workgroup_size_0)
            %12 = linalg.init_tensor [%11] : tensor<?xf32>
            %13 = linalg.generic {indexing_maps = [#map5, #map5, #map11, #map8], iterator_types = ["parallel", "parallel"]} ins(%7, %10, %0 : tensor<?x?xf32>, tensor<?x?xf32>, tensor<f32>) outs(%12 : tensor<?xf32>) attrs =  {__internal_linalg_transform__ = "workgroup"} {
            ^bb0(%arg5: f32, %arg6: f32, %arg7: f32, %arg8: f32):  // no predecessors
              %14 = addf %arg5, %arg6 : f32
              %15 = subf %14, %arg7 : f32
              %16 = math.exp %15 : f32
              linalg.yield %16 : f32
            } -> tensor<?xf32>
            flow.dispatch.tensor.store %13, %arg2, offsets = [%arg4], sizes = [%11], strides = [1] : tensor<?xf32> -> !flow.dispatch.tensor<writeonly:10xf32>
          }
        }
        return
      }
    }
  }
  flow.executable @predict_dispatch_6 attributes {sym_visibility = "private"} {
    flow.dispatch.entry @predict_dispatch_6 attributes {workgroup_rank = 3 : index}
    module  {
      func @predict_dispatch_6(%arg0: !flow.dispatch.tensor<readonly:10xf32>, %arg1: !flow.dispatch.tensor<writeonly:f32>) {
        %cst = constant 0.000000e+00 : f32
        %0 = flow.dispatch.tensor.load %arg0, offsets = [], sizes = [], strides = [] : !flow.dispatch.tensor<readonly:10xf32> -> tensor<10xf32>
        %1 = linalg.init_tensor [] : tensor<f32>
        %2 = linalg.fill(%1, %cst) : tensor<f32>, f32 -> tensor<f32> 
        %3 = linalg.generic {indexing_maps = [#map9, #map10], iterator_types = ["reduction"]} ins(%0 : tensor<10xf32>) outs(%2 : tensor<f32>) {
        ^bb0(%arg2: f32, %arg3: f32):  // no predecessors
          %4 = addf %arg2, %arg3 : f32
          linalg.yield %4 : f32
        } -> tensor<f32>
        flow.dispatch.tensor.store %3, %arg1, offsets = [], sizes = [], strides = [] : tensor<f32> -> !flow.dispatch.tensor<writeonly:f32>
        return
      }
    }
  }
  flow.executable @predict_dispatch_7 attributes {sym_visibility = "private"} {
    flow.dispatch.entry @predict_dispatch_7 attributes {workgroup_rank = 3 : index}
    module  {
      func @predict_dispatch_7(%arg0: !flow.dispatch.tensor<readonly:1x10xf32>, %arg1: !flow.dispatch.tensor<readonly:f32>, %arg2: !flow.dispatch.tensor<readonly:f32>, %arg3: !flow.dispatch.tensor<writeonly:1x10xf32>) {
        %cst = constant opaque<"_", "0xDEADBEEF"> : tensor<1x10xf32>
        %c1 = constant 1 : index
        %c10 = constant 10 : index
        %0 = flow.dispatch.tensor.load %arg1, offsets = [], sizes = [], strides = [] : !flow.dispatch.tensor<readonly:f32> -> tensor<f32>
        %1 = flow.dispatch.tensor.load %arg2, offsets = [], sizes = [], strides = [] : !flow.dispatch.tensor<readonly:f32> -> tensor<f32>
        %workgroup_size_0 = flow.dispatch.workgroup.size[0] : index
        %workgroup_size_1 = flow.dispatch.workgroup.size[1] : index
        %workgroup_id_0 = flow.dispatch.workgroup.id[0] : index
        %workgroup_count_0 = flow.dispatch.workgroup.count[0] : index
        %workgroup_id_1 = flow.dispatch.workgroup.id[1] : index
        %workgroup_count_1 = flow.dispatch.workgroup.count[1] : index
        %2 = affine.apply #map0()[%workgroup_id_1, %workgroup_size_1]
        %3 = affine.apply #map0()[%workgroup_count_1, %workgroup_size_1]
        scf.for %arg4 = %2 to %c1 step %3 {
          %4 = affine.apply #map0()[%workgroup_id_0, %workgroup_size_0]
          %5 = affine.apply #map0()[%workgroup_count_0, %workgroup_size_0]
          scf.for %arg5 = %4 to %c10 step %5 {
            %6 = affine.min #map1(%arg4, %workgroup_size_1)
            %7 = affine.min #map6(%arg5, %workgroup_size_0)
            %8 = flow.dispatch.tensor.load %arg0, offsets = [%arg4, %arg5], sizes = [%6, %7], strides = [1, 1] : !flow.dispatch.tensor<readonly:1x10xf32> -> tensor<?x?xf32>
            %9 = affine.min #map1(%arg4, %workgroup_size_1)
            %10 = affine.min #map6(%arg5, %workgroup_size_0)
            %11 = subtensor %cst[%arg4, %arg5] [%9, %10] [1, 1] : tensor<1x10xf32> to tensor<?x?xf32>
            %12 = affine.min #map1(%arg4, %workgroup_size_1)
            %13 = affine.min #map6(%arg5, %workgroup_size_0)
            %14 = linalg.init_tensor [%12, %13] : tensor<?x?xf32>
            %15 = linalg.generic {indexing_maps = [#map5, #map5, #map11, #map11, #map5], iterator_types = ["parallel", "parallel"]} ins(%8, %11, %0, %1 : tensor<?x?xf32>, tensor<?x?xf32>, tensor<f32>, tensor<f32>) outs(%14 : tensor<?x?xf32>) attrs =  {__internal_linalg_transform__ = "workgroup"} {
            ^bb0(%arg6: f32, %arg7: f32, %arg8: f32, %arg9: f32, %arg10: f32):  // no predecessors
              %16 = addf %arg6, %arg7 : f32
              %17 = subf %16, %arg8 : f32
              %18 = math.exp %17 : f32
              %19 = divf %18, %arg9 : f32
              linalg.yield %19 : f32
            } -> tensor<?x?xf32>
            flow.dispatch.tensor.store %15, %arg3, offsets = [%arg4, %arg5], sizes = [%12, %13], strides = [1, 1] : tensor<?x?xf32> -> !flow.dispatch.tensor<writeonly:1x10xf32>
          }
        }
        return
      }
    }
  }
  func @predict(%arg0: tensor<1x28x28x1xf32>) -> tensor<1x10xf32> attributes {iree.module.export, iree.reflection = {abi = "sip", abiv = 1 : i32, f = "I15!B11!d1d28d28d1R9!B6!d1d10", fv = "1", sip = "I8!S5!k0_0R3!_0"}} {
    %cst = constant opaque<"_", "0xDEADBEEF"> : tensor<128x10xf32>
    %cst_0 = constant opaque<"_", "0xDEADBEEF"> : tensor<784x128xf32>
    %cst_1 = constant opaque<"_", "0xDEADBEEF"> : tensor<1x128xf32>
    %c128 = constant 128 : index
    %c10 = constant 10 : index
    %c1 = constant 1 : index
    %0 = flow.tensor.reshape %arg0 : tensor<1x28x28x1xf32> -> tensor<1x784xf32>
    %1 = flow.dispatch @predict_dispatch_0::@predict_dispatch_0[%c128, %c1, %c1](%0, %cst_0) : (tensor<1x784xf32>, tensor<784x128xf32>) -> tensor<1x128xf32>
    %2 = flow.dispatch @predict_dispatch_1::@predict_dispatch_1[%c128, %c1, %c1](%1, %cst_1) : (tensor<1x128xf32>, tensor<1x128xf32>) -> tensor<1x128xf32>
    %3 = flow.dispatch @predict_dispatch_2::@predict_dispatch_2[%c10, %c1, %c1](%2, %cst) : (tensor<1x128xf32>, tensor<128x10xf32>) -> tensor<1x10xf32>
    %4 = flow.dispatch @predict_dispatch_3::@predict_dispatch_3[%c10, %c1, %c1](%3) : (tensor<1x10xf32>) -> tensor<10xf32>
    %5 = flow.dispatch @predict_dispatch_4::@predict_dispatch_4[%c1, %c1, %c1](%4) : (tensor<10xf32>) -> tensor<f32>
    %6 = flow.dispatch @predict_dispatch_5::@predict_dispatch_5[%c10, %c1, %c1](%3, %5) : (tensor<1x10xf32>, tensor<f32>) -> tensor<10xf32>
    %7 = flow.dispatch @predict_dispatch_6::@predict_dispatch_6[%c1, %c1, %c1](%6) : (tensor<10xf32>) -> tensor<f32>
    %8 = flow.dispatch @predict_dispatch_7::@predict_dispatch_7[%c10, %c1, %c1](%3, %5, %7) : (tensor<1x10xf32>, tensor<f32>, tensor<f32>) -> tensor<1x10xf32>
    return %8 : tensor<1x10xf32>
  }
}


// *** IR Dump After Canonicalizer ***
func @predict(%arg0: tensor<1x28x28x1xf32>) -> tensor<1x10xf32> attributes {iree.module.export, iree.reflection = {abi = "sip", abiv = 1 : i32, f = "I15!B11!d1d28d28d1R9!B6!d1d10", fv = "1", sip = "I8!S5!k0_0R3!_0"}} {
  %cst = constant opaque<"_", "0xDEADBEEF"> : tensor<128x10xf32>
  %cst_0 = constant opaque<"_", "0xDEADBEEF"> : tensor<784x128xf32>
  %cst_1 = constant opaque<"_", "0xDEADBEEF"> : tensor<1x128xf32>
  %c128 = constant 128 : index
  %c10 = constant 10 : index
  %c1 = constant 1 : index
  %0 = flow.tensor.reshape %arg0 : tensor<1x28x28x1xf32> -> tensor<1x784xf32>
  %1 = flow.dispatch @predict_dispatch_0::@predict_dispatch_0[%c128, %c1, %c1](%0, %cst_0) : (tensor<1x784xf32>, tensor<784x128xf32>) -> tensor<1x128xf32>
  %2 = flow.dispatch @predict_dispatch_1::@predict_dispatch_1[%c128, %c1, %c1](%1, %cst_1) : (tensor<1x128xf32>, tensor<1x128xf32>) -> tensor<1x128xf32>
  %3 = flow.dispatch @predict_dispatch_2::@predict_dispatch_2[%c10, %c1, %c1](%2, %cst) : (tensor<1x128xf32>, tensor<128x10xf32>) -> tensor<1x10xf32>
  %4 = flow.dispatch @predict_dispatch_3::@predict_dispatch_3[%c10, %c1, %c1](%3) : (tensor<1x10xf32>) -> tensor<10xf32>
  %5 = flow.dispatch @predict_dispatch_4::@predict_dispatch_4[%c1, %c1, %c1](%4) : (tensor<10xf32>) -> tensor<f32>
  %6 = flow.dispatch @predict_dispatch_5::@predict_dispatch_5[%c10, %c1, %c1](%3, %5) : (tensor<1x10xf32>, tensor<f32>) -> tensor<10xf32>
  %7 = flow.dispatch @predict_dispatch_6::@predict_dispatch_6[%c1, %c1, %c1](%6) : (tensor<10xf32>) -> tensor<f32>
  %8 = flow.dispatch @predict_dispatch_7::@predict_dispatch_7[%c10, %c1, %c1](%3, %5, %7) : (tensor<1x10xf32>, tensor<f32>, tensor<f32>) -> tensor<1x10xf32>
  return %8 : tensor<1x10xf32>
}

// *** IR Dump After CSE ***
func @predict(%arg0: tensor<1x28x28x1xf32>) -> tensor<1x10xf32> attributes {iree.module.export, iree.reflection = {abi = "sip", abiv = 1 : i32, f = "I15!B11!d1d28d28d1R9!B6!d1d10", fv = "1", sip = "I8!S5!k0_0R3!_0"}} {
  %cst = constant opaque<"_", "0xDEADBEEF"> : tensor<128x10xf32>
  %cst_0 = constant opaque<"_", "0xDEADBEEF"> : tensor<784x128xf32>
  %cst_1 = constant opaque<"_", "0xDEADBEEF"> : tensor<1x128xf32>
  %c128 = constant 128 : index
  %c10 = constant 10 : index
  %c1 = constant 1 : index
  %0 = flow.tensor.reshape %arg0 : tensor<1x28x28x1xf32> -> tensor<1x784xf32>
  %1 = flow.dispatch @predict_dispatch_0::@predict_dispatch_0[%c128, %c1, %c1](%0, %cst_0) : (tensor<1x784xf32>, tensor<784x128xf32>) -> tensor<1x128xf32>
  %2 = flow.dispatch @predict_dispatch_1::@predict_dispatch_1[%c128, %c1, %c1](%1, %cst_1) : (tensor<1x128xf32>, tensor<1x128xf32>) -> tensor<1x128xf32>
  %3 = flow.dispatch @predict_dispatch_2::@predict_dispatch_2[%c10, %c1, %c1](%2, %cst) : (tensor<1x128xf32>, tensor<128x10xf32>) -> tensor<1x10xf32>
  %4 = flow.dispatch @predict_dispatch_3::@predict_dispatch_3[%c10, %c1, %c1](%3) : (tensor<1x10xf32>) -> tensor<10xf32>
  %5 = flow.dispatch @predict_dispatch_4::@predict_dispatch_4[%c1, %c1, %c1](%4) : (tensor<10xf32>) -> tensor<f32>
  %6 = flow.dispatch @predict_dispatch_5::@predict_dispatch_5[%c10, %c1, %c1](%3, %5) : (tensor<1x10xf32>, tensor<f32>) -> tensor<10xf32>
  %7 = flow.dispatch @predict_dispatch_6::@predict_dispatch_6[%c1, %c1, %c1](%6) : (tensor<10xf32>) -> tensor<f32>
  %8 = flow.dispatch @predict_dispatch_7::@predict_dispatch_7[%c10, %c1, %c1](%3, %5, %7) : (tensor<1x10xf32>, tensor<f32>, tensor<f32>) -> tensor<1x10xf32>
  return %8 : tensor<1x10xf32>
}

// *** IR Dump After HoistUnstreamableOps ***
func @predict(%arg0: tensor<1x28x28x1xf32>) -> tensor<1x10xf32> attributes {iree.module.export, iree.reflection = {abi = "sip", abiv = 1 : i32, f = "I15!B11!d1d28d28d1R9!B6!d1d10", fv = "1", sip = "I8!S5!k0_0R3!_0"}} {
  %c1 = constant 1 : index
  %c10 = constant 10 : index
  %c128 = constant 128 : index
  %cst = constant opaque<"_", "0xDEADBEEF"> : tensor<1x128xf32>
  %cst_0 = constant opaque<"_", "0xDEADBEEF"> : tensor<784x128xf32>
  %cst_1 = constant opaque<"_", "0xDEADBEEF"> : tensor<128x10xf32>
  %0 = flow.tensor.reshape %arg0 : tensor<1x28x28x1xf32> -> tensor<1x784xf32>
  %1 = flow.dispatch @predict_dispatch_0::@predict_dispatch_0[%c128, %c1, %c1](%0, %cst_0) : (tensor<1x784xf32>, tensor<784x128xf32>) -> tensor<1x128xf32>
  %2 = flow.dispatch @predict_dispatch_1::@predict_dispatch_1[%c128, %c1, %c1](%1, %cst) : (tensor<1x128xf32>, tensor<1x128xf32>) -> tensor<1x128xf32>
  %3 = flow.dispatch @predict_dispatch_2::@predict_dispatch_2[%c10, %c1, %c1](%2, %cst_1) : (tensor<1x128xf32>, tensor<128x10xf32>) -> tensor<1x10xf32>
  %4 = flow.dispatch @predict_dispatch_3::@predict_dispatch_3[%c10, %c1, %c1](%3) : (tensor<1x10xf32>) -> tensor<10xf32>
  %5 = flow.dispatch @predict_dispatch_4::@predict_dispatch_4[%c1, %c1, %c1](%4) : (tensor<10xf32>) -> tensor<f32>
  %6 = flow.dispatch @predict_dispatch_5::@predict_dispatch_5[%c10, %c1, %c1](%3, %5) : (tensor<1x10xf32>, tensor<f32>) -> tensor<10xf32>
  %7 = flow.dispatch @predict_dispatch_6::@predict_dispatch_6[%c1, %c1, %c1](%6) : (tensor<10xf32>) -> tensor<f32>
  %8 = flow.dispatch @predict_dispatch_7::@predict_dispatch_7[%c10, %c1, %c1](%3, %5, %7) : (tensor<1x10xf32>, tensor<f32>, tensor<f32>) -> tensor<1x10xf32>
  return %8 : tensor<1x10xf32>
}

// *** IR Dump After Canonicalizer ***
func @predict(%arg0: tensor<1x28x28x1xf32>) -> tensor<1x10xf32> attributes {iree.module.export, iree.reflection = {abi = "sip", abiv = 1 : i32, f = "I15!B11!d1d28d28d1R9!B6!d1d10", fv = "1", sip = "I8!S5!k0_0R3!_0"}} {
  %c1 = constant 1 : index
  %c10 = constant 10 : index
  %c128 = constant 128 : index
  %cst = constant opaque<"_", "0xDEADBEEF"> : tensor<1x128xf32>
  %cst_0 = constant opaque<"_", "0xDEADBEEF"> : tensor<784x128xf32>
  %cst_1 = constant opaque<"_", "0xDEADBEEF"> : tensor<128x10xf32>
  %0 = flow.tensor.reshape %arg0 : tensor<1x28x28x1xf32> -> tensor<1x784xf32>
  %1 = flow.dispatch @predict_dispatch_0::@predict_dispatch_0[%c128, %c1, %c1](%0, %cst_0) : (tensor<1x784xf32>, tensor<784x128xf32>) -> tensor<1x128xf32>
  %2 = flow.dispatch @predict_dispatch_1::@predict_dispatch_1[%c128, %c1, %c1](%1, %cst) : (tensor<1x128xf32>, tensor<1x128xf32>) -> tensor<1x128xf32>
  %3 = flow.dispatch @predict_dispatch_2::@predict_dispatch_2[%c10, %c1, %c1](%2, %cst_1) : (tensor<1x128xf32>, tensor<128x10xf32>) -> tensor<1x10xf32>
  %4 = flow.dispatch @predict_dispatch_3::@predict_dispatch_3[%c10, %c1, %c1](%3) : (tensor<1x10xf32>) -> tensor<10xf32>
  %5 = flow.dispatch @predict_dispatch_4::@predict_dispatch_4[%c1, %c1, %c1](%4) : (tensor<10xf32>) -> tensor<f32>
  %6 = flow.dispatch @predict_dispatch_5::@predict_dispatch_5[%c10, %c1, %c1](%3, %5) : (tensor<1x10xf32>, tensor<f32>) -> tensor<10xf32>
  %7 = flow.dispatch @predict_dispatch_6::@predict_dispatch_6[%c1, %c1, %c1](%6) : (tensor<10xf32>) -> tensor<f32>
  %8 = flow.dispatch @predict_dispatch_7::@predict_dispatch_7[%c10, %c1, %c1](%3, %5, %7) : (tensor<1x10xf32>, tensor<f32>, tensor<f32>) -> tensor<1x10xf32>
  return %8 : tensor<1x10xf32>
}

// *** IR Dump After mlir::iree_compiler::IREE::Flow::FormStreamsPass ***
func @predict(%arg0: tensor<1x28x28x1xf32>) -> tensor<1x10xf32> attributes {iree.module.export, iree.reflection = {abi = "sip", abiv = 1 : i32, f = "I15!B11!d1d28d28d1R9!B6!d1d10", fv = "1", sip = "I8!S5!k0_0R3!_0"}} {
  %c1 = constant 1 : index
  %c10 = constant 10 : index
  %c128 = constant 128 : index
  %cst = constant opaque<"_", "0xDEADBEEF"> : tensor<1x128xf32>
  %cst_0 = constant opaque<"_", "0xDEADBEEF"> : tensor<784x128xf32>
  %cst_1 = constant opaque<"_", "0xDEADBEEF"> : tensor<128x10xf32>
  %0 = flow.ex.stream.fragment(%arg0, %c128, %c1, %cst_0, %cst, %c10, %cst_1) : (tensor<1x28x28x1xf32>, index, index, tensor<784x128xf32>, tensor<1x128xf32>, index, tensor<128x10xf32>) -> tensor<1x10xf32> =
      (%arg1: tensor<1x28x28x1xf32>, %arg2: index, %arg3: index, %arg4: tensor<784x128xf32>, %arg5: tensor<1x128xf32>, %arg6: index, %arg7: tensor<128x10xf32>) -> tensor<1x10xf32> {
    %1 = flow.tensor.reshape %arg1 : tensor<1x28x28x1xf32> -> tensor<1x784xf32>
    %2 = flow.dispatch @predict_dispatch_0::@predict_dispatch_0[%arg2, %arg3, %arg3](%1, %arg4) : (tensor<1x784xf32>, tensor<784x128xf32>) -> tensor<1x128xf32>
    %3 = flow.dispatch @predict_dispatch_1::@predict_dispatch_1[%arg2, %arg3, %arg3](%2, %arg5) : (tensor<1x128xf32>, tensor<1x128xf32>) -> tensor<1x128xf32>
    %4 = flow.dispatch @predict_dispatch_2::@predict_dispatch_2[%arg6, %arg3, %arg3](%3, %arg7) : (tensor<1x128xf32>, tensor<128x10xf32>) -> tensor<1x10xf32>
    %5 = flow.dispatch @predict_dispatch_3::@predict_dispatch_3[%arg6, %arg3, %arg3](%4) : (tensor<1x10xf32>) -> tensor<10xf32>
    %6 = flow.dispatch @predict_dispatch_4::@predict_dispatch_4[%arg3, %arg3, %arg3](%5) : (tensor<10xf32>) -> tensor<f32>
    %7 = flow.dispatch @predict_dispatch_5::@predict_dispatch_5[%arg6, %arg3, %arg3](%4, %6) : (tensor<1x10xf32>, tensor<f32>) -> tensor<10xf32>
    %8 = flow.dispatch @predict_dispatch_6::@predict_dispatch_6[%arg3, %arg3, %arg3](%7) : (tensor<10xf32>) -> tensor<f32>
    %9 = flow.dispatch @predict_dispatch_7::@predict_dispatch_7[%arg6, %arg3, %arg3](%4, %6, %8) : (tensor<1x10xf32>, tensor<f32>, tensor<f32>) -> tensor<1x10xf32>
    flow.return %9 : tensor<1x10xf32>
  }
  return %0 : tensor<1x10xf32>
}

// *** IR Dump After OutlineLargeConstants ***
#map0 = affine_map<()[s0, s1] -> (s0 * s1)>
#map1 = affine_map<(d0, d1) -> (d1, -d0 + 1)>
#map2 = affine_map<(d0, d1) -> (d1, -d0 + 128)>
#map3 = affine_map<(d0, d1) -> (-d0 + 1, d1)>
#map4 = affine_map<(d0, d1) -> (-d0 + 128, d1)>
#map5 = affine_map<(d0, d1) -> (d0, d1)>
#map6 = affine_map<(d0, d1) -> (d1, -d0 + 10)>
#map7 = affine_map<(d0, d1) -> (-d0 + 10, d1)>
#map8 = affine_map<(d0, d1) -> (d1)>
#map9 = affine_map<(d0) -> (d0)>
#map10 = affine_map<(d0) -> ()>
#map11 = affine_map<(d0, d1) -> ()>
module  {
  flow.variable @_large_const_0 opaque<"_", "0xDEADBEEF"> : tensor<1x128xf32> attributes {noinline, sym_visibility = "private"}
  flow.variable @_large_const_1 opaque<"_", "0xDEADBEEF"> : tensor<784x128xf32> attributes {noinline, sym_visibility = "private"}
  flow.variable @_large_const_2 opaque<"_", "0xDEADBEEF"> : tensor<128x10xf32> attributes {noinline, sym_visibility = "private"}
  flow.executable @predict_dispatch_0 attributes {sym_visibility = "private"} {
    flow.dispatch.entry @predict_dispatch_0 attributes {workgroup_rank = 3 : index}
    module  {
      func @predict_dispatch_0(%arg0: !flow.dispatch.tensor<readonly:1x784xf32>, %arg1: !flow.dispatch.tensor<readonly:784x128xf32>, %arg2: !flow.dispatch.tensor<writeonly:1x128xf32>) {
        %cst = constant 0.000000e+00 : f32
        %c1 = constant 1 : index
        %c128 = constant 128 : index
        %workgroup_size_0 = flow.dispatch.workgroup.size[0] : index
        %workgroup_size_1 = flow.dispatch.workgroup.size[1] : index
        %workgroup_id_0 = flow.dispatch.workgroup.id[0] : index
        %workgroup_count_0 = flow.dispatch.workgroup.count[0] : index
        %workgroup_id_1 = flow.dispatch.workgroup.id[1] : index
        %workgroup_count_1 = flow.dispatch.workgroup.count[1] : index
        %0 = affine.apply #map0()[%workgroup_id_1, %workgroup_size_1]
        %1 = affine.apply #map0()[%workgroup_count_1, %workgroup_size_1]
        scf.for %arg3 = %0 to %c1 step %1 {
          %2 = affine.apply #map0()[%workgroup_id_0, %workgroup_size_0]
          %3 = affine.apply #map0()[%workgroup_count_0, %workgroup_size_0]
          scf.for %arg4 = %2 to %c128 step %3 {
            %4 = affine.min #map1(%arg3, %workgroup_size_1)
            %5 = flow.dispatch.tensor.load %arg0, offsets = [%arg3, 0], sizes = [%4, 784], strides = [1, 1] : !flow.dispatch.tensor<readonly:1x784xf32> -> tensor<?x784xf32>
            %6 = affine.min #map2(%arg4, %workgroup_size_0)
            %7 = flow.dispatch.tensor.load %arg1, offsets = [0, %arg4], sizes = [784, %6], strides = [1, 1] : !flow.dispatch.tensor<readonly:784x128xf32> -> tensor<784x?xf32>
            %8 = affine.min #map1(%arg3, %workgroup_size_1)
            %9 = affine.min #map2(%arg4, %workgroup_size_0)
            %10 = affine.min #map3(%arg3, %workgroup_size_1)
            %11 = affine.min #map4(%arg4, %workgroup_size_0)
            %12 = linalg.init_tensor [%10, %11] : tensor<?x?xf32>
            %13 = linalg.fill(%12, %cst) : tensor<?x?xf32>, f32 -> tensor<?x?xf32> 
            %14 = linalg.matmul {__internal_linalg_transform__ = "workgroup"} ins(%5, %7 : tensor<?x784xf32>, tensor<784x?xf32>) outs(%13 : tensor<?x?xf32>) -> tensor<?x?xf32>
            flow.dispatch.tensor.store %14, %arg2, offsets = [%arg3, %arg4], sizes = [%8, %9], strides = [1, 1] : tensor<?x?xf32> -> !flow.dispatch.tensor<writeonly:1x128xf32>
          }
        }
        return
      }
    }
  }
  flow.executable @predict_dispatch_1 attributes {sym_visibility = "private"} {
    flow.dispatch.entry @predict_dispatch_1 attributes {workgroup_rank = 3 : index}
    module  {
      func @predict_dispatch_1(%arg0: !flow.dispatch.tensor<readonly:1x128xf32>, %arg1: !flow.dispatch.tensor<readonly:1x128xf32>, %arg2: !flow.dispatch.tensor<writeonly:1x128xf32>) {
        %cst = constant 0x7FC00000 : f32
        %cst_0 = constant 0.000000e+00 : f32
        %c1 = constant 1 : index
        %c128 = constant 128 : index
        %workgroup_size_0 = flow.dispatch.workgroup.size[0] : index
        %workgroup_size_1 = flow.dispatch.workgroup.size[1] : index
        %workgroup_id_0 = flow.dispatch.workgroup.id[0] : index
        %workgroup_count_0 = flow.dispatch.workgroup.count[0] : index
        %workgroup_id_1 = flow.dispatch.workgroup.id[1] : index
        %workgroup_count_1 = flow.dispatch.workgroup.count[1] : index
        %0 = affine.apply #map0()[%workgroup_id_1, %workgroup_size_1]
        %1 = affine.apply #map0()[%workgroup_count_1, %workgroup_size_1]
        scf.for %arg3 = %0 to %c1 step %1 {
          %2 = affine.apply #map0()[%workgroup_id_0, %workgroup_size_0]
          %3 = affine.apply #map0()[%workgroup_count_0, %workgroup_size_0]
          scf.for %arg4 = %2 to %c128 step %3 {
            %4 = affine.min #map1(%arg3, %workgroup_size_1)
            %5 = affine.min #map2(%arg4, %workgroup_size_0)
            %6 = flow.dispatch.tensor.load %arg0, offsets = [%arg3, %arg4], sizes = [%4, %5], strides = [1, 1] : !flow.dispatch.tensor<readonly:1x128xf32> -> tensor<?x?xf32>
            %7 = affine.min #map1(%arg3, %workgroup_size_1)
            %8 = affine.min #map2(%arg4, %workgroup_size_0)
            %9 = flow.dispatch.tensor.load %arg1, offsets = [%arg3, %arg4], sizes = [%7, %8], strides = [1, 1] : !flow.dispatch.tensor<readonly:1x128xf32> -> tensor<?x?xf32>
            %10 = affine.min #map1(%arg3, %workgroup_size_1)
            %11 = affine.min #map2(%arg4, %workgroup_size_0)
            %12 = linalg.init_tensor [%10, %11] : tensor<?x?xf32>
            %13 = linalg.generic {indexing_maps = [#map5, #map5, #map5], iterator_types = ["parallel", "parallel"]} ins(%6, %9 : tensor<?x?xf32>, tensor<?x?xf32>) outs(%12 : tensor<?x?xf32>) attrs =  {__internal_linalg_transform__ = "workgroup"} {
            ^bb0(%arg5: f32, %arg6: f32, %arg7: f32):  // no predecessors
              %14 = addf %arg5, %arg6 : f32
              %15 = cmpf ogt, %14, %cst_0 : f32
              %16 = select %15, %14, %cst_0 : f32
              %17 = cmpf uno, %14, %cst_0 : f32
              %18 = select %17, %cst, %16 : f32
              linalg.yield %18 : f32
            } -> tensor<?x?xf32>
            flow.dispatch.tensor.store %13, %arg2, offsets = [%arg3, %arg4], sizes = [%10, %11], strides = [1, 1] : tensor<?x?xf32> -> !flow.dispatch.tensor<writeonly:1x128xf32>
          }
        }
        return
      }
    }
  }
  flow.executable @predict_dispatch_2 attributes {sym_visibility = "private"} {
    flow.dispatch.entry @predict_dispatch_2 attributes {workgroup_rank = 3 : index}
    module  {
      func @predict_dispatch_2(%arg0: !flow.dispatch.tensor<readonly:1x128xf32>, %arg1: !flow.dispatch.tensor<readonly:128x10xf32>, %arg2: !flow.dispatch.tensor<writeonly:1x10xf32>) {
        %cst = constant 0.000000e+00 : f32
        %c1 = constant 1 : index
        %c10 = constant 10 : index
        %workgroup_size_0 = flow.dispatch.workgroup.size[0] : index
        %workgroup_size_1 = flow.dispatch.workgroup.size[1] : index
        %workgroup_id_0 = flow.dispatch.workgroup.id[0] : index
        %workgroup_count_0 = flow.dispatch.workgroup.count[0] : index
        %workgroup_id_1 = flow.dispatch.workgroup.id[1] : index
        %workgroup_count_1 = flow.dispatch.workgroup.count[1] : index
        %0 = affine.apply #map0()[%workgroup_id_1, %workgroup_size_1]
        %1 = affine.apply #map0()[%workgroup_count_1, %workgroup_size_1]
        scf.for %arg3 = %0 to %c1 step %1 {
          %2 = affine.apply #map0()[%workgroup_id_0, %workgroup_size_0]
          %3 = affine.apply #map0()[%workgroup_count_0, %workgroup_size_0]
          scf.for %arg4 = %2 to %c10 step %3 {
            %4 = affine.min #map1(%arg3, %workgroup_size_1)
            %5 = flow.dispatch.tensor.load %arg0, offsets = [%arg3, 0], sizes = [%4, 128], strides = [1, 1] : !flow.dispatch.tensor<readonly:1x128xf32> -> tensor<?x128xf32>
            %6 = affine.min #map6(%arg4, %workgroup_size_0)
            %7 = flow.dispatch.tensor.load %arg1, offsets = [0, %arg4], sizes = [128, %6], strides = [1, 1] : !flow.dispatch.tensor<readonly:128x10xf32> -> tensor<128x?xf32>
            %8 = affine.min #map1(%arg3, %workgroup_size_1)
            %9 = affine.min #map6(%arg4, %workgroup_size_0)
            %10 = affine.min #map3(%arg3, %workgroup_size_1)
            %11 = affine.min #map7(%arg4, %workgroup_size_0)
            %12 = linalg.init_tensor [%10, %11] : tensor<?x?xf32>
            %13 = linalg.fill(%12, %cst) : tensor<?x?xf32>, f32 -> tensor<?x?xf32> 
            %14 = linalg.matmul {__internal_linalg_transform__ = "workgroup"} ins(%5, %7 : tensor<?x128xf32>, tensor<128x?xf32>) outs(%13 : tensor<?x?xf32>) -> tensor<?x?xf32>
            flow.dispatch.tensor.store %14, %arg2, offsets = [%arg3, %arg4], sizes = [%8, %9], strides = [1, 1] : tensor<?x?xf32> -> !flow.dispatch.tensor<writeonly:1x10xf32>
          }
        }
        return
      }
    }
  }
  flow.executable @predict_dispatch_3 attributes {sym_visibility = "private"} {
    flow.dispatch.entry @predict_dispatch_3 attributes {workgroup_rank = 3 : index}
    module  {
      func @predict_dispatch_3(%arg0: !flow.dispatch.tensor<readonly:1x10xf32>, %arg1: !flow.dispatch.tensor<writeonly:10xf32>) {
        %cst = constant opaque<"_", "0xDEADBEEF"> : tensor<1x10xf32>
        %c1 = constant 1 : index
        %c10 = constant 10 : index
        %workgroup_size_0 = flow.dispatch.workgroup.size[0] : index
        %workgroup_size_1 = flow.dispatch.workgroup.size[1] : index
        %workgroup_id_0 = flow.dispatch.workgroup.id[0] : index
        %workgroup_count_0 = flow.dispatch.workgroup.count[0] : index
        %workgroup_id_1 = flow.dispatch.workgroup.id[1] : index
        %workgroup_count_1 = flow.dispatch.workgroup.count[1] : index
        %0 = affine.apply #map0()[%workgroup_id_1, %workgroup_size_1]
        %1 = affine.apply #map0()[%workgroup_count_1, %workgroup_size_1]
        scf.for %arg2 = %0 to %c1 step %1 {
          %2 = affine.apply #map0()[%workgroup_id_0, %workgroup_size_0]
          %3 = affine.apply #map0()[%workgroup_count_0, %workgroup_size_0]
          scf.for %arg3 = %2 to %c10 step %3 {
            %4 = affine.min #map1(%arg2, %workgroup_size_1)
            %5 = affine.min #map6(%arg3, %workgroup_size_0)
            %6 = flow.dispatch.tensor.load %arg0, offsets = [%arg2, %arg3], sizes = [%4, %5], strides = [1, 1] : !flow.dispatch.tensor<readonly:1x10xf32> -> tensor<?x?xf32>
            %7 = affine.min #map1(%arg2, %workgroup_size_1)
            %8 = affine.min #map6(%arg3, %workgroup_size_0)
            %9 = subtensor %cst[%arg2, %arg3] [%7, %8] [1, 1] : tensor<1x10xf32> to tensor<?x?xf32>
            %10 = affine.min #map6(%arg3, %workgroup_size_0)
            %11 = linalg.init_tensor [%10] : tensor<?xf32>
            %12 = linalg.generic {indexing_maps = [#map5, #map5, #map8], iterator_types = ["parallel", "parallel"]} ins(%6, %9 : tensor<?x?xf32>, tensor<?x?xf32>) outs(%11 : tensor<?xf32>) attrs =  {__internal_linalg_transform__ = "workgroup"} {
            ^bb0(%arg4: f32, %arg5: f32, %arg6: f32):  // no predecessors
              %13 = addf %arg4, %arg5 : f32
              linalg.yield %13 : f32
            } -> tensor<?xf32>
            flow.dispatch.tensor.store %12, %arg1, offsets = [%arg3], sizes = [%10], strides = [1] : tensor<?xf32> -> !flow.dispatch.tensor<writeonly:10xf32>
          }
        }
        return
      }
    }
  }
  flow.executable @predict_dispatch_4 attributes {sym_visibility = "private"} {
    flow.dispatch.entry @predict_dispatch_4 attributes {workgroup_rank = 3 : index}
    module  {
      func @predict_dispatch_4(%arg0: !flow.dispatch.tensor<readonly:10xf32>, %arg1: !flow.dispatch.tensor<writeonly:f32>) {
        %cst = constant 0x7FC00000 : f32
        %cst_0 = constant 0xFF800000 : f32
        %0 = flow.dispatch.tensor.load %arg0, offsets = [], sizes = [], strides = [] : !flow.dispatch.tensor<readonly:10xf32> -> tensor<10xf32>
        %1 = linalg.init_tensor [] : tensor<f32>
        %2 = linalg.fill(%1, %cst_0) : tensor<f32>, f32 -> tensor<f32> 
        %3 = linalg.generic {indexing_maps = [#map9, #map10], iterator_types = ["reduction"]} ins(%0 : tensor<10xf32>) outs(%2 : tensor<f32>) {
        ^bb0(%arg2: f32, %arg3: f32):  // no predecessors
          %4 = cmpf ogt, %arg2, %arg3 : f32
          %5 = select %4, %arg2, %arg3 : f32
          %6 = cmpf uno, %arg2, %arg3 : f32
          %7 = select %6, %cst, %5 : f32
          linalg.yield %7 : f32
        } -> tensor<f32>
        flow.dispatch.tensor.store %3, %arg1, offsets = [], sizes = [], strides = [] : tensor<f32> -> !flow.dispatch.tensor<writeonly:f32>
        return
      }
    }
  }
  flow.executable @predict_dispatch_5 attributes {sym_visibility = "private"} {
    flow.dispatch.entry @predict_dispatch_5 attributes {workgroup_rank = 3 : index}
    module  {
      func @predict_dispatch_5(%arg0: !flow.dispatch.tensor<readonly:1x10xf32>, %arg1: !flow.dispatch.tensor<readonly:f32>, %arg2: !flow.dispatch.tensor<writeonly:10xf32>) {
        %cst = constant opaque<"_", "0xDEADBEEF"> : tensor<1x10xf32>
        %c1 = constant 1 : index
        %c10 = constant 10 : index
        %0 = flow.dispatch.tensor.load %arg1, offsets = [], sizes = [], strides = [] : !flow.dispatch.tensor<readonly:f32> -> tensor<f32>
        %workgroup_size_0 = flow.dispatch.workgroup.size[0] : index
        %workgroup_size_1 = flow.dispatch.workgroup.size[1] : index
        %workgroup_id_0 = flow.dispatch.workgroup.id[0] : index
        %workgroup_count_0 = flow.dispatch.workgroup.count[0] : index
        %workgroup_id_1 = flow.dispatch.workgroup.id[1] : index
        %workgroup_count_1 = flow.dispatch.workgroup.count[1] : index
        %1 = affine.apply #map0()[%workgroup_id_1, %workgroup_size_1]
        %2 = affine.apply #map0()[%workgroup_count_1, %workgroup_size_1]
        scf.for %arg3 = %1 to %c1 step %2 {
          %3 = affine.apply #map0()[%workgroup_id_0, %workgroup_size_0]
          %4 = affine.apply #map0()[%workgroup_count_0, %workgroup_size_0]
          scf.for %arg4 = %3 to %c10 step %4 {
            %5 = affine.min #map1(%arg3, %workgroup_size_1)
            %6 = affine.min #map6(%arg4, %workgroup_size_0)
            %7 = flow.dispatch.tensor.load %arg0, offsets = [%arg3, %arg4], sizes = [%5, %6], strides = [1, 1] : !flow.dispatch.tensor<readonly:1x10xf32> -> tensor<?x?xf32>
            %8 = affine.min #map1(%arg3, %workgroup_size_1)
            %9 = affine.min #map6(%arg4, %workgroup_size_0)
            %10 = subtensor %cst[%arg3, %arg4] [%8, %9] [1, 1] : tensor<1x10xf32> to tensor<?x?xf32>
            %11 = affine.min #map6(%arg4, %workgroup_size_0)
            %12 = linalg.init_tensor [%11] : tensor<?xf32>
            %13 = linalg.generic {indexing_maps = [#map5, #map5, #map11, #map8], iterator_types = ["parallel", "parallel"]} ins(%7, %10, %0 : tensor<?x?xf32>, tensor<?x?xf32>, tensor<f32>) outs(%12 : tensor<?xf32>) attrs =  {__internal_linalg_transform__ = "workgroup"} {
            ^bb0(%arg5: f32, %arg6: f32, %arg7: f32, %arg8: f32):  // no predecessors
              %14 = addf %arg5, %arg6 : f32
              %15 = subf %14, %arg7 : f32
              %16 = math.exp %15 : f32
              linalg.yield %16 : f32
            } -> tensor<?xf32>
            flow.dispatch.tensor.store %13, %arg2, offsets = [%arg4], sizes = [%11], strides = [1] : tensor<?xf32> -> !flow.dispatch.tensor<writeonly:10xf32>
          }
        }
        return
      }
    }
  }
  flow.executable @predict_dispatch_6 attributes {sym_visibility = "private"} {
    flow.dispatch.entry @predict_dispatch_6 attributes {workgroup_rank = 3 : index}
    module  {
      func @predict_dispatch_6(%arg0: !flow.dispatch.tensor<readonly:10xf32>, %arg1: !flow.dispatch.tensor<writeonly:f32>) {
        %cst = constant 0.000000e+00 : f32
        %0 = flow.dispatch.tensor.load %arg0, offsets = [], sizes = [], strides = [] : !flow.dispatch.tensor<readonly:10xf32> -> tensor<10xf32>
        %1 = linalg.init_tensor [] : tensor<f32>
        %2 = linalg.fill(%1, %cst) : tensor<f32>, f32 -> tensor<f32> 
        %3 = linalg.generic {indexing_maps = [#map9, #map10], iterator_types = ["reduction"]} ins(%0 : tensor<10xf32>) outs(%2 : tensor<f32>) {
        ^bb0(%arg2: f32, %arg3: f32):  // no predecessors
          %4 = addf %arg2, %arg3 : f32
          linalg.yield %4 : f32
        } -> tensor<f32>
        flow.dispatch.tensor.store %3, %arg1, offsets = [], sizes = [], strides = [] : tensor<f32> -> !flow.dispatch.tensor<writeonly:f32>
        return
      }
    }
  }
  flow.executable @predict_dispatch_7 attributes {sym_visibility = "private"} {
    flow.dispatch.entry @predict_dispatch_7 attributes {workgroup_rank = 3 : index}
    module  {
      func @predict_dispatch_7(%arg0: !flow.dispatch.tensor<readonly:1x10xf32>, %arg1: !flow.dispatch.tensor<readonly:f32>, %arg2: !flow.dispatch.tensor<readonly:f32>, %arg3: !flow.dispatch.tensor<writeonly:1x10xf32>) {
        %cst = constant opaque<"_", "0xDEADBEEF"> : tensor<1x10xf32>
        %c1 = constant 1 : index
        %c10 = constant 10 : index
        %0 = flow.dispatch.tensor.load %arg1, offsets = [], sizes = [], strides = [] : !flow.dispatch.tensor<readonly:f32> -> tensor<f32>
        %1 = flow.dispatch.tensor.load %arg2, offsets = [], sizes = [], strides = [] : !flow.dispatch.tensor<readonly:f32> -> tensor<f32>
        %workgroup_size_0 = flow.dispatch.workgroup.size[0] : index
        %workgroup_size_1 = flow.dispatch.workgroup.size[1] : index
        %workgroup_id_0 = flow.dispatch.workgroup.id[0] : index
        %workgroup_count_0 = flow.dispatch.workgroup.count[0] : index
        %workgroup_id_1 = flow.dispatch.workgroup.id[1] : index
        %workgroup_count_1 = flow.dispatch.workgroup.count[1] : index
        %2 = affine.apply #map0()[%workgroup_id_1, %workgroup_size_1]
        %3 = affine.apply #map0()[%workgroup_count_1, %workgroup_size_1]
        scf.for %arg4 = %2 to %c1 step %3 {
          %4 = affine.apply #map0()[%workgroup_id_0, %workgroup_size_0]
          %5 = affine.apply #map0()[%workgroup_count_0, %workgroup_size_0]
          scf.for %arg5 = %4 to %c10 step %5 {
            %6 = affine.min #map1(%arg4, %workgroup_size_1)
            %7 = affine.min #map6(%arg5, %workgroup_size_0)
            %8 = flow.dispatch.tensor.load %arg0, offsets = [%arg4, %arg5], sizes = [%6, %7], strides = [1, 1] : !flow.dispatch.tensor<readonly:1x10xf32> -> tensor<?x?xf32>
            %9 = affine.min #map1(%arg4, %workgroup_size_1)
            %10 = affine.min #map6(%arg5, %workgroup_size_0)
            %11 = subtensor %cst[%arg4, %arg5] [%9, %10] [1, 1] : tensor<1x10xf32> to tensor<?x?xf32>
            %12 = affine.min #map1(%arg4, %workgroup_size_1)
            %13 = affine.min #map6(%arg5, %workgroup_size_0)
            %14 = linalg.init_tensor [%12, %13] : tensor<?x?xf32>
            %15 = linalg.generic {indexing_maps = [#map5, #map5, #map11, #map11, #map5], iterator_types = ["parallel", "parallel"]} ins(%8, %11, %0, %1 : tensor<?x?xf32>, tensor<?x?xf32>, tensor<f32>, tensor<f32>) outs(%14 : tensor<?x?xf32>) attrs =  {__internal_linalg_transform__ = "workgroup"} {
            ^bb0(%arg6: f32, %arg7: f32, %arg8: f32, %arg9: f32, %arg10: f32):  // no predecessors
              %16 = addf %arg6, %arg7 : f32
              %17 = subf %16, %arg8 : f32
              %18 = math.exp %17 : f32
              %19 = divf %18, %arg9 : f32
              linalg.yield %19 : f32
            } -> tensor<?x?xf32>
            flow.dispatch.tensor.store %15, %arg3, offsets = [%arg4, %arg5], sizes = [%12, %13], strides = [1, 1] : tensor<?x?xf32> -> !flow.dispatch.tensor<writeonly:1x10xf32>
          }
        }
        return
      }
    }
  }
  func @predict(%arg0: tensor<1x28x28x1xf32>) -> tensor<1x10xf32> attributes {iree.module.export, iree.reflection = {abi = "sip", abiv = 1 : i32, f = "I15!B11!d1d28d28d1R9!B6!d1d10", fv = "1", sip = "I8!S5!k0_0R3!_0"}} {
    %c1 = constant 1 : index
    %c10 = constant 10 : index
    %c128 = constant 128 : index
    %0 = flow.variable.load @_large_const_0 : tensor<1x128xf32>
    %1 = flow.variable.load @_large_const_1 : tensor<784x128xf32>
    %2 = flow.variable.load @_large_const_2 : tensor<128x10xf32>
    %3 = flow.ex.stream.fragment(%arg0, %c128, %c1, %1, %0, %c10, %2) : (tensor<1x28x28x1xf32>, index, index, tensor<784x128xf32>, tensor<1x128xf32>, index, tensor<128x10xf32>) -> tensor<1x10xf32> =
        (%arg1: tensor<1x28x28x1xf32>, %arg2: index, %arg3: index, %arg4: tensor<784x128xf32>, %arg5: tensor<1x128xf32>, %arg6: index, %arg7: tensor<128x10xf32>) -> tensor<1x10xf32> {
      %4 = flow.tensor.reshape %arg1 : tensor<1x28x28x1xf32> -> tensor<1x784xf32>
      %5 = flow.dispatch @predict_dispatch_0::@predict_dispatch_0[%arg2, %arg3, %arg3](%4, %arg4) : (tensor<1x784xf32>, tensor<784x128xf32>) -> tensor<1x128xf32>
      %6 = flow.dispatch @predict_dispatch_1::@predict_dispatch_1[%arg2, %arg3, %arg3](%5, %arg5) : (tensor<1x128xf32>, tensor<1x128xf32>) -> tensor<1x128xf32>
      %7 = flow.dispatch @predict_dispatch_2::@predict_dispatch_2[%arg6, %arg3, %arg3](%6, %arg7) : (tensor<1x128xf32>, tensor<128x10xf32>) -> tensor<1x10xf32>
      %8 = flow.dispatch @predict_dispatch_3::@predict_dispatch_3[%arg6, %arg3, %arg3](%7) : (tensor<1x10xf32>) -> tensor<10xf32>
      %9 = flow.dispatch @predict_dispatch_4::@predict_dispatch_4[%arg3, %arg3, %arg3](%8) : (tensor<10xf32>) -> tensor<f32>
      %10 = flow.dispatch @predict_dispatch_5::@predict_dispatch_5[%arg6, %arg3, %arg3](%7, %9) : (tensor<1x10xf32>, tensor<f32>) -> tensor<10xf32>
      %11 = flow.dispatch @predict_dispatch_6::@predict_dispatch_6[%arg3, %arg3, %arg3](%10) : (tensor<10xf32>) -> tensor<f32>
      %12 = flow.dispatch @predict_dispatch_7::@predict_dispatch_7[%arg6, %arg3, %arg3](%7, %9, %11) : (tensor<1x10xf32>, tensor<f32>, tensor<f32>) -> tensor<1x10xf32>
      flow.return %12 : tensor<1x10xf32>
    }
    return %3 : tensor<1x10xf32>
  }
}


// *** IR Dump After Canonicalizer ***
func @predict(%arg0: tensor<1x28x28x1xf32>) -> tensor<1x10xf32> attributes {iree.module.export, iree.reflection = {abi = "sip", abiv = 1 : i32, f = "I15!B11!d1d28d28d1R9!B6!d1d10", fv = "1", sip = "I8!S5!k0_0R3!_0"}} {
  %0 = flow.ex.stream.fragment(%arg0) : (tensor<1x28x28x1xf32>) -> tensor<1x10xf32> =
      (%arg1: tensor<1x28x28x1xf32>) -> tensor<1x10xf32> {
    %c128 = constant 128 : index
    %c1 = constant 1 : index
    %c10 = constant 10 : index
    %1 = flow.variable.load @_large_const_1 : tensor<784x128xf32>
    %2 = flow.variable.load @_large_const_0 : tensor<1x128xf32>
    %3 = flow.variable.load @_large_const_2 : tensor<128x10xf32>
    %4 = flow.tensor.reshape %arg1 : tensor<1x28x28x1xf32> -> tensor<1x784xf32>
    %5 = flow.dispatch @predict_dispatch_0::@predict_dispatch_0[%c128, %c1, %c1](%4, %1) : (tensor<1x784xf32>, tensor<784x128xf32>) -> tensor<1x128xf32>
    %6 = flow.dispatch @predict_dispatch_1::@predict_dispatch_1[%c128, %c1, %c1](%5, %2) : (tensor<1x128xf32>, tensor<1x128xf32>) -> tensor<1x128xf32>
    %7 = flow.dispatch @predict_dispatch_2::@predict_dispatch_2[%c10, %c1, %c1](%6, %3) : (tensor<1x128xf32>, tensor<128x10xf32>) -> tensor<1x10xf32>
    %8 = flow.dispatch @predict_dispatch_3::@predict_dispatch_3[%c10, %c1, %c1](%7) : (tensor<1x10xf32>) -> tensor<10xf32>
    %9 = flow.dispatch @predict_dispatch_4::@predict_dispatch_4[%c1, %c1, %c1](%8) : (tensor<10xf32>) -> tensor<f32>
    %10 = flow.dispatch @predict_dispatch_5::@predict_dispatch_5[%c10, %c1, %c1](%7, %9) : (tensor<1x10xf32>, tensor<f32>) -> tensor<10xf32>
    %11 = flow.dispatch @predict_dispatch_6::@predict_dispatch_6[%c1, %c1, %c1](%10) : (tensor<10xf32>) -> tensor<f32>
    %12 = flow.dispatch @predict_dispatch_7::@predict_dispatch_7[%c10, %c1, %c1](%7, %9, %11) : (tensor<1x10xf32>, tensor<f32>, tensor<f32>) -> tensor<1x10xf32>
    flow.return %12 : tensor<1x10xf32>
  }
  return %0 : tensor<1x10xf32>
}

// *** IR Dump After CSE ***
func @predict(%arg0: tensor<1x28x28x1xf32>) -> tensor<1x10xf32> attributes {iree.module.export, iree.reflection = {abi = "sip", abiv = 1 : i32, f = "I15!B11!d1d28d28d1R9!B6!d1d10", fv = "1", sip = "I8!S5!k0_0R3!_0"}} {
  %0 = flow.ex.stream.fragment(%arg0) : (tensor<1x28x28x1xf32>) -> tensor<1x10xf32> =
      (%arg1: tensor<1x28x28x1xf32>) -> tensor<1x10xf32> {
    %c128 = constant 128 : index
    %c1 = constant 1 : index
    %c10 = constant 10 : index
    %1 = flow.variable.load @_large_const_1 : tensor<784x128xf32>
    %2 = flow.variable.load @_large_const_0 : tensor<1x128xf32>
    %3 = flow.variable.load @_large_const_2 : tensor<128x10xf32>
    %4 = flow.tensor.reshape %arg1 : tensor<1x28x28x1xf32> -> tensor<1x784xf32>
    %5 = flow.dispatch @predict_dispatch_0::@predict_dispatch_0[%c128, %c1, %c1](%4, %1) : (tensor<1x784xf32>, tensor<784x128xf32>) -> tensor<1x128xf32>
    %6 = flow.dispatch @predict_dispatch_1::@predict_dispatch_1[%c128, %c1, %c1](%5, %2) : (tensor<1x128xf32>, tensor<1x128xf32>) -> tensor<1x128xf32>
    %7 = flow.dispatch @predict_dispatch_2::@predict_dispatch_2[%c10, %c1, %c1](%6, %3) : (tensor<1x128xf32>, tensor<128x10xf32>) -> tensor<1x10xf32>
    %8 = flow.dispatch @predict_dispatch_3::@predict_dispatch_3[%c10, %c1, %c1](%7) : (tensor<1x10xf32>) -> tensor<10xf32>
    %9 = flow.dispatch @predict_dispatch_4::@predict_dispatch_4[%c1, %c1, %c1](%8) : (tensor<10xf32>) -> tensor<f32>
    %10 = flow.dispatch @predict_dispatch_5::@predict_dispatch_5[%c10, %c1, %c1](%7, %9) : (tensor<1x10xf32>, tensor<f32>) -> tensor<10xf32>
    %11 = flow.dispatch @predict_dispatch_6::@predict_dispatch_6[%c1, %c1, %c1](%10) : (tensor<10xf32>) -> tensor<f32>
    %12 = flow.dispatch @predict_dispatch_7::@predict_dispatch_7[%c10, %c1, %c1](%7, %9, %11) : (tensor<1x10xf32>, tensor<f32>, tensor<f32>) -> tensor<1x10xf32>
    flow.return %12 : tensor<1x10xf32>
  }
  return %0 : tensor<1x10xf32>
}

// *** IR Dump After SymbolDCE ***
#map0 = affine_map<()[s0, s1] -> (s0 * s1)>
#map1 = affine_map<(d0, d1) -> (d1, -d0 + 1)>
#map2 = affine_map<(d0, d1) -> (d1, -d0 + 128)>
#map3 = affine_map<(d0, d1) -> (-d0 + 1, d1)>
#map4 = affine_map<(d0, d1) -> (-d0 + 128, d1)>
#map5 = affine_map<(d0, d1) -> (d0, d1)>
#map6 = affine_map<(d0, d1) -> (d1, -d0 + 10)>
#map7 = affine_map<(d0, d1) -> (-d0 + 10, d1)>
#map8 = affine_map<(d0, d1) -> (d1)>
#map9 = affine_map<(d0) -> (d0)>
#map10 = affine_map<(d0) -> ()>
#map11 = affine_map<(d0, d1) -> ()>
module  {
  flow.variable @_large_const_0 opaque<"_", "0xDEADBEEF"> : tensor<1x128xf32> attributes {noinline, sym_visibility = "private"}
  flow.variable @_large_const_1 opaque<"_", "0xDEADBEEF"> : tensor<784x128xf32> attributes {noinline, sym_visibility = "private"}
  flow.variable @_large_const_2 opaque<"_", "0xDEADBEEF"> : tensor<128x10xf32> attributes {noinline, sym_visibility = "private"}
  flow.executable @predict_dispatch_0 attributes {sym_visibility = "private"} {
    flow.dispatch.entry @predict_dispatch_0 attributes {workgroup_rank = 3 : index}
    module  {
      func @predict_dispatch_0(%arg0: !flow.dispatch.tensor<readonly:1x784xf32>, %arg1: !flow.dispatch.tensor<readonly:784x128xf32>, %arg2: !flow.dispatch.tensor<writeonly:1x128xf32>) {
        %cst = constant 0.000000e+00 : f32
        %c1 = constant 1 : index
        %c128 = constant 128 : index
        %workgroup_size_0 = flow.dispatch.workgroup.size[0] : index
        %workgroup_size_1 = flow.dispatch.workgroup.size[1] : index
        %workgroup_id_0 = flow.dispatch.workgroup.id[0] : index
        %workgroup_count_0 = flow.dispatch.workgroup.count[0] : index
        %workgroup_id_1 = flow.dispatch.workgroup.id[1] : index
        %workgroup_count_1 = flow.dispatch.workgroup.count[1] : index
        %0 = affine.apply #map0()[%workgroup_id_1, %workgroup_size_1]
        %1 = affine.apply #map0()[%workgroup_count_1, %workgroup_size_1]
        scf.for %arg3 = %0 to %c1 step %1 {
          %2 = affine.apply #map0()[%workgroup_id_0, %workgroup_size_0]
          %3 = affine.apply #map0()[%workgroup_count_0, %workgroup_size_0]
          scf.for %arg4 = %2 to %c128 step %3 {
            %4 = affine.min #map1(%arg3, %workgroup_size_1)
            %5 = flow.dispatch.tensor.load %arg0, offsets = [%arg3, 0], sizes = [%4, 784], strides = [1, 1] : !flow.dispatch.tensor<readonly:1x784xf32> -> tensor<?x784xf32>
            %6 = affine.min #map2(%arg4, %workgroup_size_0)
            %7 = flow.dispatch.tensor.load %arg1, offsets = [0, %arg4], sizes = [784, %6], strides = [1, 1] : !flow.dispatch.tensor<readonly:784x128xf32> -> tensor<784x?xf32>
            %8 = affine.min #map1(%arg3, %workgroup_size_1)
            %9 = affine.min #map2(%arg4, %workgroup_size_0)
            %10 = affine.min #map3(%arg3, %workgroup_size_1)
            %11 = affine.min #map4(%arg4, %workgroup_size_0)
            %12 = linalg.init_tensor [%10, %11] : tensor<?x?xf32>
            %13 = linalg.fill(%12, %cst) : tensor<?x?xf32>, f32 -> tensor<?x?xf32> 
            %14 = linalg.matmul {__internal_linalg_transform__ = "workgroup"} ins(%5, %7 : tensor<?x784xf32>, tensor<784x?xf32>) outs(%13 : tensor<?x?xf32>) -> tensor<?x?xf32>
            flow.dispatch.tensor.store %14, %arg2, offsets = [%arg3, %arg4], sizes = [%8, %9], strides = [1, 1] : tensor<?x?xf32> -> !flow.dispatch.tensor<writeonly:1x128xf32>
          }
        }
        return
      }
    }
  }
  flow.executable @predict_dispatch_1 attributes {sym_visibility = "private"} {
    flow.dispatch.entry @predict_dispatch_1 attributes {workgroup_rank = 3 : index}
    module  {
      func @predict_dispatch_1(%arg0: !flow.dispatch.tensor<readonly:1x128xf32>, %arg1: !flow.dispatch.tensor<readonly:1x128xf32>, %arg2: !flow.dispatch.tensor<writeonly:1x128xf32>) {
        %cst = constant 0x7FC00000 : f32
        %cst_0 = constant 0.000000e+00 : f32
        %c1 = constant 1 : index
        %c128 = constant 128 : index
        %workgroup_size_0 = flow.dispatch.workgroup.size[0] : index
        %workgroup_size_1 = flow.dispatch.workgroup.size[1] : index
        %workgroup_id_0 = flow.dispatch.workgroup.id[0] : index
        %workgroup_count_0 = flow.dispatch.workgroup.count[0] : index
        %workgroup_id_1 = flow.dispatch.workgroup.id[1] : index
        %workgroup_count_1 = flow.dispatch.workgroup.count[1] : index
        %0 = affine.apply #map0()[%workgroup_id_1, %workgroup_size_1]
        %1 = affine.apply #map0()[%workgroup_count_1, %workgroup_size_1]
        scf.for %arg3 = %0 to %c1 step %1 {
          %2 = affine.apply #map0()[%workgroup_id_0, %workgroup_size_0]
          %3 = affine.apply #map0()[%workgroup_count_0, %workgroup_size_0]
          scf.for %arg4 = %2 to %c128 step %3 {
            %4 = affine.min #map1(%arg3, %workgroup_size_1)
            %5 = affine.min #map2(%arg4, %workgroup_size_0)
            %6 = flow.dispatch.tensor.load %arg0, offsets = [%arg3, %arg4], sizes = [%4, %5], strides = [1, 1] : !flow.dispatch.tensor<readonly:1x128xf32> -> tensor<?x?xf32>
            %7 = affine.min #map1(%arg3, %workgroup_size_1)
            %8 = affine.min #map2(%arg4, %workgroup_size_0)
            %9 = flow.dispatch.tensor.load %arg1, offsets = [%arg3, %arg4], sizes = [%7, %8], strides = [1, 1] : !flow.dispatch.tensor<readonly:1x128xf32> -> tensor<?x?xf32>
            %10 = affine.min #map1(%arg3, %workgroup_size_1)
            %11 = affine.min #map2(%arg4, %workgroup_size_0)
            %12 = linalg.init_tensor [%10, %11] : tensor<?x?xf32>
            %13 = linalg.generic {indexing_maps = [#map5, #map5, #map5], iterator_types = ["parallel", "parallel"]} ins(%6, %9 : tensor<?x?xf32>, tensor<?x?xf32>) outs(%12 : tensor<?x?xf32>) attrs =  {__internal_linalg_transform__ = "workgroup"} {
            ^bb0(%arg5: f32, %arg6: f32, %arg7: f32):  // no predecessors
              %14 = addf %arg5, %arg6 : f32
              %15 = cmpf ogt, %14, %cst_0 : f32
              %16 = select %15, %14, %cst_0 : f32
              %17 = cmpf uno, %14, %cst_0 : f32
              %18 = select %17, %cst, %16 : f32
              linalg.yield %18 : f32
            } -> tensor<?x?xf32>
            flow.dispatch.tensor.store %13, %arg2, offsets = [%arg3, %arg4], sizes = [%10, %11], strides = [1, 1] : tensor<?x?xf32> -> !flow.dispatch.tensor<writeonly:1x128xf32>
          }
        }
        return
      }
    }
  }
  flow.executable @predict_dispatch_2 attributes {sym_visibility = "private"} {
    flow.dispatch.entry @predict_dispatch_2 attributes {workgroup_rank = 3 : index}
    module  {
      func @predict_dispatch_2(%arg0: !flow.dispatch.tensor<readonly:1x128xf32>, %arg1: !flow.dispatch.tensor<readonly:128x10xf32>, %arg2: !flow.dispatch.tensor<writeonly:1x10xf32>) {
        %cst = constant 0.000000e+00 : f32
        %c1 = constant 1 : index
        %c10 = constant 10 : index
        %workgroup_size_0 = flow.dispatch.workgroup.size[0] : index
        %workgroup_size_1 = flow.dispatch.workgroup.size[1] : index
        %workgroup_id_0 = flow.dispatch.workgroup.id[0] : index
        %workgroup_count_0 = flow.dispatch.workgroup.count[0] : index
        %workgroup_id_1 = flow.dispatch.workgroup.id[1] : index
        %workgroup_count_1 = flow.dispatch.workgroup.count[1] : index
        %0 = affine.apply #map0()[%workgroup_id_1, %workgroup_size_1]
        %1 = affine.apply #map0()[%workgroup_count_1, %workgroup_size_1]
        scf.for %arg3 = %0 to %c1 step %1 {
          %2 = affine.apply #map0()[%workgroup_id_0, %workgroup_size_0]
          %3 = affine.apply #map0()[%workgroup_count_0, %workgroup_size_0]
          scf.for %arg4 = %2 to %c10 step %3 {
            %4 = affine.min #map1(%arg3, %workgroup_size_1)
            %5 = flow.dispatch.tensor.load %arg0, offsets = [%arg3, 0], sizes = [%4, 128], strides = [1, 1] : !flow.dispatch.tensor<readonly:1x128xf32> -> tensor<?x128xf32>
            %6 = affine.min #map6(%arg4, %workgroup_size_0)
            %7 = flow.dispatch.tensor.load %arg1, offsets = [0, %arg4], sizes = [128, %6], strides = [1, 1] : !flow.dispatch.tensor<readonly:128x10xf32> -> tensor<128x?xf32>
            %8 = affine.min #map1(%arg3, %workgroup_size_1)
            %9 = affine.min #map6(%arg4, %workgroup_size_0)
            %10 = affine.min #map3(%arg3, %workgroup_size_1)
            %11 = affine.min #map7(%arg4, %workgroup_size_0)
            %12 = linalg.init_tensor [%10, %11] : tensor<?x?xf32>
            %13 = linalg.fill(%12, %cst) : tensor<?x?xf32>, f32 -> tensor<?x?xf32> 
            %14 = linalg.matmul {__internal_linalg_transform__ = "workgroup"} ins(%5, %7 : tensor<?x128xf32>, tensor<128x?xf32>) outs(%13 : tensor<?x?xf32>) -> tensor<?x?xf32>
            flow.dispatch.tensor.store %14, %arg2, offsets = [%arg3, %arg4], sizes = [%8, %9], strides = [1, 1] : tensor<?x?xf32> -> !flow.dispatch.tensor<writeonly:1x10xf32>
          }
        }
        return
      }
    }
  }
  flow.executable @predict_dispatch_3 attributes {sym_visibility = "private"} {
    flow.dispatch.entry @predict_dispatch_3 attributes {workgroup_rank = 3 : index}
    module  {
      func @predict_dispatch_3(%arg0: !flow.dispatch.tensor<readonly:1x10xf32>, %arg1: !flow.dispatch.tensor<writeonly:10xf32>) {
        %cst = constant opaque<"_", "0xDEADBEEF"> : tensor<1x10xf32>
        %c1 = constant 1 : index
        %c10 = constant 10 : index
        %workgroup_size_0 = flow.dispatch.workgroup.size[0] : index
        %workgroup_size_1 = flow.dispatch.workgroup.size[1] : index
        %workgroup_id_0 = flow.dispatch.workgroup.id[0] : index
        %workgroup_count_0 = flow.dispatch.workgroup.count[0] : index
        %workgroup_id_1 = flow.dispatch.workgroup.id[1] : index
        %workgroup_count_1 = flow.dispatch.workgroup.count[1] : index
        %0 = affine.apply #map0()[%workgroup_id_1, %workgroup_size_1]
        %1 = affine.apply #map0()[%workgroup_count_1, %workgroup_size_1]
        scf.for %arg2 = %0 to %c1 step %1 {
          %2 = affine.apply #map0()[%workgroup_id_0, %workgroup_size_0]
          %3 = affine.apply #map0()[%workgroup_count_0, %workgroup_size_0]
          scf.for %arg3 = %2 to %c10 step %3 {
            %4 = affine.min #map1(%arg2, %workgroup_size_1)
            %5 = affine.min #map6(%arg3, %workgroup_size_0)
            %6 = flow.dispatch.tensor.load %arg0, offsets = [%arg2, %arg3], sizes = [%4, %5], strides = [1, 1] : !flow.dispatch.tensor<readonly:1x10xf32> -> tensor<?x?xf32>
            %7 = affine.min #map1(%arg2, %workgroup_size_1)
            %8 = affine.min #map6(%arg3, %workgroup_size_0)
            %9 = subtensor %cst[%arg2, %arg3] [%7, %8] [1, 1] : tensor<1x10xf32> to tensor<?x?xf32>
            %10 = affine.min #map6(%arg3, %workgroup_size_0)
            %11 = linalg.init_tensor [%10] : tensor<?xf32>
            %12 = linalg.generic {indexing_maps = [#map5, #map5, #map8], iterator_types = ["parallel", "parallel"]} ins(%6, %9 : tensor<?x?xf32>, tensor<?x?xf32>) outs(%11 : tensor<?xf32>) attrs =  {__internal_linalg_transform__ = "workgroup"} {
            ^bb0(%arg4: f32, %arg5: f32, %arg6: f32):  // no predecessors
              %13 = addf %arg4, %arg5 : f32
              linalg.yield %13 : f32
            } -> tensor<?xf32>
            flow.dispatch.tensor.store %12, %arg1, offsets = [%arg3], sizes = [%10], strides = [1] : tensor<?xf32> -> !flow.dispatch.tensor<writeonly:10xf32>
          }
        }
        return
      }
    }
  }
  flow.executable @predict_dispatch_4 attributes {sym_visibility = "private"} {
    flow.dispatch.entry @predict_dispatch_4 attributes {workgroup_rank = 3 : index}
    module  {
      func @predict_dispatch_4(%arg0: !flow.dispatch.tensor<readonly:10xf32>, %arg1: !flow.dispatch.tensor<writeonly:f32>) {
        %cst = constant 0x7FC00000 : f32
        %cst_0 = constant 0xFF800000 : f32
        %0 = flow.dispatch.tensor.load %arg0, offsets = [], sizes = [], strides = [] : !flow.dispatch.tensor<readonly:10xf32> -> tensor<10xf32>
        %1 = linalg.init_tensor [] : tensor<f32>
        %2 = linalg.fill(%1, %cst_0) : tensor<f32>, f32 -> tensor<f32> 
        %3 = linalg.generic {indexing_maps = [#map9, #map10], iterator_types = ["reduction"]} ins(%0 : tensor<10xf32>) outs(%2 : tensor<f32>) {
        ^bb0(%arg2: f32, %arg3: f32):  // no predecessors
          %4 = cmpf ogt, %arg2, %arg3 : f32
          %5 = select %4, %arg2, %arg3 : f32
          %6 = cmpf uno, %arg2, %arg3 : f32
          %7 = select %6, %cst, %5 : f32
          linalg.yield %7 : f32
        } -> tensor<f32>
        flow.dispatch.tensor.store %3, %arg1, offsets = [], sizes = [], strides = [] : tensor<f32> -> !flow.dispatch.tensor<writeonly:f32>
        return
      }
    }
  }
  flow.executable @predict_dispatch_5 attributes {sym_visibility = "private"} {
    flow.dispatch.entry @predict_dispatch_5 attributes {workgroup_rank = 3 : index}
    module  {
      func @predict_dispatch_5(%arg0: !flow.dispatch.tensor<readonly:1x10xf32>, %arg1: !flow.dispatch.tensor<readonly:f32>, %arg2: !flow.dispatch.tensor<writeonly:10xf32>) {
        %cst = constant opaque<"_", "0xDEADBEEF"> : tensor<1x10xf32>
        %c1 = constant 1 : index
        %c10 = constant 10 : index
        %0 = flow.dispatch.tensor.load %arg1, offsets = [], sizes = [], strides = [] : !flow.dispatch.tensor<readonly:f32> -> tensor<f32>
        %workgroup_size_0 = flow.dispatch.workgroup.size[0] : index
        %workgroup_size_1 = flow.dispatch.workgroup.size[1] : index
        %workgroup_id_0 = flow.dispatch.workgroup.id[0] : index
        %workgroup_count_0 = flow.dispatch.workgroup.count[0] : index
        %workgroup_id_1 = flow.dispatch.workgroup.id[1] : index
        %workgroup_count_1 = flow.dispatch.workgroup.count[1] : index
        %1 = affine.apply #map0()[%workgroup_id_1, %workgroup_size_1]
        %2 = affine.apply #map0()[%workgroup_count_1, %workgroup_size_1]
        scf.for %arg3 = %1 to %c1 step %2 {
          %3 = affine.apply #map0()[%workgroup_id_0, %workgroup_size_0]
          %4 = affine.apply #map0()[%workgroup_count_0, %workgroup_size_0]
          scf.for %arg4 = %3 to %c10 step %4 {
            %5 = affine.min #map1(%arg3, %workgroup_size_1)
            %6 = affine.min #map6(%arg4, %workgroup_size_0)
            %7 = flow.dispatch.tensor.load %arg0, offsets = [%arg3, %arg4], sizes = [%5, %6], strides = [1, 1] : !flow.dispatch.tensor<readonly:1x10xf32> -> tensor<?x?xf32>
            %8 = affine.min #map1(%arg3, %workgroup_size_1)
            %9 = affine.min #map6(%arg4, %workgroup_size_0)
            %10 = subtensor %cst[%arg3, %arg4] [%8, %9] [1, 1] : tensor<1x10xf32> to tensor<?x?xf32>
            %11 = affine.min #map6(%arg4, %workgroup_size_0)
            %12 = linalg.init_tensor [%11] : tensor<?xf32>
            %13 = linalg.generic {indexing_maps = [#map5, #map5, #map11, #map8], iterator_types = ["parallel", "parallel"]} ins(%7, %10, %0 : tensor<?x?xf32>, tensor<?x?xf32>, tensor<f32>) outs(%12 : tensor<?xf32>) attrs =  {__internal_linalg_transform__ = "workgroup"} {
            ^bb0(%arg5: f32, %arg6: f32, %arg7: f32, %arg8: f32):  // no predecessors
              %14 = addf %arg5, %arg6 : f32
              %15 = subf %14, %arg7 : f32
              %16 = math.exp %15 : f32
              linalg.yield %16 : f32
            } -> tensor<?xf32>
            flow.dispatch.tensor.store %13, %arg2, offsets = [%arg4], sizes = [%11], strides = [1] : tensor<?xf32> -> !flow.dispatch.tensor<writeonly:10xf32>
          }
        }
        return
      }
    }
  }
  flow.executable @predict_dispatch_6 attributes {sym_visibility = "private"} {
    flow.dispatch.entry @predict_dispatch_6 attributes {workgroup_rank = 3 : index}
    module  {
      func @predict_dispatch_6(%arg0: !flow.dispatch.tensor<readonly:10xf32>, %arg1: !flow.dispatch.tensor<writeonly:f32>) {
        %cst = constant 0.000000e+00 : f32
        %0 = flow.dispatch.tensor.load %arg0, offsets = [], sizes = [], strides = [] : !flow.dispatch.tensor<readonly:10xf32> -> tensor<10xf32>
        %1 = linalg.init_tensor [] : tensor<f32>
        %2 = linalg.fill(%1, %cst) : tensor<f32>, f32 -> tensor<f32> 
        %3 = linalg.generic {indexing_maps = [#map9, #map10], iterator_types = ["reduction"]} ins(%0 : tensor<10xf32>) outs(%2 : tensor<f32>) {
        ^bb0(%arg2: f32, %arg3: f32):  // no predecessors
          %4 = addf %arg2, %arg3 : f32
          linalg.yield %4 : f32
        } -> tensor<f32>
        flow.dispatch.tensor.store %3, %arg1, offsets = [], sizes = [], strides = [] : tensor<f32> -> !flow.dispatch.tensor<writeonly:f32>
        return
      }
    }
  }
  flow.executable @predict_dispatch_7 attributes {sym_visibility = "private"} {
    flow.dispatch.entry @predict_dispatch_7 attributes {workgroup_rank = 3 : index}
    module  {
      func @predict_dispatch_7(%arg0: !flow.dispatch.tensor<readonly:1x10xf32>, %arg1: !flow.dispatch.tensor<readonly:f32>, %arg2: !flow.dispatch.tensor<readonly:f32>, %arg3: !flow.dispatch.tensor<writeonly:1x10xf32>) {
        %cst = constant opaque<"_", "0xDEADBEEF"> : tensor<1x10xf32>
        %c1 = constant 1 : index
        %c10 = constant 10 : index
        %0 = flow.dispatch.tensor.load %arg1, offsets = [], sizes = [], strides = [] : !flow.dispatch.tensor<readonly:f32> -> tensor<f32>
        %1 = flow.dispatch.tensor.load %arg2, offsets = [], sizes = [], strides = [] : !flow.dispatch.tensor<readonly:f32> -> tensor<f32>
        %workgroup_size_0 = flow.dispatch.workgroup.size[0] : index
        %workgroup_size_1 = flow.dispatch.workgroup.size[1] : index
        %workgroup_id_0 = flow.dispatch.workgroup.id[0] : index
        %workgroup_count_0 = flow.dispatch.workgroup.count[0] : index
        %workgroup_id_1 = flow.dispatch.workgroup.id[1] : index
        %workgroup_count_1 = flow.dispatch.workgroup.count[1] : index
        %2 = affine.apply #map0()[%workgroup_id_1, %workgroup_size_1]
        %3 = affine.apply #map0()[%workgroup_count_1, %workgroup_size_1]
        scf.for %arg4 = %2 to %c1 step %3 {
          %4 = affine.apply #map0()[%workgroup_id_0, %workgroup_size_0]
          %5 = affine.apply #map0()[%workgroup_count_0, %workgroup_size_0]
          scf.for %arg5 = %4 to %c10 step %5 {
            %6 = affine.min #map1(%arg4, %workgroup_size_1)
            %7 = affine.min #map6(%arg5, %workgroup_size_0)
            %8 = flow.dispatch.tensor.load %arg0, offsets = [%arg4, %arg5], sizes = [%6, %7], strides = [1, 1] : !flow.dispatch.tensor<readonly:1x10xf32> -> tensor<?x?xf32>
            %9 = affine.min #map1(%arg4, %workgroup_size_1)
            %10 = affine.min #map6(%arg5, %workgroup_size_0)
            %11 = subtensor %cst[%arg4, %arg5] [%9, %10] [1, 1] : tensor<1x10xf32> to tensor<?x?xf32>
            %12 = affine.min #map1(%arg4, %workgroup_size_1)
            %13 = affine.min #map6(%arg5, %workgroup_size_0)
            %14 = linalg.init_tensor [%12, %13] : tensor<?x?xf32>
            %15 = linalg.generic {indexing_maps = [#map5, #map5, #map11, #map11, #map5], iterator_types = ["parallel", "parallel"]} ins(%8, %11, %0, %1 : tensor<?x?xf32>, tensor<?x?xf32>, tensor<f32>, tensor<f32>) outs(%14 : tensor<?x?xf32>) attrs =  {__internal_linalg_transform__ = "workgroup"} {
            ^bb0(%arg6: f32, %arg7: f32, %arg8: f32, %arg9: f32, %arg10: f32):  // no predecessors
              %16 = addf %arg6, %arg7 : f32
              %17 = subf %16, %arg8 : f32
              %18 = math.exp %17 : f32
              %19 = divf %18, %arg9 : f32
              linalg.yield %19 : f32
            } -> tensor<?x?xf32>
            flow.dispatch.tensor.store %15, %arg3, offsets = [%arg4, %arg5], sizes = [%12, %13], strides = [1, 1] : tensor<?x?xf32> -> !flow.dispatch.tensor<writeonly:1x10xf32>
          }
        }
        return
      }
    }
  }
  func @predict(%arg0: tensor<1x28x28x1xf32>) -> tensor<1x10xf32> attributes {iree.module.export, iree.reflection = {abi = "sip", abiv = 1 : i32, f = "I15!B11!d1d28d28d1R9!B6!d1d10", fv = "1", sip = "I8!S5!k0_0R3!_0"}} {
    %0 = flow.ex.stream.fragment(%arg0) : (tensor<1x28x28x1xf32>) -> tensor<1x10xf32> =
        (%arg1: tensor<1x28x28x1xf32>) -> tensor<1x10xf32> {
      %c128 = constant 128 : index
      %c1 = constant 1 : index
      %c10 = constant 10 : index
      %1 = flow.variable.load @_large_const_1 : tensor<784x128xf32>
      %2 = flow.variable.load @_large_const_0 : tensor<1x128xf32>
      %3 = flow.variable.load @_large_const_2 : tensor<128x10xf32>
      %4 = flow.tensor.reshape %arg1 : tensor<1x28x28x1xf32> -> tensor<1x784xf32>
      %5 = flow.dispatch @predict_dispatch_0::@predict_dispatch_0[%c128, %c1, %c1](%4, %1) : (tensor<1x784xf32>, tensor<784x128xf32>) -> tensor<1x128xf32>
      %6 = flow.dispatch @predict_dispatch_1::@predict_dispatch_1[%c128, %c1, %c1](%5, %2) : (tensor<1x128xf32>, tensor<1x128xf32>) -> tensor<1x128xf32>
      %7 = flow.dispatch @predict_dispatch_2::@predict_dispatch_2[%c10, %c1, %c1](%6, %3) : (tensor<1x128xf32>, tensor<128x10xf32>) -> tensor<1x10xf32>
      %8 = flow.dispatch @predict_dispatch_3::@predict_dispatch_3[%c10, %c1, %c1](%7) : (tensor<1x10xf32>) -> tensor<10xf32>
      %9 = flow.dispatch @predict_dispatch_4::@predict_dispatch_4[%c1, %c1, %c1](%8) : (tensor<10xf32>) -> tensor<f32>
      %10 = flow.dispatch @predict_dispatch_5::@predict_dispatch_5[%c10, %c1, %c1](%7, %9) : (tensor<1x10xf32>, tensor<f32>) -> tensor<10xf32>
      %11 = flow.dispatch @predict_dispatch_6::@predict_dispatch_6[%c1, %c1, %c1](%10) : (tensor<10xf32>) -> tensor<f32>
      %12 = flow.dispatch @predict_dispatch_7::@predict_dispatch_7[%c10, %c1, %c1](%7, %9, %11) : (tensor<1x10xf32>, tensor<f32>, tensor<f32>) -> tensor<1x10xf32>
      flow.return %12 : tensor<1x10xf32>
    }
    return %0 : tensor<1x10xf32>
  }
}


// *** IR Dump After Canonicalizer ***
#map0 = affine_map<()[s0, s1] -> (s0 * s1)>
#map1 = affine_map<(d0)[s0] -> (s0, -d0 + 1)>
#map2 = affine_map<(d0)[s0] -> (s0, -d0 + 128)>
#map3 = affine_map<(d0)[s0] -> (-d0 + 1, s0)>
#map4 = affine_map<(d0)[s0] -> (-d0 + 128, s0)>
#map5 = affine_map<(d0, d1) -> (d0, d1)>
#map6 = affine_map<(d0)[s0] -> (s0, -d0 + 10)>
#map7 = affine_map<(d0)[s0] -> (-d0 + 10, s0)>
#map8 = affine_map<(d0, d1) -> (d1)>
#map9 = affine_map<(d0) -> (d0)>
#map10 = affine_map<(d0) -> ()>
#map11 = affine_map<(d0, d1) -> ()>
module  {
  flow.variable @_large_const_0 opaque<"_", "0xDEADBEEF"> : tensor<1x128xf32> attributes {noinline, sym_visibility = "private"}
  flow.variable @_large_const_1 opaque<"_", "0xDEADBEEF"> : tensor<784x128xf32> attributes {noinline, sym_visibility = "private"}
  flow.variable @_large_const_2 opaque<"_", "0xDEADBEEF"> : tensor<128x10xf32> attributes {noinline, sym_visibility = "private"}
  flow.executable @predict_dispatch_0 attributes {sym_visibility = "private"} {
    flow.dispatch.entry @predict_dispatch_0 attributes {workgroup_rank = 3 : index}
    module  {
      func @predict_dispatch_0(%arg0: !flow.dispatch.tensor<readonly:1x784xf32>, %arg1: !flow.dispatch.tensor<readonly:784x128xf32>, %arg2: !flow.dispatch.tensor<writeonly:1x128xf32>) {
        %cst = constant 0.000000e+00 : f32
        %c1 = constant 1 : index
        %c128 = constant 128 : index
        %workgroup_size_0 = flow.dispatch.workgroup.size[0] : index
        %workgroup_size_1 = flow.dispatch.workgroup.size[1] : index
        %workgroup_id_0 = flow.dispatch.workgroup.id[0] : index
        %workgroup_count_0 = flow.dispatch.workgroup.count[0] : index
        %workgroup_id_1 = flow.dispatch.workgroup.id[1] : index
        %workgroup_count_1 = flow.dispatch.workgroup.count[1] : index
        %0 = affine.apply #map0()[%workgroup_id_1, %workgroup_size_1]
        %1 = affine.apply #map0()[%workgroup_count_1, %workgroup_size_1]
        scf.for %arg3 = %0 to %c1 step %1 {
          %2 = affine.apply #map0()[%workgroup_id_0, %workgroup_size_0]
          %3 = affine.apply #map0()[%workgroup_count_0, %workgroup_size_0]
          scf.for %arg4 = %2 to %c128 step %3 {
            %4 = affine.min #map1(%arg3)[%workgroup_size_1]
            %5 = flow.dispatch.tensor.load %arg0, offsets = [%arg3, 0], sizes = [%4, 784], strides = [1, 1] : !flow.dispatch.tensor<readonly:1x784xf32> -> tensor<?x784xf32>
            %6 = affine.min #map2(%arg4)[%workgroup_size_0]
            %7 = flow.dispatch.tensor.load %arg1, offsets = [0, %arg4], sizes = [784, %6], strides = [1, 1] : !flow.dispatch.tensor<readonly:784x128xf32> -> tensor<784x?xf32>
            %8 = affine.min #map1(%arg3)[%workgroup_size_1]
            %9 = affine.min #map2(%arg4)[%workgroup_size_0]
            %10 = affine.min #map3(%arg3)[%workgroup_size_1]
            %11 = affine.min #map4(%arg4)[%workgroup_size_0]
            %12 = linalg.init_tensor [%10, %11] : tensor<?x?xf32>
            %13 = linalg.fill(%12, %cst) : tensor<?x?xf32>, f32 -> tensor<?x?xf32> 
            %14 = linalg.matmul {__internal_linalg_transform__ = "workgroup"} ins(%5, %7 : tensor<?x784xf32>, tensor<784x?xf32>) outs(%13 : tensor<?x?xf32>) -> tensor<?x?xf32>
            flow.dispatch.tensor.store %14, %arg2, offsets = [%arg3, %arg4], sizes = [%8, %9], strides = [1, 1] : tensor<?x?xf32> -> !flow.dispatch.tensor<writeonly:1x128xf32>
          }
        }
        return
      }
    }
  }
  flow.executable @predict_dispatch_1 attributes {sym_visibility = "private"} {
    flow.dispatch.entry @predict_dispatch_1 attributes {workgroup_rank = 3 : index}
    module  {
      func @predict_dispatch_1(%arg0: !flow.dispatch.tensor<readonly:1x128xf32>, %arg1: !flow.dispatch.tensor<readonly:1x128xf32>, %arg2: !flow.dispatch.tensor<writeonly:1x128xf32>) {
        %cst = constant 0x7FC00000 : f32
        %cst_0 = constant 0.000000e+00 : f32
        %c1 = constant 1 : index
        %c128 = constant 128 : index
        %workgroup_size_0 = flow.dispatch.workgroup.size[0] : index
        %workgroup_size_1 = flow.dispatch.workgroup.size[1] : index
        %workgroup_id_0 = flow.dispatch.workgroup.id[0] : index
        %workgroup_count_0 = flow.dispatch.workgroup.count[0] : index
        %workgroup_id_1 = flow.dispatch.workgroup.id[1] : index
        %workgroup_count_1 = flow.dispatch.workgroup.count[1] : index
        %0 = affine.apply #map0()[%workgroup_id_1, %workgroup_size_1]
        %1 = affine.apply #map0()[%workgroup_count_1, %workgroup_size_1]
        scf.for %arg3 = %0 to %c1 step %1 {
          %2 = affine.apply #map0()[%workgroup_id_0, %workgroup_size_0]
          %3 = affine.apply #map0()[%workgroup_count_0, %workgroup_size_0]
          scf.for %arg4 = %2 to %c128 step %3 {
            %4 = affine.min #map1(%arg3)[%workgroup_size_1]
            %5 = affine.min #map2(%arg4)[%workgroup_size_0]
            %6 = flow.dispatch.tensor.load %arg0, offsets = [%arg3, %arg4], sizes = [%4, %5], strides = [1, 1] : !flow.dispatch.tensor<readonly:1x128xf32> -> tensor<?x?xf32>
            %7 = affine.min #map1(%arg3)[%workgroup_size_1]
            %8 = affine.min #map2(%arg4)[%workgroup_size_0]
            %9 = flow.dispatch.tensor.load %arg1, offsets = [%arg3, %arg4], sizes = [%7, %8], strides = [1, 1] : !flow.dispatch.tensor<readonly:1x128xf32> -> tensor<?x?xf32>
            %10 = affine.min #map1(%arg3)[%workgroup_size_1]
            %11 = affine.min #map2(%arg4)[%workgroup_size_0]
            %12 = linalg.init_tensor [%10, %11] : tensor<?x?xf32>
            %13 = linalg.generic {indexing_maps = [#map5, #map5, #map5], iterator_types = ["parallel", "parallel"]} ins(%6, %9 : tensor<?x?xf32>, tensor<?x?xf32>) outs(%12 : tensor<?x?xf32>) attrs =  {__internal_linalg_transform__ = "workgroup"} {
            ^bb0(%arg5: f32, %arg6: f32, %arg7: f32):  // no predecessors
              %14 = addf %arg5, %arg6 : f32
              %15 = cmpf ogt, %14, %cst_0 : f32
              %16 = select %15, %14, %cst_0 : f32
              %17 = cmpf uno, %14, %cst_0 : f32
              %18 = select %17, %cst, %16 : f32
              linalg.yield %18 : f32
            } -> tensor<?x?xf32>
            flow.dispatch.tensor.store %13, %arg2, offsets = [%arg3, %arg4], sizes = [%10, %11], strides = [1, 1] : tensor<?x?xf32> -> !flow.dispatch.tensor<writeonly:1x128xf32>
          }
        }
        return
      }
    }
  }
  flow.executable @predict_dispatch_2 attributes {sym_visibility = "private"} {
    flow.dispatch.entry @predict_dispatch_2 attributes {workgroup_rank = 3 : index}
    module  {
      func @predict_dispatch_2(%arg0: !flow.dispatch.tensor<readonly:1x128xf32>, %arg1: !flow.dispatch.tensor<readonly:128x10xf32>, %arg2: !flow.dispatch.tensor<writeonly:1x10xf32>) {
        %cst = constant 0.000000e+00 : f32
        %c1 = constant 1 : index
        %c10 = constant 10 : index
        %workgroup_size_0 = flow.dispatch.workgroup.size[0] : index
        %workgroup_size_1 = flow.dispatch.workgroup.size[1] : index
        %workgroup_id_0 = flow.dispatch.workgroup.id[0] : index
        %workgroup_count_0 = flow.dispatch.workgroup.count[0] : index
        %workgroup_id_1 = flow.dispatch.workgroup.id[1] : index
        %workgroup_count_1 = flow.dispatch.workgroup.count[1] : index
        %0 = affine.apply #map0()[%workgroup_id_1, %workgroup_size_1]
        %1 = affine.apply #map0()[%workgroup_count_1, %workgroup_size_1]
        scf.for %arg3 = %0 to %c1 step %1 {
          %2 = affine.apply #map0()[%workgroup_id_0, %workgroup_size_0]
          %3 = affine.apply #map0()[%workgroup_count_0, %workgroup_size_0]
          scf.for %arg4 = %2 to %c10 step %3 {
            %4 = affine.min #map1(%arg3)[%workgroup_size_1]
            %5 = flow.dispatch.tensor.load %arg0, offsets = [%arg3, 0], sizes = [%4, 128], strides = [1, 1] : !flow.dispatch.tensor<readonly:1x128xf32> -> tensor<?x128xf32>
            %6 = affine.min #map6(%arg4)[%workgroup_size_0]
            %7 = flow.dispatch.tensor.load %arg1, offsets = [0, %arg4], sizes = [128, %6], strides = [1, 1] : !flow.dispatch.tensor<readonly:128x10xf32> -> tensor<128x?xf32>
            %8 = affine.min #map1(%arg3)[%workgroup_size_1]
            %9 = affine.min #map6(%arg4)[%workgroup_size_0]
            %10 = affine.min #map3(%arg3)[%workgroup_size_1]
            %11 = affine.min #map7(%arg4)[%workgroup_size_0]
            %12 = linalg.init_tensor [%10, %11] : tensor<?x?xf32>
            %13 = linalg.fill(%12, %cst) : tensor<?x?xf32>, f32 -> tensor<?x?xf32> 
            %14 = linalg.matmul {__internal_linalg_transform__ = "workgroup"} ins(%5, %7 : tensor<?x128xf32>, tensor<128x?xf32>) outs(%13 : tensor<?x?xf32>) -> tensor<?x?xf32>
            flow.dispatch.tensor.store %14, %arg2, offsets = [%arg3, %arg4], sizes = [%8, %9], strides = [1, 1] : tensor<?x?xf32> -> !flow.dispatch.tensor<writeonly:1x10xf32>
          }
        }
        return
      }
    }
  }
  flow.executable @predict_dispatch_3 attributes {sym_visibility = "private"} {
    flow.dispatch.entry @predict_dispatch_3 attributes {workgroup_rank = 3 : index}
    module  {
      func @predict_dispatch_3(%arg0: !flow.dispatch.tensor<readonly:1x10xf32>, %arg1: !flow.dispatch.tensor<writeonly:10xf32>) {
        %cst = constant opaque<"_", "0xDEADBEEF"> : tensor<1x10xf32>
        %c1 = constant 1 : index
        %c10 = constant 10 : index
        %workgroup_size_0 = flow.dispatch.workgroup.size[0] : index
        %workgroup_size_1 = flow.dispatch.workgroup.size[1] : index
        %workgroup_id_0 = flow.dispatch.workgroup.id[0] : index
        %workgroup_count_0 = flow.dispatch.workgroup.count[0] : index
        %workgroup_id_1 = flow.dispatch.workgroup.id[1] : index
        %workgroup_count_1 = flow.dispatch.workgroup.count[1] : index
        %0 = affine.apply #map0()[%workgroup_id_1, %workgroup_size_1]
        %1 = affine.apply #map0()[%workgroup_count_1, %workgroup_size_1]
        scf.for %arg2 = %0 to %c1 step %1 {
          %2 = affine.apply #map0()[%workgroup_id_0, %workgroup_size_0]
          %3 = affine.apply #map0()[%workgroup_count_0, %workgroup_size_0]
          scf.for %arg3 = %2 to %c10 step %3 {
            %4 = affine.min #map1(%arg2)[%workgroup_size_1]
            %5 = affine.min #map6(%arg3)[%workgroup_size_0]
            %6 = flow.dispatch.tensor.load %arg0, offsets = [%arg2, %arg3], sizes = [%4, %5], strides = [1, 1] : !flow.dispatch.tensor<readonly:1x10xf32> -> tensor<?x?xf32>
            %7 = affine.min #map1(%arg2)[%workgroup_size_1]
            %8 = affine.min #map6(%arg3)[%workgroup_size_0]
            %9 = subtensor %cst[%arg2, %arg3] [%7, %8] [1, 1] : tensor<1x10xf32> to tensor<?x?xf32>
            %10 = affine.min #map6(%arg3)[%workgroup_size_0]
            %11 = linalg.init_tensor [%10] : tensor<?xf32>
            %12 = linalg.generic {indexing_maps = [#map5, #map5, #map8], iterator_types = ["parallel", "parallel"]} ins(%6, %9 : tensor<?x?xf32>, tensor<?x?xf32>) outs(%11 : tensor<?xf32>) attrs =  {__internal_linalg_transform__ = "workgroup"} {
            ^bb0(%arg4: f32, %arg5: f32, %arg6: f32):  // no predecessors
              %13 = addf %arg4, %arg5 : f32
              linalg.yield %13 : f32
            } -> tensor<?xf32>
            flow.dispatch.tensor.store %12, %arg1, offsets = [%arg3], sizes = [%10], strides = [1] : tensor<?xf32> -> !flow.dispatch.tensor<writeonly:10xf32>
          }
        }
        return
      }
    }
  }
  flow.executable @predict_dispatch_4 attributes {sym_visibility = "private"} {
    flow.dispatch.entry @predict_dispatch_4 attributes {workgroup_rank = 3 : index}
    module  {
      func @predict_dispatch_4(%arg0: !flow.dispatch.tensor<readonly:10xf32>, %arg1: !flow.dispatch.tensor<writeonly:f32>) {
        %cst = constant 0x7FC00000 : f32
        %cst_0 = constant 0xFF800000 : f32
        %0 = flow.dispatch.tensor.load %arg0, offsets = [], sizes = [], strides = [] : !flow.dispatch.tensor<readonly:10xf32> -> tensor<10xf32>
        %1 = linalg.init_tensor [] : tensor<f32>
        %2 = linalg.fill(%1, %cst_0) : tensor<f32>, f32 -> tensor<f32> 
        %3 = linalg.generic {indexing_maps = [#map9, #map10], iterator_types = ["reduction"]} ins(%0 : tensor<10xf32>) outs(%2 : tensor<f32>) {
        ^bb0(%arg2: f32, %arg3: f32):  // no predecessors
          %4 = cmpf ogt, %arg2, %arg3 : f32
          %5 = select %4, %arg2, %arg3 : f32
          %6 = cmpf uno, %arg2, %arg3 : f32
          %7 = select %6, %cst, %5 : f32
          linalg.yield %7 : f32
        } -> tensor<f32>
        flow.dispatch.tensor.store %3, %arg1, offsets = [], sizes = [], strides = [] : tensor<f32> -> !flow.dispatch.tensor<writeonly:f32>
        return
      }
    }
  }
  flow.executable @predict_dispatch_5 attributes {sym_visibility = "private"} {
    flow.dispatch.entry @predict_dispatch_5 attributes {workgroup_rank = 3 : index}
    module  {
      func @predict_dispatch_5(%arg0: !flow.dispatch.tensor<readonly:1x10xf32>, %arg1: !flow.dispatch.tensor<readonly:f32>, %arg2: !flow.dispatch.tensor<writeonly:10xf32>) {
        %cst = constant opaque<"_", "0xDEADBEEF"> : tensor<1x10xf32>
        %c1 = constant 1 : index
        %c10 = constant 10 : index
        %0 = flow.dispatch.tensor.load %arg1, offsets = [], sizes = [], strides = [] : !flow.dispatch.tensor<readonly:f32> -> tensor<f32>
        %workgroup_size_0 = flow.dispatch.workgroup.size[0] : index
        %workgroup_size_1 = flow.dispatch.workgroup.size[1] : index
        %workgroup_id_0 = flow.dispatch.workgroup.id[0] : index
        %workgroup_count_0 = flow.dispatch.workgroup.count[0] : index
        %workgroup_id_1 = flow.dispatch.workgroup.id[1] : index
        %workgroup_count_1 = flow.dispatch.workgroup.count[1] : index
        %1 = affine.apply #map0()[%workgroup_id_1, %workgroup_size_1]
        %2 = affine.apply #map0()[%workgroup_count_1, %workgroup_size_1]
        scf.for %arg3 = %1 to %c1 step %2 {
          %3 = affine.apply #map0()[%workgroup_id_0, %workgroup_size_0]
          %4 = affine.apply #map0()[%workgroup_count_0, %workgroup_size_0]
          scf.for %arg4 = %3 to %c10 step %4 {
            %5 = affine.min #map1(%arg3)[%workgroup_size_1]
            %6 = affine.min #map6(%arg4)[%workgroup_size_0]
            %7 = flow.dispatch.tensor.load %arg0, offsets = [%arg3, %arg4], sizes = [%5, %6], strides = [1, 1] : !flow.dispatch.tensor<readonly:1x10xf32> -> tensor<?x?xf32>
            %8 = affine.min #map1(%arg3)[%workgroup_size_1]
            %9 = affine.min #map6(%arg4)[%workgroup_size_0]
            %10 = subtensor %cst[%arg3, %arg4] [%8, %9] [1, 1] : tensor<1x10xf32> to tensor<?x?xf32>
            %11 = affine.min #map6(%arg4)[%workgroup_size_0]
            %12 = linalg.init_tensor [%11] : tensor<?xf32>
            %13 = linalg.generic {indexing_maps = [#map5, #map5, #map11, #map8], iterator_types = ["parallel", "parallel"]} ins(%7, %10, %0 : tensor<?x?xf32>, tensor<?x?xf32>, tensor<f32>) outs(%12 : tensor<?xf32>) attrs =  {__internal_linalg_transform__ = "workgroup"} {
            ^bb0(%arg5: f32, %arg6: f32, %arg7: f32, %arg8: f32):  // no predecessors
              %14 = addf %arg5, %arg6 : f32
              %15 = subf %14, %arg7 : f32
              %16 = math.exp %15 : f32
              linalg.yield %16 : f32
            } -> tensor<?xf32>
            flow.dispatch.tensor.store %13, %arg2, offsets = [%arg4], sizes = [%11], strides = [1] : tensor<?xf32> -> !flow.dispatch.tensor<writeonly:10xf32>
          }
        }
        return
      }
    }
  }
  flow.executable @predict_dispatch_6 attributes {sym_visibility = "private"} {
    flow.dispatch.entry @predict_dispatch_6 attributes {workgroup_rank = 3 : index}
    module  {
      func @predict_dispatch_6(%arg0: !flow.dispatch.tensor<readonly:10xf32>, %arg1: !flow.dispatch.tensor<writeonly:f32>) {
        %cst = constant 0.000000e+00 : f32
        %0 = flow.dispatch.tensor.load %arg0, offsets = [], sizes = [], strides = [] : !flow.dispatch.tensor<readonly:10xf32> -> tensor<10xf32>
        %1 = linalg.init_tensor [] : tensor<f32>
        %2 = linalg.fill(%1, %cst) : tensor<f32>, f32 -> tensor<f32> 
        %3 = linalg.generic {indexing_maps = [#map9, #map10], iterator_types = ["reduction"]} ins(%0 : tensor<10xf32>) outs(%2 : tensor<f32>) {
        ^bb0(%arg2: f32, %arg3: f32):  // no predecessors
          %4 = addf %arg2, %arg3 : f32
          linalg.yield %4 : f32
        } -> tensor<f32>
        flow.dispatch.tensor.store %3, %arg1, offsets = [], sizes = [], strides = [] : tensor<f32> -> !flow.dispatch.tensor<writeonly:f32>
        return
      }
    }
  }
  flow.executable @predict_dispatch_7 attributes {sym_visibility = "private"} {
    flow.dispatch.entry @predict_dispatch_7 attributes {workgroup_rank = 3 : index}
    module  {
      func @predict_dispatch_7(%arg0: !flow.dispatch.tensor<readonly:1x10xf32>, %arg1: !flow.dispatch.tensor<readonly:f32>, %arg2: !flow.dispatch.tensor<readonly:f32>, %arg3: !flow.dispatch.tensor<writeonly:1x10xf32>) {
        %cst = constant opaque<"_", "0xDEADBEEF"> : tensor<1x10xf32>
        %c1 = constant 1 : index
        %c10 = constant 10 : index
        %0 = flow.dispatch.tensor.load %arg1, offsets = [], sizes = [], strides = [] : !flow.dispatch.tensor<readonly:f32> -> tensor<f32>
        %1 = flow.dispatch.tensor.load %arg2, offsets = [], sizes = [], strides = [] : !flow.dispatch.tensor<readonly:f32> -> tensor<f32>
        %workgroup_size_0 = flow.dispatch.workgroup.size[0] : index
        %workgroup_size_1 = flow.dispatch.workgroup.size[1] : index
        %workgroup_id_0 = flow.dispatch.workgroup.id[0] : index
        %workgroup_count_0 = flow.dispatch.workgroup.count[0] : index
        %workgroup_id_1 = flow.dispatch.workgroup.id[1] : index
        %workgroup_count_1 = flow.dispatch.workgroup.count[1] : index
        %2 = affine.apply #map0()[%workgroup_id_1, %workgroup_size_1]
        %3 = affine.apply #map0()[%workgroup_count_1, %workgroup_size_1]
        scf.for %arg4 = %2 to %c1 step %3 {
          %4 = affine.apply #map0()[%workgroup_id_0, %workgroup_size_0]
          %5 = affine.apply #map0()[%workgroup_count_0, %workgroup_size_0]
          scf.for %arg5 = %4 to %c10 step %5 {
            %6 = affine.min #map1(%arg4)[%workgroup_size_1]
            %7 = affine.min #map6(%arg5)[%workgroup_size_0]
            %8 = flow.dispatch.tensor.load %arg0, offsets = [%arg4, %arg5], sizes = [%6, %7], strides = [1, 1] : !flow.dispatch.tensor<readonly:1x10xf32> -> tensor<?x?xf32>
            %9 = affine.min #map1(%arg4)[%workgroup_size_1]
            %10 = affine.min #map6(%arg5)[%workgroup_size_0]
            %11 = subtensor %cst[%arg4, %arg5] [%9, %10] [1, 1] : tensor<1x10xf32> to tensor<?x?xf32>
            %12 = affine.min #map1(%arg4)[%workgroup_size_1]
            %13 = affine.min #map6(%arg5)[%workgroup_size_0]
            %14 = linalg.init_tensor [%12, %13] : tensor<?x?xf32>
            %15 = linalg.generic {indexing_maps = [#map5, #map5, #map11, #map11, #map5], iterator_types = ["parallel", "parallel"]} ins(%8, %11, %0, %1 : tensor<?x?xf32>, tensor<?x?xf32>, tensor<f32>, tensor<f32>) outs(%14 : tensor<?x?xf32>) attrs =  {__internal_linalg_transform__ = "workgroup"} {
            ^bb0(%arg6: f32, %arg7: f32, %arg8: f32, %arg9: f32, %arg10: f32):  // no predecessors
              %16 = addf %arg6, %arg7 : f32
              %17 = subf %16, %arg8 : f32
              %18 = math.exp %17 : f32
              %19 = divf %18, %arg9 : f32
              linalg.yield %19 : f32
            } -> tensor<?x?xf32>
            flow.dispatch.tensor.store %15, %arg3, offsets = [%arg4, %arg5], sizes = [%12, %13], strides = [1, 1] : tensor<?x?xf32> -> !flow.dispatch.tensor<writeonly:1x10xf32>
          }
        }
        return
      }
    }
  }
  func @predict(%arg0: tensor<1x28x28x1xf32>) -> tensor<1x10xf32> attributes {iree.module.export, iree.reflection = {abi = "sip", abiv = 1 : i32, f = "I15!B11!d1d28d28d1R9!B6!d1d10", fv = "1", sip = "I8!S5!k0_0R3!_0"}} {
    %0 = flow.ex.stream.fragment(%arg0) : (tensor<1x28x28x1xf32>) -> tensor<1x10xf32> =
        (%arg1: tensor<1x28x28x1xf32>) -> tensor<1x10xf32> {
      %c128 = constant 128 : index
      %c1 = constant 1 : index
      %c10 = constant 10 : index
      %1 = flow.variable.load @_large_const_1 : tensor<784x128xf32>
      %2 = flow.variable.load @_large_const_0 : tensor<1x128xf32>
      %3 = flow.variable.load @_large_const_2 : tensor<128x10xf32>
      %4 = flow.tensor.reshape %arg1 : tensor<1x28x28x1xf32> -> tensor<1x784xf32>
      %5 = flow.dispatch @predict_dispatch_0::@predict_dispatch_0[%c128, %c1, %c1](%4, %1) : (tensor<1x784xf32>, tensor<784x128xf32>) -> tensor<1x128xf32>
      %6 = flow.dispatch @predict_dispatch_1::@predict_dispatch_1[%c128, %c1, %c1](%5, %2) : (tensor<1x128xf32>, tensor<1x128xf32>) -> tensor<1x128xf32>
      %7 = flow.dispatch @predict_dispatch_2::@predict_dispatch_2[%c10, %c1, %c1](%6, %3) : (tensor<1x128xf32>, tensor<128x10xf32>) -> tensor<1x10xf32>
      %8 = flow.dispatch @predict_dispatch_3::@predict_dispatch_3[%c10, %c1, %c1](%7) : (tensor<1x10xf32>) -> tensor<10xf32>
      %9 = flow.dispatch @predict_dispatch_4::@predict_dispatch_4[%c1, %c1, %c1](%8) : (tensor<10xf32>) -> tensor<f32>
      %10 = flow.dispatch @predict_dispatch_5::@predict_dispatch_5[%c10, %c1, %c1](%7, %9) : (tensor<1x10xf32>, tensor<f32>) -> tensor<10xf32>
      %11 = flow.dispatch @predict_dispatch_6::@predict_dispatch_6[%c1, %c1, %c1](%10) : (tensor<10xf32>) -> tensor<f32>
      %12 = flow.dispatch @predict_dispatch_7::@predict_dispatch_7[%c10, %c1, %c1](%7, %9, %11) : (tensor<1x10xf32>, tensor<f32>, tensor<f32>) -> tensor<1x10xf32>
      flow.return %12 : tensor<1x10xf32>
    }
    return %0 : tensor<1x10xf32>
  }
}


// *** IR Dump After mlir::iree_compiler::IREE::HAL::IdentifyConstantPoolsPass ***
#map0 = affine_map<()[s0, s1] -> (s0 * s1)>
#map1 = affine_map<(d0)[s0] -> (s0, -d0 + 1)>
#map2 = affine_map<(d0)[s0] -> (s0, -d0 + 128)>
#map3 = affine_map<(d0)[s0] -> (-d0 + 1, s0)>
#map4 = affine_map<(d0)[s0] -> (-d0 + 128, s0)>
#map5 = affine_map<(d0, d1) -> (d0, d1)>
#map6 = affine_map<(d0)[s0] -> (s0, -d0 + 10)>
#map7 = affine_map<(d0)[s0] -> (-d0 + 10, s0)>
#map8 = affine_map<(d0, d1) -> (d1)>
#map9 = affine_map<(d0) -> (d0)>
#map10 = affine_map<(d0) -> ()>
#map11 = affine_map<(d0, d1) -> ()>
module  {
  hal.constant_pool @_const_pool attributes {buffer_constraints = #hal.buffer_constraints<max_allocation_size = 1073741824, min_buffer_offset_alignment = 16, max_buffer_range = 1073741824, min_buffer_range_alignment = 16>, sym_visibility = "private"} {
    hal.constant_pool.value @_large_const_0 = opaque<"_", "0xDEADBEEF"> : tensor<1x128xf32> attributes {sym_visibility = "nested"}
    hal.constant_pool.value @_large_const_1 = opaque<"_", "0xDEADBEEF"> : tensor<784x128xf32> attributes {sym_visibility = "nested"}
    hal.constant_pool.value @_large_const_2 = opaque<"_", "0xDEADBEEF"> : tensor<128x10xf32> attributes {sym_visibility = "nested"}
  }
  flow.executable @predict_dispatch_0 attributes {sym_visibility = "private"} {
    flow.dispatch.entry @predict_dispatch_0 attributes {workgroup_rank = 3 : index}
    module  {
      func @predict_dispatch_0(%arg0: !flow.dispatch.tensor<readonly:1x784xf32>, %arg1: !flow.dispatch.tensor<readonly:784x128xf32>, %arg2: !flow.dispatch.tensor<writeonly:1x128xf32>) {
        %cst = constant 0.000000e+00 : f32
        %c1 = constant 1 : index
        %c128 = constant 128 : index
        %workgroup_size_0 = flow.dispatch.workgroup.size[0] : index
        %workgroup_size_1 = flow.dispatch.workgroup.size[1] : index
        %workgroup_id_0 = flow.dispatch.workgroup.id[0] : index
        %workgroup_count_0 = flow.dispatch.workgroup.count[0] : index
        %workgroup_id_1 = flow.dispatch.workgroup.id[1] : index
        %workgroup_count_1 = flow.dispatch.workgroup.count[1] : index
        %0 = affine.apply #map0()[%workgroup_id_1, %workgroup_size_1]
        %1 = affine.apply #map0()[%workgroup_count_1, %workgroup_size_1]
        scf.for %arg3 = %0 to %c1 step %1 {
          %2 = affine.apply #map0()[%workgroup_id_0, %workgroup_size_0]
          %3 = affine.apply #map0()[%workgroup_count_0, %workgroup_size_0]
          scf.for %arg4 = %2 to %c128 step %3 {
            %4 = affine.min #map1(%arg3)[%workgroup_size_1]
            %5 = flow.dispatch.tensor.load %arg0, offsets = [%arg3, 0], sizes = [%4, 784], strides = [1, 1] : !flow.dispatch.tensor<readonly:1x784xf32> -> tensor<?x784xf32>
            %6 = affine.min #map2(%arg4)[%workgroup_size_0]
            %7 = flow.dispatch.tensor.load %arg1, offsets = [0, %arg4], sizes = [784, %6], strides = [1, 1] : !flow.dispatch.tensor<readonly:784x128xf32> -> tensor<784x?xf32>
            %8 = affine.min #map1(%arg3)[%workgroup_size_1]
            %9 = affine.min #map2(%arg4)[%workgroup_size_0]
            %10 = affine.min #map3(%arg3)[%workgroup_size_1]
            %11 = affine.min #map4(%arg4)[%workgroup_size_0]
            %12 = linalg.init_tensor [%10, %11] : tensor<?x?xf32>
            %13 = linalg.fill(%12, %cst) : tensor<?x?xf32>, f32 -> tensor<?x?xf32> 
            %14 = linalg.matmul {__internal_linalg_transform__ = "workgroup"} ins(%5, %7 : tensor<?x784xf32>, tensor<784x?xf32>) outs(%13 : tensor<?x?xf32>) -> tensor<?x?xf32>
            flow.dispatch.tensor.store %14, %arg2, offsets = [%arg3, %arg4], sizes = [%8, %9], strides = [1, 1] : tensor<?x?xf32> -> !flow.dispatch.tensor<writeonly:1x128xf32>
          }
        }
        return
      }
    }
  }
  flow.executable @predict_dispatch_1 attributes {sym_visibility = "private"} {
    flow.dispatch.entry @predict_dispatch_1 attributes {workgroup_rank = 3 : index}
    module  {
      func @predict_dispatch_1(%arg0: !flow.dispatch.tensor<readonly:1x128xf32>, %arg1: !flow.dispatch.tensor<readonly:1x128xf32>, %arg2: !flow.dispatch.tensor<writeonly:1x128xf32>) {
        %cst = constant 0x7FC00000 : f32
        %cst_0 = constant 0.000000e+00 : f32
        %c1 = constant 1 : index
        %c128 = constant 128 : index
        %workgroup_size_0 = flow.dispatch.workgroup.size[0] : index
        %workgroup_size_1 = flow.dispatch.workgroup.size[1] : index
        %workgroup_id_0 = flow.dispatch.workgroup.id[0] : index
        %workgroup_count_0 = flow.dispatch.workgroup.count[0] : index
        %workgroup_id_1 = flow.dispatch.workgroup.id[1] : index
        %workgroup_count_1 = flow.dispatch.workgroup.count[1] : index
        %0 = affine.apply #map0()[%workgroup_id_1, %workgroup_size_1]
        %1 = affine.apply #map0()[%workgroup_count_1, %workgroup_size_1]
        scf.for %arg3 = %0 to %c1 step %1 {
          %2 = affine.apply #map0()[%workgroup_id_0, %workgroup_size_0]
          %3 = affine.apply #map0()[%workgroup_count_0, %workgroup_size_0]
          scf.for %arg4 = %2 to %c128 step %3 {
            %4 = affine.min #map1(%arg3)[%workgroup_size_1]
            %5 = affine.min #map2(%arg4)[%workgroup_size_0]
            %6 = flow.dispatch.tensor.load %arg0, offsets = [%arg3, %arg4], sizes = [%4, %5], strides = [1, 1] : !flow.dispatch.tensor<readonly:1x128xf32> -> tensor<?x?xf32>
            %7 = affine.min #map1(%arg3)[%workgroup_size_1]
            %8 = affine.min #map2(%arg4)[%workgroup_size_0]
            %9 = flow.dispatch.tensor.load %arg1, offsets = [%arg3, %arg4], sizes = [%7, %8], strides = [1, 1] : !flow.dispatch.tensor<readonly:1x128xf32> -> tensor<?x?xf32>
            %10 = affine.min #map1(%arg3)[%workgroup_size_1]
            %11 = affine.min #map2(%arg4)[%workgroup_size_0]
            %12 = linalg.init_tensor [%10, %11] : tensor<?x?xf32>
            %13 = linalg.generic {indexing_maps = [#map5, #map5, #map5], iterator_types = ["parallel", "parallel"]} ins(%6, %9 : tensor<?x?xf32>, tensor<?x?xf32>) outs(%12 : tensor<?x?xf32>) attrs =  {__internal_linalg_transform__ = "workgroup"} {
            ^bb0(%arg5: f32, %arg6: f32, %arg7: f32):  // no predecessors
              %14 = addf %arg5, %arg6 : f32
              %15 = cmpf ogt, %14, %cst_0 : f32
              %16 = select %15, %14, %cst_0 : f32
              %17 = cmpf uno, %14, %cst_0 : f32
              %18 = select %17, %cst, %16 : f32
              linalg.yield %18 : f32
            } -> tensor<?x?xf32>
            flow.dispatch.tensor.store %13, %arg2, offsets = [%arg3, %arg4], sizes = [%10, %11], strides = [1, 1] : tensor<?x?xf32> -> !flow.dispatch.tensor<writeonly:1x128xf32>
          }
        }
        return
      }
    }
  }
  flow.executable @predict_dispatch_2 attributes {sym_visibility = "private"} {
    flow.dispatch.entry @predict_dispatch_2 attributes {workgroup_rank = 3 : index}
    module  {
      func @predict_dispatch_2(%arg0: !flow.dispatch.tensor<readonly:1x128xf32>, %arg1: !flow.dispatch.tensor<readonly:128x10xf32>, %arg2: !flow.dispatch.tensor<writeonly:1x10xf32>) {
        %cst = constant 0.000000e+00 : f32
        %c1 = constant 1 : index
        %c10 = constant 10 : index
        %workgroup_size_0 = flow.dispatch.workgroup.size[0] : index
        %workgroup_size_1 = flow.dispatch.workgroup.size[1] : index
        %workgroup_id_0 = flow.dispatch.workgroup.id[0] : index
        %workgroup_count_0 = flow.dispatch.workgroup.count[0] : index
        %workgroup_id_1 = flow.dispatch.workgroup.id[1] : index
        %workgroup_count_1 = flow.dispatch.workgroup.count[1] : index
        %0 = affine.apply #map0()[%workgroup_id_1, %workgroup_size_1]
        %1 = affine.apply #map0()[%workgroup_count_1, %workgroup_size_1]
        scf.for %arg3 = %0 to %c1 step %1 {
          %2 = affine.apply #map0()[%workgroup_id_0, %workgroup_size_0]
          %3 = affine.apply #map0()[%workgroup_count_0, %workgroup_size_0]
          scf.for %arg4 = %2 to %c10 step %3 {
            %4 = affine.min #map1(%arg3)[%workgroup_size_1]
            %5 = flow.dispatch.tensor.load %arg0, offsets = [%arg3, 0], sizes = [%4, 128], strides = [1, 1] : !flow.dispatch.tensor<readonly:1x128xf32> -> tensor<?x128xf32>
            %6 = affine.min #map6(%arg4)[%workgroup_size_0]
            %7 = flow.dispatch.tensor.load %arg1, offsets = [0, %arg4], sizes = [128, %6], strides = [1, 1] : !flow.dispatch.tensor<readonly:128x10xf32> -> tensor<128x?xf32>
            %8 = affine.min #map1(%arg3)[%workgroup_size_1]
            %9 = affine.min #map6(%arg4)[%workgroup_size_0]
            %10 = affine.min #map3(%arg3)[%workgroup_size_1]
            %11 = affine.min #map7(%arg4)[%workgroup_size_0]
            %12 = linalg.init_tensor [%10, %11] : tensor<?x?xf32>
            %13 = linalg.fill(%12, %cst) : tensor<?x?xf32>, f32 -> tensor<?x?xf32> 
            %14 = linalg.matmul {__internal_linalg_transform__ = "workgroup"} ins(%5, %7 : tensor<?x128xf32>, tensor<128x?xf32>) outs(%13 : tensor<?x?xf32>) -> tensor<?x?xf32>
            flow.dispatch.tensor.store %14, %arg2, offsets = [%arg3, %arg4], sizes = [%8, %9], strides = [1, 1] : tensor<?x?xf32> -> !flow.dispatch.tensor<writeonly:1x10xf32>
          }
        }
        return
      }
    }
  }
  flow.executable @predict_dispatch_3 attributes {sym_visibility = "private"} {
    flow.dispatch.entry @predict_dispatch_3 attributes {workgroup_rank = 3 : index}
    module  {
      func @predict_dispatch_3(%arg0: !flow.dispatch.tensor<readonly:1x10xf32>, %arg1: !flow.dispatch.tensor<writeonly:10xf32>) {
        %cst = constant opaque<"_", "0xDEADBEEF"> : tensor<1x10xf32>
        %c1 = constant 1 : index
        %c10 = constant 10 : index
        %workgroup_size_0 = flow.dispatch.workgroup.size[0] : index
        %workgroup_size_1 = flow.dispatch.workgroup.size[1] : index
        %workgroup_id_0 = flow.dispatch.workgroup.id[0] : index
        %workgroup_count_0 = flow.dispatch.workgroup.count[0] : index
        %workgroup_id_1 = flow.dispatch.workgroup.id[1] : index
        %workgroup_count_1 = flow.dispatch.workgroup.count[1] : index
        %0 = affine.apply #map0()[%workgroup_id_1, %workgroup_size_1]
        %1 = affine.apply #map0()[%workgroup_count_1, %workgroup_size_1]
        scf.for %arg2 = %0 to %c1 step %1 {
          %2 = affine.apply #map0()[%workgroup_id_0, %workgroup_size_0]
          %3 = affine.apply #map0()[%workgroup_count_0, %workgroup_size_0]
          scf.for %arg3 = %2 to %c10 step %3 {
            %4 = affine.min #map1(%arg2)[%workgroup_size_1]
            %5 = affine.min #map6(%arg3)[%workgroup_size_0]
            %6 = flow.dispatch.tensor.load %arg0, offsets = [%arg2, %arg3], sizes = [%4, %5], strides = [1, 1] : !flow.dispatch.tensor<readonly:1x10xf32> -> tensor<?x?xf32>
            %7 = affine.min #map1(%arg2)[%workgroup_size_1]
            %8 = affine.min #map6(%arg3)[%workgroup_size_0]
            %9 = subtensor %cst[%arg2, %arg3] [%7, %8] [1, 1] : tensor<1x10xf32> to tensor<?x?xf32>
            %10 = affine.min #map6(%arg3)[%workgroup_size_0]
            %11 = linalg.init_tensor [%10] : tensor<?xf32>
            %12 = linalg.generic {indexing_maps = [#map5, #map5, #map8], iterator_types = ["parallel", "parallel"]} ins(%6, %9 : tensor<?x?xf32>, tensor<?x?xf32>) outs(%11 : tensor<?xf32>) attrs =  {__internal_linalg_transform__ = "workgroup"} {
            ^bb0(%arg4: f32, %arg5: f32, %arg6: f32):  // no predecessors
              %13 = addf %arg4, %arg5 : f32
              linalg.yield %13 : f32
            } -> tensor<?xf32>
            flow.dispatch.tensor.store %12, %arg1, offsets = [%arg3], sizes = [%10], strides = [1] : tensor<?xf32> -> !flow.dispatch.tensor<writeonly:10xf32>
          }
        }
        return
      }
    }
  }
  flow.executable @predict_dispatch_4 attributes {sym_visibility = "private"} {
    flow.dispatch.entry @predict_dispatch_4 attributes {workgroup_rank = 3 : index}
    module  {
      func @predict_dispatch_4(%arg0: !flow.dispatch.tensor<readonly:10xf32>, %arg1: !flow.dispatch.tensor<writeonly:f32>) {
        %cst = constant 0x7FC00000 : f32
        %cst_0 = constant 0xFF800000 : f32
        %0 = flow.dispatch.tensor.load %arg0, offsets = [], sizes = [], strides = [] : !flow.dispatch.tensor<readonly:10xf32> -> tensor<10xf32>
        %1 = linalg.init_tensor [] : tensor<f32>
        %2 = linalg.fill(%1, %cst_0) : tensor<f32>, f32 -> tensor<f32> 
        %3 = linalg.generic {indexing_maps = [#map9, #map10], iterator_types = ["reduction"]} ins(%0 : tensor<10xf32>) outs(%2 : tensor<f32>) {
        ^bb0(%arg2: f32, %arg3: f32):  // no predecessors
          %4 = cmpf ogt, %arg2, %arg3 : f32
          %5 = select %4, %arg2, %arg3 : f32
          %6 = cmpf uno, %arg2, %arg3 : f32
          %7 = select %6, %cst, %5 : f32
          linalg.yield %7 : f32
        } -> tensor<f32>
        flow.dispatch.tensor.store %3, %arg1, offsets = [], sizes = [], strides = [] : tensor<f32> -> !flow.dispatch.tensor<writeonly:f32>
        return
      }
    }
  }
  flow.executable @predict_dispatch_5 attributes {sym_visibility = "private"} {
    flow.dispatch.entry @predict_dispatch_5 attributes {workgroup_rank = 3 : index}
    module  {
      func @predict_dispatch_5(%arg0: !flow.dispatch.tensor<readonly:1x10xf32>, %arg1: !flow.dispatch.tensor<readonly:f32>, %arg2: !flow.dispatch.tensor<writeonly:10xf32>) {
        %cst = constant opaque<"_", "0xDEADBEEF"> : tensor<1x10xf32>
        %c1 = constant 1 : index
        %c10 = constant 10 : index
        %0 = flow.dispatch.tensor.load %arg1, offsets = [], sizes = [], strides = [] : !flow.dispatch.tensor<readonly:f32> -> tensor<f32>
        %workgroup_size_0 = flow.dispatch.workgroup.size[0] : index
        %workgroup_size_1 = flow.dispatch.workgroup.size[1] : index
        %workgroup_id_0 = flow.dispatch.workgroup.id[0] : index
        %workgroup_count_0 = flow.dispatch.workgroup.count[0] : index
        %workgroup_id_1 = flow.dispatch.workgroup.id[1] : index
        %workgroup_count_1 = flow.dispatch.workgroup.count[1] : index
        %1 = affine.apply #map0()[%workgroup_id_1, %workgroup_size_1]
        %2 = affine.apply #map0()[%workgroup_count_1, %workgroup_size_1]
        scf.for %arg3 = %1 to %c1 step %2 {
          %3 = affine.apply #map0()[%workgroup_id_0, %workgroup_size_0]
          %4 = affine.apply #map0()[%workgroup_count_0, %workgroup_size_0]
          scf.for %arg4 = %3 to %c10 step %4 {
            %5 = affine.min #map1(%arg3)[%workgroup_size_1]
            %6 = affine.min #map6(%arg4)[%workgroup_size_0]
            %7 = flow.dispatch.tensor.load %arg0, offsets = [%arg3, %arg4], sizes = [%5, %6], strides = [1, 1] : !flow.dispatch.tensor<readonly:1x10xf32> -> tensor<?x?xf32>
            %8 = affine.min #map1(%arg3)[%workgroup_size_1]
            %9 = affine.min #map6(%arg4)[%workgroup_size_0]
            %10 = subtensor %cst[%arg3, %arg4] [%8, %9] [1, 1] : tensor<1x10xf32> to tensor<?x?xf32>
            %11 = affine.min #map6(%arg4)[%workgroup_size_0]
            %12 = linalg.init_tensor [%11] : tensor<?xf32>
            %13 = linalg.generic {indexing_maps = [#map5, #map5, #map11, #map8], iterator_types = ["parallel", "parallel"]} ins(%7, %10, %0 : tensor<?x?xf32>, tensor<?x?xf32>, tensor<f32>) outs(%12 : tensor<?xf32>) attrs =  {__internal_linalg_transform__ = "workgroup"} {
            ^bb0(%arg5: f32, %arg6: f32, %arg7: f32, %arg8: f32):  // no predecessors
              %14 = addf %arg5, %arg6 : f32
              %15 = subf %14, %arg7 : f32
              %16 = math.exp %15 : f32
              linalg.yield %16 : f32
            } -> tensor<?xf32>
            flow.dispatch.tensor.store %13, %arg2, offsets = [%arg4], sizes = [%11], strides = [1] : tensor<?xf32> -> !flow.dispatch.tensor<writeonly:10xf32>
          }
        }
        return
      }
    }
  }
  flow.executable @predict_dispatch_6 attributes {sym_visibility = "private"} {
    flow.dispatch.entry @predict_dispatch_6 attributes {workgroup_rank = 3 : index}
    module  {
      func @predict_dispatch_6(%arg0: !flow.dispatch.tensor<readonly:10xf32>, %arg1: !flow.dispatch.tensor<writeonly:f32>) {
        %cst = constant 0.000000e+00 : f32
        %0 = flow.dispatch.tensor.load %arg0, offsets = [], sizes = [], strides = [] : !flow.dispatch.tensor<readonly:10xf32> -> tensor<10xf32>
        %1 = linalg.init_tensor [] : tensor<f32>
        %2 = linalg.fill(%1, %cst) : tensor<f32>, f32 -> tensor<f32> 
        %3 = linalg.generic {indexing_maps = [#map9, #map10], iterator_types = ["reduction"]} ins(%0 : tensor<10xf32>) outs(%2 : tensor<f32>) {
        ^bb0(%arg2: f32, %arg3: f32):  // no predecessors
          %4 = addf %arg2, %arg3 : f32
          linalg.yield %4 : f32
        } -> tensor<f32>
        flow.dispatch.tensor.store %3, %arg1, offsets = [], sizes = [], strides = [] : tensor<f32> -> !flow.dispatch.tensor<writeonly:f32>
        return
      }
    }
  }
  flow.executable @predict_dispatch_7 attributes {sym_visibility = "private"} {
    flow.dispatch.entry @predict_dispatch_7 attributes {workgroup_rank = 3 : index}
    module  {
      func @predict_dispatch_7(%arg0: !flow.dispatch.tensor<readonly:1x10xf32>, %arg1: !flow.dispatch.tensor<readonly:f32>, %arg2: !flow.dispatch.tensor<readonly:f32>, %arg3: !flow.dispatch.tensor<writeonly:1x10xf32>) {
        %cst = constant opaque<"_", "0xDEADBEEF"> : tensor<1x10xf32>
        %c1 = constant 1 : index
        %c10 = constant 10 : index
        %0 = flow.dispatch.tensor.load %arg1, offsets = [], sizes = [], strides = [] : !flow.dispatch.tensor<readonly:f32> -> tensor<f32>
        %1 = flow.dispatch.tensor.load %arg2, offsets = [], sizes = [], strides = [] : !flow.dispatch.tensor<readonly:f32> -> tensor<f32>
        %workgroup_size_0 = flow.dispatch.workgroup.size[0] : index
        %workgroup_size_1 = flow.dispatch.workgroup.size[1] : index
        %workgroup_id_0 = flow.dispatch.workgroup.id[0] : index
        %workgroup_count_0 = flow.dispatch.workgroup.count[0] : index
        %workgroup_id_1 = flow.dispatch.workgroup.id[1] : index
        %workgroup_count_1 = flow.dispatch.workgroup.count[1] : index
        %2 = affine.apply #map0()[%workgroup_id_1, %workgroup_size_1]
        %3 = affine.apply #map0()[%workgroup_count_1, %workgroup_size_1]
        scf.for %arg4 = %2 to %c1 step %3 {
          %4 = affine.apply #map0()[%workgroup_id_0, %workgroup_size_0]
          %5 = affine.apply #map0()[%workgroup_count_0, %workgroup_size_0]
          scf.for %arg5 = %4 to %c10 step %5 {
            %6 = affine.min #map1(%arg4)[%workgroup_size_1]
            %7 = affine.min #map6(%arg5)[%workgroup_size_0]
            %8 = flow.dispatch.tensor.load %arg0, offsets = [%arg4, %arg5], sizes = [%6, %7], strides = [1, 1] : !flow.dispatch.tensor<readonly:1x10xf32> -> tensor<?x?xf32>
            %9 = affine.min #map1(%arg4)[%workgroup_size_1]
            %10 = affine.min #map6(%arg5)[%workgroup_size_0]
            %11 = subtensor %cst[%arg4, %arg5] [%9, %10] [1, 1] : tensor<1x10xf32> to tensor<?x?xf32>
            %12 = affine.min #map1(%arg4)[%workgroup_size_1]
            %13 = affine.min #map6(%arg5)[%workgroup_size_0]
            %14 = linalg.init_tensor [%12, %13] : tensor<?x?xf32>
            %15 = linalg.generic {indexing_maps = [#map5, #map5, #map11, #map11, #map5], iterator_types = ["parallel", "parallel"]} ins(%8, %11, %0, %1 : tensor<?x?xf32>, tensor<?x?xf32>, tensor<f32>, tensor<f32>) outs(%14 : tensor<?x?xf32>) attrs =  {__internal_linalg_transform__ = "workgroup"} {
            ^bb0(%arg6: f32, %arg7: f32, %arg8: f32, %arg9: f32, %arg10: f32):  // no predecessors
              %16 = addf %arg6, %arg7 : f32
              %17 = subf %16, %arg8 : f32
              %18 = math.exp %17 : f32
              %19 = divf %18, %arg9 : f32
              linalg.yield %19 : f32
            } -> tensor<?x?xf32>
            flow.dispatch.tensor.store %15, %arg3, offsets = [%arg4, %arg5], sizes = [%12, %13], strides = [1, 1] : tensor<?x?xf32> -> !flow.dispatch.tensor<writeonly:1x10xf32>
          }
        }
        return
      }
    }
  }
  func @predict(%arg0: tensor<1x28x28x1xf32>) -> tensor<1x10xf32> attributes {iree.module.export, iree.reflection = {abi = "sip", abiv = 1 : i32, f = "I15!B11!d1d28d28d1R9!B6!d1d10", fv = "1", sip = "I8!S5!k0_0R3!_0"}} {
    %0 = flow.ex.stream.fragment(%arg0) : (tensor<1x28x28x1xf32>) -> tensor<1x10xf32> =
        (%arg1: tensor<1x28x28x1xf32>) -> tensor<1x10xf32> {
      %c128 = constant 128 : index
      %c1 = constant 1 : index
      %c10 = constant 10 : index
      %const = hal.constant_pool.load @_const_pool::@_large_const_1 : tensor<784x128xf32>
      %const_0 = hal.constant_pool.load @_const_pool::@_large_const_0 : tensor<1x128xf32>
      %const_1 = hal.constant_pool.load @_const_pool::@_large_const_2 : tensor<128x10xf32>
      %1 = flow.tensor.reshape %arg1 : tensor<1x28x28x1xf32> -> tensor<1x784xf32>
      %2 = flow.dispatch @predict_dispatch_0::@predict_dispatch_0[%c128, %c1, %c1](%1, %const) : (tensor<1x784xf32>, tensor<784x128xf32>) -> tensor<1x128xf32>
      %3 = flow.dispatch @predict_dispatch_1::@predict_dispatch_1[%c128, %c1, %c1](%2, %const_0) : (tensor<1x128xf32>, tensor<1x128xf32>) -> tensor<1x128xf32>
      %4 = flow.dispatch @predict_dispatch_2::@predict_dispatch_2[%c10, %c1, %c1](%3, %const_1) : (tensor<1x128xf32>, tensor<128x10xf32>) -> tensor<1x10xf32>
      %5 = flow.dispatch @predict_dispatch_3::@predict_dispatch_3[%c10, %c1, %c1](%4) : (tensor<1x10xf32>) -> tensor<10xf32>
      %6 = flow.dispatch @predict_dispatch_4::@predict_dispatch_4[%c1, %c1, %c1](%5) : (tensor<10xf32>) -> tensor<f32>
      %7 = flow.dispatch @predict_dispatch_5::@predict_dispatch_5[%c10, %c1, %c1](%4, %6) : (tensor<1x10xf32>, tensor<f32>) -> tensor<10xf32>
      %8 = flow.dispatch @predict_dispatch_6::@predict_dispatch_6[%c1, %c1, %c1](%7) : (tensor<10xf32>) -> tensor<f32>
      %9 = flow.dispatch @predict_dispatch_7::@predict_dispatch_7[%c10, %c1, %c1](%4, %6, %8) : (tensor<1x10xf32>, tensor<f32>, tensor<f32>) -> tensor<1x10xf32>
      flow.return %9 : tensor<1x10xf32>
    }
    return %0 : tensor<1x10xf32>
  }
}


// *** IR Dump After mlir::iree_compiler::IREE::HAL::PackConstantPoolStoragePass ***
hal.constant_pool @_const_pool attributes {buffer_constraints = #hal.buffer_constraints<max_allocation_size = 1073741824, min_buffer_offset_alignment = 16, max_buffer_range = 1073741824, min_buffer_range_alignment = 16>, sym_visibility = "private"} {
  hal.constant_pool.span @_large_const_0 : tensor<1x128xf32> = @_storage[#hal.byte_range<0, 512>] attributes {sym_visibility = "nested"}
  hal.constant_pool.span @_large_const_1 : tensor<784x128xf32> = @_storage[#hal.byte_range<512, 401408>] attributes {sym_visibility = "nested"}
  hal.constant_pool.span @_large_const_2 : tensor<128x10xf32> = @_storage[#hal.byte_range<401920, 5120>] attributes {sym_visibility = "nested"}
  hal.constant_storage @_storage = opaque<"_", "0xDEADBEEF"> : vector<407040xi8> attributes {sym_visibility = "nested"}
}

// *** IR Dump After mlir::iree_compiler::IREE::HAL::MaterializeConstantPoolBuffersPass ***
#map0 = affine_map<()[s0, s1] -> (s0 * s1)>
#map1 = affine_map<(d0)[s0] -> (s0, -d0 + 1)>
#map2 = affine_map<(d0)[s0] -> (s0, -d0 + 128)>
#map3 = affine_map<(d0)[s0] -> (-d0 + 1, s0)>
#map4 = affine_map<(d0)[s0] -> (-d0 + 128, s0)>
#map5 = affine_map<(d0, d1) -> (d0, d1)>
#map6 = affine_map<(d0)[s0] -> (s0, -d0 + 10)>
#map7 = affine_map<(d0)[s0] -> (-d0 + 10, s0)>
#map8 = affine_map<(d0, d1) -> (d1)>
#map9 = affine_map<(d0) -> (d0)>
#map10 = affine_map<(d0) -> ()>
#map11 = affine_map<(d0, d1) -> ()>
module  {
  hal.constant_pool @_const_pool attributes {buffer_constraints = #hal.buffer_constraints<max_allocation_size = 1073741824, min_buffer_offset_alignment = 16, max_buffer_range = 1073741824, min_buffer_range_alignment = 16>, sym_visibility = "private"} {
    hal.constant_pool.span @_large_const_0 : tensor<1x128xf32> = @_storage[#hal.byte_range<0, 512>] -> @_const_pool_storage_buffer[#hal.byte_range<0, 512>] attributes {sym_visibility = "nested"}
    hal.constant_pool.span @_large_const_1 : tensor<784x128xf32> = @_storage[#hal.byte_range<512, 401408>] -> @_const_pool_storage_buffer[#hal.byte_range<512, 401408>] attributes {sym_visibility = "nested"}
    hal.constant_pool.span @_large_const_2 : tensor<128x10xf32> = @_storage[#hal.byte_range<401920, 5120>] -> @_const_pool_storage_buffer[#hal.byte_range<401920, 5120>] attributes {sym_visibility = "nested"}
    hal.constant_storage @_storage = opaque<"_", "0xDEADBEEF"> : vector<407040xi8> attributes {sym_visibility = "nested"}
  }
  hal.variable @_const_pool_storage_buffer init(@_const_pool_storage_buffer_initializer) : !hal.buffer attributes {sym_visibility = "private"}
  func private @_const_pool_storage_buffer_initializer() -> !hal.buffer {
    %device = hal.ex.shared_device : !hal.device
    %allocator = hal.device.allocator<%device : !hal.device> : !hal.allocator
    %storage = hal.constant_storage.lookup @_const_pool::@_storage : !iree.byte_buffer
    %c0 = constant 0 : index
    %c407040 = constant 407040 : index
    %mapped = hal.allocator.map<%allocator : !hal.allocator> source(%storage : !iree.byte_buffer)[%c0, %c407040] type("HostVisible|DeviceVisible|DeviceLocal") usage("Constant|Transfer|Mapping|Dispatch") : !hal.buffer
    return %mapped : !hal.buffer
  }
  flow.executable @predict_dispatch_0 attributes {sym_visibility = "private"} {
    flow.dispatch.entry @predict_dispatch_0 attributes {workgroup_rank = 3 : index}
    module  {
      func @predict_dispatch_0(%arg0: !flow.dispatch.tensor<readonly:1x784xf32>, %arg1: !flow.dispatch.tensor<readonly:784x128xf32>, %arg2: !flow.dispatch.tensor<writeonly:1x128xf32>) {
        %cst = constant 0.000000e+00 : f32
        %c1 = constant 1 : index
        %c128 = constant 128 : index
        %workgroup_size_0 = flow.dispatch.workgroup.size[0] : index
        %workgroup_size_1 = flow.dispatch.workgroup.size[1] : index
        %workgroup_id_0 = flow.dispatch.workgroup.id[0] : index
        %workgroup_count_0 = flow.dispatch.workgroup.count[0] : index
        %workgroup_id_1 = flow.dispatch.workgroup.id[1] : index
        %workgroup_count_1 = flow.dispatch.workgroup.count[1] : index
        %0 = affine.apply #map0()[%workgroup_id_1, %workgroup_size_1]
        %1 = affine.apply #map0()[%workgroup_count_1, %workgroup_size_1]
        scf.for %arg3 = %0 to %c1 step %1 {
          %2 = affine.apply #map0()[%workgroup_id_0, %workgroup_size_0]
          %3 = affine.apply #map0()[%workgroup_count_0, %workgroup_size_0]
          scf.for %arg4 = %2 to %c128 step %3 {
            %4 = affine.min #map1(%arg3)[%workgroup_size_1]
            %5 = flow.dispatch.tensor.load %arg0, offsets = [%arg3, 0], sizes = [%4, 784], strides = [1, 1] : !flow.dispatch.tensor<readonly:1x784xf32> -> tensor<?x784xf32>
            %6 = affine.min #map2(%arg4)[%workgroup_size_0]
            %7 = flow.dispatch.tensor.load %arg1, offsets = [0, %arg4], sizes = [784, %6], strides = [1, 1] : !flow.dispatch.tensor<readonly:784x128xf32> -> tensor<784x?xf32>
            %8 = affine.min #map1(%arg3)[%workgroup_size_1]
            %9 = affine.min #map2(%arg4)[%workgroup_size_0]
            %10 = affine.min #map3(%arg3)[%workgroup_size_1]
            %11 = affine.min #map4(%arg4)[%workgroup_size_0]
            %12 = linalg.init_tensor [%10, %11] : tensor<?x?xf32>
            %13 = linalg.fill(%12, %cst) : tensor<?x?xf32>, f32 -> tensor<?x?xf32> 
            %14 = linalg.matmul {__internal_linalg_transform__ = "workgroup"} ins(%5, %7 : tensor<?x784xf32>, tensor<784x?xf32>) outs(%13 : tensor<?x?xf32>) -> tensor<?x?xf32>
            flow.dispatch.tensor.store %14, %arg2, offsets = [%arg3, %arg4], sizes = [%8, %9], strides = [1, 1] : tensor<?x?xf32> -> !flow.dispatch.tensor<writeonly:1x128xf32>
          }
        }
        return
      }
    }
  }
  flow.executable @predict_dispatch_1 attributes {sym_visibility = "private"} {
    flow.dispatch.entry @predict_dispatch_1 attributes {workgroup_rank = 3 : index}
    module  {
      func @predict_dispatch_1(%arg0: !flow.dispatch.tensor<readonly:1x128xf32>, %arg1: !flow.dispatch.tensor<readonly:1x128xf32>, %arg2: !flow.dispatch.tensor<writeonly:1x128xf32>) {
        %cst = constant 0x7FC00000 : f32
        %cst_0 = constant 0.000000e+00 : f32
        %c1 = constant 1 : index
        %c128 = constant 128 : index
        %workgroup_size_0 = flow.dispatch.workgroup.size[0] : index
        %workgroup_size_1 = flow.dispatch.workgroup.size[1] : index
        %workgroup_id_0 = flow.dispatch.workgroup.id[0] : index
        %workgroup_count_0 = flow.dispatch.workgroup.count[0] : index
        %workgroup_id_1 = flow.dispatch.workgroup.id[1] : index
        %workgroup_count_1 = flow.dispatch.workgroup.count[1] : index
        %0 = affine.apply #map0()[%workgroup_id_1, %workgroup_size_1]
        %1 = affine.apply #map0()[%workgroup_count_1, %workgroup_size_1]
        scf.for %arg3 = %0 to %c1 step %1 {
          %2 = affine.apply #map0()[%workgroup_id_0, %workgroup_size_0]
          %3 = affine.apply #map0()[%workgroup_count_0, %workgroup_size_0]
          scf.for %arg4 = %2 to %c128 step %3 {
            %4 = affine.min #map1(%arg3)[%workgroup_size_1]
            %5 = affine.min #map2(%arg4)[%workgroup_size_0]
            %6 = flow.dispatch.tensor.load %arg0, offsets = [%arg3, %arg4], sizes = [%4, %5], strides = [1, 1] : !flow.dispatch.tensor<readonly:1x128xf32> -> tensor<?x?xf32>
            %7 = affine.min #map1(%arg3)[%workgroup_size_1]
            %8 = affine.min #map2(%arg4)[%workgroup_size_0]
            %9 = flow.dispatch.tensor.load %arg1, offsets = [%arg3, %arg4], sizes = [%7, %8], strides = [1, 1] : !flow.dispatch.tensor<readonly:1x128xf32> -> tensor<?x?xf32>
            %10 = affine.min #map1(%arg3)[%workgroup_size_1]
            %11 = affine.min #map2(%arg4)[%workgroup_size_0]
            %12 = linalg.init_tensor [%10, %11] : tensor<?x?xf32>
            %13 = linalg.generic {indexing_maps = [#map5, #map5, #map5], iterator_types = ["parallel", "parallel"]} ins(%6, %9 : tensor<?x?xf32>, tensor<?x?xf32>) outs(%12 : tensor<?x?xf32>) attrs =  {__internal_linalg_transform__ = "workgroup"} {
            ^bb0(%arg5: f32, %arg6: f32, %arg7: f32):  // no predecessors
              %14 = addf %arg5, %arg6 : f32
              %15 = cmpf ogt, %14, %cst_0 : f32
              %16 = select %15, %14, %cst_0 : f32
              %17 = cmpf uno, %14, %cst_0 : f32
              %18 = select %17, %cst, %16 : f32
              linalg.yield %18 : f32
            } -> tensor<?x?xf32>
            flow.dispatch.tensor.store %13, %arg2, offsets = [%arg3, %arg4], sizes = [%10, %11], strides = [1, 1] : tensor<?x?xf32> -> !flow.dispatch.tensor<writeonly:1x128xf32>
          }
        }
        return
      }
    }
  }
  flow.executable @predict_dispatch_2 attributes {sym_visibility = "private"} {
    flow.dispatch.entry @predict_dispatch_2 attributes {workgroup_rank = 3 : index}
    module  {
      func @predict_dispatch_2(%arg0: !flow.dispatch.tensor<readonly:1x128xf32>, %arg1: !flow.dispatch.tensor<readonly:128x10xf32>, %arg2: !flow.dispatch.tensor<writeonly:1x10xf32>) {
        %cst = constant 0.000000e+00 : f32
        %c1 = constant 1 : index
        %c10 = constant 10 : index
        %workgroup_size_0 = flow.dispatch.workgroup.size[0] : index
        %workgroup_size_1 = flow.dispatch.workgroup.size[1] : index
        %workgroup_id_0 = flow.dispatch.workgroup.id[0] : index
        %workgroup_count_0 = flow.dispatch.workgroup.count[0] : index
        %workgroup_id_1 = flow.dispatch.workgroup.id[1] : index
        %workgroup_count_1 = flow.dispatch.workgroup.count[1] : index
        %0 = affine.apply #map0()[%workgroup_id_1, %workgroup_size_1]
        %1 = affine.apply #map0()[%workgroup_count_1, %workgroup_size_1]
        scf.for %arg3 = %0 to %c1 step %1 {
          %2 = affine.apply #map0()[%workgroup_id_0, %workgroup_size_0]
          %3 = affine.apply #map0()[%workgroup_count_0, %workgroup_size_0]
          scf.for %arg4 = %2 to %c10 step %3 {
            %4 = affine.min #map1(%arg3)[%workgroup_size_1]
            %5 = flow.dispatch.tensor.load %arg0, offsets = [%arg3, 0], sizes = [%4, 128], strides = [1, 1] : !flow.dispatch.tensor<readonly:1x128xf32> -> tensor<?x128xf32>
            %6 = affine.min #map6(%arg4)[%workgroup_size_0]
            %7 = flow.dispatch.tensor.load %arg1, offsets = [0, %arg4], sizes = [128, %6], strides = [1, 1] : !flow.dispatch.tensor<readonly:128x10xf32> -> tensor<128x?xf32>
            %8 = affine.min #map1(%arg3)[%workgroup_size_1]
            %9 = affine.min #map6(%arg4)[%workgroup_size_0]
            %10 = affine.min #map3(%arg3)[%workgroup_size_1]
            %11 = affine.min #map7(%arg4)[%workgroup_size_0]
            %12 = linalg.init_tensor [%10, %11] : tensor<?x?xf32>
            %13 = linalg.fill(%12, %cst) : tensor<?x?xf32>, f32 -> tensor<?x?xf32> 
            %14 = linalg.matmul {__internal_linalg_transform__ = "workgroup"} ins(%5, %7 : tensor<?x128xf32>, tensor<128x?xf32>) outs(%13 : tensor<?x?xf32>) -> tensor<?x?xf32>
            flow.dispatch.tensor.store %14, %arg2, offsets = [%arg3, %arg4], sizes = [%8, %9], strides = [1, 1] : tensor<?x?xf32> -> !flow.dispatch.tensor<writeonly:1x10xf32>
          }
        }
        return
      }
    }
  }
  flow.executable @predict_dispatch_3 attributes {sym_visibility = "private"} {
    flow.dispatch.entry @predict_dispatch_3 attributes {workgroup_rank = 3 : index}
    module  {
      func @predict_dispatch_3(%arg0: !flow.dispatch.tensor<readonly:1x10xf32>, %arg1: !flow.dispatch.tensor<writeonly:10xf32>) {
        %cst = constant opaque<"_", "0xDEADBEEF"> : tensor<1x10xf32>
        %c1 = constant 1 : index
        %c10 = constant 10 : index
        %workgroup_size_0 = flow.dispatch.workgroup.size[0] : index
        %workgroup_size_1 = flow.dispatch.workgroup.size[1] : index
        %workgroup_id_0 = flow.dispatch.workgroup.id[0] : index
        %workgroup_count_0 = flow.dispatch.workgroup.count[0] : index
        %workgroup_id_1 = flow.dispatch.workgroup.id[1] : index
        %workgroup_count_1 = flow.dispatch.workgroup.count[1] : index
        %0 = affine.apply #map0()[%workgroup_id_1, %workgroup_size_1]
        %1 = affine.apply #map0()[%workgroup_count_1, %workgroup_size_1]
        scf.for %arg2 = %0 to %c1 step %1 {
          %2 = affine.apply #map0()[%workgroup_id_0, %workgroup_size_0]
          %3 = affine.apply #map0()[%workgroup_count_0, %workgroup_size_0]
          scf.for %arg3 = %2 to %c10 step %3 {
            %4 = affine.min #map1(%arg2)[%workgroup_size_1]
            %5 = affine.min #map6(%arg3)[%workgroup_size_0]
            %6 = flow.dispatch.tensor.load %arg0, offsets = [%arg2, %arg3], sizes = [%4, %5], strides = [1, 1] : !flow.dispatch.tensor<readonly:1x10xf32> -> tensor<?x?xf32>
            %7 = affine.min #map1(%arg2)[%workgroup_size_1]
            %8 = affine.min #map6(%arg3)[%workgroup_size_0]
            %9 = subtensor %cst[%arg2, %arg3] [%7, %8] [1, 1] : tensor<1x10xf32> to tensor<?x?xf32>
            %10 = affine.min #map6(%arg3)[%workgroup_size_0]
            %11 = linalg.init_tensor [%10] : tensor<?xf32>
            %12 = linalg.generic {indexing_maps = [#map5, #map5, #map8], iterator_types = ["parallel", "parallel"]} ins(%6, %9 : tensor<?x?xf32>, tensor<?x?xf32>) outs(%11 : tensor<?xf32>) attrs =  {__internal_linalg_transform__ = "workgroup"} {
            ^bb0(%arg4: f32, %arg5: f32, %arg6: f32):  // no predecessors
              %13 = addf %arg4, %arg5 : f32
              linalg.yield %13 : f32
            } -> tensor<?xf32>
            flow.dispatch.tensor.store %12, %arg1, offsets = [%arg3], sizes = [%10], strides = [1] : tensor<?xf32> -> !flow.dispatch.tensor<writeonly:10xf32>
          }
        }
        return
      }
    }
  }
  flow.executable @predict_dispatch_4 attributes {sym_visibility = "private"} {
    flow.dispatch.entry @predict_dispatch_4 attributes {workgroup_rank = 3 : index}
    module  {
      func @predict_dispatch_4(%arg0: !flow.dispatch.tensor<readonly:10xf32>, %arg1: !flow.dispatch.tensor<writeonly:f32>) {
        %cst = constant 0x7FC00000 : f32
        %cst_0 = constant 0xFF800000 : f32
        %0 = flow.dispatch.tensor.load %arg0, offsets = [], sizes = [], strides = [] : !flow.dispatch.tensor<readonly:10xf32> -> tensor<10xf32>
        %1 = linalg.init_tensor [] : tensor<f32>
        %2 = linalg.fill(%1, %cst_0) : tensor<f32>, f32 -> tensor<f32> 
        %3 = linalg.generic {indexing_maps = [#map9, #map10], iterator_types = ["reduction"]} ins(%0 : tensor<10xf32>) outs(%2 : tensor<f32>) {
        ^bb0(%arg2: f32, %arg3: f32):  // no predecessors
          %4 = cmpf ogt, %arg2, %arg3 : f32
          %5 = select %4, %arg2, %arg3 : f32
          %6 = cmpf uno, %arg2, %arg3 : f32
          %7 = select %6, %cst, %5 : f32
          linalg.yield %7 : f32
        } -> tensor<f32>
        flow.dispatch.tensor.store %3, %arg1, offsets = [], sizes = [], strides = [] : tensor<f32> -> !flow.dispatch.tensor<writeonly:f32>
        return
      }
    }
  }
  flow.executable @predict_dispatch_5 attributes {sym_visibility = "private"} {
    flow.dispatch.entry @predict_dispatch_5 attributes {workgroup_rank = 3 : index}
    module  {
      func @predict_dispatch_5(%arg0: !flow.dispatch.tensor<readonly:1x10xf32>, %arg1: !flow.dispatch.tensor<readonly:f32>, %arg2: !flow.dispatch.tensor<writeonly:10xf32>) {
        %cst = constant opaque<"_", "0xDEADBEEF"> : tensor<1x10xf32>
        %c1 = constant 1 : index
        %c10 = constant 10 : index
        %0 = flow.dispatch.tensor.load %arg1, offsets = [], sizes = [], strides = [] : !flow.dispatch.tensor<readonly:f32> -> tensor<f32>
        %workgroup_size_0 = flow.dispatch.workgroup.size[0] : index
        %workgroup_size_1 = flow.dispatch.workgroup.size[1] : index
        %workgroup_id_0 = flow.dispatch.workgroup.id[0] : index
        %workgroup_count_0 = flow.dispatch.workgroup.count[0] : index
        %workgroup_id_1 = flow.dispatch.workgroup.id[1] : index
        %workgroup_count_1 = flow.dispatch.workgroup.count[1] : index
        %1 = affine.apply #map0()[%workgroup_id_1, %workgroup_size_1]
        %2 = affine.apply #map0()[%workgroup_count_1, %workgroup_size_1]
        scf.for %arg3 = %1 to %c1 step %2 {
          %3 = affine.apply #map0()[%workgroup_id_0, %workgroup_size_0]
          %4 = affine.apply #map0()[%workgroup_count_0, %workgroup_size_0]
          scf.for %arg4 = %3 to %c10 step %4 {
            %5 = affine.min #map1(%arg3)[%workgroup_size_1]
            %6 = affine.min #map6(%arg4)[%workgroup_size_0]
            %7 = flow.dispatch.tensor.load %arg0, offsets = [%arg3, %arg4], sizes = [%5, %6], strides = [1, 1] : !flow.dispatch.tensor<readonly:1x10xf32> -> tensor<?x?xf32>
            %8 = affine.min #map1(%arg3)[%workgroup_size_1]
            %9 = affine.min #map6(%arg4)[%workgroup_size_0]
            %10 = subtensor %cst[%arg3, %arg4] [%8, %9] [1, 1] : tensor<1x10xf32> to tensor<?x?xf32>
            %11 = affine.min #map6(%arg4)[%workgroup_size_0]
            %12 = linalg.init_tensor [%11] : tensor<?xf32>
            %13 = linalg.generic {indexing_maps = [#map5, #map5, #map11, #map8], iterator_types = ["parallel", "parallel"]} ins(%7, %10, %0 : tensor<?x?xf32>, tensor<?x?xf32>, tensor<f32>) outs(%12 : tensor<?xf32>) attrs =  {__internal_linalg_transform__ = "workgroup"} {
            ^bb0(%arg5: f32, %arg6: f32, %arg7: f32, %arg8: f32):  // no predecessors
              %14 = addf %arg5, %arg6 : f32
              %15 = subf %14, %arg7 : f32
              %16 = math.exp %15 : f32
              linalg.yield %16 : f32
            } -> tensor<?xf32>
            flow.dispatch.tensor.store %13, %arg2, offsets = [%arg4], sizes = [%11], strides = [1] : tensor<?xf32> -> !flow.dispatch.tensor<writeonly:10xf32>
          }
        }
        return
      }
    }
  }
  flow.executable @predict_dispatch_6 attributes {sym_visibility = "private"} {
    flow.dispatch.entry @predict_dispatch_6 attributes {workgroup_rank = 3 : index}
    module  {
      func @predict_dispatch_6(%arg0: !flow.dispatch.tensor<readonly:10xf32>, %arg1: !flow.dispatch.tensor<writeonly:f32>) {
        %cst = constant 0.000000e+00 : f32
        %0 = flow.dispatch.tensor.load %arg0, offsets = [], sizes = [], strides = [] : !flow.dispatch.tensor<readonly:10xf32> -> tensor<10xf32>
        %1 = linalg.init_tensor [] : tensor<f32>
        %2 = linalg.fill(%1, %cst) : tensor<f32>, f32 -> tensor<f32> 
        %3 = linalg.generic {indexing_maps = [#map9, #map10], iterator_types = ["reduction"]} ins(%0 : tensor<10xf32>) outs(%2 : tensor<f32>) {
        ^bb0(%arg2: f32, %arg3: f32):  // no predecessors
          %4 = addf %arg2, %arg3 : f32
          linalg.yield %4 : f32
        } -> tensor<f32>
        flow.dispatch.tensor.store %3, %arg1, offsets = [], sizes = [], strides = [] : tensor<f32> -> !flow.dispatch.tensor<writeonly:f32>
        return
      }
    }
  }
  flow.executable @predict_dispatch_7 attributes {sym_visibility = "private"} {
    flow.dispatch.entry @predict_dispatch_7 attributes {workgroup_rank = 3 : index}
    module  {
      func @predict_dispatch_7(%arg0: !flow.dispatch.tensor<readonly:1x10xf32>, %arg1: !flow.dispatch.tensor<readonly:f32>, %arg2: !flow.dispatch.tensor<readonly:f32>, %arg3: !flow.dispatch.tensor<writeonly:1x10xf32>) {
        %cst = constant opaque<"_", "0xDEADBEEF"> : tensor<1x10xf32>
        %c1 = constant 1 : index
        %c10 = constant 10 : index
        %0 = flow.dispatch.tensor.load %arg1, offsets = [], sizes = [], strides = [] : !flow.dispatch.tensor<readonly:f32> -> tensor<f32>
        %1 = flow.dispatch.tensor.load %arg2, offsets = [], sizes = [], strides = [] : !flow.dispatch.tensor<readonly:f32> -> tensor<f32>
        %workgroup_size_0 = flow.dispatch.workgroup.size[0] : index
        %workgroup_size_1 = flow.dispatch.workgroup.size[1] : index
        %workgroup_id_0 = flow.dispatch.workgroup.id[0] : index
        %workgroup_count_0 = flow.dispatch.workgroup.count[0] : index
        %workgroup_id_1 = flow.dispatch.workgroup.id[1] : index
        %workgroup_count_1 = flow.dispatch.workgroup.count[1] : index
        %2 = affine.apply #map0()[%workgroup_id_1, %workgroup_size_1]
        %3 = affine.apply #map0()[%workgroup_count_1, %workgroup_size_1]
        scf.for %arg4 = %2 to %c1 step %3 {
          %4 = affine.apply #map0()[%workgroup_id_0, %workgroup_size_0]
          %5 = affine.apply #map0()[%workgroup_count_0, %workgroup_size_0]
          scf.for %arg5 = %4 to %c10 step %5 {
            %6 = affine.min #map1(%arg4)[%workgroup_size_1]
            %7 = affine.min #map6(%arg5)[%workgroup_size_0]
            %8 = flow.dispatch.tensor.load %arg0, offsets = [%arg4, %arg5], sizes = [%6, %7], strides = [1, 1] : !flow.dispatch.tensor<readonly:1x10xf32> -> tensor<?x?xf32>
            %9 = affine.min #map1(%arg4)[%workgroup_size_1]
            %10 = affine.min #map6(%arg5)[%workgroup_size_0]
            %11 = subtensor %cst[%arg4, %arg5] [%9, %10] [1, 1] : tensor<1x10xf32> to tensor<?x?xf32>
            %12 = affine.min #map1(%arg4)[%workgroup_size_1]
            %13 = affine.min #map6(%arg5)[%workgroup_size_0]
            %14 = linalg.init_tensor [%12, %13] : tensor<?x?xf32>
            %15 = linalg.generic {indexing_maps = [#map5, #map5, #map11, #map11, #map5], iterator_types = ["parallel", "parallel"]} ins(%8, %11, %0, %1 : tensor<?x?xf32>, tensor<?x?xf32>, tensor<f32>, tensor<f32>) outs(%14 : tensor<?x?xf32>) attrs =  {__internal_linalg_transform__ = "workgroup"} {
            ^bb0(%arg6: f32, %arg7: f32, %arg8: f32, %arg9: f32, %arg10: f32):  // no predecessors
              %16 = addf %arg6, %arg7 : f32
              %17 = subf %16, %arg8 : f32
              %18 = math.exp %17 : f32
              %19 = divf %18, %arg9 : f32
              linalg.yield %19 : f32
            } -> tensor<?x?xf32>
            flow.dispatch.tensor.store %15, %arg3, offsets = [%arg4, %arg5], sizes = [%12, %13], strides = [1, 1] : tensor<?x?xf32> -> !flow.dispatch.tensor<writeonly:1x10xf32>
          }
        }
        return
      }
    }
  }
  func @predict(%arg0: tensor<1x28x28x1xf32>) -> tensor<1x10xf32> attributes {iree.module.export, iree.reflection = {abi = "sip", abiv = 1 : i32, f = "I15!B11!d1d28d28d1R9!B6!d1d10", fv = "1", sip = "I8!S5!k0_0R3!_0"}} {
    %0 = flow.ex.stream.fragment(%arg0) : (tensor<1x28x28x1xf32>) -> tensor<1x10xf32> =
        (%arg1: tensor<1x28x28x1xf32>) -> tensor<1x10xf32> {
      %c128 = constant 128 : index
      %c1 = constant 1 : index
      %c10 = constant 10 : index
      %const = hal.constant_pool.load @_const_pool::@_large_const_1 : tensor<784x128xf32>
      %const_0 = hal.constant_pool.load @_const_pool::@_large_const_0 : tensor<1x128xf32>
      %const_1 = hal.constant_pool.load @_const_pool::@_large_const_2 : tensor<128x10xf32>
      %1 = flow.tensor.reshape %arg1 : tensor<1x28x28x1xf32> -> tensor<1x784xf32>
      %2 = flow.dispatch @predict_dispatch_0::@predict_dispatch_0[%c128, %c1, %c1](%1, %const) : (tensor<1x784xf32>, tensor<784x128xf32>) -> tensor<1x128xf32>
      %3 = flow.dispatch @predict_dispatch_1::@predict_dispatch_1[%c128, %c1, %c1](%2, %const_0) : (tensor<1x128xf32>, tensor<1x128xf32>) -> tensor<1x128xf32>
      %4 = flow.dispatch @predict_dispatch_2::@predict_dispatch_2[%c10, %c1, %c1](%3, %const_1) : (tensor<1x128xf32>, tensor<128x10xf32>) -> tensor<1x10xf32>
      %5 = flow.dispatch @predict_dispatch_3::@predict_dispatch_3[%c10, %c1, %c1](%4) : (tensor<1x10xf32>) -> tensor<10xf32>
      %6 = flow.dispatch @predict_dispatch_4::@predict_dispatch_4[%c1, %c1, %c1](%5) : (tensor<10xf32>) -> tensor<f32>
      %7 = flow.dispatch @predict_dispatch_5::@predict_dispatch_5[%c10, %c1, %c1](%4, %6) : (tensor<1x10xf32>, tensor<f32>) -> tensor<10xf32>
      %8 = flow.dispatch @predict_dispatch_6::@predict_dispatch_6[%c1, %c1, %c1](%7) : (tensor<10xf32>) -> tensor<f32>
      %9 = flow.dispatch @predict_dispatch_7::@predict_dispatch_7[%c10, %c1, %c1](%4, %6, %8) : (tensor<1x10xf32>, tensor<f32>, tensor<f32>) -> tensor<1x10xf32>
      flow.return %9 : tensor<1x10xf32>
    }
    return %0 : tensor<1x10xf32>
  }
}


// *** IR Dump After Canonicalizer ***
#map0 = affine_map<()[s0, s1] -> (s0 * s1)>
#map1 = affine_map<(d0)[s0] -> (s0, -d0 + 1)>
#map2 = affine_map<(d0)[s0] -> (s0, -d0 + 128)>
#map3 = affine_map<(d0)[s0] -> (-d0 + 1, s0)>
#map4 = affine_map<(d0)[s0] -> (-d0 + 128, s0)>
#map5 = affine_map<(d0, d1) -> (d0, d1)>
#map6 = affine_map<(d0)[s0] -> (s0, -d0 + 10)>
#map7 = affine_map<(d0)[s0] -> (-d0 + 10, s0)>
#map8 = affine_map<(d0, d1) -> (d1)>
#map9 = affine_map<(d0) -> (d0)>
#map10 = affine_map<(d0) -> ()>
#map11 = affine_map<(d0, d1) -> ()>
module  {
  hal.constant_pool @_const_pool attributes {buffer_constraints = #hal.buffer_constraints<max_allocation_size = 1073741824, min_buffer_offset_alignment = 16, max_buffer_range = 1073741824, min_buffer_range_alignment = 16>, sym_visibility = "private"} {
    hal.constant_pool.span @_large_const_0 : tensor<1x128xf32> = @_storage[#hal.byte_range<0, 512>] -> @_const_pool_storage_buffer[#hal.byte_range<0, 512>] attributes {sym_visibility = "nested"}
    hal.constant_pool.span @_large_const_1 : tensor<784x128xf32> = @_storage[#hal.byte_range<512, 401408>] -> @_const_pool_storage_buffer[#hal.byte_range<512, 401408>] attributes {sym_visibility = "nested"}
    hal.constant_pool.span @_large_const_2 : tensor<128x10xf32> = @_storage[#hal.byte_range<401920, 5120>] -> @_const_pool_storage_buffer[#hal.byte_range<401920, 5120>] attributes {sym_visibility = "nested"}
    hal.constant_storage @_storage = opaque<"_", "0xDEADBEEF"> : vector<407040xi8> attributes {sym_visibility = "nested"}
  }
  hal.variable @_const_pool_storage_buffer init(@_const_pool_storage_buffer_initializer) : !hal.buffer attributes {sym_visibility = "private"}
  func private @_const_pool_storage_buffer_initializer() -> !hal.buffer {
    %c0 = constant 0 : index
    %c407040 = constant 407040 : index
    %device = hal.ex.shared_device : !hal.device
    %allocator = hal.device.allocator<%device : !hal.device> : !hal.allocator
    %storage = hal.constant_storage.lookup @_const_pool::@_storage : !iree.byte_buffer
    %mapped = hal.allocator.map<%allocator : !hal.allocator> source(%storage : !iree.byte_buffer)[%c0, %c407040] type("HostVisible|DeviceVisible|DeviceLocal") usage("Constant|Transfer|Mapping|Dispatch") : !hal.buffer
    return %mapped : !hal.buffer
  }
  flow.executable @predict_dispatch_0 attributes {sym_visibility = "private"} {
    flow.dispatch.entry @predict_dispatch_0 attributes {workgroup_rank = 3 : index}
    module  {
      func @predict_dispatch_0(%arg0: !flow.dispatch.tensor<readonly:1x784xf32>, %arg1: !flow.dispatch.tensor<readonly:784x128xf32>, %arg2: !flow.dispatch.tensor<writeonly:1x128xf32>) {
        %cst = constant 0.000000e+00 : f32
        %c1 = constant 1 : index
        %c128 = constant 128 : index
        %workgroup_size_0 = flow.dispatch.workgroup.size[0] : index
        %workgroup_size_1 = flow.dispatch.workgroup.size[1] : index
        %workgroup_id_0 = flow.dispatch.workgroup.id[0] : index
        %workgroup_count_0 = flow.dispatch.workgroup.count[0] : index
        %workgroup_id_1 = flow.dispatch.workgroup.id[1] : index
        %workgroup_count_1 = flow.dispatch.workgroup.count[1] : index
        %0 = affine.apply #map0()[%workgroup_id_1, %workgroup_size_1]
        %1 = affine.apply #map0()[%workgroup_count_1, %workgroup_size_1]
        scf.for %arg3 = %0 to %c1 step %1 {
          %2 = affine.apply #map0()[%workgroup_id_0, %workgroup_size_0]
          %3 = affine.apply #map0()[%workgroup_count_0, %workgroup_size_0]
          scf.for %arg4 = %2 to %c128 step %3 {
            %4 = affine.min #map1(%arg3)[%workgroup_size_1]
            %5 = flow.dispatch.tensor.load %arg0, offsets = [%arg3, 0], sizes = [%4, 784], strides = [1, 1] : !flow.dispatch.tensor<readonly:1x784xf32> -> tensor<?x784xf32>
            %6 = affine.min #map2(%arg4)[%workgroup_size_0]
            %7 = flow.dispatch.tensor.load %arg1, offsets = [0, %arg4], sizes = [784, %6], strides = [1, 1] : !flow.dispatch.tensor<readonly:784x128xf32> -> tensor<784x?xf32>
            %8 = affine.min #map1(%arg3)[%workgroup_size_1]
            %9 = affine.min #map2(%arg4)[%workgroup_size_0]
            %10 = affine.min #map3(%arg3)[%workgroup_size_1]
            %11 = affine.min #map4(%arg4)[%workgroup_size_0]
            %12 = linalg.init_tensor [%10, %11] : tensor<?x?xf32>
            %13 = linalg.fill(%12, %cst) : tensor<?x?xf32>, f32 -> tensor<?x?xf32> 
            %14 = linalg.matmul {__internal_linalg_transform__ = "workgroup"} ins(%5, %7 : tensor<?x784xf32>, tensor<784x?xf32>) outs(%13 : tensor<?x?xf32>) -> tensor<?x?xf32>
            flow.dispatch.tensor.store %14, %arg2, offsets = [%arg3, %arg4], sizes = [%8, %9], strides = [1, 1] : tensor<?x?xf32> -> !flow.dispatch.tensor<writeonly:1x128xf32>
          }
        }
        return
      }
    }
  }
  flow.executable @predict_dispatch_1 attributes {sym_visibility = "private"} {
    flow.dispatch.entry @predict_dispatch_1 attributes {workgroup_rank = 3 : index}
    module  {
      func @predict_dispatch_1(%arg0: !flow.dispatch.tensor<readonly:1x128xf32>, %arg1: !flow.dispatch.tensor<readonly:1x128xf32>, %arg2: !flow.dispatch.tensor<writeonly:1x128xf32>) {
        %cst = constant 0x7FC00000 : f32
        %cst_0 = constant 0.000000e+00 : f32
        %c1 = constant 1 : index
        %c128 = constant 128 : index
        %workgroup_size_0 = flow.dispatch.workgroup.size[0] : index
        %workgroup_size_1 = flow.dispatch.workgroup.size[1] : index
        %workgroup_id_0 = flow.dispatch.workgroup.id[0] : index
        %workgroup_count_0 = flow.dispatch.workgroup.count[0] : index
        %workgroup_id_1 = flow.dispatch.workgroup.id[1] : index
        %workgroup_count_1 = flow.dispatch.workgroup.count[1] : index
        %0 = affine.apply #map0()[%workgroup_id_1, %workgroup_size_1]
        %1 = affine.apply #map0()[%workgroup_count_1, %workgroup_size_1]
        scf.for %arg3 = %0 to %c1 step %1 {
          %2 = affine.apply #map0()[%workgroup_id_0, %workgroup_size_0]
          %3 = affine.apply #map0()[%workgroup_count_0, %workgroup_size_0]
          scf.for %arg4 = %2 to %c128 step %3 {
            %4 = affine.min #map1(%arg3)[%workgroup_size_1]
            %5 = affine.min #map2(%arg4)[%workgroup_size_0]
            %6 = flow.dispatch.tensor.load %arg0, offsets = [%arg3, %arg4], sizes = [%4, %5], strides = [1, 1] : !flow.dispatch.tensor<readonly:1x128xf32> -> tensor<?x?xf32>
            %7 = affine.min #map1(%arg3)[%workgroup_size_1]
            %8 = affine.min #map2(%arg4)[%workgroup_size_0]
            %9 = flow.dispatch.tensor.load %arg1, offsets = [%arg3, %arg4], sizes = [%7, %8], strides = [1, 1] : !flow.dispatch.tensor<readonly:1x128xf32> -> tensor<?x?xf32>
            %10 = affine.min #map1(%arg3)[%workgroup_size_1]
            %11 = affine.min #map2(%arg4)[%workgroup_size_0]
            %12 = linalg.init_tensor [%10, %11] : tensor<?x?xf32>
            %13 = linalg.generic {indexing_maps = [#map5, #map5, #map5], iterator_types = ["parallel", "parallel"]} ins(%6, %9 : tensor<?x?xf32>, tensor<?x?xf32>) outs(%12 : tensor<?x?xf32>) attrs =  {__internal_linalg_transform__ = "workgroup"} {
            ^bb0(%arg5: f32, %arg6: f32, %arg7: f32):  // no predecessors
              %14 = addf %arg5, %arg6 : f32
              %15 = cmpf ogt, %14, %cst_0 : f32
              %16 = select %15, %14, %cst_0 : f32
              %17 = cmpf uno, %14, %cst_0 : f32
              %18 = select %17, %cst, %16 : f32
              linalg.yield %18 : f32
            } -> tensor<?x?xf32>
            flow.dispatch.tensor.store %13, %arg2, offsets = [%arg3, %arg4], sizes = [%10, %11], strides = [1, 1] : tensor<?x?xf32> -> !flow.dispatch.tensor<writeonly:1x128xf32>
          }
        }
        return
      }
    }
  }
  flow.executable @predict_dispatch_2 attributes {sym_visibility = "private"} {
    flow.dispatch.entry @predict_dispatch_2 attributes {workgroup_rank = 3 : index}
    module  {
      func @predict_dispatch_2(%arg0: !flow.dispatch.tensor<readonly:1x128xf32>, %arg1: !flow.dispatch.tensor<readonly:128x10xf32>, %arg2: !flow.dispatch.tensor<writeonly:1x10xf32>) {
        %cst = constant 0.000000e+00 : f32
        %c1 = constant 1 : index
        %c10 = constant 10 : index
        %workgroup_size_0 = flow.dispatch.workgroup.size[0] : index
        %workgroup_size_1 = flow.dispatch.workgroup.size[1] : index
        %workgroup_id_0 = flow.dispatch.workgroup.id[0] : index
        %workgroup_count_0 = flow.dispatch.workgroup.count[0] : index
        %workgroup_id_1 = flow.dispatch.workgroup.id[1] : index
        %workgroup_count_1 = flow.dispatch.workgroup.count[1] : index
        %0 = affine.apply #map0()[%workgroup_id_1, %workgroup_size_1]
        %1 = affine.apply #map0()[%workgroup_count_1, %workgroup_size_1]
        scf.for %arg3 = %0 to %c1 step %1 {
          %2 = affine.apply #map0()[%workgroup_id_0, %workgroup_size_0]
          %3 = affine.apply #map0()[%workgroup_count_0, %workgroup_size_0]
          scf.for %arg4 = %2 to %c10 step %3 {
            %4 = affine.min #map1(%arg3)[%workgroup_size_1]
            %5 = flow.dispatch.tensor.load %arg0, offsets = [%arg3, 0], sizes = [%4, 128], strides = [1, 1] : !flow.dispatch.tensor<readonly:1x128xf32> -> tensor<?x128xf32>
            %6 = affine.min #map6(%arg4)[%workgroup_size_0]
            %7 = flow.dispatch.tensor.load %arg1, offsets = [0, %arg4], sizes = [128, %6], strides = [1, 1] : !flow.dispatch.tensor<readonly:128x10xf32> -> tensor<128x?xf32>
            %8 = affine.min #map1(%arg3)[%workgroup_size_1]
            %9 = affine.min #map6(%arg4)[%workgroup_size_0]
            %10 = affine.min #map3(%arg3)[%workgroup_size_1]
            %11 = affine.min #map7(%arg4)[%workgroup_size_0]
            %12 = linalg.init_tensor [%10, %11] : tensor<?x?xf32>
            %13 = linalg.fill(%12, %cst) : tensor<?x?xf32>, f32 -> tensor<?x?xf32> 
            %14 = linalg.matmul {__internal_linalg_transform__ = "workgroup"} ins(%5, %7 : tensor<?x128xf32>, tensor<128x?xf32>) outs(%13 : tensor<?x?xf32>) -> tensor<?x?xf32>
            flow.dispatch.tensor.store %14, %arg2, offsets = [%arg3, %arg4], sizes = [%8, %9], strides = [1, 1] : tensor<?x?xf32> -> !flow.dispatch.tensor<writeonly:1x10xf32>
          }
        }
        return
      }
    }
  }
  flow.executable @predict_dispatch_3 attributes {sym_visibility = "private"} {
    flow.dispatch.entry @predict_dispatch_3 attributes {workgroup_rank = 3 : index}
    module  {
      func @predict_dispatch_3(%arg0: !flow.dispatch.tensor<readonly:1x10xf32>, %arg1: !flow.dispatch.tensor<writeonly:10xf32>) {
        %cst = constant opaque<"_", "0xDEADBEEF"> : tensor<1x10xf32>
        %c1 = constant 1 : index
        %c10 = constant 10 : index
        %workgroup_size_0 = flow.dispatch.workgroup.size[0] : index
        %workgroup_size_1 = flow.dispatch.workgroup.size[1] : index
        %workgroup_id_0 = flow.dispatch.workgroup.id[0] : index
        %workgroup_count_0 = flow.dispatch.workgroup.count[0] : index
        %workgroup_id_1 = flow.dispatch.workgroup.id[1] : index
        %workgroup_count_1 = flow.dispatch.workgroup.count[1] : index
        %0 = affine.apply #map0()[%workgroup_id_1, %workgroup_size_1]
        %1 = affine.apply #map0()[%workgroup_count_1, %workgroup_size_1]
        scf.for %arg2 = %0 to %c1 step %1 {
          %2 = affine.apply #map0()[%workgroup_id_0, %workgroup_size_0]
          %3 = affine.apply #map0()[%workgroup_count_0, %workgroup_size_0]
          scf.for %arg3 = %2 to %c10 step %3 {
            %4 = affine.min #map1(%arg2)[%workgroup_size_1]
            %5 = affine.min #map6(%arg3)[%workgroup_size_0]
            %6 = flow.dispatch.tensor.load %arg0, offsets = [%arg2, %arg3], sizes = [%4, %5], strides = [1, 1] : !flow.dispatch.tensor<readonly:1x10xf32> -> tensor<?x?xf32>
            %7 = affine.min #map1(%arg2)[%workgroup_size_1]
            %8 = affine.min #map6(%arg3)[%workgroup_size_0]
            %9 = subtensor %cst[%arg2, %arg3] [%7, %8] [1, 1] : tensor<1x10xf32> to tensor<?x?xf32>
            %10 = affine.min #map6(%arg3)[%workgroup_size_0]
            %11 = linalg.init_tensor [%10] : tensor<?xf32>
            %12 = linalg.generic {indexing_maps = [#map5, #map5, #map8], iterator_types = ["parallel", "parallel"]} ins(%6, %9 : tensor<?x?xf32>, tensor<?x?xf32>) outs(%11 : tensor<?xf32>) attrs =  {__internal_linalg_transform__ = "workgroup"} {
            ^bb0(%arg4: f32, %arg5: f32, %arg6: f32):  // no predecessors
              %13 = addf %arg4, %arg5 : f32
              linalg.yield %13 : f32
            } -> tensor<?xf32>
            flow.dispatch.tensor.store %12, %arg1, offsets = [%arg3], sizes = [%10], strides = [1] : tensor<?xf32> -> !flow.dispatch.tensor<writeonly:10xf32>
          }
        }
        return
      }
    }
  }
  flow.executable @predict_dispatch_4 attributes {sym_visibility = "private"} {
    flow.dispatch.entry @predict_dispatch_4 attributes {workgroup_rank = 3 : index}
    module  {
      func @predict_dispatch_4(%arg0: !flow.dispatch.tensor<readonly:10xf32>, %arg1: !flow.dispatch.tensor<writeonly:f32>) {
        %cst = constant 0x7FC00000 : f32
        %cst_0 = constant 0xFF800000 : f32
        %0 = flow.dispatch.tensor.load %arg0, offsets = [], sizes = [], strides = [] : !flow.dispatch.tensor<readonly:10xf32> -> tensor<10xf32>
        %1 = linalg.init_tensor [] : tensor<f32>
        %2 = linalg.fill(%1, %cst_0) : tensor<f32>, f32 -> tensor<f32> 
        %3 = linalg.generic {indexing_maps = [#map9, #map10], iterator_types = ["reduction"]} ins(%0 : tensor<10xf32>) outs(%2 : tensor<f32>) {
        ^bb0(%arg2: f32, %arg3: f32):  // no predecessors
          %4 = cmpf ogt, %arg2, %arg3 : f32
          %5 = select %4, %arg2, %arg3 : f32
          %6 = cmpf uno, %arg2, %arg3 : f32
          %7 = select %6, %cst, %5 : f32
          linalg.yield %7 : f32
        } -> tensor<f32>
        flow.dispatch.tensor.store %3, %arg1, offsets = [], sizes = [], strides = [] : tensor<f32> -> !flow.dispatch.tensor<writeonly:f32>
        return
      }
    }
  }
  flow.executable @predict_dispatch_5 attributes {sym_visibility = "private"} {
    flow.dispatch.entry @predict_dispatch_5 attributes {workgroup_rank = 3 : index}
    module  {
      func @predict_dispatch_5(%arg0: !flow.dispatch.tensor<readonly:1x10xf32>, %arg1: !flow.dispatch.tensor<readonly:f32>, %arg2: !flow.dispatch.tensor<writeonly:10xf32>) {
        %cst = constant opaque<"_", "0xDEADBEEF"> : tensor<1x10xf32>
        %c1 = constant 1 : index
        %c10 = constant 10 : index
        %0 = flow.dispatch.tensor.load %arg1, offsets = [], sizes = [], strides = [] : !flow.dispatch.tensor<readonly:f32> -> tensor<f32>
        %workgroup_size_0 = flow.dispatch.workgroup.size[0] : index
        %workgroup_size_1 = flow.dispatch.workgroup.size[1] : index
        %workgroup_id_0 = flow.dispatch.workgroup.id[0] : index
        %workgroup_count_0 = flow.dispatch.workgroup.count[0] : index
        %workgroup_id_1 = flow.dispatch.workgroup.id[1] : index
        %workgroup_count_1 = flow.dispatch.workgroup.count[1] : index
        %1 = affine.apply #map0()[%workgroup_id_1, %workgroup_size_1]
        %2 = affine.apply #map0()[%workgroup_count_1, %workgroup_size_1]
        scf.for %arg3 = %1 to %c1 step %2 {
          %3 = affine.apply #map0()[%workgroup_id_0, %workgroup_size_0]
          %4 = affine.apply #map0()[%workgroup_count_0, %workgroup_size_0]
          scf.for %arg4 = %3 to %c10 step %4 {
            %5 = affine.min #map1(%arg3)[%workgroup_size_1]
            %6 = affine.min #map6(%arg4)[%workgroup_size_0]
            %7 = flow.dispatch.tensor.load %arg0, offsets = [%arg3, %arg4], sizes = [%5, %6], strides = [1, 1] : !flow.dispatch.tensor<readonly:1x10xf32> -> tensor<?x?xf32>
            %8 = affine.min #map1(%arg3)[%workgroup_size_1]
            %9 = affine.min #map6(%arg4)[%workgroup_size_0]
            %10 = subtensor %cst[%arg3, %arg4] [%8, %9] [1, 1] : tensor<1x10xf32> to tensor<?x?xf32>
            %11 = affine.min #map6(%arg4)[%workgroup_size_0]
            %12 = linalg.init_tensor [%11] : tensor<?xf32>
            %13 = linalg.generic {indexing_maps = [#map5, #map5, #map11, #map8], iterator_types = ["parallel", "parallel"]} ins(%7, %10, %0 : tensor<?x?xf32>, tensor<?x?xf32>, tensor<f32>) outs(%12 : tensor<?xf32>) attrs =  {__internal_linalg_transform__ = "workgroup"} {
            ^bb0(%arg5: f32, %arg6: f32, %arg7: f32, %arg8: f32):  // no predecessors
              %14 = addf %arg5, %arg6 : f32
              %15 = subf %14, %arg7 : f32
              %16 = math.exp %15 : f32
              linalg.yield %16 : f32
            } -> tensor<?xf32>
            flow.dispatch.tensor.store %13, %arg2, offsets = [%arg4], sizes = [%11], strides = [1] : tensor<?xf32> -> !flow.dispatch.tensor<writeonly:10xf32>
          }
        }
        return
      }
    }
  }
  flow.executable @predict_dispatch_6 attributes {sym_visibility = "private"} {
    flow.dispatch.entry @predict_dispatch_6 attributes {workgroup_rank = 3 : index}
    module  {
      func @predict_dispatch_6(%arg0: !flow.dispatch.tensor<readonly:10xf32>, %arg1: !flow.dispatch.tensor<writeonly:f32>) {
        %cst = constant 0.000000e+00 : f32
        %0 = flow.dispatch.tensor.load %arg0, offsets = [], sizes = [], strides = [] : !flow.dispatch.tensor<readonly:10xf32> -> tensor<10xf32>
        %1 = linalg.init_tensor [] : tensor<f32>
        %2 = linalg.fill(%1, %cst) : tensor<f32>, f32 -> tensor<f32> 
        %3 = linalg.generic {indexing_maps = [#map9, #map10], iterator_types = ["reduction"]} ins(%0 : tensor<10xf32>) outs(%2 : tensor<f32>) {
        ^bb0(%arg2: f32, %arg3: f32):  // no predecessors
          %4 = addf %arg2, %arg3 : f32
          linalg.yield %4 : f32
        } -> tensor<f32>
        flow.dispatch.tensor.store %3, %arg1, offsets = [], sizes = [], strides = [] : tensor<f32> -> !flow.dispatch.tensor<writeonly:f32>
        return
      }
    }
  }
  flow.executable @predict_dispatch_7 attributes {sym_visibility = "private"} {
    flow.dispatch.entry @predict_dispatch_7 attributes {workgroup_rank = 3 : index}
    module  {
      func @predict_dispatch_7(%arg0: !flow.dispatch.tensor<readonly:1x10xf32>, %arg1: !flow.dispatch.tensor<readonly:f32>, %arg2: !flow.dispatch.tensor<readonly:f32>, %arg3: !flow.dispatch.tensor<writeonly:1x10xf32>) {
        %cst = constant opaque<"_", "0xDEADBEEF"> : tensor<1x10xf32>
        %c1 = constant 1 : index
        %c10 = constant 10 : index
        %0 = flow.dispatch.tensor.load %arg1, offsets = [], sizes = [], strides = [] : !flow.dispatch.tensor<readonly:f32> -> tensor<f32>
        %1 = flow.dispatch.tensor.load %arg2, offsets = [], sizes = [], strides = [] : !flow.dispatch.tensor<readonly:f32> -> tensor<f32>
        %workgroup_size_0 = flow.dispatch.workgroup.size[0] : index
        %workgroup_size_1 = flow.dispatch.workgroup.size[1] : index
        %workgroup_id_0 = flow.dispatch.workgroup.id[0] : index
        %workgroup_count_0 = flow.dispatch.workgroup.count[0] : index
        %workgroup_id_1 = flow.dispatch.workgroup.id[1] : index
        %workgroup_count_1 = flow.dispatch.workgroup.count[1] : index
        %2 = affine.apply #map0()[%workgroup_id_1, %workgroup_size_1]
        %3 = affine.apply #map0()[%workgroup_count_1, %workgroup_size_1]
        scf.for %arg4 = %2 to %c1 step %3 {
          %4 = affine.apply #map0()[%workgroup_id_0, %workgroup_size_0]
          %5 = affine.apply #map0()[%workgroup_count_0, %workgroup_size_0]
          scf.for %arg5 = %4 to %c10 step %5 {
            %6 = affine.min #map1(%arg4)[%workgroup_size_1]
            %7 = affine.min #map6(%arg5)[%workgroup_size_0]
            %8 = flow.dispatch.tensor.load %arg0, offsets = [%arg4, %arg5], sizes = [%6, %7], strides = [1, 1] : !flow.dispatch.tensor<readonly:1x10xf32> -> tensor<?x?xf32>
            %9 = affine.min #map1(%arg4)[%workgroup_size_1]
            %10 = affine.min #map6(%arg5)[%workgroup_size_0]
            %11 = subtensor %cst[%arg4, %arg5] [%9, %10] [1, 1] : tensor<1x10xf32> to tensor<?x?xf32>
            %12 = affine.min #map1(%arg4)[%workgroup_size_1]
            %13 = affine.min #map6(%arg5)[%workgroup_size_0]
            %14 = linalg.init_tensor [%12, %13] : tensor<?x?xf32>
            %15 = linalg.generic {indexing_maps = [#map5, #map5, #map11, #map11, #map5], iterator_types = ["parallel", "parallel"]} ins(%8, %11, %0, %1 : tensor<?x?xf32>, tensor<?x?xf32>, tensor<f32>, tensor<f32>) outs(%14 : tensor<?x?xf32>) attrs =  {__internal_linalg_transform__ = "workgroup"} {
            ^bb0(%arg6: f32, %arg7: f32, %arg8: f32, %arg9: f32, %arg10: f32):  // no predecessors
              %16 = addf %arg6, %arg7 : f32
              %17 = subf %16, %arg8 : f32
              %18 = math.exp %17 : f32
              %19 = divf %18, %arg9 : f32
              linalg.yield %19 : f32
            } -> tensor<?x?xf32>
            flow.dispatch.tensor.store %15, %arg3, offsets = [%arg4, %arg5], sizes = [%12, %13], strides = [1, 1] : tensor<?x?xf32> -> !flow.dispatch.tensor<writeonly:1x10xf32>
          }
        }
        return
      }
    }
  }
  func @predict(%arg0: tensor<1x28x28x1xf32>) -> tensor<1x10xf32> attributes {iree.module.export, iree.reflection = {abi = "sip", abiv = 1 : i32, f = "I15!B11!d1d28d28d1R9!B6!d1d10", fv = "1", sip = "I8!S5!k0_0R3!_0"}} {
    %0 = flow.ex.stream.fragment(%arg0) : (tensor<1x28x28x1xf32>) -> tensor<1x10xf32> =
        (%arg1: tensor<1x28x28x1xf32>) -> tensor<1x10xf32> {
      %c128 = constant 128 : index
      %c1 = constant 1 : index
      %c10 = constant 10 : index
      %const_span = hal.constant.subspan @_const_pool_storage_buffer[#hal.byte_range<512, 401408>] : tensor<784x128xf32>
      %const_span_0 = hal.constant.subspan @_const_pool_storage_buffer[#hal.byte_range<0, 512>] : tensor<1x128xf32>
      %const_span_1 = hal.constant.subspan @_const_pool_storage_buffer[#hal.byte_range<401920, 5120>] : tensor<128x10xf32>
      %1 = flow.tensor.reshape %arg1 : tensor<1x28x28x1xf32> -> tensor<1x784xf32>
      %2 = flow.dispatch @predict_dispatch_0::@predict_dispatch_0[%c128, %c1, %c1](%1, %const_span) : (tensor<1x784xf32>, tensor<784x128xf32>) -> tensor<1x128xf32>
      %3 = flow.dispatch @predict_dispatch_1::@predict_dispatch_1[%c128, %c1, %c1](%2, %const_span_0) : (tensor<1x128xf32>, tensor<1x128xf32>) -> tensor<1x128xf32>
      %4 = flow.dispatch @predict_dispatch_2::@predict_dispatch_2[%c10, %c1, %c1](%3, %const_span_1) : (tensor<1x128xf32>, tensor<128x10xf32>) -> tensor<1x10xf32>
      %5 = flow.dispatch @predict_dispatch_3::@predict_dispatch_3[%c10, %c1, %c1](%4) : (tensor<1x10xf32>) -> tensor<10xf32>
      %6 = flow.dispatch @predict_dispatch_4::@predict_dispatch_4[%c1, %c1, %c1](%5) : (tensor<10xf32>) -> tensor<f32>
      %7 = flow.dispatch @predict_dispatch_5::@predict_dispatch_5[%c10, %c1, %c1](%4, %6) : (tensor<1x10xf32>, tensor<f32>) -> tensor<10xf32>
      %8 = flow.dispatch @predict_dispatch_6::@predict_dispatch_6[%c1, %c1, %c1](%7) : (tensor<10xf32>) -> tensor<f32>
      %9 = flow.dispatch @predict_dispatch_7::@predict_dispatch_7[%c10, %c1, %c1](%4, %6, %8) : (tensor<1x10xf32>, tensor<f32>, tensor<f32>) -> tensor<1x10xf32>
      flow.return %9 : tensor<1x10xf32>
    }
    return %0 : tensor<1x10xf32>
  }
}


// *** IR Dump After SymbolDCE ***
#map0 = affine_map<()[s0, s1] -> (s0 * s1)>
#map1 = affine_map<(d0)[s0] -> (s0, -d0 + 1)>
#map2 = affine_map<(d0)[s0] -> (s0, -d0 + 128)>
#map3 = affine_map<(d0)[s0] -> (-d0 + 1, s0)>
#map4 = affine_map<(d0)[s0] -> (-d0 + 128, s0)>
#map5 = affine_map<(d0, d1) -> (d0, d1)>
#map6 = affine_map<(d0)[s0] -> (s0, -d0 + 10)>
#map7 = affine_map<(d0)[s0] -> (-d0 + 10, s0)>
#map8 = affine_map<(d0, d1) -> (d1)>
#map9 = affine_map<(d0) -> (d0)>
#map10 = affine_map<(d0) -> ()>
#map11 = affine_map<(d0, d1) -> ()>
module  {
  hal.constant_pool @_const_pool attributes {buffer_constraints = #hal.buffer_constraints<max_allocation_size = 1073741824, min_buffer_offset_alignment = 16, max_buffer_range = 1073741824, min_buffer_range_alignment = 16>, sym_visibility = "private"} {
    hal.constant_storage @_storage = opaque<"_", "0xDEADBEEF"> : vector<407040xi8> attributes {sym_visibility = "nested"}
  }
  hal.variable @_const_pool_storage_buffer init(@_const_pool_storage_buffer_initializer) : !hal.buffer attributes {sym_visibility = "private"}
  func private @_const_pool_storage_buffer_initializer() -> !hal.buffer {
    %c0 = constant 0 : index
    %c407040 = constant 407040 : index
    %device = hal.ex.shared_device : !hal.device
    %allocator = hal.device.allocator<%device : !hal.device> : !hal.allocator
    %storage = hal.constant_storage.lookup @_const_pool::@_storage : !iree.byte_buffer
    %mapped = hal.allocator.map<%allocator : !hal.allocator> source(%storage : !iree.byte_buffer)[%c0, %c407040] type("HostVisible|DeviceVisible|DeviceLocal") usage("Constant|Transfer|Mapping|Dispatch") : !hal.buffer
    return %mapped : !hal.buffer
  }
  flow.executable @predict_dispatch_0 attributes {sym_visibility = "private"} {
    flow.dispatch.entry @predict_dispatch_0 attributes {workgroup_rank = 3 : index}
    module  {
      func @predict_dispatch_0(%arg0: !flow.dispatch.tensor<readonly:1x784xf32>, %arg1: !flow.dispatch.tensor<readonly:784x128xf32>, %arg2: !flow.dispatch.tensor<writeonly:1x128xf32>) {
        %cst = constant 0.000000e+00 : f32
        %c1 = constant 1 : index
        %c128 = constant 128 : index
        %workgroup_size_0 = flow.dispatch.workgroup.size[0] : index
        %workgroup_size_1 = flow.dispatch.workgroup.size[1] : index
        %workgroup_id_0 = flow.dispatch.workgroup.id[0] : index
        %workgroup_count_0 = flow.dispatch.workgroup.count[0] : index
        %workgroup_id_1 = flow.dispatch.workgroup.id[1] : index
        %workgroup_count_1 = flow.dispatch.workgroup.count[1] : index
        %0 = affine.apply #map0()[%workgroup_id_1, %workgroup_size_1]
        %1 = affine.apply #map0()[%workgroup_count_1, %workgroup_size_1]
        scf.for %arg3 = %0 to %c1 step %1 {
          %2 = affine.apply #map0()[%workgroup_id_0, %workgroup_size_0]
          %3 = affine.apply #map0()[%workgroup_count_0, %workgroup_size_0]
          scf.for %arg4 = %2 to %c128 step %3 {
            %4 = affine.min #map1(%arg3)[%workgroup_size_1]
            %5 = flow.dispatch.tensor.load %arg0, offsets = [%arg3, 0], sizes = [%4, 784], strides = [1, 1] : !flow.dispatch.tensor<readonly:1x784xf32> -> tensor<?x784xf32>
            %6 = affine.min #map2(%arg4)[%workgroup_size_0]
            %7 = flow.dispatch.tensor.load %arg1, offsets = [0, %arg4], sizes = [784, %6], strides = [1, 1] : !flow.dispatch.tensor<readonly:784x128xf32> -> tensor<784x?xf32>
            %8 = affine.min #map1(%arg3)[%workgroup_size_1]
            %9 = affine.min #map2(%arg4)[%workgroup_size_0]
            %10 = affine.min #map3(%arg3)[%workgroup_size_1]
            %11 = affine.min #map4(%arg4)[%workgroup_size_0]
            %12 = linalg.init_tensor [%10, %11] : tensor<?x?xf32>
            %13 = linalg.fill(%12, %cst) : tensor<?x?xf32>, f32 -> tensor<?x?xf32> 
            %14 = linalg.matmul {__internal_linalg_transform__ = "workgroup"} ins(%5, %7 : tensor<?x784xf32>, tensor<784x?xf32>) outs(%13 : tensor<?x?xf32>) -> tensor<?x?xf32>
            flow.dispatch.tensor.store %14, %arg2, offsets = [%arg3, %arg4], sizes = [%8, %9], strides = [1, 1] : tensor<?x?xf32> -> !flow.dispatch.tensor<writeonly:1x128xf32>
          }
        }
        return
      }
    }
  }
  flow.executable @predict_dispatch_1 attributes {sym_visibility = "private"} {
    flow.dispatch.entry @predict_dispatch_1 attributes {workgroup_rank = 3 : index}
    module  {
      func @predict_dispatch_1(%arg0: !flow.dispatch.tensor<readonly:1x128xf32>, %arg1: !flow.dispatch.tensor<readonly:1x128xf32>, %arg2: !flow.dispatch.tensor<writeonly:1x128xf32>) {
        %cst = constant 0x7FC00000 : f32
        %cst_0 = constant 0.000000e+00 : f32
        %c1 = constant 1 : index
        %c128 = constant 128 : index
        %workgroup_size_0 = flow.dispatch.workgroup.size[0] : index
        %workgroup_size_1 = flow.dispatch.workgroup.size[1] : index
        %workgroup_id_0 = flow.dispatch.workgroup.id[0] : index
        %workgroup_count_0 = flow.dispatch.workgroup.count[0] : index
        %workgroup_id_1 = flow.dispatch.workgroup.id[1] : index
        %workgroup_count_1 = flow.dispatch.workgroup.count[1] : index
        %0 = affine.apply #map0()[%workgroup_id_1, %workgroup_size_1]
        %1 = affine.apply #map0()[%workgroup_count_1, %workgroup_size_1]
        scf.for %arg3 = %0 to %c1 step %1 {
          %2 = affine.apply #map0()[%workgroup_id_0, %workgroup_size_0]
          %3 = affine.apply #map0()[%workgroup_count_0, %workgroup_size_0]
          scf.for %arg4 = %2 to %c128 step %3 {
            %4 = affine.min #map1(%arg3)[%workgroup_size_1]
            %5 = affine.min #map2(%arg4)[%workgroup_size_0]
            %6 = flow.dispatch.tensor.load %arg0, offsets = [%arg3, %arg4], sizes = [%4, %5], strides = [1, 1] : !flow.dispatch.tensor<readonly:1x128xf32> -> tensor<?x?xf32>
            %7 = affine.min #map1(%arg3)[%workgroup_size_1]
            %8 = affine.min #map2(%arg4)[%workgroup_size_0]
            %9 = flow.dispatch.tensor.load %arg1, offsets = [%arg3, %arg4], sizes = [%7, %8], strides = [1, 1] : !flow.dispatch.tensor<readonly:1x128xf32> -> tensor<?x?xf32>
            %10 = affine.min #map1(%arg3)[%workgroup_size_1]
            %11 = affine.min #map2(%arg4)[%workgroup_size_0]
            %12 = linalg.init_tensor [%10, %11] : tensor<?x?xf32>
            %13 = linalg.generic {indexing_maps = [#map5, #map5, #map5], iterator_types = ["parallel", "parallel"]} ins(%6, %9 : tensor<?x?xf32>, tensor<?x?xf32>) outs(%12 : tensor<?x?xf32>) attrs =  {__internal_linalg_transform__ = "workgroup"} {
            ^bb0(%arg5: f32, %arg6: f32, %arg7: f32):  // no predecessors
              %14 = addf %arg5, %arg6 : f32
              %15 = cmpf ogt, %14, %cst_0 : f32
              %16 = select %15, %14, %cst_0 : f32
              %17 = cmpf uno, %14, %cst_0 : f32
              %18 = select %17, %cst, %16 : f32
              linalg.yield %18 : f32
            } -> tensor<?x?xf32>
            flow.dispatch.tensor.store %13, %arg2, offsets = [%arg3, %arg4], sizes = [%10, %11], strides = [1, 1] : tensor<?x?xf32> -> !flow.dispatch.tensor<writeonly:1x128xf32>
          }
        }
        return
      }
    }
  }
  flow.executable @predict_dispatch_2 attributes {sym_visibility = "private"} {
    flow.dispatch.entry @predict_dispatch_2 attributes {workgroup_rank = 3 : index}
    module  {
      func @predict_dispatch_2(%arg0: !flow.dispatch.tensor<readonly:1x128xf32>, %arg1: !flow.dispatch.tensor<readonly:128x10xf32>, %arg2: !flow.dispatch.tensor<writeonly:1x10xf32>) {
        %cst = constant 0.000000e+00 : f32
        %c1 = constant 1 : index
        %c10 = constant 10 : index
        %workgroup_size_0 = flow.dispatch.workgroup.size[0] : index
        %workgroup_size_1 = flow.dispatch.workgroup.size[1] : index
        %workgroup_id_0 = flow.dispatch.workgroup.id[0] : index
        %workgroup_count_0 = flow.dispatch.workgroup.count[0] : index
        %workgroup_id_1 = flow.dispatch.workgroup.id[1] : index
        %workgroup_count_1 = flow.dispatch.workgroup.count[1] : index
        %0 = affine.apply #map0()[%workgroup_id_1, %workgroup_size_1]
        %1 = affine.apply #map0()[%workgroup_count_1, %workgroup_size_1]
        scf.for %arg3 = %0 to %c1 step %1 {
          %2 = affine.apply #map0()[%workgroup_id_0, %workgroup_size_0]
          %3 = affine.apply #map0()[%workgroup_count_0, %workgroup_size_0]
          scf.for %arg4 = %2 to %c10 step %3 {
            %4 = affine.min #map1(%arg3)[%workgroup_size_1]
            %5 = flow.dispatch.tensor.load %arg0, offsets = [%arg3, 0], sizes = [%4, 128], strides = [1, 1] : !flow.dispatch.tensor<readonly:1x128xf32> -> tensor<?x128xf32>
            %6 = affine.min #map6(%arg4)[%workgroup_size_0]
            %7 = flow.dispatch.tensor.load %arg1, offsets = [0, %arg4], sizes = [128, %6], strides = [1, 1] : !flow.dispatch.tensor<readonly:128x10xf32> -> tensor<128x?xf32>
            %8 = affine.min #map1(%arg3)[%workgroup_size_1]
            %9 = affine.min #map6(%arg4)[%workgroup_size_0]
            %10 = affine.min #map3(%arg3)[%workgroup_size_1]
            %11 = affine.min #map7(%arg4)[%workgroup_size_0]
            %12 = linalg.init_tensor [%10, %11] : tensor<?x?xf32>
            %13 = linalg.fill(%12, %cst) : tensor<?x?xf32>, f32 -> tensor<?x?xf32> 
            %14 = linalg.matmul {__internal_linalg_transform__ = "workgroup"} ins(%5, %7 : tensor<?x128xf32>, tensor<128x?xf32>) outs(%13 : tensor<?x?xf32>) -> tensor<?x?xf32>
            flow.dispatch.tensor.store %14, %arg2, offsets = [%arg3, %arg4], sizes = [%8, %9], strides = [1, 1] : tensor<?x?xf32> -> !flow.dispatch.tensor<writeonly:1x10xf32>
          }
        }
        return
      }
    }
  }
  flow.executable @predict_dispatch_3 attributes {sym_visibility = "private"} {
    flow.dispatch.entry @predict_dispatch_3 attributes {workgroup_rank = 3 : index}
    module  {
      func @predict_dispatch_3(%arg0: !flow.dispatch.tensor<readonly:1x10xf32>, %arg1: !flow.dispatch.tensor<writeonly:10xf32>) {
        %cst = constant opaque<"_", "0xDEADBEEF"> : tensor<1x10xf32>
        %c1 = constant 1 : index
        %c10 = constant 10 : index
        %workgroup_size_0 = flow.dispatch.workgroup.size[0] : index
        %workgroup_size_1 = flow.dispatch.workgroup.size[1] : index
        %workgroup_id_0 = flow.dispatch.workgroup.id[0] : index
        %workgroup_count_0 = flow.dispatch.workgroup.count[0] : index
        %workgroup_id_1 = flow.dispatch.workgroup.id[1] : index
        %workgroup_count_1 = flow.dispatch.workgroup.count[1] : index
        %0 = affine.apply #map0()[%workgroup_id_1, %workgroup_size_1]
        %1 = affine.apply #map0()[%workgroup_count_1, %workgroup_size_1]
        scf.for %arg2 = %0 to %c1 step %1 {
          %2 = affine.apply #map0()[%workgroup_id_0, %workgroup_size_0]
          %3 = affine.apply #map0()[%workgroup_count_0, %workgroup_size_0]
          scf.for %arg3 = %2 to %c10 step %3 {
            %4 = affine.min #map1(%arg2)[%workgroup_size_1]
            %5 = affine.min #map6(%arg3)[%workgroup_size_0]
            %6 = flow.dispatch.tensor.load %arg0, offsets = [%arg2, %arg3], sizes = [%4, %5], strides = [1, 1] : !flow.dispatch.tensor<readonly:1x10xf32> -> tensor<?x?xf32>
            %7 = affine.min #map1(%arg2)[%workgroup_size_1]
            %8 = affine.min #map6(%arg3)[%workgroup_size_0]
            %9 = subtensor %cst[%arg2, %arg3] [%7, %8] [1, 1] : tensor<1x10xf32> to tensor<?x?xf32>
            %10 = affine.min #map6(%arg3)[%workgroup_size_0]
            %11 = linalg.init_tensor [%10] : tensor<?xf32>
            %12 = linalg.generic {indexing_maps = [#map5, #map5, #map8], iterator_types = ["parallel", "parallel"]} ins(%6, %9 : tensor<?x?xf32>, tensor<?x?xf32>) outs(%11 : tensor<?xf32>) attrs =  {__internal_linalg_transform__ = "workgroup"} {
            ^bb0(%arg4: f32, %arg5: f32, %arg6: f32):  // no predecessors
              %13 = addf %arg4, %arg5 : f32
              linalg.yield %13 : f32
            } -> tensor<?xf32>
            flow.dispatch.tensor.store %12, %arg1, offsets = [%arg3], sizes = [%10], strides = [1] : tensor<?xf32> -> !flow.dispatch.tensor<writeonly:10xf32>
          }
        }
        return
      }
    }
  }
  flow.executable @predict_dispatch_4 attributes {sym_visibility = "private"} {
    flow.dispatch.entry @predict_dispatch_4 attributes {workgroup_rank = 3 : index}
    module  {
      func @predict_dispatch_4(%arg0: !flow.dispatch.tensor<readonly:10xf32>, %arg1: !flow.dispatch.tensor<writeonly:f32>) {
        %cst = constant 0x7FC00000 : f32
        %cst_0 = constant 0xFF800000 : f32
        %0 = flow.dispatch.tensor.load %arg0, offsets = [], sizes = [], strides = [] : !flow.dispatch.tensor<readonly:10xf32> -> tensor<10xf32>
        %1 = linalg.init_tensor [] : tensor<f32>
        %2 = linalg.fill(%1, %cst_0) : tensor<f32>, f32 -> tensor<f32> 
        %3 = linalg.generic {indexing_maps = [#map9, #map10], iterator_types = ["reduction"]} ins(%0 : tensor<10xf32>) outs(%2 : tensor<f32>) {
        ^bb0(%arg2: f32, %arg3: f32):  // no predecessors
          %4 = cmpf ogt, %arg2, %arg3 : f32
          %5 = select %4, %arg2, %arg3 : f32
          %6 = cmpf uno, %arg2, %arg3 : f32
          %7 = select %6, %cst, %5 : f32
          linalg.yield %7 : f32
        } -> tensor<f32>
        flow.dispatch.tensor.store %3, %arg1, offsets = [], sizes = [], strides = [] : tensor<f32> -> !flow.dispatch.tensor<writeonly:f32>
        return
      }
    }
  }
  flow.executable @predict_dispatch_5 attributes {sym_visibility = "private"} {
    flow.dispatch.entry @predict_dispatch_5 attributes {workgroup_rank = 3 : index}
    module  {
      func @predict_dispatch_5(%arg0: !flow.dispatch.tensor<readonly:1x10xf32>, %arg1: !flow.dispatch.tensor<readonly:f32>, %arg2: !flow.dispatch.tensor<writeonly:10xf32>) {
        %cst = constant opaque<"_", "0xDEADBEEF"> : tensor<1x10xf32>
        %c1 = constant 1 : index
        %c10 = constant 10 : index
        %0 = flow.dispatch.tensor.load %arg1, offsets = [], sizes = [], strides = [] : !flow.dispatch.tensor<readonly:f32> -> tensor<f32>
        %workgroup_size_0 = flow.dispatch.workgroup.size[0] : index
        %workgroup_size_1 = flow.dispatch.workgroup.size[1] : index
        %workgroup_id_0 = flow.dispatch.workgroup.id[0] : index
        %workgroup_count_0 = flow.dispatch.workgroup.count[0] : index
        %workgroup_id_1 = flow.dispatch.workgroup.id[1] : index
        %workgroup_count_1 = flow.dispatch.workgroup.count[1] : index
        %1 = affine.apply #map0()[%workgroup_id_1, %workgroup_size_1]
        %2 = affine.apply #map0()[%workgroup_count_1, %workgroup_size_1]
        scf.for %arg3 = %1 to %c1 step %2 {
          %3 = affine.apply #map0()[%workgroup_id_0, %workgroup_size_0]
          %4 = affine.apply #map0()[%workgroup_count_0, %workgroup_size_0]
          scf.for %arg4 = %3 to %c10 step %4 {
            %5 = affine.min #map1(%arg3)[%workgroup_size_1]
            %6 = affine.min #map6(%arg4)[%workgroup_size_0]
            %7 = flow.dispatch.tensor.load %arg0, offsets = [%arg3, %arg4], sizes = [%5, %6], strides = [1, 1] : !flow.dispatch.tensor<readonly:1x10xf32> -> tensor<?x?xf32>
            %8 = affine.min #map1(%arg3)[%workgroup_size_1]
            %9 = affine.min #map6(%arg4)[%workgroup_size_0]
            %10 = subtensor %cst[%arg3, %arg4] [%8, %9] [1, 1] : tensor<1x10xf32> to tensor<?x?xf32>
            %11 = affine.min #map6(%arg4)[%workgroup_size_0]
            %12 = linalg.init_tensor [%11] : tensor<?xf32>
            %13 = linalg.generic {indexing_maps = [#map5, #map5, #map11, #map8], iterator_types = ["parallel", "parallel"]} ins(%7, %10, %0 : tensor<?x?xf32>, tensor<?x?xf32>, tensor<f32>) outs(%12 : tensor<?xf32>) attrs =  {__internal_linalg_transform__ = "workgroup"} {
            ^bb0(%arg5: f32, %arg6: f32, %arg7: f32, %arg8: f32):  // no predecessors
              %14 = addf %arg5, %arg6 : f32
              %15 = subf %14, %arg7 : f32
              %16 = math.exp %15 : f32
              linalg.yield %16 : f32
            } -> tensor<?xf32>
            flow.dispatch.tensor.store %13, %arg2, offsets = [%arg4], sizes = [%11], strides = [1] : tensor<?xf32> -> !flow.dispatch.tensor<writeonly:10xf32>
          }
        }
        return
      }
    }
  }
  flow.executable @predict_dispatch_6 attributes {sym_visibility = "private"} {
    flow.dispatch.entry @predict_dispatch_6 attributes {workgroup_rank = 3 : index}
    module  {
      func @predict_dispatch_6(%arg0: !flow.dispatch.tensor<readonly:10xf32>, %arg1: !flow.dispatch.tensor<writeonly:f32>) {
        %cst = constant 0.000000e+00 : f32
        %0 = flow.dispatch.tensor.load %arg0, offsets = [], sizes = [], strides = [] : !flow.dispatch.tensor<readonly:10xf32> -> tensor<10xf32>
        %1 = linalg.init_tensor [] : tensor<f32>
        %2 = linalg.fill(%1, %cst) : tensor<f32>, f32 -> tensor<f32> 
        %3 = linalg.generic {indexing_maps = [#map9, #map10], iterator_types = ["reduction"]} ins(%0 : tensor<10xf32>) outs(%2 : tensor<f32>) {
        ^bb0(%arg2: f32, %arg3: f32):  // no predecessors
          %4 = addf %arg2, %arg3 : f32
          linalg.yield %4 : f32
        } -> tensor<f32>
        flow.dispatch.tensor.store %3, %arg1, offsets = [], sizes = [], strides = [] : tensor<f32> -> !flow.dispatch.tensor<writeonly:f32>
        return
      }
    }
  }
  flow.executable @predict_dispatch_7 attributes {sym_visibility = "private"} {
    flow.dispatch.entry @predict_dispatch_7 attributes {workgroup_rank = 3 : index}
    module  {
      func @predict_dispatch_7(%arg0: !flow.dispatch.tensor<readonly:1x10xf32>, %arg1: !flow.dispatch.tensor<readonly:f32>, %arg2: !flow.dispatch.tensor<readonly:f32>, %arg3: !flow.dispatch.tensor<writeonly:1x10xf32>) {
        %cst = constant opaque<"_", "0xDEADBEEF"> : tensor<1x10xf32>
        %c1 = constant 1 : index
        %c10 = constant 10 : index
        %0 = flow.dispatch.tensor.load %arg1, offsets = [], sizes = [], strides = [] : !flow.dispatch.tensor<readonly:f32> -> tensor<f32>
        %1 = flow.dispatch.tensor.load %arg2, offsets = [], sizes = [], strides = [] : !flow.dispatch.tensor<readonly:f32> -> tensor<f32>
        %workgroup_size_0 = flow.dispatch.workgroup.size[0] : index
        %workgroup_size_1 = flow.dispatch.workgroup.size[1] : index
        %workgroup_id_0 = flow.dispatch.workgroup.id[0] : index
        %workgroup_count_0 = flow.dispatch.workgroup.count[0] : index
        %workgroup_id_1 = flow.dispatch.workgroup.id[1] : index
        %workgroup_count_1 = flow.dispatch.workgroup.count[1] : index
        %2 = affine.apply #map0()[%workgroup_id_1, %workgroup_size_1]
        %3 = affine.apply #map0()[%workgroup_count_1, %workgroup_size_1]
        scf.for %arg4 = %2 to %c1 step %3 {
          %4 = affine.apply #map0()[%workgroup_id_0, %workgroup_size_0]
          %5 = affine.apply #map0()[%workgroup_count_0, %workgroup_size_0]
          scf.for %arg5 = %4 to %c10 step %5 {
            %6 = affine.min #map1(%arg4)[%workgroup_size_1]
            %7 = affine.min #map6(%arg5)[%workgroup_size_0]
            %8 = flow.dispatch.tensor.load %arg0, offsets = [%arg4, %arg5], sizes = [%6, %7], strides = [1, 1] : !flow.dispatch.tensor<readonly:1x10xf32> -> tensor<?x?xf32>
            %9 = affine.min #map1(%arg4)[%workgroup_size_1]
            %10 = affine.min #map6(%arg5)[%workgroup_size_0]
            %11 = subtensor %cst[%arg4, %arg5] [%9, %10] [1, 1] : tensor<1x10xf32> to tensor<?x?xf32>
            %12 = affine.min #map1(%arg4)[%workgroup_size_1]
            %13 = affine.min #map6(%arg5)[%workgroup_size_0]
            %14 = linalg.init_tensor [%12, %13] : tensor<?x?xf32>
            %15 = linalg.generic {indexing_maps = [#map5, #map5, #map11, #map11, #map5], iterator_types = ["parallel", "parallel"]} ins(%8, %11, %0, %1 : tensor<?x?xf32>, tensor<?x?xf32>, tensor<f32>, tensor<f32>) outs(%14 : tensor<?x?xf32>) attrs =  {__internal_linalg_transform__ = "workgroup"} {
            ^bb0(%arg6: f32, %arg7: f32, %arg8: f32, %arg9: f32, %arg10: f32):  // no predecessors
              %16 = addf %arg6, %arg7 : f32
              %17 = subf %16, %arg8 : f32
              %18 = math.exp %17 : f32
              %19 = divf %18, %arg9 : f32
              linalg.yield %19 : f32
            } -> tensor<?x?xf32>
            flow.dispatch.tensor.store %15, %arg3, offsets = [%arg4, %arg5], sizes = [%12, %13], strides = [1, 1] : tensor<?x?xf32> -> !flow.dispatch.tensor<writeonly:1x10xf32>
          }
        }
        return
      }
    }
  }
  func @predict(%arg0: tensor<1x28x28x1xf32>) -> tensor<1x10xf32> attributes {iree.module.export, iree.reflection = {abi = "sip", abiv = 1 : i32, f = "I15!B11!d1d28d28d1R9!B6!d1d10", fv = "1", sip = "I8!S5!k0_0R3!_0"}} {
    %0 = flow.ex.stream.fragment(%arg0) : (tensor<1x28x28x1xf32>) -> tensor<1x10xf32> =
        (%arg1: tensor<1x28x28x1xf32>) -> tensor<1x10xf32> {
      %c128 = constant 128 : index
      %c1 = constant 1 : index
      %c10 = constant 10 : index
      %const_span = hal.constant.subspan @_const_pool_storage_buffer[#hal.byte_range<512, 401408>] : tensor<784x128xf32>
      %const_span_0 = hal.constant.subspan @_const_pool_storage_buffer[#hal.byte_range<0, 512>] : tensor<1x128xf32>
      %const_span_1 = hal.constant.subspan @_const_pool_storage_buffer[#hal.byte_range<401920, 5120>] : tensor<128x10xf32>
      %1 = flow.tensor.reshape %arg1 : tensor<1x28x28x1xf32> -> tensor<1x784xf32>
      %2 = flow.dispatch @predict_dispatch_0::@predict_dispatch_0[%c128, %c1, %c1](%1, %const_span) : (tensor<1x784xf32>, tensor<784x128xf32>) -> tensor<1x128xf32>
      %3 = flow.dispatch @predict_dispatch_1::@predict_dispatch_1[%c128, %c1, %c1](%2, %const_span_0) : (tensor<1x128xf32>, tensor<1x128xf32>) -> tensor<1x128xf32>
      %4 = flow.dispatch @predict_dispatch_2::@predict_dispatch_2[%c10, %c1, %c1](%3, %const_span_1) : (tensor<1x128xf32>, tensor<128x10xf32>) -> tensor<1x10xf32>
      %5 = flow.dispatch @predict_dispatch_3::@predict_dispatch_3[%c10, %c1, %c1](%4) : (tensor<1x10xf32>) -> tensor<10xf32>
      %6 = flow.dispatch @predict_dispatch_4::@predict_dispatch_4[%c1, %c1, %c1](%5) : (tensor<10xf32>) -> tensor<f32>
      %7 = flow.dispatch @predict_dispatch_5::@predict_dispatch_5[%c10, %c1, %c1](%4, %6) : (tensor<1x10xf32>, tensor<f32>) -> tensor<10xf32>
      %8 = flow.dispatch @predict_dispatch_6::@predict_dispatch_6[%c1, %c1, %c1](%7) : (tensor<10xf32>) -> tensor<f32>
      %9 = flow.dispatch @predict_dispatch_7::@predict_dispatch_7[%c10, %c1, %c1](%4, %6, %8) : (tensor<1x10xf32>, tensor<f32>, tensor<f32>) -> tensor<1x10xf32>
      flow.return %9 : tensor<1x10xf32>
    }
    return %0 : tensor<1x10xf32>
  }
}


// *** IR Dump After mlir::iree_compiler::IREE::HAL::MaterializeInterfacesPass ***
#map0 = affine_map<()[s0, s1] -> (s0 * s1)>
#map1 = affine_map<(d0)[s0] -> (s0, -d0 + 1)>
#map2 = affine_map<(d0)[s0] -> (s0, -d0 + 128)>
#map3 = affine_map<(d0)[s0] -> (-d0 + 1, s0)>
#map4 = affine_map<(d0)[s0] -> (-d0 + 128, s0)>
#map5 = affine_map<(d0, d1) -> (d0, d1)>
#map6 = affine_map<(d0)[s0] -> (s0, -d0 + 10)>
#map7 = affine_map<(d0)[s0] -> (-d0 + 10, s0)>
#map8 = affine_map<(d0, d1) -> (d1)>
#map9 = affine_map<(d0) -> (d0)>
#map10 = affine_map<(d0) -> ()>
#map11 = affine_map<(d0, d1) -> ()>
module  {
  hal.constant_pool @_const_pool attributes {buffer_constraints = #hal.buffer_constraints<max_allocation_size = 1073741824, min_buffer_offset_alignment = 16, max_buffer_range = 1073741824, min_buffer_range_alignment = 16>, sym_visibility = "private"} {
    hal.constant_storage @_storage = opaque<"_", "0xDEADBEEF"> : vector<407040xi8> attributes {sym_visibility = "nested"}
  }
  hal.variable @_const_pool_storage_buffer init(@_const_pool_storage_buffer_initializer) : !hal.buffer attributes {sym_visibility = "private"}
  func private @_const_pool_storage_buffer_initializer() -> !hal.buffer {
    %c0 = constant 0 : index
    %c407040 = constant 407040 : index
    %device = hal.ex.shared_device : !hal.device
    %allocator = hal.device.allocator<%device : !hal.device> : !hal.allocator
    %storage = hal.constant_storage.lookup @_const_pool::@_storage : !iree.byte_buffer
    %mapped = hal.allocator.map<%allocator : !hal.allocator> source(%storage : !iree.byte_buffer)[%c0, %c407040] type("HostVisible|DeviceVisible|DeviceLocal") usage("Constant|Transfer|Mapping|Dispatch") : !hal.buffer
    return %mapped : !hal.buffer
  }
  hal.executable @predict_dispatch_0 attributes {sym_visibility = "private"} {
    hal.interface @io {
      hal.interface.binding @s0b0_ro_constant, set=0, binding=0, type="StorageBuffer", access="Read"
      hal.interface.binding @s0b1_ro_external, set=0, binding=1, type="StorageBuffer", access="Read"
      hal.interface.binding @s0b2_xw_external, set=0, binding=2, type="StorageBuffer", access="Write|Discard"
    }
    hal.executable.target @llvm_aot, filter="dylib*" {
      hal.executable.entry_point @predict_dispatch_0 attributes {interface = @io, ordinal = 0 : index}
      module  {
        func @predict_dispatch_0() {
          %c0 = constant 0 : index
          %cst = constant 0.000000e+00 : f32
          %c1 = constant 1 : index
          %c128 = constant 128 : index
          %0 = hal.interface.binding.subspan @io::@s0b1_ro_external[%c0] : !flow.dispatch.tensor<readonly:1x784xf32>
          %1 = hal.interface.binding.subspan @io::@s0b0_ro_constant[%c0] : !flow.dispatch.tensor<readonly:784x128xf32>
          %2 = hal.interface.binding.subspan @io::@s0b2_xw_external[%c0] : !flow.dispatch.tensor<writeonly:1x128xf32>
          %workgroup_size_x = hal.interface.workgroup.size[0] : index
          %workgroup_size_y = hal.interface.workgroup.size[1] : index
          %workgroup_id_x = hal.interface.workgroup.id[0] : index
          %workgroup_count_x = hal.interface.workgroup.count[0] : index
          %workgroup_id_y = hal.interface.workgroup.id[1] : index
          %workgroup_count_y = hal.interface.workgroup.count[1] : index
          %3 = affine.apply #map0()[%workgroup_id_y, %workgroup_size_y]
          %4 = affine.apply #map0()[%workgroup_count_y, %workgroup_size_y]
          scf.for %arg0 = %3 to %c1 step %4 {
            %5 = affine.apply #map0()[%workgroup_id_x, %workgroup_size_x]
            %6 = affine.apply #map0()[%workgroup_count_x, %workgroup_size_x]
            scf.for %arg1 = %5 to %c128 step %6 {
              %7 = affine.min #map1(%arg0)[%workgroup_size_y]
              %8 = flow.dispatch.tensor.load %0, offsets = [%arg0, 0], sizes = [%7, 784], strides = [1, 1] : !flow.dispatch.tensor<readonly:1x784xf32> -> tensor<?x784xf32>
              %9 = affine.min #map2(%arg1)[%workgroup_size_x]
              %10 = flow.dispatch.tensor.load %1, offsets = [0, %arg1], sizes = [784, %9], strides = [1, 1] : !flow.dispatch.tensor<readonly:784x128xf32> -> tensor<784x?xf32>
              %11 = affine.min #map1(%arg0)[%workgroup_size_y]
              %12 = affine.min #map2(%arg1)[%workgroup_size_x]
              %13 = affine.min #map3(%arg0)[%workgroup_size_y]
              %14 = affine.min #map4(%arg1)[%workgroup_size_x]
              %15 = linalg.init_tensor [%13, %14] : tensor<?x?xf32>
              %16 = linalg.fill(%15, %cst) : tensor<?x?xf32>, f32 -> tensor<?x?xf32> 
              %17 = linalg.matmul {__internal_linalg_transform__ = "workgroup"} ins(%8, %10 : tensor<?x784xf32>, tensor<784x?xf32>) outs(%16 : tensor<?x?xf32>) -> tensor<?x?xf32>
              flow.dispatch.tensor.store %17, %2, offsets = [%arg0, %arg1], sizes = [%11, %12], strides = [1, 1] : tensor<?x?xf32> -> !flow.dispatch.tensor<writeonly:1x128xf32>
            }
          }
          return
        }
        hal.interface @io attributes {sym_visibility = "private"} {
          hal.interface.binding @s0b0_ro_constant, set=0, binding=0, type="StorageBuffer", access="Read"
          hal.interface.binding @s0b1_ro_external, set=0, binding=1, type="StorageBuffer", access="Read"
          hal.interface.binding @s0b2_xw_external, set=0, binding=2, type="StorageBuffer", access="Write|Discard"
        }
      }
    }
  }
  hal.executable @predict_dispatch_1 attributes {sym_visibility = "private"} {
    hal.interface @io {
      hal.interface.binding @s0b0_ro_constant, set=0, binding=0, type="StorageBuffer", access="Read"
      hal.interface.binding @s0b1_ro_external, set=0, binding=1, type="StorageBuffer", access="Read"
      hal.interface.binding @s0b2_xw_external, set=0, binding=2, type="StorageBuffer", access="Write|Discard"
    }
    hal.executable.target @llvm_aot, filter="dylib*" {
      hal.executable.entry_point @predict_dispatch_1 attributes {interface = @io, ordinal = 0 : index}
      module  {
        func @predict_dispatch_1() {
          %c0 = constant 0 : index
          %cst = constant 0x7FC00000 : f32
          %cst_0 = constant 0.000000e+00 : f32
          %c1 = constant 1 : index
          %c128 = constant 128 : index
          %0 = hal.interface.binding.subspan @io::@s0b1_ro_external[%c0] : !flow.dispatch.tensor<readonly:1x128xf32>
          %1 = hal.interface.binding.subspan @io::@s0b0_ro_constant[%c0] : !flow.dispatch.tensor<readonly:1x128xf32>
          %2 = hal.interface.binding.subspan @io::@s0b2_xw_external[%c0] : !flow.dispatch.tensor<writeonly:1x128xf32>
          %workgroup_size_x = hal.interface.workgroup.size[0] : index
          %workgroup_size_y = hal.interface.workgroup.size[1] : index
          %workgroup_id_x = hal.interface.workgroup.id[0] : index
          %workgroup_count_x = hal.interface.workgroup.count[0] : index
          %workgroup_id_y = hal.interface.workgroup.id[1] : index
          %workgroup_count_y = hal.interface.workgroup.count[1] : index
          %3 = affine.apply #map0()[%workgroup_id_y, %workgroup_size_y]
          %4 = affine.apply #map0()[%workgroup_count_y, %workgroup_size_y]
          scf.for %arg0 = %3 to %c1 step %4 {
            %5 = affine.apply #map0()[%workgroup_id_x, %workgroup_size_x]
            %6 = affine.apply #map0()[%workgroup_count_x, %workgroup_size_x]
            scf.for %arg1 = %5 to %c128 step %6 {
              %7 = affine.min #map1(%arg0)[%workgroup_size_y]
              %8 = affine.min #map2(%arg1)[%workgroup_size_x]
              %9 = flow.dispatch.tensor.load %0, offsets = [%arg0, %arg1], sizes = [%7, %8], strides = [1, 1] : !flow.dispatch.tensor<readonly:1x128xf32> -> tensor<?x?xf32>
              %10 = affine.min #map1(%arg0)[%workgroup_size_y]
              %11 = affine.min #map2(%arg1)[%workgroup_size_x]
              %12 = flow.dispatch.tensor.load %1, offsets = [%arg0, %arg1], sizes = [%10, %11], strides = [1, 1] : !flow.dispatch.tensor<readonly:1x128xf32> -> tensor<?x?xf32>
              %13 = affine.min #map1(%arg0)[%workgroup_size_y]
              %14 = affine.min #map2(%arg1)[%workgroup_size_x]
              %15 = linalg.init_tensor [%13, %14] : tensor<?x?xf32>
              %16 = linalg.generic {indexing_maps = [#map5, #map5, #map5], iterator_types = ["parallel", "parallel"]} ins(%9, %12 : tensor<?x?xf32>, tensor<?x?xf32>) outs(%15 : tensor<?x?xf32>) attrs =  {__internal_linalg_transform__ = "workgroup"} {
              ^bb0(%arg2: f32, %arg3: f32, %arg4: f32):  // no predecessors
                %17 = addf %arg2, %arg3 : f32
                %18 = cmpf ogt, %17, %cst_0 : f32
                %19 = select %18, %17, %cst_0 : f32
                %20 = cmpf uno, %17, %cst_0 : f32
                %21 = select %20, %cst, %19 : f32
                linalg.yield %21 : f32
              } -> tensor<?x?xf32>
              flow.dispatch.tensor.store %16, %2, offsets = [%arg0, %arg1], sizes = [%13, %14], strides = [1, 1] : tensor<?x?xf32> -> !flow.dispatch.tensor<writeonly:1x128xf32>
            }
          }
          return
        }
        hal.interface @io attributes {sym_visibility = "private"} {
          hal.interface.binding @s0b0_ro_constant, set=0, binding=0, type="StorageBuffer", access="Read"
          hal.interface.binding @s0b1_ro_external, set=0, binding=1, type="StorageBuffer", access="Read"
          hal.interface.binding @s0b2_xw_external, set=0, binding=2, type="StorageBuffer", access="Write|Discard"
        }
      }
    }
  }
  hal.executable @predict_dispatch_2 attributes {sym_visibility = "private"} {
    hal.interface @io {
      hal.interface.binding @s0b0_ro_constant, set=0, binding=0, type="StorageBuffer", access="Read"
      hal.interface.binding @s0b1_ro_external, set=0, binding=1, type="StorageBuffer", access="Read"
      hal.interface.binding @s0b2_xw_external, set=0, binding=2, type="StorageBuffer", access="Write|Discard"
    }
    hal.executable.target @llvm_aot, filter="dylib*" {
      hal.executable.entry_point @predict_dispatch_2 attributes {interface = @io, ordinal = 0 : index}
      module  {
        func @predict_dispatch_2() {
          %c0 = constant 0 : index
          %cst = constant 0.000000e+00 : f32
          %c1 = constant 1 : index
          %c10 = constant 10 : index
          %0 = hal.interface.binding.subspan @io::@s0b1_ro_external[%c0] : !flow.dispatch.tensor<readonly:1x128xf32>
          %1 = hal.interface.binding.subspan @io::@s0b0_ro_constant[%c0] : !flow.dispatch.tensor<readonly:128x10xf32>
          %2 = hal.interface.binding.subspan @io::@s0b2_xw_external[%c0] : !flow.dispatch.tensor<writeonly:1x10xf32>
          %workgroup_size_x = hal.interface.workgroup.size[0] : index
          %workgroup_size_y = hal.interface.workgroup.size[1] : index
          %workgroup_id_x = hal.interface.workgroup.id[0] : index
          %workgroup_count_x = hal.interface.workgroup.count[0] : index
          %workgroup_id_y = hal.interface.workgroup.id[1] : index
          %workgroup_count_y = hal.interface.workgroup.count[1] : index
          %3 = affine.apply #map0()[%workgroup_id_y, %workgroup_size_y]
          %4 = affine.apply #map0()[%workgroup_count_y, %workgroup_size_y]
          scf.for %arg0 = %3 to %c1 step %4 {
            %5 = affine.apply #map0()[%workgroup_id_x, %workgroup_size_x]
            %6 = affine.apply #map0()[%workgroup_count_x, %workgroup_size_x]
            scf.for %arg1 = %5 to %c10 step %6 {
              %7 = affine.min #map1(%arg0)[%workgroup_size_y]
              %8 = flow.dispatch.tensor.load %0, offsets = [%arg0, 0], sizes = [%7, 128], strides = [1, 1] : !flow.dispatch.tensor<readonly:1x128xf32> -> tensor<?x128xf32>
              %9 = affine.min #map6(%arg1)[%workgroup_size_x]
              %10 = flow.dispatch.tensor.load %1, offsets = [0, %arg1], sizes = [128, %9], strides = [1, 1] : !flow.dispatch.tensor<readonly:128x10xf32> -> tensor<128x?xf32>
              %11 = affine.min #map1(%arg0)[%workgroup_size_y]
              %12 = affine.min #map6(%arg1)[%workgroup_size_x]
              %13 = affine.min #map3(%arg0)[%workgroup_size_y]
              %14 = affine.min #map7(%arg1)[%workgroup_size_x]
              %15 = linalg.init_tensor [%13, %14] : tensor<?x?xf32>
              %16 = linalg.fill(%15, %cst) : tensor<?x?xf32>, f32 -> tensor<?x?xf32> 
              %17 = linalg.matmul {__internal_linalg_transform__ = "workgroup"} ins(%8, %10 : tensor<?x128xf32>, tensor<128x?xf32>) outs(%16 : tensor<?x?xf32>) -> tensor<?x?xf32>
              flow.dispatch.tensor.store %17, %2, offsets = [%arg0, %arg1], sizes = [%11, %12], strides = [1, 1] : tensor<?x?xf32> -> !flow.dispatch.tensor<writeonly:1x10xf32>
            }
          }
          return
        }
        hal.interface @io attributes {sym_visibility = "private"} {
          hal.interface.binding @s0b0_ro_constant, set=0, binding=0, type="StorageBuffer", access="Read"
          hal.interface.binding @s0b1_ro_external, set=0, binding=1, type="StorageBuffer", access="Read"
          hal.interface.binding @s0b2_xw_external, set=0, binding=2, type="StorageBuffer", access="Write|Discard"
        }
      }
    }
  }
  hal.executable @predict_dispatch_3 attributes {sym_visibility = "private"} {
    hal.interface @io {
      hal.interface.binding @s0b0_ro_external, set=0, binding=0, type="StorageBuffer", access="Read"
      hal.interface.binding @s0b1_xw_external, set=0, binding=1, type="StorageBuffer", access="Write|Discard"
    }
    hal.executable.target @llvm_aot, filter="dylib*" {
      hal.executable.entry_point @predict_dispatch_3 attributes {interface = @io, ordinal = 0 : index}
      module  {
        func @predict_dispatch_3() {
          %c0 = constant 0 : index
          %cst = constant opaque<"_", "0xDEADBEEF"> : tensor<1x10xf32>
          %c1 = constant 1 : index
          %c10 = constant 10 : index
          %0 = hal.interface.binding.subspan @io::@s0b0_ro_external[%c0] : !flow.dispatch.tensor<readonly:1x10xf32>
          %1 = hal.interface.binding.subspan @io::@s0b1_xw_external[%c0] : !flow.dispatch.tensor<writeonly:10xf32>
          %workgroup_size_x = hal.interface.workgroup.size[0] : index
          %workgroup_size_y = hal.interface.workgroup.size[1] : index
          %workgroup_id_x = hal.interface.workgroup.id[0] : index
          %workgroup_count_x = hal.interface.workgroup.count[0] : index
          %workgroup_id_y = hal.interface.workgroup.id[1] : index
          %workgroup_count_y = hal.interface.workgroup.count[1] : index
          %2 = affine.apply #map0()[%workgroup_id_y, %workgroup_size_y]
          %3 = affine.apply #map0()[%workgroup_count_y, %workgroup_size_y]
          scf.for %arg0 = %2 to %c1 step %3 {
            %4 = affine.apply #map0()[%workgroup_id_x, %workgroup_size_x]
            %5 = affine.apply #map0()[%workgroup_count_x, %workgroup_size_x]
            scf.for %arg1 = %4 to %c10 step %5 {
              %6 = affine.min #map1(%arg0)[%workgroup_size_y]
              %7 = affine.min #map6(%arg1)[%workgroup_size_x]
              %8 = flow.dispatch.tensor.load %0, offsets = [%arg0, %arg1], sizes = [%6, %7], strides = [1, 1] : !flow.dispatch.tensor<readonly:1x10xf32> -> tensor<?x?xf32>
              %9 = affine.min #map1(%arg0)[%workgroup_size_y]
              %10 = affine.min #map6(%arg1)[%workgroup_size_x]
              %11 = subtensor %cst[%arg0, %arg1] [%9, %10] [1, 1] : tensor<1x10xf32> to tensor<?x?xf32>
              %12 = affine.min #map6(%arg1)[%workgroup_size_x]
              %13 = linalg.init_tensor [%12] : tensor<?xf32>
              %14 = linalg.generic {indexing_maps = [#map5, #map5, #map8], iterator_types = ["parallel", "parallel"]} ins(%8, %11 : tensor<?x?xf32>, tensor<?x?xf32>) outs(%13 : tensor<?xf32>) attrs =  {__internal_linalg_transform__ = "workgroup"} {
              ^bb0(%arg2: f32, %arg3: f32, %arg4: f32):  // no predecessors
                %15 = addf %arg2, %arg3 : f32
                linalg.yield %15 : f32
              } -> tensor<?xf32>
              flow.dispatch.tensor.store %14, %1, offsets = [%arg1], sizes = [%12], strides = [1] : tensor<?xf32> -> !flow.dispatch.tensor<writeonly:10xf32>
            }
          }
          return
        }
        hal.interface @io attributes {sym_visibility = "private"} {
          hal.interface.binding @s0b0_ro_external, set=0, binding=0, type="StorageBuffer", access="Read"
          hal.interface.binding @s0b1_xw_external, set=0, binding=1, type="StorageBuffer", access="Write|Discard"
        }
      }
    }
  }
  hal.executable @predict_dispatch_4 attributes {sym_visibility = "private"} {
    hal.interface @io {
      hal.interface.binding @s0b0_ro_external, set=0, binding=0, type="StorageBuffer", access="Read"
      hal.interface.binding @s0b1_xw_external, set=0, binding=1, type="StorageBuffer", access="Write|Discard"
    }
    hal.executable.target @llvm_aot, filter="dylib*" {
      hal.executable.entry_point @predict_dispatch_4 attributes {interface = @io, ordinal = 0 : index}
      module  {
        func @predict_dispatch_4() {
          %c0 = constant 0 : index
          %cst = constant 0x7FC00000 : f32
          %cst_0 = constant 0xFF800000 : f32
          %0 = hal.interface.binding.subspan @io::@s0b0_ro_external[%c0] : !flow.dispatch.tensor<readonly:10xf32>
          %1 = hal.interface.binding.subspan @io::@s0b1_xw_external[%c0] : !flow.dispatch.tensor<writeonly:f32>
          %2 = flow.dispatch.tensor.load %0, offsets = [], sizes = [], strides = [] : !flow.dispatch.tensor<readonly:10xf32> -> tensor<10xf32>
          %3 = linalg.init_tensor [] : tensor<f32>
          %4 = linalg.fill(%3, %cst_0) : tensor<f32>, f32 -> tensor<f32> 
          %5 = linalg.generic {indexing_maps = [#map9, #map10], iterator_types = ["reduction"]} ins(%2 : tensor<10xf32>) outs(%4 : tensor<f32>) {
          ^bb0(%arg0: f32, %arg1: f32):  // no predecessors
            %6 = cmpf ogt, %arg0, %arg1 : f32
            %7 = select %6, %arg0, %arg1 : f32
            %8 = cmpf uno, %arg0, %arg1 : f32
            %9 = select %8, %cst, %7 : f32
            linalg.yield %9 : f32
          } -> tensor<f32>
          flow.dispatch.tensor.store %5, %1, offsets = [], sizes = [], strides = [] : tensor<f32> -> !flow.dispatch.tensor<writeonly:f32>
          return
        }
        hal.interface @io attributes {sym_visibility = "private"} {
          hal.interface.binding @s0b0_ro_external, set=0, binding=0, type="StorageBuffer", access="Read"
          hal.interface.binding @s0b1_xw_external, set=0, binding=1, type="StorageBuffer", access="Write|Discard"
        }
      }
    }
  }
  hal.executable @predict_dispatch_5 attributes {sym_visibility = "private"} {
    hal.interface @io {
      hal.interface.binding @s0b0_ro_external, set=0, binding=0, type="StorageBuffer", access="Read"
      hal.interface.binding @s0b1_ro_external, set=0, binding=1, type="StorageBuffer", access="Read"
      hal.interface.binding @s0b2_xw_external, set=0, binding=2, type="StorageBuffer", access="Write|Discard"
    }
    hal.executable.target @llvm_aot, filter="dylib*" {
      hal.executable.entry_point @predict_dispatch_5 attributes {interface = @io, ordinal = 0 : index}
      module  {
        func @predict_dispatch_5() {
          %c0 = constant 0 : index
          %cst = constant opaque<"_", "0xDEADBEEF"> : tensor<1x10xf32>
          %c1 = constant 1 : index
          %c10 = constant 10 : index
          %0 = hal.interface.binding.subspan @io::@s0b0_ro_external[%c0] : !flow.dispatch.tensor<readonly:1x10xf32>
          %1 = hal.interface.binding.subspan @io::@s0b1_ro_external[%c0] : !flow.dispatch.tensor<readonly:f32>
          %2 = hal.interface.binding.subspan @io::@s0b2_xw_external[%c0] : !flow.dispatch.tensor<writeonly:10xf32>
          %3 = flow.dispatch.tensor.load %1, offsets = [], sizes = [], strides = [] : !flow.dispatch.tensor<readonly:f32> -> tensor<f32>
          %workgroup_size_x = hal.interface.workgroup.size[0] : index
          %workgroup_size_y = hal.interface.workgroup.size[1] : index
          %workgroup_id_x = hal.interface.workgroup.id[0] : index
          %workgroup_count_x = hal.interface.workgroup.count[0] : index
          %workgroup_id_y = hal.interface.workgroup.id[1] : index
          %workgroup_count_y = hal.interface.workgroup.count[1] : index
          %4 = affine.apply #map0()[%workgroup_id_y, %workgroup_size_y]
          %5 = affine.apply #map0()[%workgroup_count_y, %workgroup_size_y]
          scf.for %arg0 = %4 to %c1 step %5 {
            %6 = affine.apply #map0()[%workgroup_id_x, %workgroup_size_x]
            %7 = affine.apply #map0()[%workgroup_count_x, %workgroup_size_x]
            scf.for %arg1 = %6 to %c10 step %7 {
              %8 = affine.min #map1(%arg0)[%workgroup_size_y]
              %9 = affine.min #map6(%arg1)[%workgroup_size_x]
              %10 = flow.dispatch.tensor.load %0, offsets = [%arg0, %arg1], sizes = [%8, %9], strides = [1, 1] : !flow.dispatch.tensor<readonly:1x10xf32> -> tensor<?x?xf32>
              %11 = affine.min #map1(%arg0)[%workgroup_size_y]
              %12 = affine.min #map6(%arg1)[%workgroup_size_x]
              %13 = subtensor %cst[%arg0, %arg1] [%11, %12] [1, 1] : tensor<1x10xf32> to tensor<?x?xf32>
              %14 = affine.min #map6(%arg1)[%workgroup_size_x]
              %15 = linalg.init_tensor [%14] : tensor<?xf32>
              %16 = linalg.generic {indexing_maps = [#map5, #map5, #map11, #map8], iterator_types = ["parallel", "parallel"]} ins(%10, %13, %3 : tensor<?x?xf32>, tensor<?x?xf32>, tensor<f32>) outs(%15 : tensor<?xf32>) attrs =  {__internal_linalg_transform__ = "workgroup"} {
              ^bb0(%arg2: f32, %arg3: f32, %arg4: f32, %arg5: f32):  // no predecessors
                %17 = addf %arg2, %arg3 : f32
                %18 = subf %17, %arg4 : f32
                %19 = math.exp %18 : f32
                linalg.yield %19 : f32
              } -> tensor<?xf32>
              flow.dispatch.tensor.store %16, %2, offsets = [%arg1], sizes = [%14], strides = [1] : tensor<?xf32> -> !flow.dispatch.tensor<writeonly:10xf32>
            }
          }
          return
        }
        hal.interface @io attributes {sym_visibility = "private"} {
          hal.interface.binding @s0b0_ro_external, set=0, binding=0, type="StorageBuffer", access="Read"
          hal.interface.binding @s0b1_ro_external, set=0, binding=1, type="StorageBuffer", access="Read"
          hal.interface.binding @s0b2_xw_external, set=0, binding=2, type="StorageBuffer", access="Write|Discard"
        }
      }
    }
  }
  hal.executable @predict_dispatch_6 attributes {sym_visibility = "private"} {
    hal.interface @io {
      hal.interface.binding @s0b0_ro_external, set=0, binding=0, type="StorageBuffer", access="Read"
      hal.interface.binding @s0b1_xw_external, set=0, binding=1, type="StorageBuffer", access="Write|Discard"
    }
    hal.executable.target @llvm_aot, filter="dylib*" {
      hal.executable.entry_point @predict_dispatch_6 attributes {interface = @io, ordinal = 0 : index}
      module  {
        func @predict_dispatch_6() {
          %c0 = constant 0 : index
          %cst = constant 0.000000e+00 : f32
          %0 = hal.interface.binding.subspan @io::@s0b0_ro_external[%c0] : !flow.dispatch.tensor<readonly:10xf32>
          %1 = hal.interface.binding.subspan @io::@s0b1_xw_external[%c0] : !flow.dispatch.tensor<writeonly:f32>
          %2 = flow.dispatch.tensor.load %0, offsets = [], sizes = [], strides = [] : !flow.dispatch.tensor<readonly:10xf32> -> tensor<10xf32>
          %3 = linalg.init_tensor [] : tensor<f32>
          %4 = linalg.fill(%3, %cst) : tensor<f32>, f32 -> tensor<f32> 
          %5 = linalg.generic {indexing_maps = [#map9, #map10], iterator_types = ["reduction"]} ins(%2 : tensor<10xf32>) outs(%4 : tensor<f32>) {
          ^bb0(%arg0: f32, %arg1: f32):  // no predecessors
            %6 = addf %arg0, %arg1 : f32
            linalg.yield %6 : f32
          } -> tensor<f32>
          flow.dispatch.tensor.store %5, %1, offsets = [], sizes = [], strides = [] : tensor<f32> -> !flow.dispatch.tensor<writeonly:f32>
          return
        }
        hal.interface @io attributes {sym_visibility = "private"} {
          hal.interface.binding @s0b0_ro_external, set=0, binding=0, type="StorageBuffer", access="Read"
          hal.interface.binding @s0b1_xw_external, set=0, binding=1, type="StorageBuffer", access="Write|Discard"
        }
      }
    }
  }
  hal.executable @predict_dispatch_7 attributes {sym_visibility = "private"} {
    hal.interface @io {
      hal.interface.binding @s0b0_ro_external, set=0, binding=0, type="StorageBuffer", access="Read"
      hal.interface.binding @s0b1_ro_external, set=0, binding=1, type="StorageBuffer", access="Read"
      hal.interface.binding @s0b2_ro_external, set=0, binding=2, type="StorageBuffer", access="Read"
      hal.interface.binding @s0b3_xw_external, set=0, binding=3, type="StorageBuffer", access="Write|Discard"
    }
    hal.executable.target @llvm_aot, filter="dylib*" {
      hal.executable.entry_point @predict_dispatch_7 attributes {interface = @io, ordinal = 0 : index}
      module  {
        func @predict_dispatch_7() {
          %c0 = constant 0 : index
          %cst = constant opaque<"_", "0xDEADBEEF"> : tensor<1x10xf32>
          %c1 = constant 1 : index
          %c10 = constant 10 : index
          %0 = hal.interface.binding.subspan @io::@s0b0_ro_external[%c0] : !flow.dispatch.tensor<readonly:1x10xf32>
          %1 = hal.interface.binding.subspan @io::@s0b1_ro_external[%c0] : !flow.dispatch.tensor<readonly:f32>
          %2 = hal.interface.binding.subspan @io::@s0b2_ro_external[%c0] : !flow.dispatch.tensor<readonly:f32>
          %3 = hal.interface.binding.subspan @io::@s0b3_xw_external[%c0] : !flow.dispatch.tensor<writeonly:1x10xf32>
          %4 = flow.dispatch.tensor.load %1, offsets = [], sizes = [], strides = [] : !flow.dispatch.tensor<readonly:f32> -> tensor<f32>
          %5 = flow.dispatch.tensor.load %2, offsets = [], sizes = [], strides = [] : !flow.dispatch.tensor<readonly:f32> -> tensor<f32>
          %workgroup_size_x = hal.interface.workgroup.size[0] : index
          %workgroup_size_y = hal.interface.workgroup.size[1] : index
          %workgroup_id_x = hal.interface.workgroup.id[0] : index
          %workgroup_count_x = hal.interface.workgroup.count[0] : index
          %workgroup_id_y = hal.interface.workgroup.id[1] : index
          %workgroup_count_y = hal.interface.workgroup.count[1] : index
          %6 = affine.apply #map0()[%workgroup_id_y, %workgroup_size_y]
          %7 = affine.apply #map0()[%workgroup_count_y, %workgroup_size_y]
          scf.for %arg0 = %6 to %c1 step %7 {
            %8 = affine.apply #map0()[%workgroup_id_x, %workgroup_size_x]
            %9 = affine.apply #map0()[%workgroup_count_x, %workgroup_size_x]
            scf.for %arg1 = %8 to %c10 step %9 {
              %10 = affine.min #map1(%arg0)[%workgroup_size_y]
              %11 = affine.min #map6(%arg1)[%workgroup_size_x]
              %12 = flow.dispatch.tensor.load %0, offsets = [%arg0, %arg1], sizes = [%10, %11], strides = [1, 1] : !flow.dispatch.tensor<readonly:1x10xf32> -> tensor<?x?xf32>
              %13 = affine.min #map1(%arg0)[%workgroup_size_y]
              %14 = affine.min #map6(%arg1)[%workgroup_size_x]
              %15 = subtensor %cst[%arg0, %arg1] [%13, %14] [1, 1] : tensor<1x10xf32> to tensor<?x?xf32>
              %16 = affine.min #map1(%arg0)[%workgroup_size_y]
              %17 = affine.min #map6(%arg1)[%workgroup_size_x]
              %18 = linalg.init_tensor [%16, %17] : tensor<?x?xf32>
              %19 = linalg.generic {indexing_maps = [#map5, #map5, #map11, #map11, #map5], iterator_types = ["parallel", "parallel"]} ins(%12, %15, %4, %5 : tensor<?x?xf32>, tensor<?x?xf32>, tensor<f32>, tensor<f32>) outs(%18 : tensor<?x?xf32>) attrs =  {__internal_linalg_transform__ = "workgroup"} {
              ^bb0(%arg2: f32, %arg3: f32, %arg4: f32, %arg5: f32, %arg6: f32):  // no predecessors
                %20 = addf %arg2, %arg3 : f32
                %21 = subf %20, %arg4 : f32
                %22 = math.exp %21 : f32
                %23 = divf %22, %arg5 : f32
                linalg.yield %23 : f32
              } -> tensor<?x?xf32>
              flow.dispatch.tensor.store %19, %3, offsets = [%arg0, %arg1], sizes = [%16, %17], strides = [1, 1] : tensor<?x?xf32> -> !flow.dispatch.tensor<writeonly:1x10xf32>
            }
          }
          return
        }
        hal.interface @io attributes {sym_visibility = "private"} {
          hal.interface.binding @s0b0_ro_external, set=0, binding=0, type="StorageBuffer", access="Read"
          hal.interface.binding @s0b1_ro_external, set=0, binding=1, type="StorageBuffer", access="Read"
          hal.interface.binding @s0b2_ro_external, set=0, binding=2, type="StorageBuffer", access="Read"
          hal.interface.binding @s0b3_xw_external, set=0, binding=3, type="StorageBuffer", access="Write|Discard"
        }
      }
    }
  }
  func @predict(%arg0: tensor<1x28x28x1xf32>) -> tensor<1x10xf32> attributes {iree.module.export, iree.reflection = {abi = "sip", abiv = 1 : i32, f = "I15!B11!d1d28d28d1R9!B6!d1d10", fv = "1", sip = "I8!S5!k0_0R3!_0"}} {
    %0 = flow.ex.stream.fragment(%arg0) : (tensor<1x28x28x1xf32>) -> tensor<1x10xf32> =
        (%arg1: tensor<1x28x28x1xf32>) -> tensor<1x10xf32> {
      %c128 = constant 128 : index
      %c1 = constant 1 : index
      %c10 = constant 10 : index
      %const_span = hal.constant.subspan @_const_pool_storage_buffer[#hal.byte_range<512, 401408>] : tensor<784x128xf32>
      %const_span_0 = hal.constant.subspan @_const_pool_storage_buffer[#hal.byte_range<0, 512>] : tensor<1x128xf32>
      %const_span_1 = hal.constant.subspan @_const_pool_storage_buffer[#hal.byte_range<401920, 5120>] : tensor<128x10xf32>
      %1 = flow.tensor.reshape %arg1 : tensor<1x28x28x1xf32> -> tensor<1x784xf32>
      %2 = flow.dispatch @predict_dispatch_0::@predict_dispatch_0[%c128, %c1, %c1](%1, %const_span) {hal.bindings = [#hal.ex.constant_storage<"s0b0_ro_constant", "_const_pool_storage_buffer", 512 : index, 401408 : index>, #hal.ex.operand_buffer<"s0b1_ro_external", 0 : index>, #hal.ex.result_buffer<"s0b2_xw_external", 0 : index>]} : (tensor<1x784xf32>, tensor<784x128xf32>) -> tensor<1x128xf32>
      %3 = flow.dispatch @predict_dispatch_1::@predict_dispatch_1[%c128, %c1, %c1](%2, %const_span_0) {hal.bindings = [#hal.ex.constant_storage<"s0b0_ro_constant", "_const_pool_storage_buffer", 0 : index, 512 : index>, #hal.ex.operand_buffer<"s0b1_ro_external", 0 : index>, #hal.ex.result_buffer<"s0b2_xw_external", 0 : index>]} : (tensor<1x128xf32>, tensor<1x128xf32>) -> tensor<1x128xf32>
      %4 = flow.dispatch @predict_dispatch_2::@predict_dispatch_2[%c10, %c1, %c1](%3, %const_span_1) {hal.bindings = [#hal.ex.constant_storage<"s0b0_ro_constant", "_const_pool_storage_buffer", 401920 : index, 5120 : index>, #hal.ex.operand_buffer<"s0b1_ro_external", 0 : index>, #hal.ex.result_buffer<"s0b2_xw_external", 0 : index>]} : (tensor<1x128xf32>, tensor<128x10xf32>) -> tensor<1x10xf32>
      %5 = flow.dispatch @predict_dispatch_3::@predict_dispatch_3[%c10, %c1, %c1](%4) {hal.bindings = [#hal.ex.operand_buffer<"s0b0_ro_external", 0 : index>, #hal.ex.result_buffer<"s0b1_xw_external", 0 : index>]} : (tensor<1x10xf32>) -> tensor<10xf32>
      %6 = flow.dispatch @predict_dispatch_4::@predict_dispatch_4[%c1, %c1, %c1](%5) {hal.bindings = [#hal.ex.operand_buffer<"s0b0_ro_external", 0 : index>, #hal.ex.result_buffer<"s0b1_xw_external", 0 : index>]} : (tensor<10xf32>) -> tensor<f32>
      %7 = flow.dispatch @predict_dispatch_5::@predict_dispatch_5[%c10, %c1, %c1](%4, %6) {hal.bindings = [#hal.ex.operand_buffer<"s0b0_ro_external", 0 : index>, #hal.ex.operand_buffer<"s0b1_ro_external", 1 : index>, #hal.ex.result_buffer<"s0b2_xw_external", 0 : index>]} : (tensor<1x10xf32>, tensor<f32>) -> tensor<10xf32>
      %8 = flow.dispatch @predict_dispatch_6::@predict_dispatch_6[%c1, %c1, %c1](%7) {hal.bindings = [#hal.ex.operand_buffer<"s0b0_ro_external", 0 : index>, #hal.ex.result_buffer<"s0b1_xw_external", 0 : index>]} : (tensor<10xf32>) -> tensor<f32>
      %9 = flow.dispatch @predict_dispatch_7::@predict_dispatch_7[%c10, %c1, %c1](%4, %6, %8) {hal.bindings = [#hal.ex.operand_buffer<"s0b0_ro_external", 0 : index>, #hal.ex.operand_buffer<"s0b1_ro_external", 1 : index>, #hal.ex.operand_buffer<"s0b2_ro_external", 2 : index>, #hal.ex.result_buffer<"s0b3_xw_external", 0 : index>]} : (tensor<1x10xf32>, tensor<f32>, tensor<f32>) -> tensor<1x10xf32>
      flow.return %9 : tensor<1x10xf32>
    }
    return %0 : tensor<1x10xf32>
  }
}


// *** IR Dump After mlir::iree_compiler::IREE::HAL::PropagateConstantWorkgroupInfoPass ***
hal.executable.target @llvm_aot, filter="dylib*" {
  hal.executable.entry_point @predict_dispatch_0 attributes {interface = @io, ordinal = 0 : index}
  module  {
    func @predict_dispatch_0() {
      %c0 = constant 0 : index
      %cst = constant 0.000000e+00 : f32
      %c1 = constant 1 : index
      %c128 = constant 128 : index
      %0 = hal.interface.binding.subspan @io::@s0b1_ro_external[%c0] : !flow.dispatch.tensor<readonly:1x784xf32>
      %1 = hal.interface.binding.subspan @io::@s0b0_ro_constant[%c0] : !flow.dispatch.tensor<readonly:784x128xf32>
      %2 = hal.interface.binding.subspan @io::@s0b2_xw_external[%c0] : !flow.dispatch.tensor<writeonly:1x128xf32>
      %workgroup_size_x = hal.interface.workgroup.size[0] : index
      %workgroup_size_y = hal.interface.workgroup.size[1] : index
      %workgroup_id_x = hal.interface.workgroup.id[0] : index
      %workgroup_count_x = hal.interface.workgroup.count[0] : index
      %workgroup_id_y = hal.interface.workgroup.id[1] : index
      %workgroup_count_y = hal.interface.workgroup.count[1] : index
      %3 = affine.apply affine_map<()[s0, s1] -> (s0 * s1)>()[%workgroup_id_y, %workgroup_size_y]
      %4 = affine.apply affine_map<()[s0, s1] -> (s0 * s1)>()[%workgroup_count_y, %workgroup_size_y]
      scf.for %arg0 = %3 to %c1 step %4 {
        %5 = affine.apply affine_map<()[s0, s1] -> (s0 * s1)>()[%workgroup_id_x, %workgroup_size_x]
        %6 = affine.apply affine_map<()[s0, s1] -> (s0 * s1)>()[%workgroup_count_x, %workgroup_size_x]
        scf.for %arg1 = %5 to %c128 step %6 {
          %7 = affine.min affine_map<(d0)[s0] -> (s0, -d0 + 1)>(%arg0)[%workgroup_size_y]
          %8 = flow.dispatch.tensor.load %0, offsets = [%arg0, 0], sizes = [%7, 784], strides = [1, 1] : !flow.dispatch.tensor<readonly:1x784xf32> -> tensor<?x784xf32>
          %9 = affine.min affine_map<(d0)[s0] -> (s0, -d0 + 128)>(%arg1)[%workgroup_size_x]
          %10 = flow.dispatch.tensor.load %1, offsets = [0, %arg1], sizes = [784, %9], strides = [1, 1] : !flow.dispatch.tensor<readonly:784x128xf32> -> tensor<784x?xf32>
          %11 = affine.min affine_map<(d0)[s0] -> (s0, -d0 + 1)>(%arg0)[%workgroup_size_y]
          %12 = affine.min affine_map<(d0)[s0] -> (s0, -d0 + 128)>(%arg1)[%workgroup_size_x]
          %13 = affine.min affine_map<(d0)[s0] -> (-d0 + 1, s0)>(%arg0)[%workgroup_size_y]
          %14 = affine.min affine_map<(d0)[s0] -> (-d0 + 128, s0)>(%arg1)[%workgroup_size_x]
          %15 = linalg.init_tensor [%13, %14] : tensor<?x?xf32>
          %16 = linalg.fill(%15, %cst) : tensor<?x?xf32>, f32 -> tensor<?x?xf32> 
          %17 = linalg.matmul {__internal_linalg_transform__ = "workgroup"} ins(%8, %10 : tensor<?x784xf32>, tensor<784x?xf32>) outs(%16 : tensor<?x?xf32>) -> tensor<?x?xf32>
          flow.dispatch.tensor.store %17, %2, offsets = [%arg0, %arg1], sizes = [%11, %12], strides = [1, 1] : tensor<?x?xf32> -> !flow.dispatch.tensor<writeonly:1x128xf32>
        }
      }
      return
    }
    hal.interface @io attributes {sym_visibility = "private"} {
      hal.interface.binding @s0b0_ro_constant, set=0, binding=0, type="StorageBuffer", access="Read"
      hal.interface.binding @s0b1_ro_external, set=0, binding=1, type="StorageBuffer", access="Read"
      hal.interface.binding @s0b2_xw_external, set=0, binding=2, type="StorageBuffer", access="Write|Discard"
    }
  }
}

// *** IR Dump After mlir::iree_compiler::`anonymous-namespace'::SetNumWorkgroupsPass ***
hal.executable.target @llvm_aot, filter="dylib*" {
  hal.executable.entry_point @predict_dispatch_0 attributes {interface = @io, ordinal = 0 : index} {
  ^bb0(%arg0: index, %arg1: index, %arg2: index):  // no predecessors
    %c1 = constant 1 : index
    %0 = affine.apply affine_map<()[s0] -> (s0 ceildiv 64)>()[%arg0]
    %1 = affine.apply affine_map<()[s0] -> (s0 ceildiv 4)>()[%arg1]
    hal.return %0, %1, %c1 : index, index, index
  }
  module  {
    func @predict_dispatch_0() {
      %c0 = constant 0 : index
      %cst = constant 0.000000e+00 : f32
      %c1 = constant 1 : index
      %c128 = constant 128 : index
      %c4 = constant 4 : index
      %c64 = constant 64 : index
      %0 = hal.interface.binding.subspan @io::@s0b1_ro_external[%c0] : !flow.dispatch.tensor<readonly:1x784xf32>
      %1 = hal.interface.binding.subspan @io::@s0b0_ro_constant[%c0] : !flow.dispatch.tensor<readonly:784x128xf32>
      %2 = hal.interface.binding.subspan @io::@s0b2_xw_external[%c0] : !flow.dispatch.tensor<writeonly:1x128xf32>
      %workgroup_id_x = hal.interface.workgroup.id[0] : index
      %workgroup_count_x = hal.interface.workgroup.count[0] : index
      %workgroup_id_y = hal.interface.workgroup.id[1] : index
      %workgroup_count_y = hal.interface.workgroup.count[1] : index
      %3 = affine.apply affine_map<()[s0, s1] -> (s0 * s1)>()[%workgroup_id_y, %c4]
      %4 = affine.apply affine_map<()[s0, s1] -> (s0 * s1)>()[%workgroup_count_y, %c4]
      scf.for %arg0 = %3 to %c1 step %4 {
        %5 = affine.apply affine_map<()[s0, s1] -> (s0 * s1)>()[%workgroup_id_x, %c64]
        %6 = affine.apply affine_map<()[s0, s1] -> (s0 * s1)>()[%workgroup_count_x, %c64]
        scf.for %arg1 = %5 to %c128 step %6 {
          %7 = affine.min affine_map<(d0) -> (4, -d0 + 1)>(%arg0)
          %8 = flow.dispatch.tensor.load %0, offsets = [%arg0, 0], sizes = [%7, 784], strides = [1, 1] : !flow.dispatch.tensor<readonly:1x784xf32> -> tensor<?x784xf32>
          %9 = flow.dispatch.tensor.load %1, offsets = [0, %arg1], sizes = [784, 64], strides = [1, 1] : !flow.dispatch.tensor<readonly:784x128xf32> -> tensor<784x64xf32>
          %10 = tensor.cast %9 : tensor<784x64xf32> to tensor<784x?xf32>
          %11 = affine.min affine_map<(d0) -> (4, -d0 + 1)>(%arg0)
          %12 = affine.min affine_map<(d0) -> (-d0 + 1, 4)>(%arg0)
          %13 = linalg.init_tensor [%12, %c64] : tensor<?x?xf32>
          %14 = linalg.fill(%13, %cst) {__internal_linalg_transform__ = "workgroup", lowering.config = {tileSizes = [[4, 64]]}} : tensor<?x?xf32>, f32 -> tensor<?x?xf32> 
          %15 = linalg.matmul {__internal_linalg_transform__ = "workgroup", lowering.config = {nativeVectorSize = [4, 4, 4], tileSizes = [[4, 64], [4, 32, 28], [4, 4, 4]]}} ins(%8, %10 : tensor<?x784xf32>, tensor<784x?xf32>) outs(%14 : tensor<?x?xf32>) -> tensor<?x?xf32>
          flow.dispatch.tensor.store %15, %2, offsets = [%arg0, %arg1], sizes = [%11, %c64], strides = [1, 1] : tensor<?x?xf32> -> !flow.dispatch.tensor<writeonly:1x128xf32>
        }
      }
      return
    }
    hal.interface @io attributes {sym_visibility = "private"} {
      hal.interface.binding @s0b0_ro_constant, set=0, binding=0, type="StorageBuffer", access="Read"
      hal.interface.binding @s0b1_ro_external, set=0, binding=1, type="StorageBuffer", access="Read"
      hal.interface.binding @s0b2_xw_external, set=0, binding=2, type="StorageBuffer", access="Write|Discard"
    }
  }
}

// *** IR Dump After Canonicalizer ***
module  {
  func @predict_dispatch_0() {
    %c0 = constant 0 : index
    %cst = constant 0.000000e+00 : f32
    %c1 = constant 1 : index
    %c128 = constant 128 : index
    %c64 = constant 64 : index
    %0 = hal.interface.binding.subspan @io::@s0b1_ro_external[%c0] : !flow.dispatch.tensor<readonly:1x784xf32>
    %1 = hal.interface.binding.subspan @io::@s0b0_ro_constant[%c0] : !flow.dispatch.tensor<readonly:784x128xf32>
    %2 = hal.interface.binding.subspan @io::@s0b2_xw_external[%c0] : !flow.dispatch.tensor<writeonly:1x128xf32>
    %workgroup_id_x = hal.interface.workgroup.id[0] : index
    %workgroup_count_x = hal.interface.workgroup.count[0] : index
    %workgroup_id_y = hal.interface.workgroup.id[1] : index
    %workgroup_count_y = hal.interface.workgroup.count[1] : index
    %3 = affine.apply affine_map<()[s0] -> (s0 * 4)>()[%workgroup_id_y]
    %4 = affine.apply affine_map<()[s0] -> (s0 * 4)>()[%workgroup_count_y]
    scf.for %arg0 = %3 to %c1 step %4 {
      %5 = affine.apply affine_map<()[s0] -> (s0 * 64)>()[%workgroup_id_x]
      %6 = affine.apply affine_map<()[s0] -> (s0 * 64)>()[%workgroup_count_x]
      scf.for %arg1 = %5 to %c128 step %6 {
        %7 = affine.min affine_map<(d0) -> (4, -d0 + 1)>(%arg0)
        %8 = flow.dispatch.tensor.load %0, offsets = [%arg0, 0], sizes = [%7, 784], strides = [1, 1] : !flow.dispatch.tensor<readonly:1x784xf32> -> tensor<?x784xf32>
        %9 = flow.dispatch.tensor.load %1, offsets = [0, %arg1], sizes = [784, 64], strides = [1, 1] : !flow.dispatch.tensor<readonly:784x128xf32> -> tensor<784x64xf32>
        %10 = affine.min affine_map<(d0) -> (4, -d0 + 1)>(%arg0)
        %11 = affine.min affine_map<(d0) -> (-d0 + 1, 4)>(%arg0)
        %12 = linalg.init_tensor [%11, 64] : tensor<?x64xf32>
        %13 = linalg.fill(%12, %cst) {__internal_linalg_transform__ = "workgroup", lowering.config = {tileSizes = [[4, 64]]}} : tensor<?x64xf32>, f32 -> tensor<?x64xf32> 
        %14 = linalg.matmul {__internal_linalg_transform__ = "workgroup", lowering.config = {nativeVectorSize = [4, 4, 4], tileSizes = [[4, 64], [4, 32, 28], [4, 4, 4]]}} ins(%8, %9 : tensor<?x784xf32>, tensor<784x64xf32>) outs(%13 : tensor<?x64xf32>) -> tensor<?x64xf32>
        flow.dispatch.tensor.store %14, %2, offsets = [%arg0, %arg1], sizes = [%10, %c64], strides = [1, 1] : tensor<?x64xf32> -> !flow.dispatch.tensor<writeonly:1x128xf32>
      }
    }
    return
  }
  hal.interface @io attributes {sym_visibility = "private"} {
    hal.interface.binding @s0b0_ro_constant, set=0, binding=0, type="StorageBuffer", access="Read"
    hal.interface.binding @s0b1_ro_external, set=0, binding=1, type="StorageBuffer", access="Read"
    hal.interface.binding @s0b2_xw_external, set=0, binding=2, type="StorageBuffer", access="Write|Discard"
  }
}

// *** IR Dump After mlir::iree_compiler::`anonymous-namespace'::LinalgBufferizePass ***
func @predict_dispatch_0() {
  %c0 = constant 0 : index
  %cst = constant 0.000000e+00 : f32
  %c1 = constant 1 : index
  %c128 = constant 128 : index
  %c64 = constant 64 : index
  %0 = hal.interface.binding.subspan @io::@s0b1_ro_external[%c0] : memref<1x784xf32>
  %1 = hal.interface.binding.subspan @io::@s0b1_ro_external[%c0] : !flow.dispatch.tensor<readonly:1x784xf32>
  %2 = hal.interface.binding.subspan @io::@s0b0_ro_constant[%c0] : memref<784x128xf32>
  %3 = hal.interface.binding.subspan @io::@s0b0_ro_constant[%c0] : !flow.dispatch.tensor<readonly:784x128xf32>
  %4 = hal.interface.binding.subspan @io::@s0b2_xw_external[%c0] : memref<1x128xf32>
  %5 = hal.interface.binding.subspan @io::@s0b2_xw_external[%c0] : !flow.dispatch.tensor<writeonly:1x128xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %6 = affine.apply affine_map<()[s0] -> (s0 * 4)>()[%workgroup_id_y]
  %7 = affine.apply affine_map<()[s0] -> (s0 * 4)>()[%workgroup_count_y]
  scf.for %arg0 = %6 to %c1 step %7 {
    %8 = affine.apply affine_map<()[s0] -> (s0 * 64)>()[%workgroup_id_x]
    %9 = affine.apply affine_map<()[s0] -> (s0 * 64)>()[%workgroup_count_x]
    scf.for %arg1 = %8 to %c128 step %9 {
      %10 = affine.min affine_map<(d0) -> (4, -d0 + 1)>(%arg0)
      %11 = memref.subview %0[%arg0, 0] [%10, 784] [1, 1] : memref<1x784xf32> to memref<?x784xf32, affine_map<(d0, d1)[s0] -> (d0 * 784 + s0 + d1)>>
      %12 = flow.dispatch.tensor.load %1, offsets = [%arg0, 0], sizes = [%10, 784], strides = [1, 1] : !flow.dispatch.tensor<readonly:1x784xf32> -> tensor<?x784xf32>
      %13 = memref.subview %2[0, %arg1] [784, 64] [1, 1] : memref<784x128xf32> to memref<784x64xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
      %14 = flow.dispatch.tensor.load %3, offsets = [0, %arg1], sizes = [784, 64], strides = [1, 1] : !flow.dispatch.tensor<readonly:784x128xf32> -> tensor<784x64xf32>
      %15 = affine.min affine_map<(d0) -> (4, -d0 + 1)>(%arg0)
      %16 = affine.min affine_map<(d0) -> (-d0 + 1, 4)>(%arg0)
      %17 = linalg.init_tensor [%16, 64] : tensor<?x64xf32>
      %18 = memref.subview %4[%arg0, %arg1] [%15, %c64] [1, 1] : memref<1x128xf32> to memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
      linalg.fill(%18, %cst) {__internal_linalg_transform__ = "workgroup", lowering.config = {tileSizes = [[4, 64]]}} : memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>, f32 
      %19 = linalg.fill(%17, %cst) {__internal_linalg_transform__ = "workgroup", lowering.config = {tileSizes = [[4, 64]]}} : tensor<?x64xf32>, f32 -> tensor<?x64xf32> 
      linalg.matmul {__internal_linalg_transform__ = "workgroup", lowering.config = {nativeVectorSize = [4, 4, 4], tileSizes = [[4, 64], [4, 32, 28], [4, 4, 4]]}} ins(%11, %13 : memref<?x784xf32, affine_map<(d0, d1)[s0] -> (d0 * 784 + s0 + d1)>>, memref<784x64xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>) outs(%18 : memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>)
      %20 = linalg.matmul {__internal_linalg_transform__ = "workgroup", lowering.config = {nativeVectorSize = [4, 4, 4], tileSizes = [[4, 64], [4, 32, 28], [4, 4, 4]]}} ins(%12, %14 : tensor<?x784xf32>, tensor<784x64xf32>) outs(%19 : tensor<?x64xf32>) -> tensor<?x64xf32>
    }
  }
  return
}

// *** IR Dump After Canonicalizer ***
func @predict_dispatch_0() {
  %c0 = constant 0 : index
  %cst = constant 0.000000e+00 : f32
  %c1 = constant 1 : index
  %c128 = constant 128 : index
  %0 = hal.interface.binding.subspan @io::@s0b1_ro_external[%c0] : memref<1x784xf32>
  %1 = hal.interface.binding.subspan @io::@s0b1_ro_external[%c0] : !flow.dispatch.tensor<readonly:1x784xf32>
  %2 = hal.interface.binding.subspan @io::@s0b0_ro_constant[%c0] : memref<784x128xf32>
  %3 = hal.interface.binding.subspan @io::@s0b0_ro_constant[%c0] : !flow.dispatch.tensor<readonly:784x128xf32>
  %4 = hal.interface.binding.subspan @io::@s0b2_xw_external[%c0] : memref<1x128xf32>
  %5 = hal.interface.binding.subspan @io::@s0b2_xw_external[%c0] : !flow.dispatch.tensor<writeonly:1x128xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %6 = affine.apply affine_map<()[s0] -> (s0 * 4)>()[%workgroup_id_y]
  %7 = affine.apply affine_map<()[s0] -> (s0 * 4)>()[%workgroup_count_y]
  scf.for %arg0 = %6 to %c1 step %7 {
    %8 = affine.apply affine_map<()[s0] -> (s0 * 64)>()[%workgroup_id_x]
    %9 = affine.apply affine_map<()[s0] -> (s0 * 64)>()[%workgroup_count_x]
    scf.for %arg1 = %8 to %c128 step %9 {
      %10 = affine.min affine_map<(d0) -> (4, -d0 + 1)>(%arg0)
      %11 = memref.subview %0[%arg0, 0] [%10, 784] [1, 1] : memref<1x784xf32> to memref<?x784xf32, affine_map<(d0, d1)[s0] -> (d0 * 784 + s0 + d1)>>
      %12 = memref.subview %2[0, %arg1] [784, 64] [1, 1] : memref<784x128xf32> to memref<784x64xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
      %13 = affine.min affine_map<(d0) -> (4, -d0 + 1)>(%arg0)
      %14 = memref.subview %4[%arg0, %arg1] [%13, 64] [1, 1] : memref<1x128xf32> to memref<?x64xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
      linalg.fill(%14, %cst) {__internal_linalg_transform__ = "workgroup", lowering.config = {tileSizes = [[4, 64]]}} : memref<?x64xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>, f32 
      linalg.matmul {__internal_linalg_transform__ = "workgroup", lowering.config = {nativeVectorSize = [4, 4, 4], tileSizes = [[4, 64], [4, 32, 28], [4, 4, 4]]}} ins(%11, %12 : memref<?x784xf32, affine_map<(d0, d1)[s0] -> (d0 * 784 + s0 + d1)>>, memref<784x64xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>) outs(%14 : memref<?x64xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>)
    }
  }
  return
}

// *** IR Dump After CSE ***
func @predict_dispatch_0() {
  %c0 = constant 0 : index
  %cst = constant 0.000000e+00 : f32
  %c1 = constant 1 : index
  %c128 = constant 128 : index
  %0 = hal.interface.binding.subspan @io::@s0b1_ro_external[%c0] : memref<1x784xf32>
  %1 = hal.interface.binding.subspan @io::@s0b1_ro_external[%c0] : !flow.dispatch.tensor<readonly:1x784xf32>
  %2 = hal.interface.binding.subspan @io::@s0b0_ro_constant[%c0] : memref<784x128xf32>
  %3 = hal.interface.binding.subspan @io::@s0b0_ro_constant[%c0] : !flow.dispatch.tensor<readonly:784x128xf32>
  %4 = hal.interface.binding.subspan @io::@s0b2_xw_external[%c0] : memref<1x128xf32>
  %5 = hal.interface.binding.subspan @io::@s0b2_xw_external[%c0] : !flow.dispatch.tensor<writeonly:1x128xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %6 = affine.apply affine_map<()[s0] -> (s0 * 4)>()[%workgroup_id_y]
  %7 = affine.apply affine_map<()[s0] -> (s0 * 4)>()[%workgroup_count_y]
  scf.for %arg0 = %6 to %c1 step %7 {
    %8 = affine.apply affine_map<()[s0] -> (s0 * 64)>()[%workgroup_id_x]
    %9 = affine.apply affine_map<()[s0] -> (s0 * 64)>()[%workgroup_count_x]
    scf.for %arg1 = %8 to %c128 step %9 {
      %10 = affine.min affine_map<(d0) -> (4, -d0 + 1)>(%arg0)
      %11 = memref.subview %0[%arg0, 0] [%10, 784] [1, 1] : memref<1x784xf32> to memref<?x784xf32, affine_map<(d0, d1)[s0] -> (d0 * 784 + s0 + d1)>>
      %12 = memref.subview %2[0, %arg1] [784, 64] [1, 1] : memref<784x128xf32> to memref<784x64xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
      %13 = memref.subview %4[%arg0, %arg1] [%10, 64] [1, 1] : memref<1x128xf32> to memref<?x64xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
      linalg.fill(%13, %cst) {__internal_linalg_transform__ = "workgroup", lowering.config = {tileSizes = [[4, 64]]}} : memref<?x64xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>, f32 
      linalg.matmul {__internal_linalg_transform__ = "workgroup", lowering.config = {nativeVectorSize = [4, 4, 4], tileSizes = [[4, 64], [4, 32, 28], [4, 4, 4]]}} ins(%11, %12 : memref<?x784xf32, affine_map<(d0, d1)[s0] -> (d0 * 784 + s0 + d1)>>, memref<784x64xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>) outs(%13 : memref<?x64xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>)
    }
  }
  return
}

// *** IR Dump After mlir::iree_compiler::`anonymous-namespace'::BufferAllocViewCleanUpPass ***
func @predict_dispatch_0() {
  %c0 = constant 0 : index
  %cst = constant 0.000000e+00 : f32
  %c1 = constant 1 : index
  %c128 = constant 128 : index
  %0 = hal.interface.binding.subspan @io::@s0b1_ro_external[%c0] : memref<1x784xf32>
  %1 = hal.interface.binding.subspan @io::@s0b0_ro_constant[%c0] : memref<784x128xf32>
  %2 = hal.interface.binding.subspan @io::@s0b2_xw_external[%c0] : memref<1x128xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 4)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 4)>()[%workgroup_count_y]
  scf.for %arg0 = %3 to %c1 step %4 {
    %5 = affine.apply affine_map<()[s0] -> (s0 * 64)>()[%workgroup_id_x]
    %6 = affine.apply affine_map<()[s0] -> (s0 * 64)>()[%workgroup_count_x]
    scf.for %arg1 = %5 to %c128 step %6 {
      %7 = affine.min affine_map<(d0) -> (4, -d0 + 1)>(%arg0)
      %8 = memref.subview %0[%arg0, 0] [%7, 784] [1, 1] : memref<1x784xf32> to memref<?x784xf32, affine_map<(d0, d1)[s0] -> (d0 * 784 + s0 + d1)>>
      %9 = memref.subview %1[0, %arg1] [784, 64] [1, 1] : memref<784x128xf32> to memref<784x64xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
      %10 = memref.subview %2[%arg0, %arg1] [%7, 64] [1, 1] : memref<1x128xf32> to memref<?x64xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
      linalg.fill(%10, %cst) {__internal_linalg_transform__ = "workgroup", lowering.config = {tileSizes = [[4, 64]]}} : memref<?x64xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>, f32 
      linalg.matmul {__internal_linalg_transform__ = "workgroup", lowering.config = {nativeVectorSize = [4, 4, 4], tileSizes = [[4, 64], [4, 32, 28], [4, 4, 4]]}} ins(%8, %9 : memref<?x784xf32, affine_map<(d0, d1)[s0] -> (d0 * 784 + s0 + d1)>>, memref<784x64xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>) outs(%10 : memref<?x64xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>)
    }
  }
  return
}

// *** IR Dump After Canonicalizer ***
func @predict_dispatch_0() {
  %c0 = constant 0 : index
  %cst = constant 0.000000e+00 : f32
  %c1 = constant 1 : index
  %c128 = constant 128 : index
  %0 = hal.interface.binding.subspan @io::@s0b1_ro_external[%c0] : memref<1x784xf32>
  %1 = hal.interface.binding.subspan @io::@s0b0_ro_constant[%c0] : memref<784x128xf32>
  %2 = hal.interface.binding.subspan @io::@s0b2_xw_external[%c0] : memref<1x128xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 4)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 4)>()[%workgroup_count_y]
  scf.for %arg0 = %3 to %c1 step %4 {
    %5 = affine.apply affine_map<()[s0] -> (s0 * 64)>()[%workgroup_id_x]
    %6 = affine.apply affine_map<()[s0] -> (s0 * 64)>()[%workgroup_count_x]
    scf.for %arg1 = %5 to %c128 step %6 {
      %7 = affine.min affine_map<(d0) -> (4, -d0 + 1)>(%arg0)
      %8 = memref.subview %0[%arg0, 0] [%7, 784] [1, 1] : memref<1x784xf32> to memref<?x784xf32, affine_map<(d0, d1)[s0] -> (d0 * 784 + s0 + d1)>>
      %9 = memref.subview %1[0, %arg1] [784, 64] [1, 1] : memref<784x128xf32> to memref<784x64xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
      %10 = memref.subview %2[%arg0, %arg1] [%7, 64] [1, 1] : memref<1x128xf32> to memref<?x64xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
      linalg.fill(%10, %cst) {__internal_linalg_transform__ = "workgroup", lowering.config = {tileSizes = [[4, 64]]}} : memref<?x64xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>, f32 
      linalg.matmul {__internal_linalg_transform__ = "workgroup", lowering.config = {nativeVectorSize = [4, 4, 4], tileSizes = [[4, 64], [4, 32, 28], [4, 4, 4]]}} ins(%8, %9 : memref<?x784xf32, affine_map<(d0, d1)[s0] -> (d0 * 784 + s0 + d1)>>, memref<784x64xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>) outs(%10 : memref<?x64xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>)
    }
  }
  return
}

// *** IR Dump After mlir::iree_compiler::`anonymous-namespace'::TileAndVectorizeWorkgroups ***
func @predict_dispatch_0() {
  %cst = constant 0.000000e+00 : f32
  %c1 = constant 1 : index
  %c128 = constant 128 : index
  %c784 = constant 784 : index
  %c64 = constant 64 : index
  %c4 = constant 4 : index
  %c0 = constant 0 : index
  %c28 = constant 28 : index
  %c32 = constant 32 : index
  %0 = hal.interface.binding.subspan @io::@s0b1_ro_external[%c0] : memref<1x784xf32>
  %1 = hal.interface.binding.subspan @io::@s0b0_ro_constant[%c0] : memref<784x128xf32>
  %2 = hal.interface.binding.subspan @io::@s0b2_xw_external[%c0] : memref<1x128xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 4)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 4)>()[%workgroup_count_y]
  scf.for %arg0 = %3 to %c1 step %4 {
    %5 = affine.apply affine_map<()[s0] -> (s0 * 64)>()[%workgroup_id_x]
    %6 = affine.apply affine_map<()[s0] -> (s0 * 64)>()[%workgroup_count_x]
    scf.for %arg1 = %5 to %c128 step %6 {
      %7 = affine.min affine_map<(d0) -> (4, -d0 + 1)>(%arg0)
      %8 = memref.subview %0[%arg0, 0] [%7, 784] [1, 1] : memref<1x784xf32> to memref<?x784xf32, affine_map<(d0, d1)[s0] -> (d0 * 784 + s0 + d1)>>
      %9 = memref.subview %1[0, %arg1] [784, 64] [1, 1] : memref<784x128xf32> to memref<784x64xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
      %10 = memref.subview %2[%arg0, %arg1] [%7, 64] [1, 1] : memref<1x128xf32> to memref<?x64xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
      linalg.fill(%10, %cst) {__internal_linalg_transform__ = "workgroup", lowering.config = {tileSizes = [[4, 64]]}} : memref<?x64xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>, f32 
      scf.for %arg2 = %c0 to %7 step %c4 {
        scf.for %arg3 = %c0 to %c64 step %c32 {
          scf.for %arg4 = %c0 to %c784 step %c28 {
            %11 = affine.min affine_map<(d0, d1) -> (4, d0 - d1)>(%7, %arg2)
            %12 = memref.subview %8[%arg2, %arg4] [%11, 28] [1, 1] : memref<?x784xf32, affine_map<(d0, d1)[s0] -> (d0 * 784 + s0 + d1)>> to memref<?x28xf32, affine_map<(d0, d1)[s0] -> (d0 * 784 + s0 + d1)>>
            %13 = memref.subview %9[%arg4, %arg3] [28, 32] [1, 1] : memref<784x64xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>> to memref<28x32xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
            %14 = affine.min affine_map<(d0, d1) -> (4, d0 - d1)>(%7, %arg2)
            %15 = memref.subview %10[%arg2, %arg3] [%14, 32] [1, 1] : memref<?x64xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>> to memref<?x32xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
            scf.for %arg5 = %c0 to %11 step %c4 {
              scf.for %arg6 = %c0 to %c32 step %c4 {
                scf.for %arg7 = %c0 to %c28 step %c4 {
                  %16 = affine.min affine_map<(d0, d1) -> (4, d0 - d1)>(%11, %arg5)
                  %17 = memref.subview %12[%arg5, %arg7] [%16, 4] [1, 1] : memref<?x28xf32, affine_map<(d0, d1)[s0] -> (d0 * 784 + s0 + d1)>> to memref<?x4xf32, affine_map<(d0, d1)[s0] -> (d0 * 784 + s0 + d1)>>
                  %18 = memref.subview %13[%arg7, %arg6] [4, 4] [1, 1] : memref<28x32xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>> to memref<4x4xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
                  %19 = affine.min affine_map<(d0, d1) -> (4, d0 - d1)>(%14, %arg5)
                  %20 = memref.subview %15[%arg5, %arg6] [%19, 4] [1, 1] : memref<?x32xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>> to memref<?x4xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
                  linalg.matmul {__internal_linalg_transform__ = "vectorize", lowering.config = {nativeVectorSize = [4, 4, 4], tileSizes = [[4, 64], [4, 32, 28], [4, 4, 4]]}} ins(%17, %18 : memref<?x4xf32, affine_map<(d0, d1)[s0] -> (d0 * 784 + s0 + d1)>>, memref<4x4xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>) outs(%20 : memref<?x4xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>)
                }
              }
            }
          }
        }
      }
    }
  }
  return
}

// *** IR Dump After Canonicalizer ***
func @predict_dispatch_0() {
  %cst = constant 0.000000e+00 : f32
  %c1 = constant 1 : index
  %c128 = constant 128 : index
  %c784 = constant 784 : index
  %c64 = constant 64 : index
  %c4 = constant 4 : index
  %c0 = constant 0 : index
  %c28 = constant 28 : index
  %c32 = constant 32 : index
  %0 = hal.interface.binding.subspan @io::@s0b1_ro_external[%c0] : memref<1x784xf32>
  %1 = hal.interface.binding.subspan @io::@s0b0_ro_constant[%c0] : memref<784x128xf32>
  %2 = hal.interface.binding.subspan @io::@s0b2_xw_external[%c0] : memref<1x128xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 4)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 4)>()[%workgroup_count_y]
  scf.for %arg0 = %3 to %c1 step %4 {
    %5 = affine.apply affine_map<()[s0] -> (s0 * 64)>()[%workgroup_id_x]
    %6 = affine.apply affine_map<()[s0] -> (s0 * 64)>()[%workgroup_count_x]
    scf.for %arg1 = %5 to %c128 step %6 {
      %7 = affine.min affine_map<(d0) -> (4, -d0 + 1)>(%arg0)
      %8 = memref.subview %0[%arg0, 0] [%7, 784] [1, 1] : memref<1x784xf32> to memref<?x784xf32, affine_map<(d0, d1)[s0] -> (d0 * 784 + s0 + d1)>>
      %9 = memref.subview %1[0, %arg1] [784, 64] [1, 1] : memref<784x128xf32> to memref<784x64xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
      %10 = memref.subview %2[%arg0, %arg1] [%7, 64] [1, 1] : memref<1x128xf32> to memref<?x64xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
      linalg.fill(%10, %cst) {__internal_linalg_transform__ = "workgroup", lowering.config = {tileSizes = [[4, 64]]}} : memref<?x64xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>, f32 
      scf.for %arg2 = %c0 to %7 step %c4 {
        scf.for %arg3 = %c0 to %c64 step %c32 {
          scf.for %arg4 = %c0 to %c784 step %c28 {
            %11 = affine.min affine_map<(d0, d1) -> (4, d0 - d1)>(%7, %arg2)
            %12 = memref.subview %8[%arg2, %arg4] [%11, 28] [1, 1] : memref<?x784xf32, affine_map<(d0, d1)[s0] -> (d0 * 784 + s0 + d1)>> to memref<?x28xf32, affine_map<(d0, d1)[s0] -> (d0 * 784 + s0 + d1)>>
            %13 = memref.subview %9[%arg4, %arg3] [28, 32] [1, 1] : memref<784x64xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>> to memref<28x32xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
            %14 = affine.min affine_map<(d0, d1) -> (4, d0 - d1)>(%7, %arg2)
            %15 = memref.subview %10[%arg2, %arg3] [%14, 32] [1, 1] : memref<?x64xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>> to memref<?x32xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
            scf.for %arg5 = %c0 to %11 step %c4 {
              scf.for %arg6 = %c0 to %c32 step %c4 {
                scf.for %arg7 = %c0 to %c28 step %c4 {
                  %16 = affine.min affine_map<(d0, d1) -> (4, d0 - d1)>(%11, %arg5)
                  %17 = memref.subview %12[%arg5, %arg7] [%16, 4] [1, 1] : memref<?x28xf32, affine_map<(d0, d1)[s0] -> (d0 * 784 + s0 + d1)>> to memref<?x4xf32, affine_map<(d0, d1)[s0] -> (d0 * 784 + s0 + d1)>>
                  %18 = memref.subview %13[%arg7, %arg6] [4, 4] [1, 1] : memref<28x32xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>> to memref<4x4xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
                  %19 = affine.min affine_map<(d0, d1) -> (4, d0 - d1)>(%14, %arg5)
                  %20 = memref.subview %15[%arg5, %arg6] [%19, 4] [1, 1] : memref<?x32xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>> to memref<?x4xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
                  linalg.matmul {__internal_linalg_transform__ = "vectorize", lowering.config = {nativeVectorSize = [4, 4, 4], tileSizes = [[4, 64], [4, 32, 28], [4, 4, 4]]}} ins(%17, %18 : memref<?x4xf32, affine_map<(d0, d1)[s0] -> (d0 * 784 + s0 + d1)>>, memref<4x4xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>) outs(%20 : memref<?x4xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>)
                }
              }
            }
          }
        }
      }
    }
  }
  return
}

// *** IR Dump After mlir::iree_compiler::`anonymous-namespace'::ForOpCanonicalizationPass ***
func @predict_dispatch_0() {
  %cst = constant 0.000000e+00 : f32
  %c1 = constant 1 : index
  %c128 = constant 128 : index
  %c784 = constant 784 : index
  %c64 = constant 64 : index
  %c4 = constant 4 : index
  %c0 = constant 0 : index
  %c28 = constant 28 : index
  %c32 = constant 32 : index
  %0 = hal.interface.binding.subspan @io::@s0b1_ro_external[%c0] : memref<1x784xf32>
  %1 = hal.interface.binding.subspan @io::@s0b0_ro_constant[%c0] : memref<784x128xf32>
  %2 = hal.interface.binding.subspan @io::@s0b2_xw_external[%c0] : memref<1x128xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 4)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 4)>()[%workgroup_count_y]
  scf.for %arg0 = %3 to %c1 step %4 {
    %5 = affine.apply affine_map<()[s0] -> (s0 * 64)>()[%workgroup_id_x]
    %6 = affine.apply affine_map<()[s0] -> (s0 * 64)>()[%workgroup_count_x]
    scf.for %arg1 = %5 to %c128 step %6 {
      %7 = affine.min affine_map<(d0) -> (4, -d0 + 1)>(%arg0)
      %8 = memref.subview %0[%arg0, 0] [%7, 784] [1, 1] : memref<1x784xf32> to memref<?x784xf32, affine_map<(d0, d1)[s0] -> (d0 * 784 + s0 + d1)>>
      %9 = memref.subview %1[0, %arg1] [784, 64] [1, 1] : memref<784x128xf32> to memref<784x64xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
      %10 = memref.subview %2[%arg0, %arg1] [%7, 64] [1, 1] : memref<1x128xf32> to memref<?x64xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
      linalg.fill(%10, %cst) {__internal_linalg_transform__ = "workgroup", lowering.config = {tileSizes = [[4, 64]]}} : memref<?x64xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>, f32 
      scf.for %arg2 = %c0 to %7 step %c4 {
        scf.for %arg3 = %c0 to %c64 step %c32 {
          scf.for %arg4 = %c0 to %c784 step %c28 {
            %11 = affine.min affine_map<(d0, d1) -> (4, d0 - d1)>(%7, %arg2)
            %12 = memref.subview %8[%arg2, %arg4] [%11, 28] [1, 1] : memref<?x784xf32, affine_map<(d0, d1)[s0] -> (d0 * 784 + s0 + d1)>> to memref<?x28xf32, affine_map<(d0, d1)[s0] -> (d0 * 784 + s0 + d1)>>
            %13 = memref.subview %9[%arg4, %arg3] [28, 32] [1, 1] : memref<784x64xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>> to memref<28x32xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
            %14 = affine.min affine_map<(d0, d1) -> (4, d0 - d1)>(%7, %arg2)
            %15 = memref.subview %10[%arg2, %arg3] [%14, 32] [1, 1] : memref<?x64xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>> to memref<?x32xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
            scf.for %arg5 = %c0 to %11 step %c4 {
              scf.for %arg6 = %c0 to %c32 step %c4 {
                scf.for %arg7 = %c0 to %c28 step %c4 {
                  %16 = affine.min affine_map<(d0, d1) -> (4, d0 - d1)>(%11, %arg5)
                  %17 = memref.subview %12[%arg5, %arg7] [%16, 4] [1, 1] : memref<?x28xf32, affine_map<(d0, d1)[s0] -> (d0 * 784 + s0 + d1)>> to memref<?x4xf32, affine_map<(d0, d1)[s0] -> (d0 * 784 + s0 + d1)>>
                  %18 = memref.subview %13[%arg7, %arg6] [4, 4] [1, 1] : memref<28x32xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>> to memref<4x4xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
                  %19 = affine.min affine_map<(d0, d1) -> (4, d0 - d1)>(%14, %arg5)
                  %20 = memref.subview %15[%arg5, %arg6] [%19, 4] [1, 1] : memref<?x32xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>> to memref<?x4xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
                  linalg.matmul {__internal_linalg_transform__ = "vectorize", lowering.config = {nativeVectorSize = [4, 4, 4], tileSizes = [[4, 64], [4, 32, 28], [4, 4, 4]]}} ins(%17, %18 : memref<?x4xf32, affine_map<(d0, d1)[s0] -> (d0 * 784 + s0 + d1)>>, memref<4x4xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>) outs(%20 : memref<?x4xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>)
                }
              }
            }
          }
        }
      }
    }
  }
  return
}

// *** IR Dump After mlir::iree_compiler::`anonymous-namespace'::PlanConvLoopOrderPass ***
func @predict_dispatch_0() {
  %cst = constant 0.000000e+00 : f32
  %c1 = constant 1 : index
  %c128 = constant 128 : index
  %c784 = constant 784 : index
  %c64 = constant 64 : index
  %c4 = constant 4 : index
  %c0 = constant 0 : index
  %c28 = constant 28 : index
  %c32 = constant 32 : index
  %0 = hal.interface.binding.subspan @io::@s0b1_ro_external[%c0] : memref<1x784xf32>
  %1 = hal.interface.binding.subspan @io::@s0b0_ro_constant[%c0] : memref<784x128xf32>
  %2 = hal.interface.binding.subspan @io::@s0b2_xw_external[%c0] : memref<1x128xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 4)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 4)>()[%workgroup_count_y]
  scf.for %arg0 = %3 to %c1 step %4 {
    %5 = affine.apply affine_map<()[s0] -> (s0 * 64)>()[%workgroup_id_x]
    %6 = affine.apply affine_map<()[s0] -> (s0 * 64)>()[%workgroup_count_x]
    scf.for %arg1 = %5 to %c128 step %6 {
      %7 = affine.min affine_map<(d0) -> (4, -d0 + 1)>(%arg0)
      %8 = memref.subview %0[%arg0, 0] [%7, 784] [1, 1] : memref<1x784xf32> to memref<?x784xf32, affine_map<(d0, d1)[s0] -> (d0 * 784 + s0 + d1)>>
      %9 = memref.subview %1[0, %arg1] [784, 64] [1, 1] : memref<784x128xf32> to memref<784x64xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
      %10 = memref.subview %2[%arg0, %arg1] [%7, 64] [1, 1] : memref<1x128xf32> to memref<?x64xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
      linalg.fill(%10, %cst) {__internal_linalg_transform__ = "workgroup", lowering.config = {tileSizes = [[4, 64]]}} : memref<?x64xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>, f32 
      scf.for %arg2 = %c0 to %7 step %c4 {
        scf.for %arg3 = %c0 to %c64 step %c32 {
          scf.for %arg4 = %c0 to %c784 step %c28 {
            %11 = affine.min affine_map<(d0, d1) -> (4, d0 - d1)>(%7, %arg2)
            %12 = memref.subview %8[%arg2, %arg4] [%11, 28] [1, 1] : memref<?x784xf32, affine_map<(d0, d1)[s0] -> (d0 * 784 + s0 + d1)>> to memref<?x28xf32, affine_map<(d0, d1)[s0] -> (d0 * 784 + s0 + d1)>>
            %13 = memref.subview %9[%arg4, %arg3] [28, 32] [1, 1] : memref<784x64xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>> to memref<28x32xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
            %14 = affine.min affine_map<(d0, d1) -> (4, d0 - d1)>(%7, %arg2)
            %15 = memref.subview %10[%arg2, %arg3] [%14, 32] [1, 1] : memref<?x64xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>> to memref<?x32xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
            scf.for %arg5 = %c0 to %11 step %c4 {
              scf.for %arg6 = %c0 to %c32 step %c4 {
                scf.for %arg7 = %c0 to %c28 step %c4 {
                  %16 = affine.min affine_map<(d0, d1) -> (4, d0 - d1)>(%11, %arg5)
                  %17 = memref.subview %12[%arg5, %arg7] [%16, 4] [1, 1] : memref<?x28xf32, affine_map<(d0, d1)[s0] -> (d0 * 784 + s0 + d1)>> to memref<?x4xf32, affine_map<(d0, d1)[s0] -> (d0 * 784 + s0 + d1)>>
                  %18 = memref.subview %13[%arg7, %arg6] [4, 4] [1, 1] : memref<28x32xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>> to memref<4x4xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
                  %19 = affine.min affine_map<(d0, d1) -> (4, d0 - d1)>(%14, %arg5)
                  %20 = memref.subview %15[%arg5, %arg6] [%19, 4] [1, 1] : memref<?x32xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>> to memref<?x4xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
                  linalg.matmul {__internal_linalg_transform__ = "vectorize", lowering.config = {nativeVectorSize = [4, 4, 4], tileSizes = [[4, 64], [4, 32, 28], [4, 4, 4]]}} ins(%17, %18 : memref<?x4xf32, affine_map<(d0, d1)[s0] -> (d0 * 784 + s0 + d1)>>, memref<4x4xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>) outs(%20 : memref<?x4xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>)
                }
              }
            }
          }
        }
      }
    }
  }
  return
}

// *** IR Dump After LinalgLowerToLoops ***
func @predict_dispatch_0() {
  %cst = constant 0.000000e+00 : f32
  %c128 = constant 128 : index
  %c784 = constant 784 : index
  %c28 = constant 28 : index
  %c32 = constant 32 : index
  %c64 = constant 64 : index
  %c4 = constant 4 : index
  %c0 = constant 0 : index
  %c1 = constant 1 : index
  %0 = hal.interface.binding.subspan @io::@s0b1_ro_external[%c0] : memref<1x784xf32>
  %1 = hal.interface.binding.subspan @io::@s0b0_ro_constant[%c0] : memref<784x128xf32>
  %2 = hal.interface.binding.subspan @io::@s0b2_xw_external[%c0] : memref<1x128xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 4)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 4)>()[%workgroup_count_y]
  scf.for %arg0 = %3 to %c1 step %4 {
    %5 = affine.apply affine_map<()[s0] -> (s0 * 64)>()[%workgroup_id_x]
    %6 = affine.apply affine_map<()[s0] -> (s0 * 64)>()[%workgroup_count_x]
    scf.for %arg1 = %5 to %c128 step %6 {
      %7 = affine.min affine_map<(d0) -> (4, -d0 + 1)>(%arg0)
      %8 = memref.subview %0[%arg0, 0] [%7, 784] [1, 1] : memref<1x784xf32> to memref<?x784xf32, affine_map<(d0, d1)[s0] -> (d0 * 784 + s0 + d1)>>
      %9 = memref.subview %1[0, %arg1] [784, 64] [1, 1] : memref<784x128xf32> to memref<784x64xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
      %10 = memref.subview %2[%arg0, %arg1] [%7, 64] [1, 1] : memref<1x128xf32> to memref<?x64xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
      scf.for %arg2 = %c0 to %7 step %c1 {
        scf.for %arg3 = %c0 to %c64 step %c1 {
          memref.store %cst, %10[%arg2, %arg3] : memref<?x64xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
        }
      }
      scf.for %arg2 = %c0 to %7 step %c4 {
        scf.for %arg3 = %c0 to %c64 step %c32 {
          scf.for %arg4 = %c0 to %c784 step %c28 {
            %11 = affine.min affine_map<(d0, d1) -> (4, d0 - d1)>(%7, %arg2)
            %12 = memref.subview %8[%arg2, %arg4] [%11, 28] [1, 1] : memref<?x784xf32, affine_map<(d0, d1)[s0] -> (d0 * 784 + s0 + d1)>> to memref<?x28xf32, affine_map<(d0, d1)[s0] -> (d0 * 784 + s0 + d1)>>
            %13 = memref.subview %9[%arg4, %arg3] [28, 32] [1, 1] : memref<784x64xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>> to memref<28x32xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
            %14 = affine.min affine_map<(d0, d1) -> (4, d0 - d1)>(%7, %arg2)
            %15 = memref.subview %10[%arg2, %arg3] [%14, 32] [1, 1] : memref<?x64xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>> to memref<?x32xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
            scf.for %arg5 = %c0 to %11 step %c4 {
              scf.for %arg6 = %c0 to %c32 step %c4 {
                scf.for %arg7 = %c0 to %c28 step %c4 {
                  %16 = affine.min affine_map<(d0, d1) -> (4, d0 - d1)>(%11, %arg5)
                  %17 = memref.subview %12[%arg5, %arg7] [%16, 4] [1, 1] : memref<?x28xf32, affine_map<(d0, d1)[s0] -> (d0 * 784 + s0 + d1)>> to memref<?x4xf32, affine_map<(d0, d1)[s0] -> (d0 * 784 + s0 + d1)>>
                  %18 = memref.subview %13[%arg7, %arg6] [4, 4] [1, 1] : memref<28x32xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>> to memref<4x4xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
                  %19 = affine.min affine_map<(d0, d1) -> (4, d0 - d1)>(%14, %arg5)
                  %20 = memref.subview %15[%arg5, %arg6] [%19, 4] [1, 1] : memref<?x32xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>> to memref<?x4xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
                  scf.for %arg8 = %c0 to %16 step %c1 {
                    scf.for %arg9 = %c0 to %c4 step %c1 {
                      scf.for %arg10 = %c0 to %c4 step %c1 {
                        %21 = memref.load %17[%arg8, %arg10] : memref<?x4xf32, affine_map<(d0, d1)[s0] -> (d0 * 784 + s0 + d1)>>
                        %22 = memref.load %18[%arg10, %arg9] : memref<4x4xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
                        %23 = memref.load %20[%arg8, %arg9] : memref<?x4xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
                        %24 = mulf %21, %22 : f32
                        %25 = addf %23, %24 : f32
                        memref.store %25, %20[%arg8, %arg9] : memref<?x4xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return
}

// *** IR Dump After Canonicalizer ***
func @predict_dispatch_0() {
  %cst = constant 0.000000e+00 : f32
  %c128 = constant 128 : index
  %c784 = constant 784 : index
  %c28 = constant 28 : index
  %c32 = constant 32 : index
  %c64 = constant 64 : index
  %c4 = constant 4 : index
  %c0 = constant 0 : index
  %c1 = constant 1 : index
  %0 = hal.interface.binding.subspan @io::@s0b1_ro_external[%c0] : memref<1x784xf32>
  %1 = hal.interface.binding.subspan @io::@s0b0_ro_constant[%c0] : memref<784x128xf32>
  %2 = hal.interface.binding.subspan @io::@s0b2_xw_external[%c0] : memref<1x128xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 4)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 4)>()[%workgroup_count_y]
  scf.for %arg0 = %3 to %c1 step %4 {
    %5 = affine.apply affine_map<()[s0] -> (s0 * 64)>()[%workgroup_id_x]
    %6 = affine.apply affine_map<()[s0] -> (s0 * 64)>()[%workgroup_count_x]
    scf.for %arg1 = %5 to %c128 step %6 {
      %7 = affine.min affine_map<(d0) -> (4, -d0 + 1)>(%arg0)
      %8 = memref.subview %0[%arg0, 0] [%7, 784] [1, 1] : memref<1x784xf32> to memref<?x784xf32, affine_map<(d0, d1)[s0] -> (d0 * 784 + s0 + d1)>>
      %9 = memref.subview %1[0, %arg1] [784, 64] [1, 1] : memref<784x128xf32> to memref<784x64xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
      %10 = memref.subview %2[%arg0, %arg1] [%7, 64] [1, 1] : memref<1x128xf32> to memref<?x64xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
      scf.for %arg2 = %c0 to %7 step %c1 {
        scf.for %arg3 = %c0 to %c64 step %c1 {
          memref.store %cst, %10[%arg2, %arg3] : memref<?x64xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
        }
      }
      scf.for %arg2 = %c0 to %7 step %c4 {
        scf.for %arg3 = %c0 to %c64 step %c32 {
          scf.for %arg4 = %c0 to %c784 step %c28 {
            %11 = affine.min affine_map<(d0, d1) -> (4, d0 - d1)>(%7, %arg2)
            %12 = memref.subview %8[%arg2, %arg4] [%11, 28] [1, 1] : memref<?x784xf32, affine_map<(d0, d1)[s0] -> (d0 * 784 + s0 + d1)>> to memref<?x28xf32, affine_map<(d0, d1)[s0] -> (d0 * 784 + s0 + d1)>>
            %13 = memref.subview %9[%arg4, %arg3] [28, 32] [1, 1] : memref<784x64xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>> to memref<28x32xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
            %14 = affine.min affine_map<(d0, d1) -> (4, d0 - d1)>(%7, %arg2)
            %15 = memref.subview %10[%arg2, %arg3] [%14, 32] [1, 1] : memref<?x64xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>> to memref<?x32xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
            scf.for %arg5 = %c0 to %11 step %c4 {
              scf.for %arg6 = %c0 to %c32 step %c4 {
                scf.for %arg7 = %c0 to %c28 step %c4 {
                  %16 = affine.min affine_map<(d0, d1) -> (4, d0 - d1)>(%11, %arg5)
                  %17 = memref.subview %12[%arg5, %arg7] [%16, 4] [1, 1] : memref<?x28xf32, affine_map<(d0, d1)[s0] -> (d0 * 784 + s0 + d1)>> to memref<?x4xf32, affine_map<(d0, d1)[s0] -> (d0 * 784 + s0 + d1)>>
                  %18 = memref.subview %13[%arg7, %arg6] [4, 4] [1, 1] : memref<28x32xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>> to memref<4x4xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
                  %19 = affine.min affine_map<(d0, d1) -> (4, d0 - d1)>(%14, %arg5)
                  %20 = memref.subview %15[%arg5, %arg6] [%19, 4] [1, 1] : memref<?x32xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>> to memref<?x4xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
                  scf.for %arg8 = %c0 to %16 step %c1 {
                    scf.for %arg9 = %c0 to %c4 step %c1 {
                      scf.for %arg10 = %c0 to %c4 step %c1 {
                        %21 = memref.load %17[%arg8, %arg10] : memref<?x4xf32, affine_map<(d0, d1)[s0] -> (d0 * 784 + s0 + d1)>>
                        %22 = memref.load %18[%arg10, %arg9] : memref<4x4xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
                        %23 = memref.load %20[%arg8, %arg9] : memref<?x4xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
                        %24 = mulf %21, %22 : f32
                        %25 = addf %23, %24 : f32
                        memref.store %25, %20[%arg8, %arg9] : memref<?x4xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return
}

// *** IR Dump After CSE ***
func @predict_dispatch_0() {
  %cst = constant 0.000000e+00 : f32
  %c128 = constant 128 : index
  %c784 = constant 784 : index
  %c28 = constant 28 : index
  %c32 = constant 32 : index
  %c64 = constant 64 : index
  %c4 = constant 4 : index
  %c0 = constant 0 : index
  %c1 = constant 1 : index
  %0 = hal.interface.binding.subspan @io::@s0b1_ro_external[%c0] : memref<1x784xf32>
  %1 = hal.interface.binding.subspan @io::@s0b0_ro_constant[%c0] : memref<784x128xf32>
  %2 = hal.interface.binding.subspan @io::@s0b2_xw_external[%c0] : memref<1x128xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 4)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 4)>()[%workgroup_count_y]
  scf.for %arg0 = %3 to %c1 step %4 {
    %5 = affine.apply affine_map<()[s0] -> (s0 * 64)>()[%workgroup_id_x]
    %6 = affine.apply affine_map<()[s0] -> (s0 * 64)>()[%workgroup_count_x]
    scf.for %arg1 = %5 to %c128 step %6 {
      %7 = affine.min affine_map<(d0) -> (4, -d0 + 1)>(%arg0)
      %8 = memref.subview %0[%arg0, 0] [%7, 784] [1, 1] : memref<1x784xf32> to memref<?x784xf32, affine_map<(d0, d1)[s0] -> (d0 * 784 + s0 + d1)>>
      %9 = memref.subview %1[0, %arg1] [784, 64] [1, 1] : memref<784x128xf32> to memref<784x64xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
      %10 = memref.subview %2[%arg0, %arg1] [%7, 64] [1, 1] : memref<1x128xf32> to memref<?x64xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
      scf.for %arg2 = %c0 to %7 step %c1 {
        scf.for %arg3 = %c0 to %c64 step %c1 {
          memref.store %cst, %10[%arg2, %arg3] : memref<?x64xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
        }
      }
      scf.for %arg2 = %c0 to %7 step %c4 {
        scf.for %arg3 = %c0 to %c64 step %c32 {
          scf.for %arg4 = %c0 to %c784 step %c28 {
            %11 = affine.min affine_map<(d0, d1) -> (4, d0 - d1)>(%7, %arg2)
            %12 = memref.subview %8[%arg2, %arg4] [%11, 28] [1, 1] : memref<?x784xf32, affine_map<(d0, d1)[s0] -> (d0 * 784 + s0 + d1)>> to memref<?x28xf32, affine_map<(d0, d1)[s0] -> (d0 * 784 + s0 + d1)>>
            %13 = memref.subview %9[%arg4, %arg3] [28, 32] [1, 1] : memref<784x64xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>> to memref<28x32xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
            %14 = memref.subview %10[%arg2, %arg3] [%11, 32] [1, 1] : memref<?x64xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>> to memref<?x32xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
            scf.for %arg5 = %c0 to %11 step %c4 {
              scf.for %arg6 = %c0 to %c32 step %c4 {
                scf.for %arg7 = %c0 to %c28 step %c4 {
                  %15 = affine.min affine_map<(d0, d1) -> (4, d0 - d1)>(%11, %arg5)
                  %16 = memref.subview %12[%arg5, %arg7] [%15, 4] [1, 1] : memref<?x28xf32, affine_map<(d0, d1)[s0] -> (d0 * 784 + s0 + d1)>> to memref<?x4xf32, affine_map<(d0, d1)[s0] -> (d0 * 784 + s0 + d1)>>
                  %17 = memref.subview %13[%arg7, %arg6] [4, 4] [1, 1] : memref<28x32xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>> to memref<4x4xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
                  %18 = memref.subview %14[%arg5, %arg6] [%15, 4] [1, 1] : memref<?x32xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>> to memref<?x4xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
                  scf.for %arg8 = %c0 to %15 step %c1 {
                    scf.for %arg9 = %c0 to %c4 step %c1 {
                      scf.for %arg10 = %c0 to %c4 step %c1 {
                        %19 = memref.load %16[%arg8, %arg10] : memref<?x4xf32, affine_map<(d0, d1)[s0] -> (d0 * 784 + s0 + d1)>>
                        %20 = memref.load %17[%arg10, %arg9] : memref<4x4xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
                        %21 = memref.load %18[%arg8, %arg9] : memref<?x4xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
                        %22 = mulf %19, %20 : f32
                        %23 = addf %21, %22 : f32
                        memref.store %23, %18[%arg8, %arg9] : memref<?x4xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return
}

// *** IR Dump After SCFToStandard ***
func @predict_dispatch_0() {
  %cst = constant 0.000000e+00 : f32
  %c128 = constant 128 : index
  %c784 = constant 784 : index
  %c28 = constant 28 : index
  %c32 = constant 32 : index
  %c64 = constant 64 : index
  %c4 = constant 4 : index
  %c0 = constant 0 : index
  %c1 = constant 1 : index
  %0 = hal.interface.binding.subspan @io::@s0b1_ro_external[%c0] : memref<1x784xf32>
  %1 = hal.interface.binding.subspan @io::@s0b0_ro_constant[%c0] : memref<784x128xf32>
  %2 = hal.interface.binding.subspan @io::@s0b2_xw_external[%c0] : memref<1x128xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 4)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 4)>()[%workgroup_count_y]
  br ^bb1(%3 : index)
^bb1(%5: index):  // 2 preds: ^bb0, ^bb38
  %6 = cmpi slt, %5, %c1 : index
  cond_br %6, ^bb2, ^bb39
^bb2:  // pred: ^bb1
  %7 = affine.apply affine_map<()[s0] -> (s0 * 64)>()[%workgroup_id_x]
  %8 = affine.apply affine_map<()[s0] -> (s0 * 64)>()[%workgroup_count_x]
  br ^bb3(%7 : index)
^bb3(%9: index):  // 2 preds: ^bb2, ^bb37
  %10 = cmpi slt, %9, %c128 : index
  cond_br %10, ^bb4, ^bb38
^bb4:  // pred: ^bb3
  %11 = affine.min affine_map<(d0) -> (4, -d0 + 1)>(%5)
  %12 = memref.subview %0[%5, 0] [%11, 784] [1, 1] : memref<1x784xf32> to memref<?x784xf32, affine_map<(d0, d1)[s0] -> (d0 * 784 + s0 + d1)>>
  %13 = memref.subview %1[0, %9] [784, 64] [1, 1] : memref<784x128xf32> to memref<784x64xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
  %14 = memref.subview %2[%5, %9] [%11, 64] [1, 1] : memref<1x128xf32> to memref<?x64xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
  br ^bb5(%c0 : index)
^bb5(%15: index):  // 2 preds: ^bb4, ^bb9
  %16 = cmpi slt, %15, %11 : index
  cond_br %16, ^bb6, ^bb10
^bb6:  // pred: ^bb5
  br ^bb7(%c0 : index)
^bb7(%17: index):  // 2 preds: ^bb6, ^bb8
  %18 = cmpi slt, %17, %c64 : index
  cond_br %18, ^bb8, ^bb9
^bb8:  // pred: ^bb7
  memref.store %cst, %14[%15, %17] : memref<?x64xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
  %19 = addi %17, %c1 : index
  br ^bb7(%19 : index)
^bb9:  // pred: ^bb7
  %20 = addi %15, %c1 : index
  br ^bb5(%20 : index)
^bb10:  // pred: ^bb5
  br ^bb11(%c0 : index)
^bb11(%21: index):  // 2 preds: ^bb10, ^bb36
  %22 = cmpi slt, %21, %11 : index
  cond_br %22, ^bb12, ^bb37
^bb12:  // pred: ^bb11
  br ^bb13(%c0 : index)
^bb13(%23: index):  // 2 preds: ^bb12, ^bb35
  %24 = cmpi slt, %23, %c64 : index
  cond_br %24, ^bb14, ^bb36
^bb14:  // pred: ^bb13
  br ^bb15(%c0 : index)
^bb15(%25: index):  // 2 preds: ^bb14, ^bb34
  %26 = cmpi slt, %25, %c784 : index
  cond_br %26, ^bb16, ^bb35
^bb16:  // pred: ^bb15
  %27 = affine.min affine_map<(d0, d1) -> (4, d0 - d1)>(%11, %21)
  %28 = memref.subview %12[%21, %25] [%27, 28] [1, 1] : memref<?x784xf32, affine_map<(d0, d1)[s0] -> (d0 * 784 + s0 + d1)>> to memref<?x28xf32, affine_map<(d0, d1)[s0] -> (d0 * 784 + s0 + d1)>>
  %29 = memref.subview %13[%25, %23] [28, 32] [1, 1] : memref<784x64xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>> to memref<28x32xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
  %30 = memref.subview %14[%21, %23] [%27, 32] [1, 1] : memref<?x64xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>> to memref<?x32xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
  br ^bb17(%c0 : index)
^bb17(%31: index):  // 2 preds: ^bb16, ^bb33
  %32 = cmpi slt, %31, %27 : index
  cond_br %32, ^bb18, ^bb34
^bb18:  // pred: ^bb17
  br ^bb19(%c0 : index)
^bb19(%33: index):  // 2 preds: ^bb18, ^bb32
  %34 = cmpi slt, %33, %c32 : index
  cond_br %34, ^bb20, ^bb33
^bb20:  // pred: ^bb19
  br ^bb21(%c0 : index)
^bb21(%35: index):  // 2 preds: ^bb20, ^bb31
  %36 = cmpi slt, %35, %c28 : index
  cond_br %36, ^bb22, ^bb32
^bb22:  // pred: ^bb21
  %37 = affine.min affine_map<(d0, d1) -> (4, d0 - d1)>(%27, %31)
  %38 = memref.subview %28[%31, %35] [%37, 4] [1, 1] : memref<?x28xf32, affine_map<(d0, d1)[s0] -> (d0 * 784 + s0 + d1)>> to memref<?x4xf32, affine_map<(d0, d1)[s0] -> (d0 * 784 + s0 + d1)>>
  %39 = memref.subview %29[%35, %33] [4, 4] [1, 1] : memref<28x32xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>> to memref<4x4xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
  %40 = memref.subview %30[%31, %33] [%37, 4] [1, 1] : memref<?x32xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>> to memref<?x4xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
  br ^bb23(%c0 : index)
^bb23(%41: index):  // 2 preds: ^bb22, ^bb30
  %42 = cmpi slt, %41, %37 : index
  cond_br %42, ^bb24, ^bb31
^bb24:  // pred: ^bb23
  br ^bb25(%c0 : index)
^bb25(%43: index):  // 2 preds: ^bb24, ^bb29
  %44 = cmpi slt, %43, %c4 : index
  cond_br %44, ^bb26, ^bb30
^bb26:  // pred: ^bb25
  br ^bb27(%c0 : index)
^bb27(%45: index):  // 2 preds: ^bb26, ^bb28
  %46 = cmpi slt, %45, %c4 : index
  cond_br %46, ^bb28, ^bb29
^bb28:  // pred: ^bb27
  %47 = memref.load %38[%41, %45] : memref<?x4xf32, affine_map<(d0, d1)[s0] -> (d0 * 784 + s0 + d1)>>
  %48 = memref.load %39[%45, %43] : memref<4x4xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
  %49 = memref.load %40[%41, %43] : memref<?x4xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
  %50 = mulf %47, %48 : f32
  %51 = addf %49, %50 : f32
  memref.store %51, %40[%41, %43] : memref<?x4xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
  %52 = addi %45, %c1 : index
  br ^bb27(%52 : index)
^bb29:  // pred: ^bb27
  %53 = addi %43, %c1 : index
  br ^bb25(%53 : index)
^bb30:  // pred: ^bb25
  %54 = addi %41, %c1 : index
  br ^bb23(%54 : index)
^bb31:  // pred: ^bb23
  %55 = addi %35, %c4 : index
  br ^bb21(%55 : index)
^bb32:  // pred: ^bb21
  %56 = addi %33, %c4 : index
  br ^bb19(%56 : index)
^bb33:  // pred: ^bb19
  %57 = addi %31, %c4 : index
  br ^bb17(%57 : index)
^bb34:  // pred: ^bb17
  %58 = addi %25, %c28 : index
  br ^bb15(%58 : index)
^bb35:  // pred: ^bb15
  %59 = addi %23, %c32 : index
  br ^bb13(%59 : index)
^bb36:  // pred: ^bb13
  %60 = addi %21, %c4 : index
  br ^bb11(%60 : index)
^bb37:  // pred: ^bb11
  %61 = addi %9, %8 : index
  br ^bb3(%61 : index)
^bb38:  // pred: ^bb3
  %62 = addi %5, %4 : index
  br ^bb1(%62 : index)
^bb39:  // pred: ^bb1
  return
}

// *** IR Dump After Canonicalizer ***
func @predict_dispatch_0() {
  %cst = constant 0.000000e+00 : f32
  %c128 = constant 128 : index
  %c784 = constant 784 : index
  %c28 = constant 28 : index
  %c32 = constant 32 : index
  %c64 = constant 64 : index
  %c4 = constant 4 : index
  %c0 = constant 0 : index
  %c1 = constant 1 : index
  %0 = hal.interface.binding.subspan @io::@s0b1_ro_external[%c0] : memref<1x784xf32>
  %1 = hal.interface.binding.subspan @io::@s0b0_ro_constant[%c0] : memref<784x128xf32>
  %2 = hal.interface.binding.subspan @io::@s0b2_xw_external[%c0] : memref<1x128xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 4)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 4)>()[%workgroup_count_y]
  br ^bb1(%3 : index)
^bb1(%5: index):  // 2 preds: ^bb0, ^bb30
  %6 = cmpi slt, %5, %c1 : index
  cond_br %6, ^bb2, ^bb31
^bb2:  // pred: ^bb1
  %7 = affine.apply affine_map<()[s0] -> (s0 * 64)>()[%workgroup_id_x]
  %8 = affine.apply affine_map<()[s0] -> (s0 * 64)>()[%workgroup_count_x]
  br ^bb3(%7 : index)
^bb3(%9: index):  // 2 preds: ^bb2, ^bb29
  %10 = cmpi slt, %9, %c128 : index
  cond_br %10, ^bb4, ^bb30
^bb4:  // pred: ^bb3
  %11 = affine.min affine_map<()[s0] -> (4, -s0 + 1)>()[%5]
  %12 = memref.subview %0[%5, 0] [%11, 784] [1, 1] : memref<1x784xf32> to memref<?x784xf32, affine_map<(d0, d1)[s0] -> (d0 * 784 + s0 + d1)>>
  %13 = memref.subview %1[0, %9] [784, 64] [1, 1] : memref<784x128xf32> to memref<784x64xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
  %14 = memref.subview %2[%5, %9] [%11, 64] [1, 1] : memref<1x128xf32> to memref<?x64xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
  br ^bb5(%c0 : index)
^bb5(%15: index):  // 2 preds: ^bb4, ^bb8
  %16 = cmpi slt, %15, %11 : index
  cond_br %16, ^bb6(%c0 : index), ^bb9(%c0 : index)
^bb6(%17: index):  // 2 preds: ^bb5, ^bb7
  %18 = cmpi slt, %17, %c64 : index
  cond_br %18, ^bb7, ^bb8
^bb7:  // pred: ^bb6
  memref.store %cst, %14[%15, %17] : memref<?x64xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
  %19 = addi %17, %c1 : index
  br ^bb6(%19 : index)
^bb8:  // pred: ^bb6
  %20 = addi %15, %c1 : index
  br ^bb5(%20 : index)
^bb9(%21: index):  // 2 preds: ^bb5, ^bb28
  %22 = cmpi slt, %21, %11 : index
  cond_br %22, ^bb10(%c0 : index), ^bb29
^bb10(%23: index):  // 2 preds: ^bb9, ^bb27
  %24 = cmpi slt, %23, %c64 : index
  cond_br %24, ^bb11(%c0 : index), ^bb28
^bb11(%25: index):  // 2 preds: ^bb10, ^bb26
  %26 = cmpi slt, %25, %c784 : index
  cond_br %26, ^bb12, ^bb27
^bb12:  // pred: ^bb11
  %27 = affine.min affine_map<()[s0, s1] -> (4, s0 - s1)>()[%11, %21]
  %28 = memref.subview %12[%21, %25] [%27, 28] [1, 1] : memref<?x784xf32, affine_map<(d0, d1)[s0] -> (d0 * 784 + s0 + d1)>> to memref<?x28xf32, affine_map<(d0, d1)[s0] -> (d0 * 784 + s0 + d1)>>
  %29 = memref.subview %13[%25, %23] [28, 32] [1, 1] : memref<784x64xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>> to memref<28x32xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
  %30 = memref.subview %14[%21, %23] [%27, 32] [1, 1] : memref<?x64xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>> to memref<?x32xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
  br ^bb13(%c0 : index)
^bb13(%31: index):  // 2 preds: ^bb12, ^bb25
  %32 = cmpi slt, %31, %27 : index
  cond_br %32, ^bb14(%c0 : index), ^bb26
^bb14(%33: index):  // 2 preds: ^bb13, ^bb24
  %34 = cmpi slt, %33, %c32 : index
  cond_br %34, ^bb15(%c0 : index), ^bb25
^bb15(%35: index):  // 2 preds: ^bb14, ^bb23
  %36 = cmpi slt, %35, %c28 : index
  cond_br %36, ^bb16, ^bb24
^bb16:  // pred: ^bb15
  %37 = affine.min affine_map<()[s0, s1] -> (4, s0 - s1)>()[%27, %31]
  %38 = memref.subview %28[%31, %35] [%37, 4] [1, 1] : memref<?x28xf32, affine_map<(d0, d1)[s0] -> (d0 * 784 + s0 + d1)>> to memref<?x4xf32, affine_map<(d0, d1)[s0] -> (d0 * 784 + s0 + d1)>>
  %39 = memref.subview %29[%35, %33] [4, 4] [1, 1] : memref<28x32xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>> to memref<4x4xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
  %40 = memref.subview %30[%31, %33] [%37, 4] [1, 1] : memref<?x32xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>> to memref<?x4xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
  br ^bb17(%c0 : index)
^bb17(%41: index):  // 2 preds: ^bb16, ^bb22
  %42 = cmpi slt, %41, %37 : index
  cond_br %42, ^bb18(%c0 : index), ^bb23
^bb18(%43: index):  // 2 preds: ^bb17, ^bb21
  %44 = cmpi slt, %43, %c4 : index
  cond_br %44, ^bb19(%c0 : index), ^bb22
^bb19(%45: index):  // 2 preds: ^bb18, ^bb20
  %46 = cmpi slt, %45, %c4 : index
  cond_br %46, ^bb20, ^bb21
^bb20:  // pred: ^bb19
  %47 = memref.load %38[%41, %45] : memref<?x4xf32, affine_map<(d0, d1)[s0] -> (d0 * 784 + s0 + d1)>>
  %48 = memref.load %39[%45, %43] : memref<4x4xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
  %49 = memref.load %40[%41, %43] : memref<?x4xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
  %50 = mulf %47, %48 : f32
  %51 = addf %49, %50 : f32
  memref.store %51, %40[%41, %43] : memref<?x4xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
  %52 = addi %45, %c1 : index
  br ^bb19(%52 : index)
^bb21:  // pred: ^bb19
  %53 = addi %43, %c1 : index
  br ^bb18(%53 : index)
^bb22:  // pred: ^bb18
  %54 = addi %41, %c1 : index
  br ^bb17(%54 : index)
^bb23:  // pred: ^bb17
  %55 = addi %35, %c4 : index
  br ^bb15(%55 : index)
^bb24:  // pred: ^bb15
  %56 = addi %33, %c4 : index
  br ^bb14(%56 : index)
^bb25:  // pred: ^bb14
  %57 = addi %31, %c4 : index
  br ^bb13(%57 : index)
^bb26:  // pred: ^bb13
  %58 = addi %25, %c28 : index
  br ^bb11(%58 : index)
^bb27:  // pred: ^bb11
  %59 = addi %23, %c32 : index
  br ^bb10(%59 : index)
^bb28:  // pred: ^bb10
  %60 = addi %21, %c4 : index
  br ^bb9(%60 : index)
^bb29:  // pred: ^bb9
  %61 = addi %9, %8 : index
  br ^bb3(%61 : index)
^bb30:  // pred: ^bb3
  %62 = addi %5, %4 : index
  br ^bb1(%62 : index)
^bb31:  // pred: ^bb1
  return
}

// *** IR Dump After CSE ***
func @predict_dispatch_0() {
  %cst = constant 0.000000e+00 : f32
  %c128 = constant 128 : index
  %c784 = constant 784 : index
  %c28 = constant 28 : index
  %c32 = constant 32 : index
  %c64 = constant 64 : index
  %c4 = constant 4 : index
  %c0 = constant 0 : index
  %c1 = constant 1 : index
  %0 = hal.interface.binding.subspan @io::@s0b1_ro_external[%c0] : memref<1x784xf32>
  %1 = hal.interface.binding.subspan @io::@s0b0_ro_constant[%c0] : memref<784x128xf32>
  %2 = hal.interface.binding.subspan @io::@s0b2_xw_external[%c0] : memref<1x128xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 4)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 4)>()[%workgroup_count_y]
  br ^bb1(%3 : index)
^bb1(%5: index):  // 2 preds: ^bb0, ^bb30
  %6 = cmpi slt, %5, %c1 : index
  cond_br %6, ^bb2, ^bb31
^bb2:  // pred: ^bb1
  %7 = affine.apply affine_map<()[s0] -> (s0 * 64)>()[%workgroup_id_x]
  %8 = affine.apply affine_map<()[s0] -> (s0 * 64)>()[%workgroup_count_x]
  br ^bb3(%7 : index)
^bb3(%9: index):  // 2 preds: ^bb2, ^bb29
  %10 = cmpi slt, %9, %c128 : index
  cond_br %10, ^bb4, ^bb30
^bb4:  // pred: ^bb3
  %11 = affine.min affine_map<()[s0] -> (4, -s0 + 1)>()[%5]
  %12 = memref.subview %0[%5, 0] [%11, 784] [1, 1] : memref<1x784xf32> to memref<?x784xf32, affine_map<(d0, d1)[s0] -> (d0 * 784 + s0 + d1)>>
  %13 = memref.subview %1[0, %9] [784, 64] [1, 1] : memref<784x128xf32> to memref<784x64xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
  %14 = memref.subview %2[%5, %9] [%11, 64] [1, 1] : memref<1x128xf32> to memref<?x64xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
  br ^bb5(%c0 : index)
^bb5(%15: index):  // 2 preds: ^bb4, ^bb8
  %16 = cmpi slt, %15, %11 : index
  cond_br %16, ^bb6(%c0 : index), ^bb9(%c0 : index)
^bb6(%17: index):  // 2 preds: ^bb5, ^bb7
  %18 = cmpi slt, %17, %c64 : index
  cond_br %18, ^bb7, ^bb8
^bb7:  // pred: ^bb6
  memref.store %cst, %14[%15, %17] : memref<?x64xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
  %19 = addi %17, %c1 : index
  br ^bb6(%19 : index)
^bb8:  // pred: ^bb6
  %20 = addi %15, %c1 : index
  br ^bb5(%20 : index)
^bb9(%21: index):  // 2 preds: ^bb5, ^bb28
  %22 = cmpi slt, %21, %11 : index
  cond_br %22, ^bb10(%c0 : index), ^bb29
^bb10(%23: index):  // 2 preds: ^bb9, ^bb27
  %24 = cmpi slt, %23, %c64 : index
  cond_br %24, ^bb11(%c0 : index), ^bb28
^bb11(%25: index):  // 2 preds: ^bb10, ^bb26
  %26 = cmpi slt, %25, %c784 : index
  cond_br %26, ^bb12, ^bb27
^bb12:  // pred: ^bb11
  %27 = affine.min affine_map<()[s0, s1] -> (4, s0 - s1)>()[%11, %21]
  %28 = memref.subview %12[%21, %25] [%27, 28] [1, 1] : memref<?x784xf32, affine_map<(d0, d1)[s0] -> (d0 * 784 + s0 + d1)>> to memref<?x28xf32, affine_map<(d0, d1)[s0] -> (d0 * 784 + s0 + d1)>>
  %29 = memref.subview %13[%25, %23] [28, 32] [1, 1] : memref<784x64xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>> to memref<28x32xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
  %30 = memref.subview %14[%21, %23] [%27, 32] [1, 1] : memref<?x64xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>> to memref<?x32xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
  br ^bb13(%c0 : index)
^bb13(%31: index):  // 2 preds: ^bb12, ^bb25
  %32 = cmpi slt, %31, %27 : index
  cond_br %32, ^bb14(%c0 : index), ^bb26
^bb14(%33: index):  // 2 preds: ^bb13, ^bb24
  %34 = cmpi slt, %33, %c32 : index
  cond_br %34, ^bb15(%c0 : index), ^bb25
^bb15(%35: index):  // 2 preds: ^bb14, ^bb23
  %36 = cmpi slt, %35, %c28 : index
  cond_br %36, ^bb16, ^bb24
^bb16:  // pred: ^bb15
  %37 = affine.min affine_map<()[s0, s1] -> (4, s0 - s1)>()[%27, %31]
  %38 = memref.subview %28[%31, %35] [%37, 4] [1, 1] : memref<?x28xf32, affine_map<(d0, d1)[s0] -> (d0 * 784 + s0 + d1)>> to memref<?x4xf32, affine_map<(d0, d1)[s0] -> (d0 * 784 + s0 + d1)>>
  %39 = memref.subview %29[%35, %33] [4, 4] [1, 1] : memref<28x32xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>> to memref<4x4xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
  %40 = memref.subview %30[%31, %33] [%37, 4] [1, 1] : memref<?x32xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>> to memref<?x4xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
  br ^bb17(%c0 : index)
^bb17(%41: index):  // 2 preds: ^bb16, ^bb22
  %42 = cmpi slt, %41, %37 : index
  cond_br %42, ^bb18(%c0 : index), ^bb23
^bb18(%43: index):  // 2 preds: ^bb17, ^bb21
  %44 = cmpi slt, %43, %c4 : index
  cond_br %44, ^bb19(%c0 : index), ^bb22
^bb19(%45: index):  // 2 preds: ^bb18, ^bb20
  %46 = cmpi slt, %45, %c4 : index
  cond_br %46, ^bb20, ^bb21
^bb20:  // pred: ^bb19
  %47 = memref.load %38[%41, %45] : memref<?x4xf32, affine_map<(d0, d1)[s0] -> (d0 * 784 + s0 + d1)>>
  %48 = memref.load %39[%45, %43] : memref<4x4xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
  %49 = memref.load %40[%41, %43] : memref<?x4xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
  %50 = mulf %47, %48 : f32
  %51 = addf %49, %50 : f32
  memref.store %51, %40[%41, %43] : memref<?x4xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
  %52 = addi %45, %c1 : index
  br ^bb19(%52 : index)
^bb21:  // pred: ^bb19
  %53 = addi %43, %c1 : index
  br ^bb18(%53 : index)
^bb22:  // pred: ^bb18
  %54 = addi %41, %c1 : index
  br ^bb17(%54 : index)
^bb23:  // pred: ^bb17
  %55 = addi %35, %c4 : index
  br ^bb15(%55 : index)
^bb24:  // pred: ^bb15
  %56 = addi %33, %c4 : index
  br ^bb14(%56 : index)
^bb25:  // pred: ^bb14
  %57 = addi %31, %c4 : index
  br ^bb13(%57 : index)
^bb26:  // pred: ^bb13
  %58 = addi %25, %c28 : index
  br ^bb11(%58 : index)
^bb27:  // pred: ^bb11
  %59 = addi %23, %c32 : index
  br ^bb10(%59 : index)
^bb28:  // pred: ^bb10
  %60 = addi %21, %c4 : index
  br ^bb9(%60 : index)
^bb29:  // pred: ^bb9
  %61 = addi %9, %8 : index
  br ^bb3(%61 : index)
^bb30:  // pred: ^bb3
  %62 = addi %5, %4 : index
  br ^bb1(%62 : index)
^bb31:  // pred: ^bb1
  return
}

// *** IR Dump After TensorConstantBufferize ***
module  {
  func @predict_dispatch_0() {
    %cst = constant 0.000000e+00 : f32
    %c128 = constant 128 : index
    %c784 = constant 784 : index
    %c28 = constant 28 : index
    %c32 = constant 32 : index
    %c64 = constant 64 : index
    %c4 = constant 4 : index
    %c0 = constant 0 : index
    %c1 = constant 1 : index
    %0 = hal.interface.binding.subspan @io::@s0b1_ro_external[%c0] : memref<1x784xf32>
    %1 = hal.interface.binding.subspan @io::@s0b0_ro_constant[%c0] : memref<784x128xf32>
    %2 = hal.interface.binding.subspan @io::@s0b2_xw_external[%c0] : memref<1x128xf32>
    %workgroup_id_x = hal.interface.workgroup.id[0] : index
    %workgroup_count_x = hal.interface.workgroup.count[0] : index
    %workgroup_id_y = hal.interface.workgroup.id[1] : index
    %workgroup_count_y = hal.interface.workgroup.count[1] : index
    %3 = affine.apply affine_map<()[s0] -> (s0 * 4)>()[%workgroup_id_y]
    %4 = affine.apply affine_map<()[s0] -> (s0 * 4)>()[%workgroup_count_y]
    br ^bb1(%3 : index)
  ^bb1(%5: index):  // 2 preds: ^bb0, ^bb30
    %6 = cmpi slt, %5, %c1 : index
    cond_br %6, ^bb2, ^bb31
  ^bb2:  // pred: ^bb1
    %7 = affine.apply affine_map<()[s0] -> (s0 * 64)>()[%workgroup_id_x]
    %8 = affine.apply affine_map<()[s0] -> (s0 * 64)>()[%workgroup_count_x]
    br ^bb3(%7 : index)
  ^bb3(%9: index):  // 2 preds: ^bb2, ^bb29
    %10 = cmpi slt, %9, %c128 : index
    cond_br %10, ^bb4, ^bb30
  ^bb4:  // pred: ^bb3
    %11 = affine.min affine_map<()[s0] -> (4, -s0 + 1)>()[%5]
    %12 = memref.subview %0[%5, 0] [%11, 784] [1, 1] : memref<1x784xf32> to memref<?x784xf32, affine_map<(d0, d1)[s0] -> (d0 * 784 + s0 + d1)>>
    %13 = memref.subview %1[0, %9] [784, 64] [1, 1] : memref<784x128xf32> to memref<784x64xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
    %14 = memref.subview %2[%5, %9] [%11, 64] [1, 1] : memref<1x128xf32> to memref<?x64xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
    br ^bb5(%c0 : index)
  ^bb5(%15: index):  // 2 preds: ^bb4, ^bb8
    %16 = cmpi slt, %15, %11 : index
    cond_br %16, ^bb6(%c0 : index), ^bb9(%c0 : index)
  ^bb6(%17: index):  // 2 preds: ^bb5, ^bb7
    %18 = cmpi slt, %17, %c64 : index
    cond_br %18, ^bb7, ^bb8
  ^bb7:  // pred: ^bb6
    memref.store %cst, %14[%15, %17] : memref<?x64xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
    %19 = addi %17, %c1 : index
    br ^bb6(%19 : index)
  ^bb8:  // pred: ^bb6
    %20 = addi %15, %c1 : index
    br ^bb5(%20 : index)
  ^bb9(%21: index):  // 2 preds: ^bb5, ^bb28
    %22 = cmpi slt, %21, %11 : index
    cond_br %22, ^bb10(%c0 : index), ^bb29
  ^bb10(%23: index):  // 2 preds: ^bb9, ^bb27
    %24 = cmpi slt, %23, %c64 : index
    cond_br %24, ^bb11(%c0 : index), ^bb28
  ^bb11(%25: index):  // 2 preds: ^bb10, ^bb26
    %26 = cmpi slt, %25, %c784 : index
    cond_br %26, ^bb12, ^bb27
  ^bb12:  // pred: ^bb11
    %27 = affine.min affine_map<()[s0, s1] -> (4, s0 - s1)>()[%11, %21]
    %28 = memref.subview %12[%21, %25] [%27, 28] [1, 1] : memref<?x784xf32, affine_map<(d0, d1)[s0] -> (d0 * 784 + s0 + d1)>> to memref<?x28xf32, affine_map<(d0, d1)[s0] -> (d0 * 784 + s0 + d1)>>
    %29 = memref.subview %13[%25, %23] [28, 32] [1, 1] : memref<784x64xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>> to memref<28x32xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
    %30 = memref.subview %14[%21, %23] [%27, 32] [1, 1] : memref<?x64xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>> to memref<?x32xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
    br ^bb13(%c0 : index)
  ^bb13(%31: index):  // 2 preds: ^bb12, ^bb25
    %32 = cmpi slt, %31, %27 : index
    cond_br %32, ^bb14(%c0 : index), ^bb26
  ^bb14(%33: index):  // 2 preds: ^bb13, ^bb24
    %34 = cmpi slt, %33, %c32 : index
    cond_br %34, ^bb15(%c0 : index), ^bb25
  ^bb15(%35: index):  // 2 preds: ^bb14, ^bb23
    %36 = cmpi slt, %35, %c28 : index
    cond_br %36, ^bb16, ^bb24
  ^bb16:  // pred: ^bb15
    %37 = affine.min affine_map<()[s0, s1] -> (4, s0 - s1)>()[%27, %31]
    %38 = memref.subview %28[%31, %35] [%37, 4] [1, 1] : memref<?x28xf32, affine_map<(d0, d1)[s0] -> (d0 * 784 + s0 + d1)>> to memref<?x4xf32, affine_map<(d0, d1)[s0] -> (d0 * 784 + s0 + d1)>>
    %39 = memref.subview %29[%35, %33] [4, 4] [1, 1] : memref<28x32xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>> to memref<4x4xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
    %40 = memref.subview %30[%31, %33] [%37, 4] [1, 1] : memref<?x32xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>> to memref<?x4xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
    br ^bb17(%c0 : index)
  ^bb17(%41: index):  // 2 preds: ^bb16, ^bb22
    %42 = cmpi slt, %41, %37 : index
    cond_br %42, ^bb18(%c0 : index), ^bb23
  ^bb18(%43: index):  // 2 preds: ^bb17, ^bb21
    %44 = cmpi slt, %43, %c4 : index
    cond_br %44, ^bb19(%c0 : index), ^bb22
  ^bb19(%45: index):  // 2 preds: ^bb18, ^bb20
    %46 = cmpi slt, %45, %c4 : index
    cond_br %46, ^bb20, ^bb21
  ^bb20:  // pred: ^bb19
    %47 = memref.load %38[%41, %45] : memref<?x4xf32, affine_map<(d0, d1)[s0] -> (d0 * 784 + s0 + d1)>>
    %48 = memref.load %39[%45, %43] : memref<4x4xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
    %49 = memref.load %40[%41, %43] : memref<?x4xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
    %50 = mulf %47, %48 : f32
    %51 = addf %49, %50 : f32
    memref.store %51, %40[%41, %43] : memref<?x4xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
    %52 = addi %45, %c1 : index
    br ^bb19(%52 : index)
  ^bb21:  // pred: ^bb19
    %53 = addi %43, %c1 : index
    br ^bb18(%53 : index)
  ^bb22:  // pred: ^bb18
    %54 = addi %41, %c1 : index
    br ^bb17(%54 : index)
  ^bb23:  // pred: ^bb17
    %55 = addi %35, %c4 : index
    br ^bb15(%55 : index)
  ^bb24:  // pred: ^bb15
    %56 = addi %33, %c4 : index
    br ^bb14(%56 : index)
  ^bb25:  // pred: ^bb14
    %57 = addi %31, %c4 : index
    br ^bb13(%57 : index)
  ^bb26:  // pred: ^bb13
    %58 = addi %25, %c28 : index
    br ^bb11(%58 : index)
  ^bb27:  // pred: ^bb11
    %59 = addi %23, %c32 : index
    br ^bb10(%59 : index)
  ^bb28:  // pred: ^bb10
    %60 = addi %21, %c4 : index
    br ^bb9(%60 : index)
  ^bb29:  // pred: ^bb9
    %61 = addi %9, %8 : index
    br ^bb3(%61 : index)
  ^bb30:  // pred: ^bb3
    %62 = addi %5, %4 : index
    br ^bb1(%62 : index)
  ^bb31:  // pred: ^bb1
    return
  }
  hal.interface @io attributes {sym_visibility = "private"} {
    hal.interface.binding @s0b0_ro_constant, set=0, binding=0, type="StorageBuffer", access="Read"
    hal.interface.binding @s0b1_ro_external, set=0, binding=1, type="StorageBuffer", access="Read"
    hal.interface.binding @s0b2_xw_external, set=0, binding=2, type="StorageBuffer", access="Write|Discard"
  }
}

// *** IR Dump After mlir::iree_compiler::`anonymous-namespace'::FoldTensorExtractOpPass ***
module  {
  func @predict_dispatch_0() {
    %cst = constant 0.000000e+00 : f32
    %c128 = constant 128 : index
    %c784 = constant 784 : index
    %c28 = constant 28 : index
    %c32 = constant 32 : index
    %c64 = constant 64 : index
    %c4 = constant 4 : index
    %c0 = constant 0 : index
    %c1 = constant 1 : index
    %0 = hal.interface.binding.subspan @io::@s0b1_ro_external[%c0] : memref<1x784xf32>
    %1 = hal.interface.binding.subspan @io::@s0b0_ro_constant[%c0] : memref<784x128xf32>
    %2 = hal.interface.binding.subspan @io::@s0b2_xw_external[%c0] : memref<1x128xf32>
    %workgroup_id_x = hal.interface.workgroup.id[0] : index
    %workgroup_count_x = hal.interface.workgroup.count[0] : index
    %workgroup_id_y = hal.interface.workgroup.id[1] : index
    %workgroup_count_y = hal.interface.workgroup.count[1] : index
    %3 = affine.apply affine_map<()[s0] -> (s0 * 4)>()[%workgroup_id_y]
    %4 = affine.apply affine_map<()[s0] -> (s0 * 4)>()[%workgroup_count_y]
    br ^bb1(%3 : index)
  ^bb1(%5: index):  // 2 preds: ^bb0, ^bb30
    %6 = cmpi slt, %5, %c1 : index
    cond_br %6, ^bb2, ^bb31
  ^bb2:  // pred: ^bb1
    %7 = affine.apply affine_map<()[s0] -> (s0 * 64)>()[%workgroup_id_x]
    %8 = affine.apply affine_map<()[s0] -> (s0 * 64)>()[%workgroup_count_x]
    br ^bb3(%7 : index)
  ^bb3(%9: index):  // 2 preds: ^bb2, ^bb29
    %10 = cmpi slt, %9, %c128 : index
    cond_br %10, ^bb4, ^bb30
  ^bb4:  // pred: ^bb3
    %11 = affine.min affine_map<()[s0] -> (4, -s0 + 1)>()[%5]
    %12 = memref.subview %0[%5, 0] [%11, 784] [1, 1] : memref<1x784xf32> to memref<?x784xf32, affine_map<(d0, d1)[s0] -> (d0 * 784 + s0 + d1)>>
    %13 = memref.subview %1[0, %9] [784, 64] [1, 1] : memref<784x128xf32> to memref<784x64xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
    %14 = memref.subview %2[%5, %9] [%11, 64] [1, 1] : memref<1x128xf32> to memref<?x64xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
    br ^bb5(%c0 : index)
  ^bb5(%15: index):  // 2 preds: ^bb4, ^bb8
    %16 = cmpi slt, %15, %11 : index
    cond_br %16, ^bb6(%c0 : index), ^bb9(%c0 : index)
  ^bb6(%17: index):  // 2 preds: ^bb5, ^bb7
    %18 = cmpi slt, %17, %c64 : index
    cond_br %18, ^bb7, ^bb8
  ^bb7:  // pred: ^bb6
    memref.store %cst, %14[%15, %17] : memref<?x64xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
    %19 = addi %17, %c1 : index
    br ^bb6(%19 : index)
  ^bb8:  // pred: ^bb6
    %20 = addi %15, %c1 : index
    br ^bb5(%20 : index)
  ^bb9(%21: index):  // 2 preds: ^bb5, ^bb28
    %22 = cmpi slt, %21, %11 : index
    cond_br %22, ^bb10(%c0 : index), ^bb29
  ^bb10(%23: index):  // 2 preds: ^bb9, ^bb27
    %24 = cmpi slt, %23, %c64 : index
    cond_br %24, ^bb11(%c0 : index), ^bb28
  ^bb11(%25: index):  // 2 preds: ^bb10, ^bb26
    %26 = cmpi slt, %25, %c784 : index
    cond_br %26, ^bb12, ^bb27
  ^bb12:  // pred: ^bb11
    %27 = affine.min affine_map<()[s0, s1] -> (4, s0 - s1)>()[%11, %21]
    %28 = memref.subview %12[%21, %25] [%27, 28] [1, 1] : memref<?x784xf32, affine_map<(d0, d1)[s0] -> (d0 * 784 + s0 + d1)>> to memref<?x28xf32, affine_map<(d0, d1)[s0] -> (d0 * 784 + s0 + d1)>>
    %29 = memref.subview %13[%25, %23] [28, 32] [1, 1] : memref<784x64xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>> to memref<28x32xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
    %30 = memref.subview %14[%21, %23] [%27, 32] [1, 1] : memref<?x64xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>> to memref<?x32xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
    br ^bb13(%c0 : index)
  ^bb13(%31: index):  // 2 preds: ^bb12, ^bb25
    %32 = cmpi slt, %31, %27 : index
    cond_br %32, ^bb14(%c0 : index), ^bb26
  ^bb14(%33: index):  // 2 preds: ^bb13, ^bb24
    %34 = cmpi slt, %33, %c32 : index
    cond_br %34, ^bb15(%c0 : index), ^bb25
  ^bb15(%35: index):  // 2 preds: ^bb14, ^bb23
    %36 = cmpi slt, %35, %c28 : index
    cond_br %36, ^bb16, ^bb24
  ^bb16:  // pred: ^bb15
    %37 = affine.min affine_map<()[s0, s1] -> (4, s0 - s1)>()[%27, %31]
    %38 = memref.subview %28[%31, %35] [%37, 4] [1, 1] : memref<?x28xf32, affine_map<(d0, d1)[s0] -> (d0 * 784 + s0 + d1)>> to memref<?x4xf32, affine_map<(d0, d1)[s0] -> (d0 * 784 + s0 + d1)>>
    %39 = memref.subview %29[%35, %33] [4, 4] [1, 1] : memref<28x32xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>> to memref<4x4xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
    %40 = memref.subview %30[%31, %33] [%37, 4] [1, 1] : memref<?x32xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>> to memref<?x4xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
    br ^bb17(%c0 : index)
  ^bb17(%41: index):  // 2 preds: ^bb16, ^bb22
    %42 = cmpi slt, %41, %37 : index
    cond_br %42, ^bb18(%c0 : index), ^bb23
  ^bb18(%43: index):  // 2 preds: ^bb17, ^bb21
    %44 = cmpi slt, %43, %c4 : index
    cond_br %44, ^bb19(%c0 : index), ^bb22
  ^bb19(%45: index):  // 2 preds: ^bb18, ^bb20
    %46 = cmpi slt, %45, %c4 : index
    cond_br %46, ^bb20, ^bb21
  ^bb20:  // pred: ^bb19
    %47 = memref.load %38[%41, %45] : memref<?x4xf32, affine_map<(d0, d1)[s0] -> (d0 * 784 + s0 + d1)>>
    %48 = memref.load %39[%45, %43] : memref<4x4xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
    %49 = memref.load %40[%41, %43] : memref<?x4xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
    %50 = mulf %47, %48 : f32
    %51 = addf %49, %50 : f32
    memref.store %51, %40[%41, %43] : memref<?x4xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
    %52 = addi %45, %c1 : index
    br ^bb19(%52 : index)
  ^bb21:  // pred: ^bb19
    %53 = addi %43, %c1 : index
    br ^bb18(%53 : index)
  ^bb22:  // pred: ^bb18
    %54 = addi %41, %c1 : index
    br ^bb17(%54 : index)
  ^bb23:  // pred: ^bb17
    %55 = addi %35, %c4 : index
    br ^bb15(%55 : index)
  ^bb24:  // pred: ^bb15
    %56 = addi %33, %c4 : index
    br ^bb14(%56 : index)
  ^bb25:  // pred: ^bb14
    %57 = addi %31, %c4 : index
    br ^bb13(%57 : index)
  ^bb26:  // pred: ^bb13
    %58 = addi %25, %c28 : index
    br ^bb11(%58 : index)
  ^bb27:  // pred: ^bb11
    %59 = addi %23, %c32 : index
    br ^bb10(%59 : index)
  ^bb28:  // pred: ^bb10
    %60 = addi %21, %c4 : index
    br ^bb9(%60 : index)
  ^bb29:  // pred: ^bb9
    %61 = addi %9, %8 : index
    br ^bb3(%61 : index)
  ^bb30:  // pred: ^bb3
    %62 = addi %5, %4 : index
    br ^bb1(%62 : index)
  ^bb31:  // pred: ^bb1
    return
  }
  hal.interface @io attributes {sym_visibility = "private"} {
    hal.interface.binding @s0b0_ro_constant, set=0, binding=0, type="StorageBuffer", access="Read"
    hal.interface.binding @s0b1_ro_external, set=0, binding=1, type="StorageBuffer", access="Read"
    hal.interface.binding @s0b2_xw_external, set=0, binding=2, type="StorageBuffer", access="Write|Discard"
  }
}

// *** IR Dump After mlir::iree_compiler::`anonymous-namespace'::ConvertToLLVMPass ***
module  {
  llvm.func internal @predict_dispatch_0(%arg0: !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>, %arg1: !llvm.ptr<array<3 x i32>>) -> i32 {
    %0 = llvm.mlir.constant(0.000000e+00 : f32) : f32
    %1 = llvm.mlir.constant(128 : index) : i64
    %2 = llvm.mlir.constant(784 : index) : i64
    %3 = llvm.mlir.constant(28 : index) : i64
    %4 = llvm.mlir.constant(32 : index) : i64
    %5 = llvm.mlir.constant(64 : index) : i64
    %6 = llvm.mlir.constant(4 : index) : i64
    %7 = llvm.mlir.constant(0 : index) : i64
    %8 = llvm.mlir.constant(1 : index) : i64
    %9 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
    %10 = llvm.extractvalue %9[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
    %11 = llvm.mlir.constant(1 : index) : i64
    %12 = llvm.getelementptr %10[%11] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
    %13 = llvm.load %12 : !llvm.ptr<ptr<i8>>
    %14 = llvm.getelementptr %13[%7] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
    %15 = llvm.bitcast %14 : !llvm.ptr<i8> to !llvm.ptr<f32>
    %16 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %17 = llvm.insertvalue %15, %16[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %18 = llvm.insertvalue %15, %17[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %19 = llvm.mlir.constant(0 : index) : i64
    %20 = llvm.insertvalue %19, %18[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %21 = llvm.mlir.constant(1 : index) : i64
    %22 = llvm.insertvalue %21, %20[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %23 = llvm.mlir.constant(784 : index) : i64
    %24 = llvm.insertvalue %23, %22[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %25 = llvm.mlir.constant(784 : index) : i64
    %26 = llvm.insertvalue %25, %24[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %27 = llvm.mlir.constant(1 : index) : i64
    %28 = llvm.insertvalue %27, %26[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %29 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
    %30 = llvm.extractvalue %29[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
    %31 = llvm.mlir.constant(0 : index) : i64
    %32 = llvm.getelementptr %30[%31] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
    %33 = llvm.load %32 : !llvm.ptr<ptr<i8>>
    %34 = llvm.getelementptr %33[%7] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
    %35 = llvm.bitcast %34 : !llvm.ptr<i8> to !llvm.ptr<f32>
    %36 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %37 = llvm.insertvalue %35, %36[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %38 = llvm.insertvalue %35, %37[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %39 = llvm.mlir.constant(0 : index) : i64
    %40 = llvm.insertvalue %39, %38[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %41 = llvm.mlir.constant(784 : index) : i64
    %42 = llvm.insertvalue %41, %40[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %43 = llvm.mlir.constant(128 : index) : i64
    %44 = llvm.insertvalue %43, %42[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %45 = llvm.mlir.constant(128 : index) : i64
    %46 = llvm.insertvalue %45, %44[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %47 = llvm.mlir.constant(1 : index) : i64
    %48 = llvm.insertvalue %47, %46[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %49 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
    %50 = llvm.extractvalue %49[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
    %51 = llvm.mlir.constant(2 : index) : i64
    %52 = llvm.getelementptr %50[%51] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
    %53 = llvm.load %52 : !llvm.ptr<ptr<i8>>
    %54 = llvm.getelementptr %53[%7] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
    %55 = llvm.bitcast %54 : !llvm.ptr<i8> to !llvm.ptr<f32>
    %56 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %57 = llvm.insertvalue %55, %56[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %58 = llvm.insertvalue %55, %57[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %59 = llvm.mlir.constant(0 : index) : i64
    %60 = llvm.insertvalue %59, %58[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %61 = llvm.mlir.constant(1 : index) : i64
    %62 = llvm.insertvalue %61, %60[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %63 = llvm.mlir.constant(128 : index) : i64
    %64 = llvm.insertvalue %63, %62[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %65 = llvm.mlir.constant(128 : index) : i64
    %66 = llvm.insertvalue %65, %64[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %67 = llvm.mlir.constant(1 : index) : i64
    %68 = llvm.insertvalue %67, %66[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %69 = llvm.load %arg1 : !llvm.ptr<array<3 x i32>>
    %70 = llvm.extractvalue %69[0] : !llvm.array<3 x i32>
    %71 = llvm.zext %70 : i32 to i64
    %72 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
    %73 = llvm.extractvalue %72[0] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
    %74 = llvm.extractvalue %73[0] : !llvm.array<3 x i32>
    %75 = llvm.zext %74 : i32 to i64
    %76 = llvm.load %arg1 : !llvm.ptr<array<3 x i32>>
    %77 = llvm.extractvalue %76[1] : !llvm.array<3 x i32>
    %78 = llvm.zext %77 : i32 to i64
    %79 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
    %80 = llvm.extractvalue %79[0] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
    %81 = llvm.extractvalue %80[1] : !llvm.array<3 x i32>
    %82 = llvm.zext %81 : i32 to i64
    %83 = llvm.mlir.constant(4 : index) : i64
    %84 = llvm.mul %78, %83  : i64
    %85 = llvm.mlir.constant(4 : index) : i64
    %86 = llvm.mul %82, %85  : i64
    llvm.br ^bb1(%84 : i64)
  ^bb1(%87: i64):  // 2 preds: ^bb0, ^bb30
    %88 = llvm.icmp "slt" %87, %8 : i64
    llvm.cond_br %88, ^bb2, ^bb31
  ^bb2:  // pred: ^bb1
    %89 = llvm.mlir.constant(64 : index) : i64
    %90 = llvm.mul %71, %89  : i64
    %91 = llvm.mlir.constant(64 : index) : i64
    %92 = llvm.mul %75, %91  : i64
    llvm.br ^bb3(%90 : i64)
  ^bb3(%93: i64):  // 2 preds: ^bb2, ^bb29
    %94 = llvm.icmp "slt" %93, %1 : i64
    llvm.cond_br %94, ^bb4, ^bb30
  ^bb4:  // pred: ^bb3
    %95 = llvm.mlir.constant(4 : index) : i64
    %96 = llvm.mlir.constant(-1 : index) : i64
    %97 = llvm.mul %87, %96  : i64
    %98 = llvm.mlir.constant(1 : index) : i64
    %99 = llvm.add %97, %98  : i64
    %100 = llvm.icmp "slt" %95, %99 : i64
    %101 = llvm.select %100, %95, %99 : i1, i64
    %102 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %103 = llvm.extractvalue %28[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %104 = llvm.bitcast %103 : !llvm.ptr<f32> to !llvm.ptr<f32>
    %105 = llvm.insertvalue %104, %102[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %106 = llvm.extractvalue %28[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %107 = llvm.bitcast %106 : !llvm.ptr<f32> to !llvm.ptr<f32>
    %108 = llvm.insertvalue %107, %105[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %109 = llvm.extractvalue %28[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %110 = llvm.extractvalue %28[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %111 = llvm.extractvalue %28[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %112 = llvm.mul %87, %109  : i64
    %113 = llvm.add %111, %112  : i64
    %114 = llvm.mlir.constant(0 : i64) : i64
    %115 = llvm.mul %114, %110  : i64
    %116 = llvm.add %113, %115  : i64
    %117 = llvm.insertvalue %116, %108[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %118 = llvm.mlir.constant(784 : i64) : i64
    %119 = llvm.mlir.constant(1 : i64) : i64
    %120 = llvm.insertvalue %118, %117[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %121 = llvm.insertvalue %119, %120[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %122 = llvm.mlir.constant(784 : i64) : i64
    %123 = llvm.insertvalue %101, %121[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %124 = llvm.insertvalue %122, %123[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %125 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %126 = llvm.extractvalue %48[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %127 = llvm.bitcast %126 : !llvm.ptr<f32> to !llvm.ptr<f32>
    %128 = llvm.insertvalue %127, %125[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %129 = llvm.extractvalue %48[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %130 = llvm.bitcast %129 : !llvm.ptr<f32> to !llvm.ptr<f32>
    %131 = llvm.insertvalue %130, %128[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %132 = llvm.extractvalue %48[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %133 = llvm.extractvalue %48[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %134 = llvm.extractvalue %48[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %135 = llvm.mlir.constant(0 : i64) : i64
    %136 = llvm.mul %135, %132  : i64
    %137 = llvm.add %134, %136  : i64
    %138 = llvm.mul %93, %133  : i64
    %139 = llvm.add %137, %138  : i64
    %140 = llvm.insertvalue %139, %131[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %141 = llvm.mlir.constant(64 : i64) : i64
    %142 = llvm.mlir.constant(1 : i64) : i64
    %143 = llvm.insertvalue %141, %140[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %144 = llvm.insertvalue %142, %143[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %145 = llvm.mlir.constant(784 : i64) : i64
    %146 = llvm.mlir.constant(128 : i64) : i64
    %147 = llvm.insertvalue %145, %144[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %148 = llvm.insertvalue %146, %147[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %149 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %150 = llvm.extractvalue %68[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %151 = llvm.bitcast %150 : !llvm.ptr<f32> to !llvm.ptr<f32>
    %152 = llvm.insertvalue %151, %149[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %153 = llvm.extractvalue %68[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %154 = llvm.bitcast %153 : !llvm.ptr<f32> to !llvm.ptr<f32>
    %155 = llvm.insertvalue %154, %152[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %156 = llvm.extractvalue %68[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %157 = llvm.extractvalue %68[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %158 = llvm.extractvalue %68[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %159 = llvm.mul %87, %156  : i64
    %160 = llvm.add %158, %159  : i64
    %161 = llvm.mul %93, %157  : i64
    %162 = llvm.add %160, %161  : i64
    %163 = llvm.insertvalue %162, %155[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %164 = llvm.mlir.constant(64 : i64) : i64
    %165 = llvm.mlir.constant(1 : i64) : i64
    %166 = llvm.insertvalue %164, %163[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %167 = llvm.insertvalue %165, %166[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %168 = llvm.mlir.constant(128 : i64) : i64
    %169 = llvm.insertvalue %101, %167[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %170 = llvm.insertvalue %168, %169[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    llvm.br ^bb5(%7 : i64)
  ^bb5(%171: i64):  // 2 preds: ^bb4, ^bb8
    %172 = llvm.icmp "slt" %171, %101 : i64
    llvm.cond_br %172, ^bb6(%7 : i64), ^bb9(%7 : i64)
  ^bb6(%173: i64):  // 2 preds: ^bb5, ^bb7
    %174 = llvm.icmp "slt" %173, %5 : i64
    llvm.cond_br %174, ^bb7, ^bb8
  ^bb7:  // pred: ^bb6
    %175 = llvm.extractvalue %170[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %176 = llvm.extractvalue %170[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %177 = llvm.mlir.constant(128 : index) : i64
    %178 = llvm.mul %171, %177  : i64
    %179 = llvm.add %176, %178  : i64
    %180 = llvm.add %179, %173  : i64
    %181 = llvm.getelementptr %175[%180] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    llvm.store %0, %181 : !llvm.ptr<f32>
    %182 = llvm.add %173, %8  : i64
    llvm.br ^bb6(%182 : i64)
  ^bb8:  // pred: ^bb6
    %183 = llvm.add %171, %8  : i64
    llvm.br ^bb5(%183 : i64)
  ^bb9(%184: i64):  // 2 preds: ^bb5, ^bb28
    %185 = llvm.icmp "slt" %184, %101 : i64
    llvm.cond_br %185, ^bb10(%7 : i64), ^bb29
  ^bb10(%186: i64):  // 2 preds: ^bb9, ^bb27
    %187 = llvm.icmp "slt" %186, %5 : i64
    llvm.cond_br %187, ^bb11(%7 : i64), ^bb28
  ^bb11(%188: i64):  // 2 preds: ^bb10, ^bb26
    %189 = llvm.icmp "slt" %188, %2 : i64
    llvm.cond_br %189, ^bb12, ^bb27
  ^bb12:  // pred: ^bb11
    %190 = llvm.mlir.constant(4 : index) : i64
    %191 = llvm.mlir.constant(-1 : index) : i64
    %192 = llvm.mul %184, %191  : i64
    %193 = llvm.add %101, %192  : i64
    %194 = llvm.icmp "slt" %190, %193 : i64
    %195 = llvm.select %194, %190, %193 : i1, i64
    %196 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %197 = llvm.extractvalue %124[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %198 = llvm.bitcast %197 : !llvm.ptr<f32> to !llvm.ptr<f32>
    %199 = llvm.insertvalue %198, %196[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %200 = llvm.extractvalue %124[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %201 = llvm.bitcast %200 : !llvm.ptr<f32> to !llvm.ptr<f32>
    %202 = llvm.insertvalue %201, %199[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %203 = llvm.extractvalue %124[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %204 = llvm.extractvalue %124[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %205 = llvm.extractvalue %124[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %206 = llvm.mul %184, %203  : i64
    %207 = llvm.add %205, %206  : i64
    %208 = llvm.mul %188, %204  : i64
    %209 = llvm.add %207, %208  : i64
    %210 = llvm.insertvalue %209, %202[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %211 = llvm.mlir.constant(28 : i64) : i64
    %212 = llvm.mlir.constant(1 : i64) : i64
    %213 = llvm.insertvalue %211, %210[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %214 = llvm.insertvalue %212, %213[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %215 = llvm.mlir.constant(784 : i64) : i64
    %216 = llvm.insertvalue %195, %214[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %217 = llvm.insertvalue %215, %216[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %218 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %219 = llvm.extractvalue %148[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %220 = llvm.bitcast %219 : !llvm.ptr<f32> to !llvm.ptr<f32>
    %221 = llvm.insertvalue %220, %218[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %222 = llvm.extractvalue %148[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %223 = llvm.bitcast %222 : !llvm.ptr<f32> to !llvm.ptr<f32>
    %224 = llvm.insertvalue %223, %221[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %225 = llvm.extractvalue %148[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %226 = llvm.extractvalue %148[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %227 = llvm.extractvalue %148[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %228 = llvm.mul %188, %225  : i64
    %229 = llvm.add %227, %228  : i64
    %230 = llvm.mul %186, %226  : i64
    %231 = llvm.add %229, %230  : i64
    %232 = llvm.insertvalue %231, %224[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %233 = llvm.mlir.constant(32 : i64) : i64
    %234 = llvm.mlir.constant(1 : i64) : i64
    %235 = llvm.insertvalue %233, %232[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %236 = llvm.insertvalue %234, %235[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %237 = llvm.mlir.constant(28 : i64) : i64
    %238 = llvm.mlir.constant(128 : i64) : i64
    %239 = llvm.insertvalue %237, %236[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %240 = llvm.insertvalue %238, %239[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %241 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %242 = llvm.extractvalue %170[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %243 = llvm.bitcast %242 : !llvm.ptr<f32> to !llvm.ptr<f32>
    %244 = llvm.insertvalue %243, %241[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %245 = llvm.extractvalue %170[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %246 = llvm.bitcast %245 : !llvm.ptr<f32> to !llvm.ptr<f32>
    %247 = llvm.insertvalue %246, %244[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %248 = llvm.extractvalue %170[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %249 = llvm.extractvalue %170[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %250 = llvm.extractvalue %170[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %251 = llvm.mul %184, %248  : i64
    %252 = llvm.add %250, %251  : i64
    %253 = llvm.mul %186, %249  : i64
    %254 = llvm.add %252, %253  : i64
    %255 = llvm.insertvalue %254, %247[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %256 = llvm.mlir.constant(32 : i64) : i64
    %257 = llvm.mlir.constant(1 : i64) : i64
    %258 = llvm.insertvalue %256, %255[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %259 = llvm.insertvalue %257, %258[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %260 = llvm.mlir.constant(128 : i64) : i64
    %261 = llvm.insertvalue %195, %259[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %262 = llvm.insertvalue %260, %261[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    llvm.br ^bb13(%7 : i64)
  ^bb13(%263: i64):  // 2 preds: ^bb12, ^bb25
    %264 = llvm.icmp "slt" %263, %195 : i64
    llvm.cond_br %264, ^bb14(%7 : i64), ^bb26
  ^bb14(%265: i64):  // 2 preds: ^bb13, ^bb24
    %266 = llvm.icmp "slt" %265, %4 : i64
    llvm.cond_br %266, ^bb15(%7 : i64), ^bb25
  ^bb15(%267: i64):  // 2 preds: ^bb14, ^bb23
    %268 = llvm.icmp "slt" %267, %3 : i64
    llvm.cond_br %268, ^bb16, ^bb24
  ^bb16:  // pred: ^bb15
    %269 = llvm.mlir.constant(4 : index) : i64
    %270 = llvm.mlir.constant(-1 : index) : i64
    %271 = llvm.mul %263, %270  : i64
    %272 = llvm.add %195, %271  : i64
    %273 = llvm.icmp "slt" %269, %272 : i64
    %274 = llvm.select %273, %269, %272 : i1, i64
    %275 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %276 = llvm.extractvalue %217[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %277 = llvm.bitcast %276 : !llvm.ptr<f32> to !llvm.ptr<f32>
    %278 = llvm.insertvalue %277, %275[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %279 = llvm.extractvalue %217[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %280 = llvm.bitcast %279 : !llvm.ptr<f32> to !llvm.ptr<f32>
    %281 = llvm.insertvalue %280, %278[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %282 = llvm.extractvalue %217[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %283 = llvm.extractvalue %217[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %284 = llvm.extractvalue %217[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %285 = llvm.mul %263, %282  : i64
    %286 = llvm.add %284, %285  : i64
    %287 = llvm.mul %267, %283  : i64
    %288 = llvm.add %286, %287  : i64
    %289 = llvm.insertvalue %288, %281[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %290 = llvm.mlir.constant(4 : i64) : i64
    %291 = llvm.mlir.constant(1 : i64) : i64
    %292 = llvm.insertvalue %290, %289[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %293 = llvm.insertvalue %291, %292[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %294 = llvm.mlir.constant(784 : i64) : i64
    %295 = llvm.insertvalue %274, %293[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %296 = llvm.insertvalue %294, %295[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %297 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %298 = llvm.extractvalue %240[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %299 = llvm.bitcast %298 : !llvm.ptr<f32> to !llvm.ptr<f32>
    %300 = llvm.insertvalue %299, %297[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %301 = llvm.extractvalue %240[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %302 = llvm.bitcast %301 : !llvm.ptr<f32> to !llvm.ptr<f32>
    %303 = llvm.insertvalue %302, %300[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %304 = llvm.extractvalue %240[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %305 = llvm.extractvalue %240[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %306 = llvm.extractvalue %240[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %307 = llvm.mul %267, %304  : i64
    %308 = llvm.add %306, %307  : i64
    %309 = llvm.mul %265, %305  : i64
    %310 = llvm.add %308, %309  : i64
    %311 = llvm.insertvalue %310, %303[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %312 = llvm.mlir.constant(4 : i64) : i64
    %313 = llvm.mlir.constant(1 : i64) : i64
    %314 = llvm.insertvalue %312, %311[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %315 = llvm.insertvalue %313, %314[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %316 = llvm.mlir.constant(4 : i64) : i64
    %317 = llvm.mlir.constant(128 : i64) : i64
    %318 = llvm.insertvalue %316, %315[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %319 = llvm.insertvalue %317, %318[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %320 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %321 = llvm.extractvalue %262[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %322 = llvm.bitcast %321 : !llvm.ptr<f32> to !llvm.ptr<f32>
    %323 = llvm.insertvalue %322, %320[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %324 = llvm.extractvalue %262[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %325 = llvm.bitcast %324 : !llvm.ptr<f32> to !llvm.ptr<f32>
    %326 = llvm.insertvalue %325, %323[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %327 = llvm.extractvalue %262[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %328 = llvm.extractvalue %262[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %329 = llvm.extractvalue %262[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %330 = llvm.mul %263, %327  : i64
    %331 = llvm.add %329, %330  : i64
    %332 = llvm.mul %265, %328  : i64
    %333 = llvm.add %331, %332  : i64
    %334 = llvm.insertvalue %333, %326[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %335 = llvm.mlir.constant(4 : i64) : i64
    %336 = llvm.mlir.constant(1 : i64) : i64
    %337 = llvm.insertvalue %335, %334[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %338 = llvm.insertvalue %336, %337[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %339 = llvm.mlir.constant(128 : i64) : i64
    %340 = llvm.insertvalue %274, %338[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %341 = llvm.insertvalue %339, %340[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    llvm.br ^bb17(%7 : i64)
  ^bb17(%342: i64):  // 2 preds: ^bb16, ^bb22
    %343 = llvm.icmp "slt" %342, %274 : i64
    llvm.cond_br %343, ^bb18(%7 : i64), ^bb23
  ^bb18(%344: i64):  // 2 preds: ^bb17, ^bb21
    %345 = llvm.icmp "slt" %344, %6 : i64
    llvm.cond_br %345, ^bb19(%7 : i64), ^bb22
  ^bb19(%346: i64):  // 2 preds: ^bb18, ^bb20
    %347 = llvm.icmp "slt" %346, %6 : i64
    llvm.cond_br %347, ^bb20, ^bb21
  ^bb20:  // pred: ^bb19
    %348 = llvm.extractvalue %296[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %349 = llvm.extractvalue %296[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %350 = llvm.mlir.constant(784 : index) : i64
    %351 = llvm.mul %342, %350  : i64
    %352 = llvm.add %349, %351  : i64
    %353 = llvm.add %352, %346  : i64
    %354 = llvm.getelementptr %348[%353] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %355 = llvm.load %354 : !llvm.ptr<f32>
    %356 = llvm.extractvalue %319[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %357 = llvm.extractvalue %319[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %358 = llvm.mlir.constant(128 : index) : i64
    %359 = llvm.mul %346, %358  : i64
    %360 = llvm.add %357, %359  : i64
    %361 = llvm.add %360, %344  : i64
    %362 = llvm.getelementptr %356[%361] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %363 = llvm.load %362 : !llvm.ptr<f32>
    %364 = llvm.extractvalue %341[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %365 = llvm.extractvalue %341[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %366 = llvm.mlir.constant(128 : index) : i64
    %367 = llvm.mul %342, %366  : i64
    %368 = llvm.add %365, %367  : i64
    %369 = llvm.add %368, %344  : i64
    %370 = llvm.getelementptr %364[%369] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %371 = llvm.load %370 : !llvm.ptr<f32>
    %372 = llvm.fmul %355, %363  : f32
    %373 = llvm.fadd %371, %372  : f32
    %374 = llvm.extractvalue %341[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %375 = llvm.extractvalue %341[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %376 = llvm.mlir.constant(128 : index) : i64
    %377 = llvm.mul %342, %376  : i64
    %378 = llvm.add %375, %377  : i64
    %379 = llvm.add %378, %344  : i64
    %380 = llvm.getelementptr %374[%379] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    llvm.store %373, %380 : !llvm.ptr<f32>
    %381 = llvm.add %346, %8  : i64
    llvm.br ^bb19(%381 : i64)
  ^bb21:  // pred: ^bb19
    %382 = llvm.add %344, %8  : i64
    llvm.br ^bb18(%382 : i64)
  ^bb22:  // pred: ^bb18
    %383 = llvm.add %342, %8  : i64
    llvm.br ^bb17(%383 : i64)
  ^bb23:  // pred: ^bb17
    %384 = llvm.add %267, %6  : i64
    llvm.br ^bb15(%384 : i64)
  ^bb24:  // pred: ^bb15
    %385 = llvm.add %265, %6  : i64
    llvm.br ^bb14(%385 : i64)
  ^bb25:  // pred: ^bb14
    %386 = llvm.add %263, %6  : i64
    llvm.br ^bb13(%386 : i64)
  ^bb26:  // pred: ^bb13
    %387 = llvm.add %188, %3  : i64
    llvm.br ^bb11(%387 : i64)
  ^bb27:  // pred: ^bb11
    %388 = llvm.add %186, %4  : i64
    llvm.br ^bb10(%388 : i64)
  ^bb28:  // pred: ^bb10
    %389 = llvm.add %184, %6  : i64
    llvm.br ^bb9(%389 : i64)
  ^bb29:  // pred: ^bb9
    %390 = llvm.add %93, %92  : i64
    llvm.br ^bb3(%390 : i64)
  ^bb30:  // pred: ^bb3
    %391 = llvm.add %87, %86  : i64
    llvm.br ^bb1(%391 : i64)
  ^bb31:  // pred: ^bb1
    %392 = llvm.mlir.constant(0 : i32) : i32
    llvm.return %392 : i32
  }
}

// *** IR Dump After Canonicalizer ***
module  {
  llvm.func internal @predict_dispatch_0(%arg0: !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>, %arg1: !llvm.ptr<array<3 x i32>>) -> i32 {
    %0 = llvm.mlir.constant(0.000000e+00 : f32) : f32
    %1 = llvm.mlir.constant(128 : index) : i64
    %2 = llvm.mlir.constant(784 : index) : i64
    %3 = llvm.mlir.constant(28 : index) : i64
    %4 = llvm.mlir.constant(32 : index) : i64
    %5 = llvm.mlir.constant(64 : index) : i64
    %6 = llvm.mlir.constant(4 : index) : i64
    %7 = llvm.mlir.constant(0 : index) : i64
    %8 = llvm.mlir.constant(1 : index) : i64
    %9 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
    %10 = llvm.extractvalue %9[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
    %11 = llvm.mlir.constant(1 : index) : i64
    %12 = llvm.getelementptr %10[%11] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
    %13 = llvm.load %12 : !llvm.ptr<ptr<i8>>
    %14 = llvm.getelementptr %13[%7] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
    %15 = llvm.bitcast %14 : !llvm.ptr<i8> to !llvm.ptr<f32>
    %16 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %17 = llvm.insertvalue %15, %16[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %18 = llvm.insertvalue %15, %17[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %19 = llvm.mlir.constant(0 : index) : i64
    %20 = llvm.insertvalue %19, %18[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %21 = llvm.mlir.constant(1 : index) : i64
    %22 = llvm.insertvalue %21, %20[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %23 = llvm.mlir.constant(784 : index) : i64
    %24 = llvm.insertvalue %23, %22[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %25 = llvm.mlir.constant(784 : index) : i64
    %26 = llvm.insertvalue %25, %24[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %27 = llvm.mlir.constant(1 : index) : i64
    %28 = llvm.insertvalue %27, %26[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %29 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
    %30 = llvm.extractvalue %29[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
    %31 = llvm.mlir.constant(0 : index) : i64
    %32 = llvm.getelementptr %30[%31] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
    %33 = llvm.load %32 : !llvm.ptr<ptr<i8>>
    %34 = llvm.getelementptr %33[%7] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
    %35 = llvm.bitcast %34 : !llvm.ptr<i8> to !llvm.ptr<f32>
    %36 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %37 = llvm.insertvalue %35, %36[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %38 = llvm.insertvalue %35, %37[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %39 = llvm.mlir.constant(0 : index) : i64
    %40 = llvm.insertvalue %39, %38[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %41 = llvm.mlir.constant(784 : index) : i64
    %42 = llvm.insertvalue %41, %40[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %43 = llvm.mlir.constant(128 : index) : i64
    %44 = llvm.insertvalue %43, %42[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %45 = llvm.mlir.constant(128 : index) : i64
    %46 = llvm.insertvalue %45, %44[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %47 = llvm.mlir.constant(1 : index) : i64
    %48 = llvm.insertvalue %47, %46[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %49 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
    %50 = llvm.extractvalue %49[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
    %51 = llvm.mlir.constant(2 : index) : i64
    %52 = llvm.getelementptr %50[%51] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
    %53 = llvm.load %52 : !llvm.ptr<ptr<i8>>
    %54 = llvm.getelementptr %53[%7] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
    %55 = llvm.bitcast %54 : !llvm.ptr<i8> to !llvm.ptr<f32>
    %56 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %57 = llvm.insertvalue %55, %56[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %58 = llvm.insertvalue %55, %57[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %59 = llvm.mlir.constant(0 : index) : i64
    %60 = llvm.insertvalue %59, %58[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %61 = llvm.mlir.constant(1 : index) : i64
    %62 = llvm.insertvalue %61, %60[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %63 = llvm.mlir.constant(128 : index) : i64
    %64 = llvm.insertvalue %63, %62[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %65 = llvm.mlir.constant(128 : index) : i64
    %66 = llvm.insertvalue %65, %64[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %67 = llvm.mlir.constant(1 : index) : i64
    %68 = llvm.insertvalue %67, %66[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %69 = llvm.load %arg1 : !llvm.ptr<array<3 x i32>>
    %70 = llvm.extractvalue %69[0] : !llvm.array<3 x i32>
    %71 = llvm.zext %70 : i32 to i64
    %72 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
    %73 = llvm.extractvalue %72[0] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
    %74 = llvm.extractvalue %73[0] : !llvm.array<3 x i32>
    %75 = llvm.zext %74 : i32 to i64
    %76 = llvm.load %arg1 : !llvm.ptr<array<3 x i32>>
    %77 = llvm.extractvalue %76[1] : !llvm.array<3 x i32>
    %78 = llvm.zext %77 : i32 to i64
    %79 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
    %80 = llvm.extractvalue %79[0] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
    %81 = llvm.extractvalue %80[1] : !llvm.array<3 x i32>
    %82 = llvm.zext %81 : i32 to i64
    %83 = llvm.mlir.constant(4 : index) : i64
    %84 = llvm.mul %78, %83  : i64
    %85 = llvm.mlir.constant(4 : index) : i64
    %86 = llvm.mul %82, %85  : i64
    llvm.br ^bb1(%84 : i64)
  ^bb1(%87: i64):  // 2 preds: ^bb0, ^bb30
    %88 = llvm.icmp "slt" %87, %8 : i64
    llvm.cond_br %88, ^bb2, ^bb31
  ^bb2:  // pred: ^bb1
    %89 = llvm.mlir.constant(64 : index) : i64
    %90 = llvm.mul %71, %89  : i64
    %91 = llvm.mlir.constant(64 : index) : i64
    %92 = llvm.mul %75, %91  : i64
    llvm.br ^bb3(%90 : i64)
  ^bb3(%93: i64):  // 2 preds: ^bb2, ^bb29
    %94 = llvm.icmp "slt" %93, %1 : i64
    llvm.cond_br %94, ^bb4, ^bb30
  ^bb4:  // pred: ^bb3
    %95 = llvm.mlir.constant(4 : index) : i64
    %96 = llvm.mlir.constant(-1 : index) : i64
    %97 = llvm.mul %87, %96  : i64
    %98 = llvm.mlir.constant(1 : index) : i64
    %99 = llvm.add %97, %98  : i64
    %100 = llvm.icmp "slt" %95, %99 : i64
    %101 = llvm.select %100, %95, %99 : i1, i64
    %102 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %103 = llvm.extractvalue %28[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %104 = llvm.bitcast %103 : !llvm.ptr<f32> to !llvm.ptr<f32>
    %105 = llvm.insertvalue %104, %102[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %106 = llvm.extractvalue %28[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %107 = llvm.bitcast %106 : !llvm.ptr<f32> to !llvm.ptr<f32>
    %108 = llvm.insertvalue %107, %105[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %109 = llvm.extractvalue %28[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %110 = llvm.extractvalue %28[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %111 = llvm.extractvalue %28[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %112 = llvm.mul %87, %109  : i64
    %113 = llvm.add %111, %112  : i64
    %114 = llvm.mlir.constant(0 : i64) : i64
    %115 = llvm.mul %114, %110  : i64
    %116 = llvm.add %113, %115  : i64
    %117 = llvm.insertvalue %116, %108[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %118 = llvm.mlir.constant(784 : i64) : i64
    %119 = llvm.mlir.constant(1 : i64) : i64
    %120 = llvm.insertvalue %118, %117[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %121 = llvm.insertvalue %119, %120[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %122 = llvm.mlir.constant(784 : i64) : i64
    %123 = llvm.insertvalue %101, %121[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %124 = llvm.insertvalue %122, %123[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %125 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %126 = llvm.extractvalue %48[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %127 = llvm.bitcast %126 : !llvm.ptr<f32> to !llvm.ptr<f32>
    %128 = llvm.insertvalue %127, %125[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %129 = llvm.extractvalue %48[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %130 = llvm.bitcast %129 : !llvm.ptr<f32> to !llvm.ptr<f32>
    %131 = llvm.insertvalue %130, %128[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %132 = llvm.extractvalue %48[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %133 = llvm.extractvalue %48[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %134 = llvm.extractvalue %48[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %135 = llvm.mlir.constant(0 : i64) : i64
    %136 = llvm.mul %135, %132  : i64
    %137 = llvm.add %134, %136  : i64
    %138 = llvm.mul %93, %133  : i64
    %139 = llvm.add %137, %138  : i64
    %140 = llvm.insertvalue %139, %131[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %141 = llvm.mlir.constant(64 : i64) : i64
    %142 = llvm.mlir.constant(1 : i64) : i64
    %143 = llvm.insertvalue %141, %140[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %144 = llvm.insertvalue %142, %143[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %145 = llvm.mlir.constant(784 : i64) : i64
    %146 = llvm.mlir.constant(128 : i64) : i64
    %147 = llvm.insertvalue %145, %144[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %148 = llvm.insertvalue %146, %147[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %149 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %150 = llvm.extractvalue %68[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %151 = llvm.bitcast %150 : !llvm.ptr<f32> to !llvm.ptr<f32>
    %152 = llvm.insertvalue %151, %149[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %153 = llvm.extractvalue %68[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %154 = llvm.bitcast %153 : !llvm.ptr<f32> to !llvm.ptr<f32>
    %155 = llvm.insertvalue %154, %152[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %156 = llvm.extractvalue %68[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %157 = llvm.extractvalue %68[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %158 = llvm.extractvalue %68[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %159 = llvm.mul %87, %156  : i64
    %160 = llvm.add %158, %159  : i64
    %161 = llvm.mul %93, %157  : i64
    %162 = llvm.add %160, %161  : i64
    %163 = llvm.insertvalue %162, %155[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %164 = llvm.mlir.constant(64 : i64) : i64
    %165 = llvm.mlir.constant(1 : i64) : i64
    %166 = llvm.insertvalue %164, %163[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %167 = llvm.insertvalue %165, %166[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %168 = llvm.mlir.constant(128 : i64) : i64
    %169 = llvm.insertvalue %101, %167[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %170 = llvm.insertvalue %168, %169[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    llvm.br ^bb5(%7 : i64)
  ^bb5(%171: i64):  // 2 preds: ^bb4, ^bb8
    %172 = llvm.icmp "slt" %171, %101 : i64
    llvm.cond_br %172, ^bb6(%7 : i64), ^bb9(%7 : i64)
  ^bb6(%173: i64):  // 2 preds: ^bb5, ^bb7
    %174 = llvm.icmp "slt" %173, %5 : i64
    llvm.cond_br %174, ^bb7, ^bb8
  ^bb7:  // pred: ^bb6
    %175 = llvm.extractvalue %170[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %176 = llvm.extractvalue %170[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %177 = llvm.mlir.constant(128 : index) : i64
    %178 = llvm.mul %171, %177  : i64
    %179 = llvm.add %176, %178  : i64
    %180 = llvm.add %179, %173  : i64
    %181 = llvm.getelementptr %175[%180] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    llvm.store %0, %181 : !llvm.ptr<f32>
    %182 = llvm.add %173, %8  : i64
    llvm.br ^bb6(%182 : i64)
  ^bb8:  // pred: ^bb6
    %183 = llvm.add %171, %8  : i64
    llvm.br ^bb5(%183 : i64)
  ^bb9(%184: i64):  // 2 preds: ^bb5, ^bb28
    %185 = llvm.icmp "slt" %184, %101 : i64
    llvm.cond_br %185, ^bb10(%7 : i64), ^bb29
  ^bb10(%186: i64):  // 2 preds: ^bb9, ^bb27
    %187 = llvm.icmp "slt" %186, %5 : i64
    llvm.cond_br %187, ^bb11(%7 : i64), ^bb28
  ^bb11(%188: i64):  // 2 preds: ^bb10, ^bb26
    %189 = llvm.icmp "slt" %188, %2 : i64
    llvm.cond_br %189, ^bb12, ^bb27
  ^bb12:  // pred: ^bb11
    %190 = llvm.mlir.constant(4 : index) : i64
    %191 = llvm.mlir.constant(-1 : index) : i64
    %192 = llvm.mul %184, %191  : i64
    %193 = llvm.add %101, %192  : i64
    %194 = llvm.icmp "slt" %190, %193 : i64
    %195 = llvm.select %194, %190, %193 : i1, i64
    %196 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %197 = llvm.extractvalue %124[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %198 = llvm.bitcast %197 : !llvm.ptr<f32> to !llvm.ptr<f32>
    %199 = llvm.insertvalue %198, %196[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %200 = llvm.extractvalue %124[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %201 = llvm.bitcast %200 : !llvm.ptr<f32> to !llvm.ptr<f32>
    %202 = llvm.insertvalue %201, %199[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %203 = llvm.extractvalue %124[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %204 = llvm.extractvalue %124[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %205 = llvm.extractvalue %124[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %206 = llvm.mul %184, %203  : i64
    %207 = llvm.add %205, %206  : i64
    %208 = llvm.mul %188, %204  : i64
    %209 = llvm.add %207, %208  : i64
    %210 = llvm.insertvalue %209, %202[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %211 = llvm.mlir.constant(28 : i64) : i64
    %212 = llvm.mlir.constant(1 : i64) : i64
    %213 = llvm.insertvalue %211, %210[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %214 = llvm.insertvalue %212, %213[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %215 = llvm.mlir.constant(784 : i64) : i64
    %216 = llvm.insertvalue %195, %214[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %217 = llvm.insertvalue %215, %216[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %218 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %219 = llvm.extractvalue %148[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %220 = llvm.bitcast %219 : !llvm.ptr<f32> to !llvm.ptr<f32>
    %221 = llvm.insertvalue %220, %218[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %222 = llvm.extractvalue %148[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %223 = llvm.bitcast %222 : !llvm.ptr<f32> to !llvm.ptr<f32>
    %224 = llvm.insertvalue %223, %221[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %225 = llvm.extractvalue %148[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %226 = llvm.extractvalue %148[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %227 = llvm.extractvalue %148[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %228 = llvm.mul %188, %225  : i64
    %229 = llvm.add %227, %228  : i64
    %230 = llvm.mul %186, %226  : i64
    %231 = llvm.add %229, %230  : i64
    %232 = llvm.insertvalue %231, %224[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %233 = llvm.mlir.constant(32 : i64) : i64
    %234 = llvm.mlir.constant(1 : i64) : i64
    %235 = llvm.insertvalue %233, %232[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %236 = llvm.insertvalue %234, %235[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %237 = llvm.mlir.constant(28 : i64) : i64
    %238 = llvm.mlir.constant(128 : i64) : i64
    %239 = llvm.insertvalue %237, %236[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %240 = llvm.insertvalue %238, %239[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %241 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %242 = llvm.extractvalue %170[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %243 = llvm.bitcast %242 : !llvm.ptr<f32> to !llvm.ptr<f32>
    %244 = llvm.insertvalue %243, %241[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %245 = llvm.extractvalue %170[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %246 = llvm.bitcast %245 : !llvm.ptr<f32> to !llvm.ptr<f32>
    %247 = llvm.insertvalue %246, %244[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %248 = llvm.extractvalue %170[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %249 = llvm.extractvalue %170[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %250 = llvm.extractvalue %170[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %251 = llvm.mul %184, %248  : i64
    %252 = llvm.add %250, %251  : i64
    %253 = llvm.mul %186, %249  : i64
    %254 = llvm.add %252, %253  : i64
    %255 = llvm.insertvalue %254, %247[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %256 = llvm.mlir.constant(32 : i64) : i64
    %257 = llvm.mlir.constant(1 : i64) : i64
    %258 = llvm.insertvalue %256, %255[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %259 = llvm.insertvalue %257, %258[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %260 = llvm.mlir.constant(128 : i64) : i64
    %261 = llvm.insertvalue %195, %259[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %262 = llvm.insertvalue %260, %261[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    llvm.br ^bb13(%7 : i64)
  ^bb13(%263: i64):  // 2 preds: ^bb12, ^bb25
    %264 = llvm.icmp "slt" %263, %195 : i64
    llvm.cond_br %264, ^bb14(%7 : i64), ^bb26
  ^bb14(%265: i64):  // 2 preds: ^bb13, ^bb24
    %266 = llvm.icmp "slt" %265, %4 : i64
    llvm.cond_br %266, ^bb15(%7 : i64), ^bb25
  ^bb15(%267: i64):  // 2 preds: ^bb14, ^bb23
    %268 = llvm.icmp "slt" %267, %3 : i64
    llvm.cond_br %268, ^bb16, ^bb24
  ^bb16:  // pred: ^bb15
    %269 = llvm.mlir.constant(4 : index) : i64
    %270 = llvm.mlir.constant(-1 : index) : i64
    %271 = llvm.mul %263, %270  : i64
    %272 = llvm.add %195, %271  : i64
    %273 = llvm.icmp "slt" %269, %272 : i64
    %274 = llvm.select %273, %269, %272 : i1, i64
    %275 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %276 = llvm.extractvalue %217[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %277 = llvm.bitcast %276 : !llvm.ptr<f32> to !llvm.ptr<f32>
    %278 = llvm.insertvalue %277, %275[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %279 = llvm.extractvalue %217[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %280 = llvm.bitcast %279 : !llvm.ptr<f32> to !llvm.ptr<f32>
    %281 = llvm.insertvalue %280, %278[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %282 = llvm.extractvalue %217[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %283 = llvm.extractvalue %217[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %284 = llvm.extractvalue %217[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %285 = llvm.mul %263, %282  : i64
    %286 = llvm.add %284, %285  : i64
    %287 = llvm.mul %267, %283  : i64
    %288 = llvm.add %286, %287  : i64
    %289 = llvm.insertvalue %288, %281[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %290 = llvm.mlir.constant(4 : i64) : i64
    %291 = llvm.mlir.constant(1 : i64) : i64
    %292 = llvm.insertvalue %290, %289[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %293 = llvm.insertvalue %291, %292[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %294 = llvm.mlir.constant(784 : i64) : i64
    %295 = llvm.insertvalue %274, %293[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %296 = llvm.insertvalue %294, %295[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %297 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %298 = llvm.extractvalue %240[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %299 = llvm.bitcast %298 : !llvm.ptr<f32> to !llvm.ptr<f32>
    %300 = llvm.insertvalue %299, %297[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %301 = llvm.extractvalue %240[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %302 = llvm.bitcast %301 : !llvm.ptr<f32> to !llvm.ptr<f32>
    %303 = llvm.insertvalue %302, %300[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %304 = llvm.extractvalue %240[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %305 = llvm.extractvalue %240[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %306 = llvm.extractvalue %240[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %307 = llvm.mul %267, %304  : i64
    %308 = llvm.add %306, %307  : i64
    %309 = llvm.mul %265, %305  : i64
    %310 = llvm.add %308, %309  : i64
    %311 = llvm.insertvalue %310, %303[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %312 = llvm.mlir.constant(4 : i64) : i64
    %313 = llvm.mlir.constant(1 : i64) : i64
    %314 = llvm.insertvalue %312, %311[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %315 = llvm.insertvalue %313, %314[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %316 = llvm.mlir.constant(4 : i64) : i64
    %317 = llvm.mlir.constant(128 : i64) : i64
    %318 = llvm.insertvalue %316, %315[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %319 = llvm.insertvalue %317, %318[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %320 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %321 = llvm.extractvalue %262[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %322 = llvm.bitcast %321 : !llvm.ptr<f32> to !llvm.ptr<f32>
    %323 = llvm.insertvalue %322, %320[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %324 = llvm.extractvalue %262[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %325 = llvm.bitcast %324 : !llvm.ptr<f32> to !llvm.ptr<f32>
    %326 = llvm.insertvalue %325, %323[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %327 = llvm.extractvalue %262[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %328 = llvm.extractvalue %262[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %329 = llvm.extractvalue %262[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %330 = llvm.mul %263, %327  : i64
    %331 = llvm.add %329, %330  : i64
    %332 = llvm.mul %265, %328  : i64
    %333 = llvm.add %331, %332  : i64
    %334 = llvm.insertvalue %333, %326[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %335 = llvm.mlir.constant(4 : i64) : i64
    %336 = llvm.mlir.constant(1 : i64) : i64
    %337 = llvm.insertvalue %335, %334[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %338 = llvm.insertvalue %336, %337[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %339 = llvm.mlir.constant(128 : i64) : i64
    %340 = llvm.insertvalue %274, %338[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %341 = llvm.insertvalue %339, %340[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    llvm.br ^bb17(%7 : i64)
  ^bb17(%342: i64):  // 2 preds: ^bb16, ^bb22
    %343 = llvm.icmp "slt" %342, %274 : i64
    llvm.cond_br %343, ^bb18(%7 : i64), ^bb23
  ^bb18(%344: i64):  // 2 preds: ^bb17, ^bb21
    %345 = llvm.icmp "slt" %344, %6 : i64
    llvm.cond_br %345, ^bb19(%7 : i64), ^bb22
  ^bb19(%346: i64):  // 2 preds: ^bb18, ^bb20
    %347 = llvm.icmp "slt" %346, %6 : i64
    llvm.cond_br %347, ^bb20, ^bb21
  ^bb20:  // pred: ^bb19
    %348 = llvm.extractvalue %296[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %349 = llvm.extractvalue %296[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %350 = llvm.mlir.constant(784 : index) : i64
    %351 = llvm.mul %342, %350  : i64
    %352 = llvm.add %349, %351  : i64
    %353 = llvm.add %352, %346  : i64
    %354 = llvm.getelementptr %348[%353] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %355 = llvm.load %354 : !llvm.ptr<f32>
    %356 = llvm.extractvalue %319[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %357 = llvm.extractvalue %319[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %358 = llvm.mlir.constant(128 : index) : i64
    %359 = llvm.mul %346, %358  : i64
    %360 = llvm.add %357, %359  : i64
    %361 = llvm.add %360, %344  : i64
    %362 = llvm.getelementptr %356[%361] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %363 = llvm.load %362 : !llvm.ptr<f32>
    %364 = llvm.extractvalue %341[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %365 = llvm.extractvalue %341[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %366 = llvm.mlir.constant(128 : index) : i64
    %367 = llvm.mul %342, %366  : i64
    %368 = llvm.add %365, %367  : i64
    %369 = llvm.add %368, %344  : i64
    %370 = llvm.getelementptr %364[%369] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %371 = llvm.load %370 : !llvm.ptr<f32>
    %372 = llvm.fmul %355, %363  : f32
    %373 = llvm.fadd %371, %372  : f32
    %374 = llvm.extractvalue %341[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %375 = llvm.extractvalue %341[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %376 = llvm.mlir.constant(128 : index) : i64
    %377 = llvm.mul %342, %376  : i64
    %378 = llvm.add %375, %377  : i64
    %379 = llvm.add %378, %344  : i64
    %380 = llvm.getelementptr %374[%379] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    llvm.store %373, %380 : !llvm.ptr<f32>
    %381 = llvm.add %346, %8  : i64
    llvm.br ^bb19(%381 : i64)
  ^bb21:  // pred: ^bb19
    %382 = llvm.add %344, %8  : i64
    llvm.br ^bb18(%382 : i64)
  ^bb22:  // pred: ^bb18
    %383 = llvm.add %342, %8  : i64
    llvm.br ^bb17(%383 : i64)
  ^bb23:  // pred: ^bb17
    %384 = llvm.add %267, %6  : i64
    llvm.br ^bb15(%384 : i64)
  ^bb24:  // pred: ^bb15
    %385 = llvm.add %265, %6  : i64
    llvm.br ^bb14(%385 : i64)
  ^bb25:  // pred: ^bb14
    %386 = llvm.add %263, %6  : i64
    llvm.br ^bb13(%386 : i64)
  ^bb26:  // pred: ^bb13
    %387 = llvm.add %188, %3  : i64
    llvm.br ^bb11(%387 : i64)
  ^bb27:  // pred: ^bb11
    %388 = llvm.add %186, %4  : i64
    llvm.br ^bb10(%388 : i64)
  ^bb28:  // pred: ^bb10
    %389 = llvm.add %184, %6  : i64
    llvm.br ^bb9(%389 : i64)
  ^bb29:  // pred: ^bb9
    %390 = llvm.add %93, %92  : i64
    llvm.br ^bb3(%390 : i64)
  ^bb30:  // pred: ^bb3
    %391 = llvm.add %87, %86  : i64
    llvm.br ^bb1(%391 : i64)
  ^bb31:  // pred: ^bb1
    %392 = llvm.mlir.constant(0 : i32) : i32
    llvm.return %392 : i32
  }
}

// *** IR Dump After CSE ***
module  {
  llvm.func internal @predict_dispatch_0(%arg0: !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>, %arg1: !llvm.ptr<array<3 x i32>>) -> i32 {
    %0 = llvm.mlir.constant(0.000000e+00 : f32) : f32
    %1 = llvm.mlir.constant(128 : index) : i64
    %2 = llvm.mlir.constant(784 : index) : i64
    %3 = llvm.mlir.constant(28 : index) : i64
    %4 = llvm.mlir.constant(32 : index) : i64
    %5 = llvm.mlir.constant(64 : index) : i64
    %6 = llvm.mlir.constant(4 : index) : i64
    %7 = llvm.mlir.constant(0 : index) : i64
    %8 = llvm.mlir.constant(1 : index) : i64
    %9 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
    %10 = llvm.extractvalue %9[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
    %11 = llvm.getelementptr %10[%8] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
    %12 = llvm.load %11 : !llvm.ptr<ptr<i8>>
    %13 = llvm.getelementptr %12[%7] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
    %14 = llvm.bitcast %13 : !llvm.ptr<i8> to !llvm.ptr<f32>
    %15 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %16 = llvm.insertvalue %14, %15[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %17 = llvm.insertvalue %14, %16[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %18 = llvm.insertvalue %7, %17[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %19 = llvm.insertvalue %8, %18[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %20 = llvm.insertvalue %2, %19[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %21 = llvm.insertvalue %2, %20[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %22 = llvm.insertvalue %8, %21[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %23 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
    %24 = llvm.extractvalue %23[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
    %25 = llvm.getelementptr %24[%7] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
    %26 = llvm.load %25 : !llvm.ptr<ptr<i8>>
    %27 = llvm.getelementptr %26[%7] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
    %28 = llvm.bitcast %27 : !llvm.ptr<i8> to !llvm.ptr<f32>
    %29 = llvm.insertvalue %28, %15[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %30 = llvm.insertvalue %28, %29[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %31 = llvm.insertvalue %7, %30[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %32 = llvm.insertvalue %2, %31[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %33 = llvm.insertvalue %1, %32[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %34 = llvm.insertvalue %1, %33[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %35 = llvm.insertvalue %8, %34[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %36 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
    %37 = llvm.extractvalue %36[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
    %38 = llvm.mlir.constant(2 : index) : i64
    %39 = llvm.getelementptr %37[%38] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
    %40 = llvm.load %39 : !llvm.ptr<ptr<i8>>
    %41 = llvm.getelementptr %40[%7] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
    %42 = llvm.bitcast %41 : !llvm.ptr<i8> to !llvm.ptr<f32>
    %43 = llvm.insertvalue %42, %15[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %44 = llvm.insertvalue %42, %43[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %45 = llvm.insertvalue %7, %44[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %46 = llvm.insertvalue %8, %45[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %47 = llvm.insertvalue %1, %46[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %48 = llvm.insertvalue %1, %47[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %49 = llvm.insertvalue %8, %48[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %50 = llvm.load %arg1 : !llvm.ptr<array<3 x i32>>
    %51 = llvm.extractvalue %50[0] : !llvm.array<3 x i32>
    %52 = llvm.zext %51 : i32 to i64
    %53 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
    %54 = llvm.extractvalue %53[0] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
    %55 = llvm.extractvalue %54[0] : !llvm.array<3 x i32>
    %56 = llvm.zext %55 : i32 to i64
    %57 = llvm.load %arg1 : !llvm.ptr<array<3 x i32>>
    %58 = llvm.extractvalue %57[1] : !llvm.array<3 x i32>
    %59 = llvm.zext %58 : i32 to i64
    %60 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
    %61 = llvm.extractvalue %60[0] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
    %62 = llvm.extractvalue %61[1] : !llvm.array<3 x i32>
    %63 = llvm.zext %62 : i32 to i64
    %64 = llvm.mul %59, %6  : i64
    %65 = llvm.mul %63, %6  : i64
    llvm.br ^bb1(%64 : i64)
  ^bb1(%66: i64):  // 2 preds: ^bb0, ^bb30
    %67 = llvm.icmp "slt" %66, %8 : i64
    llvm.cond_br %67, ^bb2, ^bb31
  ^bb2:  // pred: ^bb1
    %68 = llvm.mul %52, %5  : i64
    %69 = llvm.mul %56, %5  : i64
    llvm.br ^bb3(%68 : i64)
  ^bb3(%70: i64):  // 2 preds: ^bb2, ^bb29
    %71 = llvm.icmp "slt" %70, %1 : i64
    llvm.cond_br %71, ^bb4, ^bb30
  ^bb4:  // pred: ^bb3
    %72 = llvm.mlir.constant(-1 : index) : i64
    %73 = llvm.mul %66, %72  : i64
    %74 = llvm.add %73, %8  : i64
    %75 = llvm.icmp "slt" %6, %74 : i64
    %76 = llvm.select %75, %6, %74 : i1, i64
    %77 = llvm.extractvalue %22[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %78 = llvm.bitcast %77 : !llvm.ptr<f32> to !llvm.ptr<f32>
    %79 = llvm.insertvalue %78, %15[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %80 = llvm.extractvalue %22[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %81 = llvm.bitcast %80 : !llvm.ptr<f32> to !llvm.ptr<f32>
    %82 = llvm.insertvalue %81, %79[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %83 = llvm.extractvalue %22[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %84 = llvm.extractvalue %22[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %85 = llvm.extractvalue %22[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %86 = llvm.mul %66, %83  : i64
    %87 = llvm.add %85, %86  : i64
    %88 = llvm.mlir.constant(0 : i64) : i64
    %89 = llvm.mul %88, %84  : i64
    %90 = llvm.add %87, %89  : i64
    %91 = llvm.insertvalue %90, %82[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %92 = llvm.mlir.constant(784 : i64) : i64
    %93 = llvm.mlir.constant(1 : i64) : i64
    %94 = llvm.insertvalue %92, %91[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %95 = llvm.insertvalue %93, %94[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %96 = llvm.insertvalue %76, %95[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %97 = llvm.insertvalue %92, %96[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %98 = llvm.extractvalue %35[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %99 = llvm.bitcast %98 : !llvm.ptr<f32> to !llvm.ptr<f32>
    %100 = llvm.insertvalue %99, %15[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %101 = llvm.extractvalue %35[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %102 = llvm.bitcast %101 : !llvm.ptr<f32> to !llvm.ptr<f32>
    %103 = llvm.insertvalue %102, %100[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %104 = llvm.extractvalue %35[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %105 = llvm.extractvalue %35[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %106 = llvm.extractvalue %35[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %107 = llvm.mul %88, %104  : i64
    %108 = llvm.add %106, %107  : i64
    %109 = llvm.mul %70, %105  : i64
    %110 = llvm.add %108, %109  : i64
    %111 = llvm.insertvalue %110, %103[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %112 = llvm.mlir.constant(64 : i64) : i64
    %113 = llvm.insertvalue %112, %111[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %114 = llvm.insertvalue %93, %113[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %115 = llvm.mlir.constant(128 : i64) : i64
    %116 = llvm.insertvalue %92, %114[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %117 = llvm.insertvalue %115, %116[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %118 = llvm.extractvalue %49[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %119 = llvm.bitcast %118 : !llvm.ptr<f32> to !llvm.ptr<f32>
    %120 = llvm.insertvalue %119, %15[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %121 = llvm.extractvalue %49[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %122 = llvm.bitcast %121 : !llvm.ptr<f32> to !llvm.ptr<f32>
    %123 = llvm.insertvalue %122, %120[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %124 = llvm.extractvalue %49[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %125 = llvm.extractvalue %49[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %126 = llvm.extractvalue %49[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %127 = llvm.mul %66, %124  : i64
    %128 = llvm.add %126, %127  : i64
    %129 = llvm.mul %70, %125  : i64
    %130 = llvm.add %128, %129  : i64
    %131 = llvm.insertvalue %130, %123[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %132 = llvm.insertvalue %112, %131[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %133 = llvm.insertvalue %93, %132[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %134 = llvm.insertvalue %76, %133[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %135 = llvm.insertvalue %115, %134[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    llvm.br ^bb5(%7 : i64)
  ^bb5(%136: i64):  // 2 preds: ^bb4, ^bb8
    %137 = llvm.icmp "slt" %136, %76 : i64
    llvm.cond_br %137, ^bb6(%7 : i64), ^bb9(%7 : i64)
  ^bb6(%138: i64):  // 2 preds: ^bb5, ^bb7
    %139 = llvm.icmp "slt" %138, %5 : i64
    llvm.cond_br %139, ^bb7, ^bb8
  ^bb7:  // pred: ^bb6
    %140 = llvm.extractvalue %135[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %141 = llvm.extractvalue %135[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %142 = llvm.mul %136, %1  : i64
    %143 = llvm.add %141, %142  : i64
    %144 = llvm.add %143, %138  : i64
    %145 = llvm.getelementptr %140[%144] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    llvm.store %0, %145 : !llvm.ptr<f32>
    %146 = llvm.add %138, %8  : i64
    llvm.br ^bb6(%146 : i64)
  ^bb8:  // pred: ^bb6
    %147 = llvm.add %136, %8  : i64
    llvm.br ^bb5(%147 : i64)
  ^bb9(%148: i64):  // 2 preds: ^bb5, ^bb28
    %149 = llvm.icmp "slt" %148, %76 : i64
    llvm.cond_br %149, ^bb10(%7 : i64), ^bb29
  ^bb10(%150: i64):  // 2 preds: ^bb9, ^bb27
    %151 = llvm.icmp "slt" %150, %5 : i64
    llvm.cond_br %151, ^bb11(%7 : i64), ^bb28
  ^bb11(%152: i64):  // 2 preds: ^bb10, ^bb26
    %153 = llvm.icmp "slt" %152, %2 : i64
    llvm.cond_br %153, ^bb12, ^bb27
  ^bb12:  // pred: ^bb11
    %154 = llvm.mul %148, %72  : i64
    %155 = llvm.add %76, %154  : i64
    %156 = llvm.icmp "slt" %6, %155 : i64
    %157 = llvm.select %156, %6, %155 : i1, i64
    %158 = llvm.extractvalue %97[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %159 = llvm.bitcast %158 : !llvm.ptr<f32> to !llvm.ptr<f32>
    %160 = llvm.insertvalue %159, %15[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %161 = llvm.extractvalue %97[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %162 = llvm.bitcast %161 : !llvm.ptr<f32> to !llvm.ptr<f32>
    %163 = llvm.insertvalue %162, %160[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %164 = llvm.extractvalue %97[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %165 = llvm.extractvalue %97[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %166 = llvm.extractvalue %97[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %167 = llvm.mul %148, %164  : i64
    %168 = llvm.add %166, %167  : i64
    %169 = llvm.mul %152, %165  : i64
    %170 = llvm.add %168, %169  : i64
    %171 = llvm.insertvalue %170, %163[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %172 = llvm.mlir.constant(28 : i64) : i64
    %173 = llvm.insertvalue %172, %171[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %174 = llvm.insertvalue %93, %173[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %175 = llvm.insertvalue %157, %174[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %176 = llvm.insertvalue %92, %175[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %177 = llvm.extractvalue %117[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %178 = llvm.bitcast %177 : !llvm.ptr<f32> to !llvm.ptr<f32>
    %179 = llvm.insertvalue %178, %15[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %180 = llvm.extractvalue %117[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %181 = llvm.bitcast %180 : !llvm.ptr<f32> to !llvm.ptr<f32>
    %182 = llvm.insertvalue %181, %179[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %183 = llvm.extractvalue %117[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %184 = llvm.extractvalue %117[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %185 = llvm.extractvalue %117[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %186 = llvm.mul %152, %183  : i64
    %187 = llvm.add %185, %186  : i64
    %188 = llvm.mul %150, %184  : i64
    %189 = llvm.add %187, %188  : i64
    %190 = llvm.insertvalue %189, %182[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %191 = llvm.mlir.constant(32 : i64) : i64
    %192 = llvm.insertvalue %191, %190[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %193 = llvm.insertvalue %93, %192[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %194 = llvm.insertvalue %172, %193[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %195 = llvm.insertvalue %115, %194[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %196 = llvm.extractvalue %135[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %197 = llvm.bitcast %196 : !llvm.ptr<f32> to !llvm.ptr<f32>
    %198 = llvm.insertvalue %197, %15[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %199 = llvm.extractvalue %135[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %200 = llvm.bitcast %199 : !llvm.ptr<f32> to !llvm.ptr<f32>
    %201 = llvm.insertvalue %200, %198[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %202 = llvm.extractvalue %135[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %203 = llvm.extractvalue %135[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %204 = llvm.extractvalue %135[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %205 = llvm.mul %148, %202  : i64
    %206 = llvm.add %204, %205  : i64
    %207 = llvm.mul %150, %203  : i64
    %208 = llvm.add %206, %207  : i64
    %209 = llvm.insertvalue %208, %201[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %210 = llvm.insertvalue %191, %209[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %211 = llvm.insertvalue %93, %210[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %212 = llvm.insertvalue %157, %211[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %213 = llvm.insertvalue %115, %212[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    llvm.br ^bb13(%7 : i64)
  ^bb13(%214: i64):  // 2 preds: ^bb12, ^bb25
    %215 = llvm.icmp "slt" %214, %157 : i64
    llvm.cond_br %215, ^bb14(%7 : i64), ^bb26
  ^bb14(%216: i64):  // 2 preds: ^bb13, ^bb24
    %217 = llvm.icmp "slt" %216, %4 : i64
    llvm.cond_br %217, ^bb15(%7 : i64), ^bb25
  ^bb15(%218: i64):  // 2 preds: ^bb14, ^bb23
    %219 = llvm.icmp "slt" %218, %3 : i64
    llvm.cond_br %219, ^bb16, ^bb24
  ^bb16:  // pred: ^bb15
    %220 = llvm.mul %214, %72  : i64
    %221 = llvm.add %157, %220  : i64
    %222 = llvm.icmp "slt" %6, %221 : i64
    %223 = llvm.select %222, %6, %221 : i1, i64
    %224 = llvm.extractvalue %176[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %225 = llvm.bitcast %224 : !llvm.ptr<f32> to !llvm.ptr<f32>
    %226 = llvm.insertvalue %225, %15[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %227 = llvm.extractvalue %176[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %228 = llvm.bitcast %227 : !llvm.ptr<f32> to !llvm.ptr<f32>
    %229 = llvm.insertvalue %228, %226[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %230 = llvm.extractvalue %176[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %231 = llvm.extractvalue %176[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %232 = llvm.extractvalue %176[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %233 = llvm.mul %214, %230  : i64
    %234 = llvm.add %232, %233  : i64
    %235 = llvm.mul %218, %231  : i64
    %236 = llvm.add %234, %235  : i64
    %237 = llvm.insertvalue %236, %229[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %238 = llvm.mlir.constant(4 : i64) : i64
    %239 = llvm.insertvalue %238, %237[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %240 = llvm.insertvalue %93, %239[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %241 = llvm.insertvalue %223, %240[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %242 = llvm.insertvalue %92, %241[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %243 = llvm.extractvalue %195[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %244 = llvm.bitcast %243 : !llvm.ptr<f32> to !llvm.ptr<f32>
    %245 = llvm.insertvalue %244, %15[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %246 = llvm.extractvalue %195[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %247 = llvm.bitcast %246 : !llvm.ptr<f32> to !llvm.ptr<f32>
    %248 = llvm.insertvalue %247, %245[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %249 = llvm.extractvalue %195[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %250 = llvm.extractvalue %195[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %251 = llvm.extractvalue %195[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %252 = llvm.mul %218, %249  : i64
    %253 = llvm.add %251, %252  : i64
    %254 = llvm.mul %216, %250  : i64
    %255 = llvm.add %253, %254  : i64
    %256 = llvm.insertvalue %255, %248[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %257 = llvm.insertvalue %238, %256[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %258 = llvm.insertvalue %93, %257[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %259 = llvm.insertvalue %238, %258[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %260 = llvm.insertvalue %115, %259[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %261 = llvm.extractvalue %213[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %262 = llvm.bitcast %261 : !llvm.ptr<f32> to !llvm.ptr<f32>
    %263 = llvm.insertvalue %262, %15[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %264 = llvm.extractvalue %213[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %265 = llvm.bitcast %264 : !llvm.ptr<f32> to !llvm.ptr<f32>
    %266 = llvm.insertvalue %265, %263[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %267 = llvm.extractvalue %213[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %268 = llvm.extractvalue %213[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %269 = llvm.extractvalue %213[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %270 = llvm.mul %214, %267  : i64
    %271 = llvm.add %269, %270  : i64
    %272 = llvm.mul %216, %268  : i64
    %273 = llvm.add %271, %272  : i64
    %274 = llvm.insertvalue %273, %266[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %275 = llvm.insertvalue %238, %274[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %276 = llvm.insertvalue %93, %275[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %277 = llvm.insertvalue %223, %276[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %278 = llvm.insertvalue %115, %277[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    llvm.br ^bb17(%7 : i64)
  ^bb17(%279: i64):  // 2 preds: ^bb16, ^bb22
    %280 = llvm.icmp "slt" %279, %223 : i64
    llvm.cond_br %280, ^bb18(%7 : i64), ^bb23
  ^bb18(%281: i64):  // 2 preds: ^bb17, ^bb21
    %282 = llvm.icmp "slt" %281, %6 : i64
    llvm.cond_br %282, ^bb19(%7 : i64), ^bb22
  ^bb19(%283: i64):  // 2 preds: ^bb18, ^bb20
    %284 = llvm.icmp "slt" %283, %6 : i64
    llvm.cond_br %284, ^bb20, ^bb21
  ^bb20:  // pred: ^bb19
    %285 = llvm.extractvalue %242[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %286 = llvm.extractvalue %242[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %287 = llvm.mul %279, %2  : i64
    %288 = llvm.add %286, %287  : i64
    %289 = llvm.add %288, %283  : i64
    %290 = llvm.getelementptr %285[%289] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %291 = llvm.load %290 : !llvm.ptr<f32>
    %292 = llvm.extractvalue %260[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %293 = llvm.extractvalue %260[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %294 = llvm.mul %283, %1  : i64
    %295 = llvm.add %293, %294  : i64
    %296 = llvm.add %295, %281  : i64
    %297 = llvm.getelementptr %292[%296] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %298 = llvm.load %297 : !llvm.ptr<f32>
    %299 = llvm.extractvalue %278[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %300 = llvm.extractvalue %278[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %301 = llvm.mul %279, %1  : i64
    %302 = llvm.add %300, %301  : i64
    %303 = llvm.add %302, %281  : i64
    %304 = llvm.getelementptr %299[%303] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %305 = llvm.load %304 : !llvm.ptr<f32>
    %306 = llvm.fmul %291, %298  : f32
    %307 = llvm.fadd %305, %306  : f32
    llvm.store %307, %304 : !llvm.ptr<f32>
    %308 = llvm.add %283, %8  : i64
    llvm.br ^bb19(%308 : i64)
  ^bb21:  // pred: ^bb19
    %309 = llvm.add %281, %8  : i64
    llvm.br ^bb18(%309 : i64)
  ^bb22:  // pred: ^bb18
    %310 = llvm.add %279, %8  : i64
    llvm.br ^bb17(%310 : i64)
  ^bb23:  // pred: ^bb17
    %311 = llvm.add %218, %6  : i64
    llvm.br ^bb15(%311 : i64)
  ^bb24:  // pred: ^bb15
    %312 = llvm.add %216, %6  : i64
    llvm.br ^bb14(%312 : i64)
  ^bb25:  // pred: ^bb14
    %313 = llvm.add %214, %6  : i64
    llvm.br ^bb13(%313 : i64)
  ^bb26:  // pred: ^bb13
    %314 = llvm.add %152, %3  : i64
    llvm.br ^bb11(%314 : i64)
  ^bb27:  // pred: ^bb11
    %315 = llvm.add %150, %4  : i64
    llvm.br ^bb10(%315 : i64)
  ^bb28:  // pred: ^bb10
    %316 = llvm.add %148, %6  : i64
    llvm.br ^bb9(%316 : i64)
  ^bb29:  // pred: ^bb9
    %317 = llvm.add %70, %69  : i64
    llvm.br ^bb3(%317 : i64)
  ^bb30:  // pred: ^bb3
    %318 = llvm.add %66, %65  : i64
    llvm.br ^bb1(%318 : i64)
  ^bb31:  // pred: ^bb1
    %319 = llvm.mlir.constant(0 : i32) : i32
    llvm.return %319 : i32
  }
}

// *** IR Dump After mlir::iree_compiler::`anonymous-namespace'::LowerExecutableTargetPass ***
hal.executable.target @llvm_aot, filter="dylib*" {
  hal.executable.entry_point @predict_dispatch_0 attributes {interface = @io, ordinal = 0 : index} {
  ^bb0(%arg0: index, %arg1: index, %arg2: index):  // no predecessors
    %c1 = constant 1 : index
    %0 = affine.apply affine_map<()[s0] -> (s0 ceildiv 64)>()[%arg0]
    %1 = affine.apply affine_map<()[s0] -> (s0 ceildiv 4)>()[%arg1]
    hal.return %0, %1, %c1 : index, index, index
  }
  module  {
    llvm.func internal @predict_dispatch_0(%arg0: !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>, %arg1: !llvm.ptr<array<3 x i32>>) -> i32 {
      %0 = llvm.mlir.constant(0.000000e+00 : f32) : f32
      %1 = llvm.mlir.constant(128 : index) : i64
      %2 = llvm.mlir.constant(784 : index) : i64
      %3 = llvm.mlir.constant(28 : index) : i64
      %4 = llvm.mlir.constant(32 : index) : i64
      %5 = llvm.mlir.constant(64 : index) : i64
      %6 = llvm.mlir.constant(4 : index) : i64
      %7 = llvm.mlir.constant(0 : index) : i64
      %8 = llvm.mlir.constant(1 : index) : i64
      %9 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
      %10 = llvm.extractvalue %9[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
      %11 = llvm.getelementptr %10[%8] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
      %12 = llvm.load %11 : !llvm.ptr<ptr<i8>>
      %13 = llvm.getelementptr %12[%7] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
      %14 = llvm.bitcast %13 : !llvm.ptr<i8> to !llvm.ptr<f32>
      %15 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %16 = llvm.insertvalue %14, %15[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %17 = llvm.insertvalue %14, %16[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %18 = llvm.insertvalue %7, %17[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %19 = llvm.insertvalue %8, %18[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %20 = llvm.insertvalue %2, %19[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %21 = llvm.insertvalue %2, %20[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %22 = llvm.insertvalue %8, %21[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %23 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
      %24 = llvm.extractvalue %23[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
      %25 = llvm.getelementptr %24[%7] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
      %26 = llvm.load %25 : !llvm.ptr<ptr<i8>>
      %27 = llvm.getelementptr %26[%7] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
      %28 = llvm.bitcast %27 : !llvm.ptr<i8> to !llvm.ptr<f32>
      %29 = llvm.insertvalue %28, %15[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %30 = llvm.insertvalue %28, %29[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %31 = llvm.insertvalue %7, %30[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %32 = llvm.insertvalue %2, %31[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %33 = llvm.insertvalue %1, %32[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %34 = llvm.insertvalue %1, %33[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %35 = llvm.insertvalue %8, %34[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %36 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
      %37 = llvm.extractvalue %36[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
      %38 = llvm.mlir.constant(2 : index) : i64
      %39 = llvm.getelementptr %37[%38] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
      %40 = llvm.load %39 : !llvm.ptr<ptr<i8>>
      %41 = llvm.getelementptr %40[%7] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
      %42 = llvm.bitcast %41 : !llvm.ptr<i8> to !llvm.ptr<f32>
      %43 = llvm.insertvalue %42, %15[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %44 = llvm.insertvalue %42, %43[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %45 = llvm.insertvalue %7, %44[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %46 = llvm.insertvalue %8, %45[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %47 = llvm.insertvalue %1, %46[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %48 = llvm.insertvalue %1, %47[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %49 = llvm.insertvalue %8, %48[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %50 = llvm.load %arg1 : !llvm.ptr<array<3 x i32>>
      %51 = llvm.extractvalue %50[0] : !llvm.array<3 x i32>
      %52 = llvm.zext %51 : i32 to i64
      %53 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
      %54 = llvm.extractvalue %53[0] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
      %55 = llvm.extractvalue %54[0] : !llvm.array<3 x i32>
      %56 = llvm.zext %55 : i32 to i64
      %57 = llvm.load %arg1 : !llvm.ptr<array<3 x i32>>
      %58 = llvm.extractvalue %57[1] : !llvm.array<3 x i32>
      %59 = llvm.zext %58 : i32 to i64
      %60 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
      %61 = llvm.extractvalue %60[0] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
      %62 = llvm.extractvalue %61[1] : !llvm.array<3 x i32>
      %63 = llvm.zext %62 : i32 to i64
      %64 = llvm.mul %59, %6  : i64
      %65 = llvm.mul %63, %6  : i64
      llvm.br ^bb1(%64 : i64)
    ^bb1(%66: i64):  // 2 preds: ^bb0, ^bb30
      %67 = llvm.icmp "slt" %66, %8 : i64
      llvm.cond_br %67, ^bb2, ^bb31
    ^bb2:  // pred: ^bb1
      %68 = llvm.mul %52, %5  : i64
      %69 = llvm.mul %56, %5  : i64
      llvm.br ^bb3(%68 : i64)
    ^bb3(%70: i64):  // 2 preds: ^bb2, ^bb29
      %71 = llvm.icmp "slt" %70, %1 : i64
      llvm.cond_br %71, ^bb4, ^bb30
    ^bb4:  // pred: ^bb3
      %72 = llvm.mlir.constant(-1 : index) : i64
      %73 = llvm.mul %66, %72  : i64
      %74 = llvm.add %73, %8  : i64
      %75 = llvm.icmp "slt" %6, %74 : i64
      %76 = llvm.select %75, %6, %74 : i1, i64
      %77 = llvm.extractvalue %22[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %78 = llvm.bitcast %77 : !llvm.ptr<f32> to !llvm.ptr<f32>
      %79 = llvm.insertvalue %78, %15[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %80 = llvm.extractvalue %22[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %81 = llvm.bitcast %80 : !llvm.ptr<f32> to !llvm.ptr<f32>
      %82 = llvm.insertvalue %81, %79[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %83 = llvm.extractvalue %22[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %84 = llvm.extractvalue %22[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %85 = llvm.extractvalue %22[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %86 = llvm.mul %66, %83  : i64
      %87 = llvm.add %85, %86  : i64
      %88 = llvm.mlir.constant(0 : i64) : i64
      %89 = llvm.mul %88, %84  : i64
      %90 = llvm.add %87, %89  : i64
      %91 = llvm.insertvalue %90, %82[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %92 = llvm.mlir.constant(784 : i64) : i64
      %93 = llvm.mlir.constant(1 : i64) : i64
      %94 = llvm.insertvalue %92, %91[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %95 = llvm.insertvalue %93, %94[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %96 = llvm.insertvalue %76, %95[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %97 = llvm.insertvalue %92, %96[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %98 = llvm.extractvalue %35[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %99 = llvm.bitcast %98 : !llvm.ptr<f32> to !llvm.ptr<f32>
      %100 = llvm.insertvalue %99, %15[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %101 = llvm.extractvalue %35[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %102 = llvm.bitcast %101 : !llvm.ptr<f32> to !llvm.ptr<f32>
      %103 = llvm.insertvalue %102, %100[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %104 = llvm.extractvalue %35[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %105 = llvm.extractvalue %35[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %106 = llvm.extractvalue %35[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %107 = llvm.mul %88, %104  : i64
      %108 = llvm.add %106, %107  : i64
      %109 = llvm.mul %70, %105  : i64
      %110 = llvm.add %108, %109  : i64
      %111 = llvm.insertvalue %110, %103[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %112 = llvm.mlir.constant(64 : i64) : i64
      %113 = llvm.insertvalue %112, %111[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %114 = llvm.insertvalue %93, %113[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %115 = llvm.mlir.constant(128 : i64) : i64
      %116 = llvm.insertvalue %92, %114[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %117 = llvm.insertvalue %115, %116[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %118 = llvm.extractvalue %49[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %119 = llvm.bitcast %118 : !llvm.ptr<f32> to !llvm.ptr<f32>
      %120 = llvm.insertvalue %119, %15[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %121 = llvm.extractvalue %49[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %122 = llvm.bitcast %121 : !llvm.ptr<f32> to !llvm.ptr<f32>
      %123 = llvm.insertvalue %122, %120[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %124 = llvm.extractvalue %49[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %125 = llvm.extractvalue %49[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %126 = llvm.extractvalue %49[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %127 = llvm.mul %66, %124  : i64
      %128 = llvm.add %126, %127  : i64
      %129 = llvm.mul %70, %125  : i64
      %130 = llvm.add %128, %129  : i64
      %131 = llvm.insertvalue %130, %123[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %132 = llvm.insertvalue %112, %131[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %133 = llvm.insertvalue %93, %132[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %134 = llvm.insertvalue %76, %133[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %135 = llvm.insertvalue %115, %134[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      llvm.br ^bb5(%7 : i64)
    ^bb5(%136: i64):  // 2 preds: ^bb4, ^bb8
      %137 = llvm.icmp "slt" %136, %76 : i64
      llvm.cond_br %137, ^bb6(%7 : i64), ^bb9(%7 : i64)
    ^bb6(%138: i64):  // 2 preds: ^bb5, ^bb7
      %139 = llvm.icmp "slt" %138, %5 : i64
      llvm.cond_br %139, ^bb7, ^bb8
    ^bb7:  // pred: ^bb6
      %140 = llvm.extractvalue %135[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %141 = llvm.extractvalue %135[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %142 = llvm.mul %136, %1  : i64
      %143 = llvm.add %141, %142  : i64
      %144 = llvm.add %143, %138  : i64
      %145 = llvm.getelementptr %140[%144] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
      llvm.store %0, %145 : !llvm.ptr<f32>
      %146 = llvm.add %138, %8  : i64
      llvm.br ^bb6(%146 : i64)
    ^bb8:  // pred: ^bb6
      %147 = llvm.add %136, %8  : i64
      llvm.br ^bb5(%147 : i64)
    ^bb9(%148: i64):  // 2 preds: ^bb5, ^bb28
      %149 = llvm.icmp "slt" %148, %76 : i64
      llvm.cond_br %149, ^bb10(%7 : i64), ^bb29
    ^bb10(%150: i64):  // 2 preds: ^bb9, ^bb27
      %151 = llvm.icmp "slt" %150, %5 : i64
      llvm.cond_br %151, ^bb11(%7 : i64), ^bb28
    ^bb11(%152: i64):  // 2 preds: ^bb10, ^bb26
      %153 = llvm.icmp "slt" %152, %2 : i64
      llvm.cond_br %153, ^bb12, ^bb27
    ^bb12:  // pred: ^bb11
      %154 = llvm.mul %148, %72  : i64
      %155 = llvm.add %76, %154  : i64
      %156 = llvm.icmp "slt" %6, %155 : i64
      %157 = llvm.select %156, %6, %155 : i1, i64
      %158 = llvm.extractvalue %97[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %159 = llvm.bitcast %158 : !llvm.ptr<f32> to !llvm.ptr<f32>
      %160 = llvm.insertvalue %159, %15[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %161 = llvm.extractvalue %97[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %162 = llvm.bitcast %161 : !llvm.ptr<f32> to !llvm.ptr<f32>
      %163 = llvm.insertvalue %162, %160[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %164 = llvm.extractvalue %97[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %165 = llvm.extractvalue %97[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %166 = llvm.extractvalue %97[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %167 = llvm.mul %148, %164  : i64
      %168 = llvm.add %166, %167  : i64
      %169 = llvm.mul %152, %165  : i64
      %170 = llvm.add %168, %169  : i64
      %171 = llvm.insertvalue %170, %163[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %172 = llvm.mlir.constant(28 : i64) : i64
      %173 = llvm.insertvalue %172, %171[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %174 = llvm.insertvalue %93, %173[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %175 = llvm.insertvalue %157, %174[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %176 = llvm.insertvalue %92, %175[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %177 = llvm.extractvalue %117[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %178 = llvm.bitcast %177 : !llvm.ptr<f32> to !llvm.ptr<f32>
      %179 = llvm.insertvalue %178, %15[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %180 = llvm.extractvalue %117[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %181 = llvm.bitcast %180 : !llvm.ptr<f32> to !llvm.ptr<f32>
      %182 = llvm.insertvalue %181, %179[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %183 = llvm.extractvalue %117[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %184 = llvm.extractvalue %117[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %185 = llvm.extractvalue %117[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %186 = llvm.mul %152, %183  : i64
      %187 = llvm.add %185, %186  : i64
      %188 = llvm.mul %150, %184  : i64
      %189 = llvm.add %187, %188  : i64
      %190 = llvm.insertvalue %189, %182[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %191 = llvm.mlir.constant(32 : i64) : i64
      %192 = llvm.insertvalue %191, %190[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %193 = llvm.insertvalue %93, %192[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %194 = llvm.insertvalue %172, %193[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %195 = llvm.insertvalue %115, %194[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %196 = llvm.extractvalue %135[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %197 = llvm.bitcast %196 : !llvm.ptr<f32> to !llvm.ptr<f32>
      %198 = llvm.insertvalue %197, %15[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %199 = llvm.extractvalue %135[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %200 = llvm.bitcast %199 : !llvm.ptr<f32> to !llvm.ptr<f32>
      %201 = llvm.insertvalue %200, %198[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %202 = llvm.extractvalue %135[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %203 = llvm.extractvalue %135[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %204 = llvm.extractvalue %135[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %205 = llvm.mul %148, %202  : i64
      %206 = llvm.add %204, %205  : i64
      %207 = llvm.mul %150, %203  : i64
      %208 = llvm.add %206, %207  : i64
      %209 = llvm.insertvalue %208, %201[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %210 = llvm.insertvalue %191, %209[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %211 = llvm.insertvalue %93, %210[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %212 = llvm.insertvalue %157, %211[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %213 = llvm.insertvalue %115, %212[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      llvm.br ^bb13(%7 : i64)
    ^bb13(%214: i64):  // 2 preds: ^bb12, ^bb25
      %215 = llvm.icmp "slt" %214, %157 : i64
      llvm.cond_br %215, ^bb14(%7 : i64), ^bb26
    ^bb14(%216: i64):  // 2 preds: ^bb13, ^bb24
      %217 = llvm.icmp "slt" %216, %4 : i64
      llvm.cond_br %217, ^bb15(%7 : i64), ^bb25
    ^bb15(%218: i64):  // 2 preds: ^bb14, ^bb23
      %219 = llvm.icmp "slt" %218, %3 : i64
      llvm.cond_br %219, ^bb16, ^bb24
    ^bb16:  // pred: ^bb15
      %220 = llvm.mul %214, %72  : i64
      %221 = llvm.add %157, %220  : i64
      %222 = llvm.icmp "slt" %6, %221 : i64
      %223 = llvm.select %222, %6, %221 : i1, i64
      %224 = llvm.extractvalue %176[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %225 = llvm.bitcast %224 : !llvm.ptr<f32> to !llvm.ptr<f32>
      %226 = llvm.insertvalue %225, %15[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %227 = llvm.extractvalue %176[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %228 = llvm.bitcast %227 : !llvm.ptr<f32> to !llvm.ptr<f32>
      %229 = llvm.insertvalue %228, %226[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %230 = llvm.extractvalue %176[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %231 = llvm.extractvalue %176[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %232 = llvm.extractvalue %176[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %233 = llvm.mul %214, %230  : i64
      %234 = llvm.add %232, %233  : i64
      %235 = llvm.mul %218, %231  : i64
      %236 = llvm.add %234, %235  : i64
      %237 = llvm.insertvalue %236, %229[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %238 = llvm.mlir.constant(4 : i64) : i64
      %239 = llvm.insertvalue %238, %237[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %240 = llvm.insertvalue %93, %239[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %241 = llvm.insertvalue %223, %240[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %242 = llvm.insertvalue %92, %241[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %243 = llvm.extractvalue %195[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %244 = llvm.bitcast %243 : !llvm.ptr<f32> to !llvm.ptr<f32>
      %245 = llvm.insertvalue %244, %15[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %246 = llvm.extractvalue %195[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %247 = llvm.bitcast %246 : !llvm.ptr<f32> to !llvm.ptr<f32>
      %248 = llvm.insertvalue %247, %245[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %249 = llvm.extractvalue %195[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %250 = llvm.extractvalue %195[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %251 = llvm.extractvalue %195[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %252 = llvm.mul %218, %249  : i64
      %253 = llvm.add %251, %252  : i64
      %254 = llvm.mul %216, %250  : i64
      %255 = llvm.add %253, %254  : i64
      %256 = llvm.insertvalue %255, %248[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %257 = llvm.insertvalue %238, %256[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %258 = llvm.insertvalue %93, %257[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %259 = llvm.insertvalue %238, %258[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %260 = llvm.insertvalue %115, %259[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %261 = llvm.extractvalue %213[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %262 = llvm.bitcast %261 : !llvm.ptr<f32> to !llvm.ptr<f32>
      %263 = llvm.insertvalue %262, %15[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %264 = llvm.extractvalue %213[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %265 = llvm.bitcast %264 : !llvm.ptr<f32> to !llvm.ptr<f32>
      %266 = llvm.insertvalue %265, %263[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %267 = llvm.extractvalue %213[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %268 = llvm.extractvalue %213[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %269 = llvm.extractvalue %213[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %270 = llvm.mul %214, %267  : i64
      %271 = llvm.add %269, %270  : i64
      %272 = llvm.mul %216, %268  : i64
      %273 = llvm.add %271, %272  : i64
      %274 = llvm.insertvalue %273, %266[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %275 = llvm.insertvalue %238, %274[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %276 = llvm.insertvalue %93, %275[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %277 = llvm.insertvalue %223, %276[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %278 = llvm.insertvalue %115, %277[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      llvm.br ^bb17(%7 : i64)
    ^bb17(%279: i64):  // 2 preds: ^bb16, ^bb22
      %280 = llvm.icmp "slt" %279, %223 : i64
      llvm.cond_br %280, ^bb18(%7 : i64), ^bb23
    ^bb18(%281: i64):  // 2 preds: ^bb17, ^bb21
      %282 = llvm.icmp "slt" %281, %6 : i64
      llvm.cond_br %282, ^bb19(%7 : i64), ^bb22
    ^bb19(%283: i64):  // 2 preds: ^bb18, ^bb20
      %284 = llvm.icmp "slt" %283, %6 : i64
      llvm.cond_br %284, ^bb20, ^bb21
    ^bb20:  // pred: ^bb19
      %285 = llvm.extractvalue %242[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %286 = llvm.extractvalue %242[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %287 = llvm.mul %279, %2  : i64
      %288 = llvm.add %286, %287  : i64
      %289 = llvm.add %288, %283  : i64
      %290 = llvm.getelementptr %285[%289] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
      %291 = llvm.load %290 : !llvm.ptr<f32>
      %292 = llvm.extractvalue %260[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %293 = llvm.extractvalue %260[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %294 = llvm.mul %283, %1  : i64
      %295 = llvm.add %293, %294  : i64
      %296 = llvm.add %295, %281  : i64
      %297 = llvm.getelementptr %292[%296] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
      %298 = llvm.load %297 : !llvm.ptr<f32>
      %299 = llvm.extractvalue %278[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %300 = llvm.extractvalue %278[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %301 = llvm.mul %279, %1  : i64
      %302 = llvm.add %300, %301  : i64
      %303 = llvm.add %302, %281  : i64
      %304 = llvm.getelementptr %299[%303] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
      %305 = llvm.load %304 : !llvm.ptr<f32>
      %306 = llvm.fmul %291, %298  : f32
      %307 = llvm.fadd %305, %306  : f32
      llvm.store %307, %304 : !llvm.ptr<f32>
      %308 = llvm.add %283, %8  : i64
      llvm.br ^bb19(%308 : i64)
    ^bb21:  // pred: ^bb19
      %309 = llvm.add %281, %8  : i64
      llvm.br ^bb18(%309 : i64)
    ^bb22:  // pred: ^bb18
      %310 = llvm.add %279, %8  : i64
      llvm.br ^bb17(%310 : i64)
    ^bb23:  // pred: ^bb17
      %311 = llvm.add %218, %6  : i64
      llvm.br ^bb15(%311 : i64)
    ^bb24:  // pred: ^bb15
      %312 = llvm.add %216, %6  : i64
      llvm.br ^bb14(%312 : i64)
    ^bb25:  // pred: ^bb14
      %313 = llvm.add %214, %6  : i64
      llvm.br ^bb13(%313 : i64)
    ^bb26:  // pred: ^bb13
      %314 = llvm.add %152, %3  : i64
      llvm.br ^bb11(%314 : i64)
    ^bb27:  // pred: ^bb11
      %315 = llvm.add %150, %4  : i64
      llvm.br ^bb10(%315 : i64)
    ^bb28:  // pred: ^bb10
      %316 = llvm.add %148, %6  : i64
      llvm.br ^bb9(%316 : i64)
    ^bb29:  // pred: ^bb9
      %317 = llvm.add %70, %69  : i64
      llvm.br ^bb3(%317 : i64)
    ^bb30:  // pred: ^bb3
      %318 = llvm.add %66, %65  : i64
      llvm.br ^bb1(%318 : i64)
    ^bb31:  // pred: ^bb1
      %319 = llvm.mlir.constant(0 : i32) : i32
      llvm.return %319 : i32
    }
  }
}

// *** IR Dump After mlir::iree_compiler::IREE::HAL::TranslateExecutablesPass ***
hal.executable.target @llvm_aot, filter="dylib*" {
  hal.executable.entry_point @predict_dispatch_0 attributes {interface = @io, ordinal = 0 : index} {
  ^bb0(%arg0: index, %arg1: index, %arg2: index):  // no predecessors
    %c1 = constant 1 : index
    %0 = affine.apply affine_map<()[s0] -> (s0 ceildiv 64)>()[%arg0]
    %1 = affine.apply affine_map<()[s0] -> (s0 ceildiv 4)>()[%arg1]
    hal.return %0, %1, %c1 : index, index, index
  }
  module  {
    llvm.func internal @predict_dispatch_0(%arg0: !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>, %arg1: !llvm.ptr<array<3 x i32>>) -> i32 {
      %0 = llvm.mlir.constant(0.000000e+00 : f32) : f32
      %1 = llvm.mlir.constant(128 : index) : i64
      %2 = llvm.mlir.constant(784 : index) : i64
      %3 = llvm.mlir.constant(28 : index) : i64
      %4 = llvm.mlir.constant(32 : index) : i64
      %5 = llvm.mlir.constant(64 : index) : i64
      %6 = llvm.mlir.constant(4 : index) : i64
      %7 = llvm.mlir.constant(0 : index) : i64
      %8 = llvm.mlir.constant(1 : index) : i64
      %9 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
      %10 = llvm.extractvalue %9[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
      %11 = llvm.getelementptr %10[%8] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
      %12 = llvm.load %11 : !llvm.ptr<ptr<i8>>
      %13 = llvm.getelementptr %12[%7] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
      %14 = llvm.bitcast %13 : !llvm.ptr<i8> to !llvm.ptr<f32>
      %15 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %16 = llvm.insertvalue %14, %15[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %17 = llvm.insertvalue %14, %16[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %18 = llvm.insertvalue %7, %17[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %19 = llvm.insertvalue %8, %18[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %20 = llvm.insertvalue %2, %19[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %21 = llvm.insertvalue %2, %20[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %22 = llvm.insertvalue %8, %21[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %23 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
      %24 = llvm.extractvalue %23[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
      %25 = llvm.getelementptr %24[%7] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
      %26 = llvm.load %25 : !llvm.ptr<ptr<i8>>
      %27 = llvm.getelementptr %26[%7] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
      %28 = llvm.bitcast %27 : !llvm.ptr<i8> to !llvm.ptr<f32>
      %29 = llvm.insertvalue %28, %15[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %30 = llvm.insertvalue %28, %29[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %31 = llvm.insertvalue %7, %30[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %32 = llvm.insertvalue %2, %31[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %33 = llvm.insertvalue %1, %32[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %34 = llvm.insertvalue %1, %33[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %35 = llvm.insertvalue %8, %34[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %36 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
      %37 = llvm.extractvalue %36[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
      %38 = llvm.mlir.constant(2 : index) : i64
      %39 = llvm.getelementptr %37[%38] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
      %40 = llvm.load %39 : !llvm.ptr<ptr<i8>>
      %41 = llvm.getelementptr %40[%7] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
      %42 = llvm.bitcast %41 : !llvm.ptr<i8> to !llvm.ptr<f32>
      %43 = llvm.insertvalue %42, %15[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %44 = llvm.insertvalue %42, %43[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %45 = llvm.insertvalue %7, %44[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %46 = llvm.insertvalue %8, %45[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %47 = llvm.insertvalue %1, %46[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %48 = llvm.insertvalue %1, %47[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %49 = llvm.insertvalue %8, %48[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %50 = llvm.load %arg1 : !llvm.ptr<array<3 x i32>>
      %51 = llvm.extractvalue %50[0] : !llvm.array<3 x i32>
      %52 = llvm.zext %51 : i32 to i64
      %53 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
      %54 = llvm.extractvalue %53[0] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
      %55 = llvm.extractvalue %54[0] : !llvm.array<3 x i32>
      %56 = llvm.zext %55 : i32 to i64
      %57 = llvm.load %arg1 : !llvm.ptr<array<3 x i32>>
      %58 = llvm.extractvalue %57[1] : !llvm.array<3 x i32>
      %59 = llvm.zext %58 : i32 to i64
      %60 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
      %61 = llvm.extractvalue %60[0] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
      %62 = llvm.extractvalue %61[1] : !llvm.array<3 x i32>
      %63 = llvm.zext %62 : i32 to i64
      %64 = llvm.mul %59, %6  : i64
      %65 = llvm.mul %63, %6  : i64
      llvm.br ^bb1(%64 : i64)
    ^bb1(%66: i64):  // 2 preds: ^bb0, ^bb30
      %67 = llvm.icmp "slt" %66, %8 : i64
      llvm.cond_br %67, ^bb2, ^bb31
    ^bb2:  // pred: ^bb1
      %68 = llvm.mul %52, %5  : i64
      %69 = llvm.mul %56, %5  : i64
      llvm.br ^bb3(%68 : i64)
    ^bb3(%70: i64):  // 2 preds: ^bb2, ^bb29
      %71 = llvm.icmp "slt" %70, %1 : i64
      llvm.cond_br %71, ^bb4, ^bb30
    ^bb4:  // pred: ^bb3
      %72 = llvm.mlir.constant(-1 : index) : i64
      %73 = llvm.mul %66, %72  : i64
      %74 = llvm.add %73, %8  : i64
      %75 = llvm.icmp "slt" %6, %74 : i64
      %76 = llvm.select %75, %6, %74 : i1, i64
      %77 = llvm.extractvalue %22[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %78 = llvm.bitcast %77 : !llvm.ptr<f32> to !llvm.ptr<f32>
      %79 = llvm.insertvalue %78, %15[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %80 = llvm.extractvalue %22[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %81 = llvm.bitcast %80 : !llvm.ptr<f32> to !llvm.ptr<f32>
      %82 = llvm.insertvalue %81, %79[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %83 = llvm.extractvalue %22[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %84 = llvm.extractvalue %22[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %85 = llvm.extractvalue %22[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %86 = llvm.mul %66, %83  : i64
      %87 = llvm.add %85, %86  : i64
      %88 = llvm.mlir.constant(0 : i64) : i64
      %89 = llvm.mul %88, %84  : i64
      %90 = llvm.add %87, %89  : i64
      %91 = llvm.insertvalue %90, %82[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %92 = llvm.mlir.constant(784 : i64) : i64
      %93 = llvm.mlir.constant(1 : i64) : i64
      %94 = llvm.insertvalue %92, %91[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %95 = llvm.insertvalue %93, %94[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %96 = llvm.insertvalue %76, %95[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %97 = llvm.insertvalue %92, %96[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %98 = llvm.extractvalue %35[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %99 = llvm.bitcast %98 : !llvm.ptr<f32> to !llvm.ptr<f32>
      %100 = llvm.insertvalue %99, %15[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %101 = llvm.extractvalue %35[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %102 = llvm.bitcast %101 : !llvm.ptr<f32> to !llvm.ptr<f32>
      %103 = llvm.insertvalue %102, %100[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %104 = llvm.extractvalue %35[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %105 = llvm.extractvalue %35[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %106 = llvm.extractvalue %35[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %107 = llvm.mul %88, %104  : i64
      %108 = llvm.add %106, %107  : i64
      %109 = llvm.mul %70, %105  : i64
      %110 = llvm.add %108, %109  : i64
      %111 = llvm.insertvalue %110, %103[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %112 = llvm.mlir.constant(64 : i64) : i64
      %113 = llvm.insertvalue %112, %111[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %114 = llvm.insertvalue %93, %113[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %115 = llvm.mlir.constant(128 : i64) : i64
      %116 = llvm.insertvalue %92, %114[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %117 = llvm.insertvalue %115, %116[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %118 = llvm.extractvalue %49[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %119 = llvm.bitcast %118 : !llvm.ptr<f32> to !llvm.ptr<f32>
      %120 = llvm.insertvalue %119, %15[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %121 = llvm.extractvalue %49[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %122 = llvm.bitcast %121 : !llvm.ptr<f32> to !llvm.ptr<f32>
      %123 = llvm.insertvalue %122, %120[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %124 = llvm.extractvalue %49[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %125 = llvm.extractvalue %49[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %126 = llvm.extractvalue %49[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %127 = llvm.mul %66, %124  : i64
      %128 = llvm.add %126, %127  : i64
      %129 = llvm.mul %70, %125  : i64
      %130 = llvm.add %128, %129  : i64
      %131 = llvm.insertvalue %130, %123[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %132 = llvm.insertvalue %112, %131[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %133 = llvm.insertvalue %93, %132[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %134 = llvm.insertvalue %76, %133[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %135 = llvm.insertvalue %115, %134[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      llvm.br ^bb5(%7 : i64)
    ^bb5(%136: i64):  // 2 preds: ^bb4, ^bb8
      %137 = llvm.icmp "slt" %136, %76 : i64
      llvm.cond_br %137, ^bb6(%7 : i64), ^bb9(%7 : i64)
    ^bb6(%138: i64):  // 2 preds: ^bb5, ^bb7
      %139 = llvm.icmp "slt" %138, %5 : i64
      llvm.cond_br %139, ^bb7, ^bb8
    ^bb7:  // pred: ^bb6
      %140 = llvm.extractvalue %135[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %141 = llvm.extractvalue %135[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %142 = llvm.mul %136, %1  : i64
      %143 = llvm.add %141, %142  : i64
      %144 = llvm.add %143, %138  : i64
      %145 = llvm.getelementptr %140[%144] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
      llvm.store %0, %145 : !llvm.ptr<f32>
      %146 = llvm.add %138, %8  : i64
      llvm.br ^bb6(%146 : i64)
    ^bb8:  // pred: ^bb6
      %147 = llvm.add %136, %8  : i64
      llvm.br ^bb5(%147 : i64)
    ^bb9(%148: i64):  // 2 preds: ^bb5, ^bb28
      %149 = llvm.icmp "slt" %148, %76 : i64
      llvm.cond_br %149, ^bb10(%7 : i64), ^bb29
    ^bb10(%150: i64):  // 2 preds: ^bb9, ^bb27
      %151 = llvm.icmp "slt" %150, %5 : i64
      llvm.cond_br %151, ^bb11(%7 : i64), ^bb28
    ^bb11(%152: i64):  // 2 preds: ^bb10, ^bb26
      %153 = llvm.icmp "slt" %152, %2 : i64
      llvm.cond_br %153, ^bb12, ^bb27
    ^bb12:  // pred: ^bb11
      %154 = llvm.mul %148, %72  : i64
      %155 = llvm.add %76, %154  : i64
      %156 = llvm.icmp "slt" %6, %155 : i64
      %157 = llvm.select %156, %6, %155 : i1, i64
      %158 = llvm.extractvalue %97[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %159 = llvm.bitcast %158 : !llvm.ptr<f32> to !llvm.ptr<f32>
      %160 = llvm.insertvalue %159, %15[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %161 = llvm.extractvalue %97[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %162 = llvm.bitcast %161 : !llvm.ptr<f32> to !llvm.ptr<f32>
      %163 = llvm.insertvalue %162, %160[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %164 = llvm.extractvalue %97[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %165 = llvm.extractvalue %97[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %166 = llvm.extractvalue %97[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %167 = llvm.mul %148, %164  : i64
      %168 = llvm.add %166, %167  : i64
      %169 = llvm.mul %152, %165  : i64
      %170 = llvm.add %168, %169  : i64
      %171 = llvm.insertvalue %170, %163[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %172 = llvm.mlir.constant(28 : i64) : i64
      %173 = llvm.insertvalue %172, %171[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %174 = llvm.insertvalue %93, %173[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %175 = llvm.insertvalue %157, %174[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %176 = llvm.insertvalue %92, %175[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %177 = llvm.extractvalue %117[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %178 = llvm.bitcast %177 : !llvm.ptr<f32> to !llvm.ptr<f32>
      %179 = llvm.insertvalue %178, %15[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %180 = llvm.extractvalue %117[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %181 = llvm.bitcast %180 : !llvm.ptr<f32> to !llvm.ptr<f32>
      %182 = llvm.insertvalue %181, %179[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %183 = llvm.extractvalue %117[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %184 = llvm.extractvalue %117[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %185 = llvm.extractvalue %117[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %186 = llvm.mul %152, %183  : i64
      %187 = llvm.add %185, %186  : i64
      %188 = llvm.mul %150, %184  : i64
      %189 = llvm.add %187, %188  : i64
      %190 = llvm.insertvalue %189, %182[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %191 = llvm.mlir.constant(32 : i64) : i64
      %192 = llvm.insertvalue %191, %190[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %193 = llvm.insertvalue %93, %192[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %194 = llvm.insertvalue %172, %193[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %195 = llvm.insertvalue %115, %194[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %196 = llvm.extractvalue %135[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %197 = llvm.bitcast %196 : !llvm.ptr<f32> to !llvm.ptr<f32>
      %198 = llvm.insertvalue %197, %15[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %199 = llvm.extractvalue %135[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %200 = llvm.bitcast %199 : !llvm.ptr<f32> to !llvm.ptr<f32>
      %201 = llvm.insertvalue %200, %198[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %202 = llvm.extractvalue %135[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %203 = llvm.extractvalue %135[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %204 = llvm.extractvalue %135[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %205 = llvm.mul %148, %202  : i64
      %206 = llvm.add %204, %205  : i64
      %207 = llvm.mul %150, %203  : i64
      %208 = llvm.add %206, %207  : i64
      %209 = llvm.insertvalue %208, %201[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %210 = llvm.insertvalue %191, %209[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %211 = llvm.insertvalue %93, %210[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %212 = llvm.insertvalue %157, %211[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %213 = llvm.insertvalue %115, %212[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      llvm.br ^bb13(%7 : i64)
    ^bb13(%214: i64):  // 2 preds: ^bb12, ^bb25
      %215 = llvm.icmp "slt" %214, %157 : i64
      llvm.cond_br %215, ^bb14(%7 : i64), ^bb26
    ^bb14(%216: i64):  // 2 preds: ^bb13, ^bb24
      %217 = llvm.icmp "slt" %216, %4 : i64
      llvm.cond_br %217, ^bb15(%7 : i64), ^bb25
    ^bb15(%218: i64):  // 2 preds: ^bb14, ^bb23
      %219 = llvm.icmp "slt" %218, %3 : i64
      llvm.cond_br %219, ^bb16, ^bb24
    ^bb16:  // pred: ^bb15
      %220 = llvm.mul %214, %72  : i64
      %221 = llvm.add %157, %220  : i64
      %222 = llvm.icmp "slt" %6, %221 : i64
      %223 = llvm.select %222, %6, %221 : i1, i64
      %224 = llvm.extractvalue %176[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %225 = llvm.bitcast %224 : !llvm.ptr<f32> to !llvm.ptr<f32>
      %226 = llvm.insertvalue %225, %15[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %227 = llvm.extractvalue %176[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %228 = llvm.bitcast %227 : !llvm.ptr<f32> to !llvm.ptr<f32>
      %229 = llvm.insertvalue %228, %226[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %230 = llvm.extractvalue %176[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %231 = llvm.extractvalue %176[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %232 = llvm.extractvalue %176[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %233 = llvm.mul %214, %230  : i64
      %234 = llvm.add %232, %233  : i64
      %235 = llvm.mul %218, %231  : i64
      %236 = llvm.add %234, %235  : i64
      %237 = llvm.insertvalue %236, %229[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %238 = llvm.mlir.constant(4 : i64) : i64
      %239 = llvm.insertvalue %238, %237[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %240 = llvm.insertvalue %93, %239[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %241 = llvm.insertvalue %223, %240[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %242 = llvm.insertvalue %92, %241[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %243 = llvm.extractvalue %195[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %244 = llvm.bitcast %243 : !llvm.ptr<f32> to !llvm.ptr<f32>
      %245 = llvm.insertvalue %244, %15[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %246 = llvm.extractvalue %195[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %247 = llvm.bitcast %246 : !llvm.ptr<f32> to !llvm.ptr<f32>
      %248 = llvm.insertvalue %247, %245[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %249 = llvm.extractvalue %195[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %250 = llvm.extractvalue %195[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %251 = llvm.extractvalue %195[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %252 = llvm.mul %218, %249  : i64
      %253 = llvm.add %251, %252  : i64
      %254 = llvm.mul %216, %250  : i64
      %255 = llvm.add %253, %254  : i64
      %256 = llvm.insertvalue %255, %248[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %257 = llvm.insertvalue %238, %256[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %258 = llvm.insertvalue %93, %257[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %259 = llvm.insertvalue %238, %258[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %260 = llvm.insertvalue %115, %259[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %261 = llvm.extractvalue %213[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %262 = llvm.bitcast %261 : !llvm.ptr<f32> to !llvm.ptr<f32>
      %263 = llvm.insertvalue %262, %15[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %264 = llvm.extractvalue %213[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %265 = llvm.bitcast %264 : !llvm.ptr<f32> to !llvm.ptr<f32>
      %266 = llvm.insertvalue %265, %263[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %267 = llvm.extractvalue %213[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %268 = llvm.extractvalue %213[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %269 = llvm.extractvalue %213[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %270 = llvm.mul %214, %267  : i64
      %271 = llvm.add %269, %270  : i64
      %272 = llvm.mul %216, %268  : i64
      %273 = llvm.add %271, %272  : i64
      %274 = llvm.insertvalue %273, %266[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %275 = llvm.insertvalue %238, %274[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %276 = llvm.insertvalue %93, %275[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %277 = llvm.insertvalue %223, %276[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %278 = llvm.insertvalue %115, %277[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      llvm.br ^bb17(%7 : i64)
    ^bb17(%279: i64):  // 2 preds: ^bb16, ^bb22
      %280 = llvm.icmp "slt" %279, %223 : i64
      llvm.cond_br %280, ^bb18(%7 : i64), ^bb23
    ^bb18(%281: i64):  // 2 preds: ^bb17, ^bb21
      %282 = llvm.icmp "slt" %281, %6 : i64
      llvm.cond_br %282, ^bb19(%7 : i64), ^bb22
    ^bb19(%283: i64):  // 2 preds: ^bb18, ^bb20
      %284 = llvm.icmp "slt" %283, %6 : i64
      llvm.cond_br %284, ^bb20, ^bb21
    ^bb20:  // pred: ^bb19
      %285 = llvm.extractvalue %242[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %286 = llvm.extractvalue %242[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %287 = llvm.mul %279, %2  : i64
      %288 = llvm.add %286, %287  : i64
      %289 = llvm.add %288, %283  : i64
      %290 = llvm.getelementptr %285[%289] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
      %291 = llvm.load %290 : !llvm.ptr<f32>
      %292 = llvm.extractvalue %260[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %293 = llvm.extractvalue %260[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %294 = llvm.mul %283, %1  : i64
      %295 = llvm.add %293, %294  : i64
      %296 = llvm.add %295, %281  : i64
      %297 = llvm.getelementptr %292[%296] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
      %298 = llvm.load %297 : !llvm.ptr<f32>
      %299 = llvm.extractvalue %278[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %300 = llvm.extractvalue %278[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %301 = llvm.mul %279, %1  : i64
      %302 = llvm.add %300, %301  : i64
      %303 = llvm.add %302, %281  : i64
      %304 = llvm.getelementptr %299[%303] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
      %305 = llvm.load %304 : !llvm.ptr<f32>
      %306 = llvm.fmul %291, %298  : f32
      %307 = llvm.fadd %305, %306  : f32
      llvm.store %307, %304 : !llvm.ptr<f32>
      %308 = llvm.add %283, %8  : i64
      llvm.br ^bb19(%308 : i64)
    ^bb21:  // pred: ^bb19
      %309 = llvm.add %281, %8  : i64
      llvm.br ^bb18(%309 : i64)
    ^bb22:  // pred: ^bb18
      %310 = llvm.add %279, %8  : i64
      llvm.br ^bb17(%310 : i64)
    ^bb23:  // pred: ^bb17
      %311 = llvm.add %218, %6  : i64
      llvm.br ^bb15(%311 : i64)
    ^bb24:  // pred: ^bb15
      %312 = llvm.add %216, %6  : i64
      llvm.br ^bb14(%312 : i64)
    ^bb25:  // pred: ^bb14
      %313 = llvm.add %214, %6  : i64
      llvm.br ^bb13(%313 : i64)
    ^bb26:  // pred: ^bb13
      %314 = llvm.add %152, %3  : i64
      llvm.br ^bb11(%314 : i64)
    ^bb27:  // pred: ^bb11
      %315 = llvm.add %150, %4  : i64
      llvm.br ^bb10(%315 : i64)
    ^bb28:  // pred: ^bb10
      %316 = llvm.add %148, %6  : i64
      llvm.br ^bb9(%316 : i64)
    ^bb29:  // pred: ^bb9
      %317 = llvm.add %70, %69  : i64
      llvm.br ^bb3(%317 : i64)
    ^bb30:  // pred: ^bb3
      %318 = llvm.add %66, %65  : i64
      llvm.br ^bb1(%318 : i64)
    ^bb31:  // pred: ^bb1
      %319 = llvm.mlir.constant(0 : i32) : i32
      llvm.return %319 : i32
    }
  }
}

// *** IR Dump After mlir::iree_compiler::IREE::HAL::PropagateConstantWorkgroupInfoPass ***
hal.executable.target @llvm_aot, filter="dylib*" {
  hal.executable.entry_point @predict_dispatch_1 attributes {interface = @io, ordinal = 0 : index}
  module  {
    func @predict_dispatch_1() {
      %c0 = constant 0 : index
      %cst = constant 0x7FC00000 : f32
      %cst_0 = constant 0.000000e+00 : f32
      %c1 = constant 1 : index
      %c128 = constant 128 : index
      %0 = hal.interface.binding.subspan @io::@s0b1_ro_external[%c0] : !flow.dispatch.tensor<readonly:1x128xf32>
      %1 = hal.interface.binding.subspan @io::@s0b0_ro_constant[%c0] : !flow.dispatch.tensor<readonly:1x128xf32>
      %2 = hal.interface.binding.subspan @io::@s0b2_xw_external[%c0] : !flow.dispatch.tensor<writeonly:1x128xf32>
      %workgroup_size_x = hal.interface.workgroup.size[0] : index
      %workgroup_size_y = hal.interface.workgroup.size[1] : index
      %workgroup_id_x = hal.interface.workgroup.id[0] : index
      %workgroup_count_x = hal.interface.workgroup.count[0] : index
      %workgroup_id_y = hal.interface.workgroup.id[1] : index
      %workgroup_count_y = hal.interface.workgroup.count[1] : index
      %3 = affine.apply affine_map<()[s0, s1] -> (s0 * s1)>()[%workgroup_id_y, %workgroup_size_y]
      %4 = affine.apply affine_map<()[s0, s1] -> (s0 * s1)>()[%workgroup_count_y, %workgroup_size_y]
      scf.for %arg0 = %3 to %c1 step %4 {
        %5 = affine.apply affine_map<()[s0, s1] -> (s0 * s1)>()[%workgroup_id_x, %workgroup_size_x]
        %6 = affine.apply affine_map<()[s0, s1] -> (s0 * s1)>()[%workgroup_count_x, %workgroup_size_x]
        scf.for %arg1 = %5 to %c128 step %6 {
          %7 = affine.min affine_map<(d0)[s0] -> (s0, -d0 + 1)>(%arg0)[%workgroup_size_y]
          %8 = affine.min affine_map<(d0)[s0] -> (s0, -d0 + 128)>(%arg1)[%workgroup_size_x]
          %9 = flow.dispatch.tensor.load %0, offsets = [%arg0, %arg1], sizes = [%7, %8], strides = [1, 1] : !flow.dispatch.tensor<readonly:1x128xf32> -> tensor<?x?xf32>
          %10 = affine.min affine_map<(d0)[s0] -> (s0, -d0 + 1)>(%arg0)[%workgroup_size_y]
          %11 = affine.min affine_map<(d0)[s0] -> (s0, -d0 + 128)>(%arg1)[%workgroup_size_x]
          %12 = flow.dispatch.tensor.load %1, offsets = [%arg0, %arg1], sizes = [%10, %11], strides = [1, 1] : !flow.dispatch.tensor<readonly:1x128xf32> -> tensor<?x?xf32>
          %13 = affine.min affine_map<(d0)[s0] -> (s0, -d0 + 1)>(%arg0)[%workgroup_size_y]
          %14 = affine.min affine_map<(d0)[s0] -> (s0, -d0 + 128)>(%arg1)[%workgroup_size_x]
          %15 = linalg.init_tensor [%13, %14] : tensor<?x?xf32>
          %16 = linalg.generic {indexing_maps = [affine_map<(d0, d1) -> (d0, d1)>, affine_map<(d0, d1) -> (d0, d1)>, affine_map<(d0, d1) -> (d0, d1)>], iterator_types = ["parallel", "parallel"]} ins(%9, %12 : tensor<?x?xf32>, tensor<?x?xf32>) outs(%15 : tensor<?x?xf32>) attrs =  {__internal_linalg_transform__ = "workgroup"} {
          ^bb0(%arg2: f32, %arg3: f32, %arg4: f32):  // no predecessors
            %17 = addf %arg2, %arg3 : f32
            %18 = cmpf ogt, %17, %cst_0 : f32
            %19 = select %18, %17, %cst_0 : f32
            %20 = cmpf uno, %17, %cst_0 : f32
            %21 = select %20, %cst, %19 : f32
            linalg.yield %21 : f32
          } -> tensor<?x?xf32>
          flow.dispatch.tensor.store %16, %2, offsets = [%arg0, %arg1], sizes = [%13, %14], strides = [1, 1] : tensor<?x?xf32> -> !flow.dispatch.tensor<writeonly:1x128xf32>
        }
      }
      return
    }
    hal.interface @io attributes {sym_visibility = "private"} {
      hal.interface.binding @s0b0_ro_constant, set=0, binding=0, type="StorageBuffer", access="Read"
      hal.interface.binding @s0b1_ro_external, set=0, binding=1, type="StorageBuffer", access="Read"
      hal.interface.binding @s0b2_xw_external, set=0, binding=2, type="StorageBuffer", access="Write|Discard"
    }
  }
}

// *** IR Dump After mlir::iree_compiler::`anonymous-namespace'::SetNumWorkgroupsPass ***
hal.executable.target @llvm_aot, filter="dylib*" {
  hal.executable.entry_point @predict_dispatch_1 attributes {interface = @io, ordinal = 0 : index} {
  ^bb0(%arg0: index, %arg1: index, %arg2: index):  // no predecessors
    %c1 = constant 1 : index
    %0 = affine.apply affine_map<()[s0] -> (s0 ceildiv 128)>()[%arg0]
    %1 = affine.apply affine_map<()[s0] -> (s0 ceildiv 128)>()[%arg1]
    hal.return %0, %1, %c1 : index, index, index
  }
  module  {
    func @predict_dispatch_1() {
      %c0 = constant 0 : index
      %cst = constant 0x7FC00000 : f32
      %cst_0 = constant 0.000000e+00 : f32
      %c1 = constant 1 : index
      %c128 = constant 128 : index
      %0 = hal.interface.binding.subspan @io::@s0b1_ro_external[%c0] : !flow.dispatch.tensor<readonly:1x128xf32>
      %1 = hal.interface.binding.subspan @io::@s0b0_ro_constant[%c0] : !flow.dispatch.tensor<readonly:1x128xf32>
      %2 = hal.interface.binding.subspan @io::@s0b2_xw_external[%c0] : !flow.dispatch.tensor<writeonly:1x128xf32>
      %workgroup_id_x = hal.interface.workgroup.id[0] : index
      %workgroup_count_x = hal.interface.workgroup.count[0] : index
      %workgroup_id_y = hal.interface.workgroup.id[1] : index
      %workgroup_count_y = hal.interface.workgroup.count[1] : index
      %3 = affine.apply affine_map<()[s0, s1] -> (s0 * s1)>()[%workgroup_id_y, %c128]
      %4 = affine.apply affine_map<()[s0, s1] -> (s0 * s1)>()[%workgroup_count_y, %c128]
      scf.for %arg0 = %3 to %c1 step %4 {
        %5 = affine.apply affine_map<()[s0, s1] -> (s0 * s1)>()[%workgroup_id_x, %c128]
        %6 = affine.apply affine_map<()[s0, s1] -> (s0 * s1)>()[%workgroup_count_x, %c128]
        scf.for %arg1 = %5 to %c128 step %6 {
          %7 = affine.min affine_map<(d0) -> (128, -d0 + 1)>(%arg0)
          %8 = flow.dispatch.tensor.load %0, offsets = [%arg0, %arg1], sizes = [%7, 128], strides = [1, 1] : !flow.dispatch.tensor<readonly:1x128xf32> -> tensor<?x128xf32>
          %9 = tensor.cast %8 : tensor<?x128xf32> to tensor<?x?xf32>
          %10 = affine.min affine_map<(d0) -> (128, -d0 + 1)>(%arg0)
          %11 = flow.dispatch.tensor.load %1, offsets = [%arg0, %arg1], sizes = [%10, 128], strides = [1, 1] : !flow.dispatch.tensor<readonly:1x128xf32> -> tensor<?x128xf32>
          %12 = tensor.cast %11 : tensor<?x128xf32> to tensor<?x?xf32>
          %13 = affine.min affine_map<(d0) -> (128, -d0 + 1)>(%arg0)
          %14 = linalg.init_tensor [%13, %c128] : tensor<?x?xf32>
          %15 = linalg.generic {indexing_maps = [affine_map<(d0, d1) -> (d0, d1)>, affine_map<(d0, d1) -> (d0, d1)>, affine_map<(d0, d1) -> (d0, d1)>], iterator_types = ["parallel", "parallel"]} ins(%9, %12 : tensor<?x?xf32>, tensor<?x?xf32>) outs(%14 : tensor<?x?xf32>) attrs =  {__internal_linalg_transform__ = "workgroup", lowering.config = {tileSizes = [[128, 128]]}} {
          ^bb0(%arg2: f32, %arg3: f32, %arg4: f32):  // no predecessors
            %16 = addf %arg2, %arg3 : f32
            %17 = cmpf ogt, %16, %cst_0 : f32
            %18 = select %17, %16, %cst_0 : f32
            %19 = cmpf uno, %16, %cst_0 : f32
            %20 = select %19, %cst, %18 : f32
            linalg.yield %20 : f32
          } -> tensor<?x?xf32>
          flow.dispatch.tensor.store %15, %2, offsets = [%arg0, %arg1], sizes = [%13, %c128], strides = [1, 1] : tensor<?x?xf32> -> !flow.dispatch.tensor<writeonly:1x128xf32>
        }
      }
      return
    }
    hal.interface @io attributes {sym_visibility = "private"} {
      hal.interface.binding @s0b0_ro_constant, set=0, binding=0, type="StorageBuffer", access="Read"
      hal.interface.binding @s0b1_ro_external, set=0, binding=1, type="StorageBuffer", access="Read"
      hal.interface.binding @s0b2_xw_external, set=0, binding=2, type="StorageBuffer", access="Write|Discard"
    }
  }
}

// *** IR Dump After Canonicalizer ***
module  {
  func @predict_dispatch_1() {
    %c0 = constant 0 : index
    %cst = constant 0x7FC00000 : f32
    %cst_0 = constant 0.000000e+00 : f32
    %c1 = constant 1 : index
    %c128 = constant 128 : index
    %0 = hal.interface.binding.subspan @io::@s0b1_ro_external[%c0] : !flow.dispatch.tensor<readonly:1x128xf32>
    %1 = hal.interface.binding.subspan @io::@s0b0_ro_constant[%c0] : !flow.dispatch.tensor<readonly:1x128xf32>
    %2 = hal.interface.binding.subspan @io::@s0b2_xw_external[%c0] : !flow.dispatch.tensor<writeonly:1x128xf32>
    %workgroup_id_x = hal.interface.workgroup.id[0] : index
    %workgroup_count_x = hal.interface.workgroup.count[0] : index
    %workgroup_id_y = hal.interface.workgroup.id[1] : index
    %workgroup_count_y = hal.interface.workgroup.count[1] : index
    %3 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_y]
    %4 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_y]
    scf.for %arg0 = %3 to %c1 step %4 {
      %5 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
      %6 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
      scf.for %arg1 = %5 to %c128 step %6 {
        %7 = affine.min affine_map<(d0) -> (128, -d0 + 1)>(%arg0)
        %8 = flow.dispatch.tensor.load %0, offsets = [%arg0, %arg1], sizes = [%7, 128], strides = [1, 1] : !flow.dispatch.tensor<readonly:1x128xf32> -> tensor<?x128xf32>
        %9 = affine.min affine_map<(d0) -> (128, -d0 + 1)>(%arg0)
        %10 = flow.dispatch.tensor.load %1, offsets = [%arg0, %arg1], sizes = [%9, 128], strides = [1, 1] : !flow.dispatch.tensor<readonly:1x128xf32> -> tensor<?x128xf32>
        %11 = affine.min affine_map<(d0) -> (128, -d0 + 1)>(%arg0)
        %12 = linalg.init_tensor [%11, 128] : tensor<?x128xf32>
        %13 = linalg.generic {indexing_maps = [affine_map<(d0, d1) -> (d0, d1)>, affine_map<(d0, d1) -> (d0, d1)>, affine_map<(d0, d1) -> (d0, d1)>], iterator_types = ["parallel", "parallel"]} ins(%8, %10 : tensor<?x128xf32>, tensor<?x128xf32>) outs(%12 : tensor<?x128xf32>) attrs =  {__internal_linalg_transform__ = "workgroup", lowering.config = {tileSizes = [[128, 128]]}} {
        ^bb0(%arg2: f32, %arg3: f32, %arg4: f32):  // no predecessors
          %14 = addf %arg2, %arg3 : f32
          %15 = cmpf ogt, %14, %cst_0 : f32
          %16 = select %15, %14, %cst_0 : f32
          %17 = cmpf uno, %14, %cst_0 : f32
          %18 = select %17, %cst, %16 : f32
          linalg.yield %18 : f32
        } -> tensor<?x128xf32>
        flow.dispatch.tensor.store %13, %2, offsets = [%arg0, %arg1], sizes = [%11, %c128], strides = [1, 1] : tensor<?x128xf32> -> !flow.dispatch.tensor<writeonly:1x128xf32>
      }
    }
    return
  }
  hal.interface @io attributes {sym_visibility = "private"} {
    hal.interface.binding @s0b0_ro_constant, set=0, binding=0, type="StorageBuffer", access="Read"
    hal.interface.binding @s0b1_ro_external, set=0, binding=1, type="StorageBuffer", access="Read"
    hal.interface.binding @s0b2_xw_external, set=0, binding=2, type="StorageBuffer", access="Write|Discard"
  }
}

// *** IR Dump After mlir::iree_compiler::`anonymous-namespace'::LinalgBufferizePass ***
func @predict_dispatch_1() {
  %c0 = constant 0 : index
  %cst = constant 0x7FC00000 : f32
  %cst_0 = constant 0.000000e+00 : f32
  %c1 = constant 1 : index
  %c128 = constant 128 : index
  %0 = hal.interface.binding.subspan @io::@s0b1_ro_external[%c0] : memref<1x128xf32>
  %1 = hal.interface.binding.subspan @io::@s0b1_ro_external[%c0] : !flow.dispatch.tensor<readonly:1x128xf32>
  %2 = hal.interface.binding.subspan @io::@s0b0_ro_constant[%c0] : memref<1x128xf32>
  %3 = hal.interface.binding.subspan @io::@s0b0_ro_constant[%c0] : !flow.dispatch.tensor<readonly:1x128xf32>
  %4 = hal.interface.binding.subspan @io::@s0b2_xw_external[%c0] : memref<1x128xf32>
  %5 = hal.interface.binding.subspan @io::@s0b2_xw_external[%c0] : !flow.dispatch.tensor<writeonly:1x128xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %6 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_y]
  %7 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_y]
  scf.for %arg0 = %6 to %c1 step %7 {
    %8 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
    %9 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
    scf.for %arg1 = %8 to %c128 step %9 {
      %10 = affine.min affine_map<(d0) -> (128, -d0 + 1)>(%arg0)
      %11 = memref.subview %0[%arg0, %arg1] [%10, 128] [1, 1] : memref<1x128xf32> to memref<?x128xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
      %12 = flow.dispatch.tensor.load %1, offsets = [%arg0, %arg1], sizes = [%10, 128], strides = [1, 1] : !flow.dispatch.tensor<readonly:1x128xf32> -> tensor<?x128xf32>
      %13 = affine.min affine_map<(d0) -> (128, -d0 + 1)>(%arg0)
      %14 = memref.subview %2[%arg0, %arg1] [%13, 128] [1, 1] : memref<1x128xf32> to memref<?x128xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
      %15 = flow.dispatch.tensor.load %3, offsets = [%arg0, %arg1], sizes = [%13, 128], strides = [1, 1] : !flow.dispatch.tensor<readonly:1x128xf32> -> tensor<?x128xf32>
      %16 = affine.min affine_map<(d0) -> (128, -d0 + 1)>(%arg0)
      %17 = linalg.init_tensor [%16, 128] : tensor<?x128xf32>
      %18 = memref.subview %4[%arg0, %arg1] [%16, %c128] [1, 1] : memref<1x128xf32> to memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
      linalg.generic {indexing_maps = [affine_map<(d0, d1) -> (d0, d1)>, affine_map<(d0, d1) -> (d0, d1)>, affine_map<(d0, d1) -> (d0, d1)>], iterator_types = ["parallel", "parallel"]} ins(%11, %14 : memref<?x128xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>, memref<?x128xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>) outs(%18 : memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>) attrs =  {__internal_linalg_transform__ = "workgroup", lowering.config = {tileSizes = [[128, 128]]}} {
      ^bb0(%arg2: f32, %arg3: f32, %arg4: f32):  // no predecessors
        %20 = addf %arg2, %arg3 : f32
        %21 = cmpf ogt, %20, %cst_0 : f32
        %22 = select %21, %20, %cst_0 : f32
        %23 = cmpf uno, %20, %cst_0 : f32
        %24 = select %23, %cst, %22 : f32
        linalg.yield %24 : f32
      }
      %19 = linalg.generic {indexing_maps = [affine_map<(d0, d1) -> (d0, d1)>, affine_map<(d0, d1) -> (d0, d1)>, affine_map<(d0, d1) -> (d0, d1)>], iterator_types = ["parallel", "parallel"]} ins(%12, %15 : tensor<?x128xf32>, tensor<?x128xf32>) outs(%17 : tensor<?x128xf32>) attrs =  {__internal_linalg_transform__ = "workgroup", lowering.config = {tileSizes = [[128, 128]]}} {
      ^bb0(%arg2: f32, %arg3: f32, %arg4: f32):  // no predecessors
        %20 = addf %arg2, %arg3 : f32
        %21 = cmpf ogt, %20, %cst_0 : f32
        %22 = select %21, %20, %cst_0 : f32
        %23 = cmpf uno, %20, %cst_0 : f32
        %24 = select %23, %cst, %22 : f32
        linalg.yield %24 : f32
      } -> tensor<?x128xf32>
    }
  }
  return
}

// *** IR Dump After Canonicalizer ***
func @predict_dispatch_1() {
  %c0 = constant 0 : index
  %cst = constant 0x7FC00000 : f32
  %cst_0 = constant 0.000000e+00 : f32
  %c1 = constant 1 : index
  %c128 = constant 128 : index
  %0 = hal.interface.binding.subspan @io::@s0b1_ro_external[%c0] : memref<1x128xf32>
  %1 = hal.interface.binding.subspan @io::@s0b1_ro_external[%c0] : !flow.dispatch.tensor<readonly:1x128xf32>
  %2 = hal.interface.binding.subspan @io::@s0b0_ro_constant[%c0] : memref<1x128xf32>
  %3 = hal.interface.binding.subspan @io::@s0b0_ro_constant[%c0] : !flow.dispatch.tensor<readonly:1x128xf32>
  %4 = hal.interface.binding.subspan @io::@s0b2_xw_external[%c0] : memref<1x128xf32>
  %5 = hal.interface.binding.subspan @io::@s0b2_xw_external[%c0] : !flow.dispatch.tensor<writeonly:1x128xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %6 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_y]
  %7 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_y]
  scf.for %arg0 = %6 to %c1 step %7 {
    %8 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
    %9 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
    scf.for %arg1 = %8 to %c128 step %9 {
      %10 = affine.min affine_map<(d0) -> (128, -d0 + 1)>(%arg0)
      %11 = memref.subview %0[%arg0, %arg1] [%10, 128] [1, 1] : memref<1x128xf32> to memref<?x128xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
      %12 = affine.min affine_map<(d0) -> (128, -d0 + 1)>(%arg0)
      %13 = memref.subview %2[%arg0, %arg1] [%12, 128] [1, 1] : memref<1x128xf32> to memref<?x128xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
      %14 = affine.min affine_map<(d0) -> (128, -d0 + 1)>(%arg0)
      %15 = memref.subview %4[%arg0, %arg1] [%14, 128] [1, 1] : memref<1x128xf32> to memref<?x128xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
      linalg.generic {indexing_maps = [affine_map<(d0, d1) -> (d0, d1)>, affine_map<(d0, d1) -> (d0, d1)>, affine_map<(d0, d1) -> (d0, d1)>], iterator_types = ["parallel", "parallel"]} ins(%11, %13 : memref<?x128xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>, memref<?x128xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>) outs(%15 : memref<?x128xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>) attrs =  {__internal_linalg_transform__ = "workgroup", lowering.config = {tileSizes = [[128, 128]]}} {
      ^bb0(%arg2: f32, %arg3: f32, %arg4: f32):  // no predecessors
        %16 = addf %arg2, %arg3 : f32
        %17 = cmpf ogt, %16, %cst_0 : f32
        %18 = select %17, %16, %cst_0 : f32
        %19 = cmpf uno, %16, %cst_0 : f32
        %20 = select %19, %cst, %18 : f32
        linalg.yield %20 : f32
      }
    }
  }
  return
}

// *** IR Dump After CSE ***
func @predict_dispatch_1() {
  %c0 = constant 0 : index
  %cst = constant 0x7FC00000 : f32
  %cst_0 = constant 0.000000e+00 : f32
  %c1 = constant 1 : index
  %c128 = constant 128 : index
  %0 = hal.interface.binding.subspan @io::@s0b1_ro_external[%c0] : memref<1x128xf32>
  %1 = hal.interface.binding.subspan @io::@s0b1_ro_external[%c0] : !flow.dispatch.tensor<readonly:1x128xf32>
  %2 = hal.interface.binding.subspan @io::@s0b0_ro_constant[%c0] : memref<1x128xf32>
  %3 = hal.interface.binding.subspan @io::@s0b0_ro_constant[%c0] : !flow.dispatch.tensor<readonly:1x128xf32>
  %4 = hal.interface.binding.subspan @io::@s0b2_xw_external[%c0] : memref<1x128xf32>
  %5 = hal.interface.binding.subspan @io::@s0b2_xw_external[%c0] : !flow.dispatch.tensor<writeonly:1x128xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %6 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_y]
  %7 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_y]
  scf.for %arg0 = %6 to %c1 step %7 {
    %8 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
    %9 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
    scf.for %arg1 = %8 to %c128 step %9 {
      %10 = affine.min affine_map<(d0) -> (128, -d0 + 1)>(%arg0)
      %11 = memref.subview %0[%arg0, %arg1] [%10, 128] [1, 1] : memref<1x128xf32> to memref<?x128xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
      %12 = memref.subview %2[%arg0, %arg1] [%10, 128] [1, 1] : memref<1x128xf32> to memref<?x128xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
      %13 = memref.subview %4[%arg0, %arg1] [%10, 128] [1, 1] : memref<1x128xf32> to memref<?x128xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
      linalg.generic {indexing_maps = [affine_map<(d0, d1) -> (d0, d1)>, affine_map<(d0, d1) -> (d0, d1)>, affine_map<(d0, d1) -> (d0, d1)>], iterator_types = ["parallel", "parallel"]} ins(%11, %12 : memref<?x128xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>, memref<?x128xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>) outs(%13 : memref<?x128xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>) attrs =  {__internal_linalg_transform__ = "workgroup", lowering.config = {tileSizes = [[128, 128]]}} {
      ^bb0(%arg2: f32, %arg3: f32, %arg4: f32):  // no predecessors
        %14 = addf %arg2, %arg3 : f32
        %15 = cmpf ogt, %14, %cst_0 : f32
        %16 = select %15, %14, %cst_0 : f32
        %17 = cmpf uno, %14, %cst_0 : f32
        %18 = select %17, %cst, %16 : f32
        linalg.yield %18 : f32
      }
    }
  }
  return
}

// *** IR Dump After mlir::iree_compiler::`anonymous-namespace'::BufferAllocViewCleanUpPass ***
func @predict_dispatch_1() {
  %c0 = constant 0 : index
  %cst = constant 0x7FC00000 : f32
  %cst_0 = constant 0.000000e+00 : f32
  %c1 = constant 1 : index
  %c128 = constant 128 : index
  %0 = hal.interface.binding.subspan @io::@s0b1_ro_external[%c0] : memref<1x128xf32>
  %1 = hal.interface.binding.subspan @io::@s0b0_ro_constant[%c0] : memref<1x128xf32>
  %2 = hal.interface.binding.subspan @io::@s0b2_xw_external[%c0] : memref<1x128xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_y]
  scf.for %arg0 = %3 to %c1 step %4 {
    %5 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
    %6 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
    scf.for %arg1 = %5 to %c128 step %6 {
      %7 = affine.min affine_map<(d0) -> (128, -d0 + 1)>(%arg0)
      %8 = memref.subview %0[%arg0, %arg1] [%7, 128] [1, 1] : memref<1x128xf32> to memref<?x128xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
      %9 = memref.subview %1[%arg0, %arg1] [%7, 128] [1, 1] : memref<1x128xf32> to memref<?x128xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
      %10 = memref.subview %2[%arg0, %arg1] [%7, 128] [1, 1] : memref<1x128xf32> to memref<?x128xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
      linalg.generic {indexing_maps = [affine_map<(d0, d1) -> (d0, d1)>, affine_map<(d0, d1) -> (d0, d1)>, affine_map<(d0, d1) -> (d0, d1)>], iterator_types = ["parallel", "parallel"]} ins(%8, %9 : memref<?x128xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>, memref<?x128xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>) outs(%10 : memref<?x128xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>) attrs =  {__internal_linalg_transform__ = "workgroup", lowering.config = {tileSizes = [[128, 128]]}} {
      ^bb0(%arg2: f32, %arg3: f32, %arg4: f32):  // no predecessors
        %11 = addf %arg2, %arg3 : f32
        %12 = cmpf ogt, %11, %cst_0 : f32
        %13 = select %12, %11, %cst_0 : f32
        %14 = cmpf uno, %11, %cst_0 : f32
        %15 = select %14, %cst, %13 : f32
        linalg.yield %15 : f32
      }
    }
  }
  return
}

// *** IR Dump After Canonicalizer ***
func @predict_dispatch_1() {
  %c0 = constant 0 : index
  %cst = constant 0x7FC00000 : f32
  %cst_0 = constant 0.000000e+00 : f32
  %c1 = constant 1 : index
  %c128 = constant 128 : index
  %0 = hal.interface.binding.subspan @io::@s0b1_ro_external[%c0] : memref<1x128xf32>
  %1 = hal.interface.binding.subspan @io::@s0b0_ro_constant[%c0] : memref<1x128xf32>
  %2 = hal.interface.binding.subspan @io::@s0b2_xw_external[%c0] : memref<1x128xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_y]
  scf.for %arg0 = %3 to %c1 step %4 {
    %5 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
    %6 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
    scf.for %arg1 = %5 to %c128 step %6 {
      %7 = affine.min affine_map<(d0) -> (128, -d0 + 1)>(%arg0)
      %8 = memref.subview %0[%arg0, %arg1] [%7, 128] [1, 1] : memref<1x128xf32> to memref<?x128xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
      %9 = memref.subview %1[%arg0, %arg1] [%7, 128] [1, 1] : memref<1x128xf32> to memref<?x128xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
      %10 = memref.subview %2[%arg0, %arg1] [%7, 128] [1, 1] : memref<1x128xf32> to memref<?x128xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
      linalg.generic {indexing_maps = [affine_map<(d0, d1) -> (d0, d1)>, affine_map<(d0, d1) -> (d0, d1)>, affine_map<(d0, d1) -> (d0, d1)>], iterator_types = ["parallel", "parallel"]} ins(%8, %9 : memref<?x128xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>, memref<?x128xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>) outs(%10 : memref<?x128xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>) attrs =  {__internal_linalg_transform__ = "workgroup", lowering.config = {tileSizes = [[128, 128]]}} {
      ^bb0(%arg2: f32, %arg3: f32, %arg4: f32):  // no predecessors
        %11 = addf %arg2, %arg3 : f32
        %12 = cmpf ogt, %11, %cst_0 : f32
        %13 = select %12, %11, %cst_0 : f32
        %14 = cmpf uno, %11, %cst_0 : f32
        %15 = select %14, %cst, %13 : f32
        linalg.yield %15 : f32
      }
    }
  }
  return
}

// *** IR Dump After mlir::iree_compiler::`anonymous-namespace'::TileAndVectorizeWorkgroups ***
func @predict_dispatch_1() {
  %c0 = constant 0 : index
  %cst = constant 0x7FC00000 : f32
  %cst_0 = constant 0.000000e+00 : f32
  %c1 = constant 1 : index
  %c128 = constant 128 : index
  %0 = hal.interface.binding.subspan @io::@s0b1_ro_external[%c0] : memref<1x128xf32>
  %1 = hal.interface.binding.subspan @io::@s0b0_ro_constant[%c0] : memref<1x128xf32>
  %2 = hal.interface.binding.subspan @io::@s0b2_xw_external[%c0] : memref<1x128xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_y]
  scf.for %arg0 = %3 to %c1 step %4 {
    %5 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
    %6 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
    scf.for %arg1 = %5 to %c128 step %6 {
      %7 = affine.min affine_map<(d0) -> (128, -d0 + 1)>(%arg0)
      %8 = memref.subview %0[%arg0, %arg1] [%7, 128] [1, 1] : memref<1x128xf32> to memref<?x128xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
      %9 = memref.subview %1[%arg0, %arg1] [%7, 128] [1, 1] : memref<1x128xf32> to memref<?x128xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
      %10 = memref.subview %2[%arg0, %arg1] [%7, 128] [1, 1] : memref<1x128xf32> to memref<?x128xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
      linalg.generic {indexing_maps = [affine_map<(d0, d1) -> (d0, d1)>, affine_map<(d0, d1) -> (d0, d1)>, affine_map<(d0, d1) -> (d0, d1)>], iterator_types = ["parallel", "parallel"]} ins(%8, %9 : memref<?x128xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>, memref<?x128xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>) outs(%10 : memref<?x128xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>) attrs =  {__internal_linalg_transform__ = "workgroup", lowering.config = {tileSizes = [[128, 128]]}} {
      ^bb0(%arg2: f32, %arg3: f32, %arg4: f32):  // no predecessors
        %11 = addf %arg2, %arg3 : f32
        %12 = cmpf ogt, %11, %cst_0 : f32
        %13 = select %12, %11, %cst_0 : f32
        %14 = cmpf uno, %11, %cst_0 : f32
        %15 = select %14, %cst, %13 : f32
        linalg.yield %15 : f32
      }
    }
  }
  return
}

// *** IR Dump After Canonicalizer ***
func @predict_dispatch_1() {
  %c0 = constant 0 : index
  %cst = constant 0x7FC00000 : f32
  %cst_0 = constant 0.000000e+00 : f32
  %c1 = constant 1 : index
  %c128 = constant 128 : index
  %0 = hal.interface.binding.subspan @io::@s0b1_ro_external[%c0] : memref<1x128xf32>
  %1 = hal.interface.binding.subspan @io::@s0b0_ro_constant[%c0] : memref<1x128xf32>
  %2 = hal.interface.binding.subspan @io::@s0b2_xw_external[%c0] : memref<1x128xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_y]
  scf.for %arg0 = %3 to %c1 step %4 {
    %5 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
    %6 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
    scf.for %arg1 = %5 to %c128 step %6 {
      %7 = affine.min affine_map<(d0) -> (128, -d0 + 1)>(%arg0)
      %8 = memref.subview %0[%arg0, %arg1] [%7, 128] [1, 1] : memref<1x128xf32> to memref<?x128xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
      %9 = memref.subview %1[%arg0, %arg1] [%7, 128] [1, 1] : memref<1x128xf32> to memref<?x128xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
      %10 = memref.subview %2[%arg0, %arg1] [%7, 128] [1, 1] : memref<1x128xf32> to memref<?x128xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
      linalg.generic {indexing_maps = [affine_map<(d0, d1) -> (d0, d1)>, affine_map<(d0, d1) -> (d0, d1)>, affine_map<(d0, d1) -> (d0, d1)>], iterator_types = ["parallel", "parallel"]} ins(%8, %9 : memref<?x128xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>, memref<?x128xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>) outs(%10 : memref<?x128xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>) attrs =  {__internal_linalg_transform__ = "workgroup", lowering.config = {tileSizes = [[128, 128]]}} {
      ^bb0(%arg2: f32, %arg3: f32, %arg4: f32):  // no predecessors
        %11 = addf %arg2, %arg3 : f32
        %12 = cmpf ogt, %11, %cst_0 : f32
        %13 = select %12, %11, %cst_0 : f32
        %14 = cmpf uno, %11, %cst_0 : f32
        %15 = select %14, %cst, %13 : f32
        linalg.yield %15 : f32
      }
    }
  }
  return
}

// *** IR Dump After mlir::iree_compiler::`anonymous-namespace'::ForOpCanonicalizationPass ***
func @predict_dispatch_1() {
  %c0 = constant 0 : index
  %cst = constant 0x7FC00000 : f32
  %cst_0 = constant 0.000000e+00 : f32
  %c1 = constant 1 : index
  %c128 = constant 128 : index
  %0 = hal.interface.binding.subspan @io::@s0b1_ro_external[%c0] : memref<1x128xf32>
  %1 = hal.interface.binding.subspan @io::@s0b0_ro_constant[%c0] : memref<1x128xf32>
  %2 = hal.interface.binding.subspan @io::@s0b2_xw_external[%c0] : memref<1x128xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_y]
  scf.for %arg0 = %3 to %c1 step %4 {
    %5 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
    %6 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
    scf.for %arg1 = %5 to %c128 step %6 {
      %7 = affine.min affine_map<(d0) -> (128, -d0 + 1)>(%arg0)
      %8 = memref.subview %0[%arg0, %arg1] [%7, 128] [1, 1] : memref<1x128xf32> to memref<?x128xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
      %9 = memref.subview %1[%arg0, %arg1] [%7, 128] [1, 1] : memref<1x128xf32> to memref<?x128xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
      %10 = memref.subview %2[%arg0, %arg1] [%7, 128] [1, 1] : memref<1x128xf32> to memref<?x128xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
      linalg.generic {indexing_maps = [affine_map<(d0, d1) -> (d0, d1)>, affine_map<(d0, d1) -> (d0, d1)>, affine_map<(d0, d1) -> (d0, d1)>], iterator_types = ["parallel", "parallel"]} ins(%8, %9 : memref<?x128xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>, memref<?x128xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>) outs(%10 : memref<?x128xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>) attrs =  {__internal_linalg_transform__ = "workgroup", lowering.config = {tileSizes = [[128, 128]]}} {
      ^bb0(%arg2: f32, %arg3: f32, %arg4: f32):  // no predecessors
        %11 = addf %arg2, %arg3 : f32
        %12 = cmpf ogt, %11, %cst_0 : f32
        %13 = select %12, %11, %cst_0 : f32
        %14 = cmpf uno, %11, %cst_0 : f32
        %15 = select %14, %cst, %13 : f32
        linalg.yield %15 : f32
      }
    }
  }
  return
}

// *** IR Dump After mlir::iree_compiler::`anonymous-namespace'::PlanConvLoopOrderPass ***
func @predict_dispatch_1() {
  %c0 = constant 0 : index
  %cst = constant 0x7FC00000 : f32
  %cst_0 = constant 0.000000e+00 : f32
  %c1 = constant 1 : index
  %c128 = constant 128 : index
  %0 = hal.interface.binding.subspan @io::@s0b1_ro_external[%c0] : memref<1x128xf32>
  %1 = hal.interface.binding.subspan @io::@s0b0_ro_constant[%c0] : memref<1x128xf32>
  %2 = hal.interface.binding.subspan @io::@s0b2_xw_external[%c0] : memref<1x128xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_y]
  scf.for %arg0 = %3 to %c1 step %4 {
    %5 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
    %6 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
    scf.for %arg1 = %5 to %c128 step %6 {
      %7 = affine.min affine_map<(d0) -> (128, -d0 + 1)>(%arg0)
      %8 = memref.subview %0[%arg0, %arg1] [%7, 128] [1, 1] : memref<1x128xf32> to memref<?x128xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
      %9 = memref.subview %1[%arg0, %arg1] [%7, 128] [1, 1] : memref<1x128xf32> to memref<?x128xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
      %10 = memref.subview %2[%arg0, %arg1] [%7, 128] [1, 1] : memref<1x128xf32> to memref<?x128xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
      linalg.generic {indexing_maps = [affine_map<(d0, d1) -> (d0, d1)>, affine_map<(d0, d1) -> (d0, d1)>, affine_map<(d0, d1) -> (d0, d1)>], iterator_types = ["parallel", "parallel"]} ins(%8, %9 : memref<?x128xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>, memref<?x128xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>) outs(%10 : memref<?x128xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>) attrs =  {__internal_linalg_transform__ = "workgroup", lowering.config = {tileSizes = [[128, 128]]}} {
      ^bb0(%arg2: f32, %arg3: f32, %arg4: f32):  // no predecessors
        %11 = addf %arg2, %arg3 : f32
        %12 = cmpf ogt, %11, %cst_0 : f32
        %13 = select %12, %11, %cst_0 : f32
        %14 = cmpf uno, %11, %cst_0 : f32
        %15 = select %14, %cst, %13 : f32
        linalg.yield %15 : f32
      }
    }
  }
  return
}

// *** IR Dump After LinalgLowerToLoops ***
func @predict_dispatch_1() {
  %cst = constant 0x7FC00000 : f32
  %cst_0 = constant 0.000000e+00 : f32
  %c128 = constant 128 : index
  %c0 = constant 0 : index
  %c1 = constant 1 : index
  %0 = hal.interface.binding.subspan @io::@s0b1_ro_external[%c0] : memref<1x128xf32>
  %1 = hal.interface.binding.subspan @io::@s0b0_ro_constant[%c0] : memref<1x128xf32>
  %2 = hal.interface.binding.subspan @io::@s0b2_xw_external[%c0] : memref<1x128xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_y]
  scf.for %arg0 = %3 to %c1 step %4 {
    %5 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
    %6 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
    scf.for %arg1 = %5 to %c128 step %6 {
      %7 = affine.min affine_map<(d0) -> (128, -d0 + 1)>(%arg0)
      %8 = memref.subview %0[%arg0, %arg1] [%7, 128] [1, 1] : memref<1x128xf32> to memref<?x128xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
      %9 = memref.subview %1[%arg0, %arg1] [%7, 128] [1, 1] : memref<1x128xf32> to memref<?x128xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
      %10 = memref.subview %2[%arg0, %arg1] [%7, 128] [1, 1] : memref<1x128xf32> to memref<?x128xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
      scf.for %arg2 = %c0 to %7 step %c1 {
        scf.for %arg3 = %c0 to %c128 step %c1 {
          %11 = memref.load %8[%arg2, %arg3] : memref<?x128xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
          %12 = memref.load %9[%arg2, %arg3] : memref<?x128xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
          %13 = addf %11, %12 : f32
          %14 = cmpf ogt, %13, %cst_0 : f32
          %15 = select %14, %13, %cst_0 : f32
          %16 = cmpf uno, %13, %cst_0 : f32
          %17 = select %16, %cst, %15 : f32
          memref.store %17, %10[%arg2, %arg3] : memref<?x128xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
        }
      }
    }
  }
  return
}

// *** IR Dump After Canonicalizer ***
func @predict_dispatch_1() {
  %cst = constant 0x7FC00000 : f32
  %cst_0 = constant 0.000000e+00 : f32
  %c128 = constant 128 : index
  %c0 = constant 0 : index
  %c1 = constant 1 : index
  %0 = hal.interface.binding.subspan @io::@s0b1_ro_external[%c0] : memref<1x128xf32>
  %1 = hal.interface.binding.subspan @io::@s0b0_ro_constant[%c0] : memref<1x128xf32>
  %2 = hal.interface.binding.subspan @io::@s0b2_xw_external[%c0] : memref<1x128xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_y]
  scf.for %arg0 = %3 to %c1 step %4 {
    %5 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
    %6 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
    scf.for %arg1 = %5 to %c128 step %6 {
      %7 = affine.min affine_map<(d0) -> (128, -d0 + 1)>(%arg0)
      %8 = memref.subview %0[%arg0, %arg1] [%7, 128] [1, 1] : memref<1x128xf32> to memref<?x128xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
      %9 = memref.subview %1[%arg0, %arg1] [%7, 128] [1, 1] : memref<1x128xf32> to memref<?x128xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
      %10 = memref.subview %2[%arg0, %arg1] [%7, 128] [1, 1] : memref<1x128xf32> to memref<?x128xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
      scf.for %arg2 = %c0 to %7 step %c1 {
        scf.for %arg3 = %c0 to %c128 step %c1 {
          %11 = memref.load %8[%arg2, %arg3] : memref<?x128xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
          %12 = memref.load %9[%arg2, %arg3] : memref<?x128xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
          %13 = addf %11, %12 : f32
          %14 = cmpf ogt, %13, %cst_0 : f32
          %15 = select %14, %13, %cst_0 : f32
          %16 = cmpf uno, %13, %cst_0 : f32
          %17 = select %16, %cst, %15 : f32
          memref.store %17, %10[%arg2, %arg3] : memref<?x128xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
        }
      }
    }
  }
  return
}

// *** IR Dump After CSE ***
func @predict_dispatch_1() {
  %cst = constant 0x7FC00000 : f32
  %cst_0 = constant 0.000000e+00 : f32
  %c128 = constant 128 : index
  %c0 = constant 0 : index
  %c1 = constant 1 : index
  %0 = hal.interface.binding.subspan @io::@s0b1_ro_external[%c0] : memref<1x128xf32>
  %1 = hal.interface.binding.subspan @io::@s0b0_ro_constant[%c0] : memref<1x128xf32>
  %2 = hal.interface.binding.subspan @io::@s0b2_xw_external[%c0] : memref<1x128xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_y]
  scf.for %arg0 = %3 to %c1 step %4 {
    %5 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
    %6 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
    scf.for %arg1 = %5 to %c128 step %6 {
      %7 = affine.min affine_map<(d0) -> (128, -d0 + 1)>(%arg0)
      %8 = memref.subview %0[%arg0, %arg1] [%7, 128] [1, 1] : memref<1x128xf32> to memref<?x128xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
      %9 = memref.subview %1[%arg0, %arg1] [%7, 128] [1, 1] : memref<1x128xf32> to memref<?x128xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
      %10 = memref.subview %2[%arg0, %arg1] [%7, 128] [1, 1] : memref<1x128xf32> to memref<?x128xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
      scf.for %arg2 = %c0 to %7 step %c1 {
        scf.for %arg3 = %c0 to %c128 step %c1 {
          %11 = memref.load %8[%arg2, %arg3] : memref<?x128xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
          %12 = memref.load %9[%arg2, %arg3] : memref<?x128xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
          %13 = addf %11, %12 : f32
          %14 = cmpf ogt, %13, %cst_0 : f32
          %15 = select %14, %13, %cst_0 : f32
          %16 = cmpf uno, %13, %cst_0 : f32
          %17 = select %16, %cst, %15 : f32
          memref.store %17, %10[%arg2, %arg3] : memref<?x128xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
        }
      }
    }
  }
  return
}

// *** IR Dump After SCFToStandard ***
func @predict_dispatch_1() {
  %cst = constant 0x7FC00000 : f32
  %cst_0 = constant 0.000000e+00 : f32
  %c128 = constant 128 : index
  %c0 = constant 0 : index
  %c1 = constant 1 : index
  %0 = hal.interface.binding.subspan @io::@s0b1_ro_external[%c0] : memref<1x128xf32>
  %1 = hal.interface.binding.subspan @io::@s0b0_ro_constant[%c0] : memref<1x128xf32>
  %2 = hal.interface.binding.subspan @io::@s0b2_xw_external[%c0] : memref<1x128xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_y]
  br ^bb1(%3 : index)
^bb1(%5: index):  // 2 preds: ^bb0, ^bb11
  %6 = cmpi slt, %5, %c1 : index
  cond_br %6, ^bb2, ^bb12
^bb2:  // pred: ^bb1
  %7 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %8 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
  br ^bb3(%7 : index)
^bb3(%9: index):  // 2 preds: ^bb2, ^bb10
  %10 = cmpi slt, %9, %c128 : index
  cond_br %10, ^bb4, ^bb11
^bb4:  // pred: ^bb3
  %11 = affine.min affine_map<(d0) -> (128, -d0 + 1)>(%5)
  %12 = memref.subview %0[%5, %9] [%11, 128] [1, 1] : memref<1x128xf32> to memref<?x128xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
  %13 = memref.subview %1[%5, %9] [%11, 128] [1, 1] : memref<1x128xf32> to memref<?x128xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
  %14 = memref.subview %2[%5, %9] [%11, 128] [1, 1] : memref<1x128xf32> to memref<?x128xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
  br ^bb5(%c0 : index)
^bb5(%15: index):  // 2 preds: ^bb4, ^bb9
  %16 = cmpi slt, %15, %11 : index
  cond_br %16, ^bb6, ^bb10
^bb6:  // pred: ^bb5
  br ^bb7(%c0 : index)
^bb7(%17: index):  // 2 preds: ^bb6, ^bb8
  %18 = cmpi slt, %17, %c128 : index
  cond_br %18, ^bb8, ^bb9
^bb8:  // pred: ^bb7
  %19 = memref.load %12[%15, %17] : memref<?x128xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
  %20 = memref.load %13[%15, %17] : memref<?x128xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
  %21 = addf %19, %20 : f32
  %22 = cmpf ogt, %21, %cst_0 : f32
  %23 = select %22, %21, %cst_0 : f32
  %24 = cmpf uno, %21, %cst_0 : f32
  %25 = select %24, %cst, %23 : f32
  memref.store %25, %14[%15, %17] : memref<?x128xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
  %26 = addi %17, %c1 : index
  br ^bb7(%26 : index)
^bb9:  // pred: ^bb7
  %27 = addi %15, %c1 : index
  br ^bb5(%27 : index)
^bb10:  // pred: ^bb5
  %28 = addi %9, %8 : index
  br ^bb3(%28 : index)
^bb11:  // pred: ^bb3
  %29 = addi %5, %4 : index
  br ^bb1(%29 : index)
^bb12:  // pred: ^bb1
  return
}

// *** IR Dump After Canonicalizer ***
func @predict_dispatch_1() {
  %cst = constant 0x7FC00000 : f32
  %cst_0 = constant 0.000000e+00 : f32
  %c128 = constant 128 : index
  %c0 = constant 0 : index
  %c1 = constant 1 : index
  %0 = hal.interface.binding.subspan @io::@s0b1_ro_external[%c0] : memref<1x128xf32>
  %1 = hal.interface.binding.subspan @io::@s0b0_ro_constant[%c0] : memref<1x128xf32>
  %2 = hal.interface.binding.subspan @io::@s0b2_xw_external[%c0] : memref<1x128xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_y]
  br ^bb1(%3 : index)
^bb1(%5: index):  // 2 preds: ^bb0, ^bb10
  %6 = cmpi slt, %5, %c1 : index
  cond_br %6, ^bb2, ^bb11
^bb2:  // pred: ^bb1
  %7 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %8 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
  br ^bb3(%7 : index)
^bb3(%9: index):  // 2 preds: ^bb2, ^bb9
  %10 = cmpi slt, %9, %c128 : index
  cond_br %10, ^bb4, ^bb10
^bb4:  // pred: ^bb3
  %11 = affine.min affine_map<()[s0] -> (128, -s0 + 1)>()[%5]
  %12 = memref.subview %0[%5, %9] [%11, 128] [1, 1] : memref<1x128xf32> to memref<?x128xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
  %13 = memref.subview %1[%5, %9] [%11, 128] [1, 1] : memref<1x128xf32> to memref<?x128xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
  %14 = memref.subview %2[%5, %9] [%11, 128] [1, 1] : memref<1x128xf32> to memref<?x128xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
  br ^bb5(%c0 : index)
^bb5(%15: index):  // 2 preds: ^bb4, ^bb8
  %16 = cmpi slt, %15, %11 : index
  cond_br %16, ^bb6(%c0 : index), ^bb9
^bb6(%17: index):  // 2 preds: ^bb5, ^bb7
  %18 = cmpi slt, %17, %c128 : index
  cond_br %18, ^bb7, ^bb8
^bb7:  // pred: ^bb6
  %19 = memref.load %12[%15, %17] : memref<?x128xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
  %20 = memref.load %13[%15, %17] : memref<?x128xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
  %21 = addf %19, %20 : f32
  %22 = cmpf ogt, %21, %cst_0 : f32
  %23 = select %22, %21, %cst_0 : f32
  %24 = cmpf uno, %21, %cst_0 : f32
  %25 = select %24, %cst, %23 : f32
  memref.store %25, %14[%15, %17] : memref<?x128xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
  %26 = addi %17, %c1 : index
  br ^bb6(%26 : index)
^bb8:  // pred: ^bb6
  %27 = addi %15, %c1 : index
  br ^bb5(%27 : index)
^bb9:  // pred: ^bb5
  %28 = addi %9, %8 : index
  br ^bb3(%28 : index)
^bb10:  // pred: ^bb3
  %29 = addi %5, %4 : index
  br ^bb1(%29 : index)
^bb11:  // pred: ^bb1
  return
}

// *** IR Dump After CSE ***
func @predict_dispatch_1() {
  %cst = constant 0x7FC00000 : f32
  %cst_0 = constant 0.000000e+00 : f32
  %c128 = constant 128 : index
  %c0 = constant 0 : index
  %c1 = constant 1 : index
  %0 = hal.interface.binding.subspan @io::@s0b1_ro_external[%c0] : memref<1x128xf32>
  %1 = hal.interface.binding.subspan @io::@s0b0_ro_constant[%c0] : memref<1x128xf32>
  %2 = hal.interface.binding.subspan @io::@s0b2_xw_external[%c0] : memref<1x128xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_y]
  br ^bb1(%3 : index)
^bb1(%5: index):  // 2 preds: ^bb0, ^bb10
  %6 = cmpi slt, %5, %c1 : index
  cond_br %6, ^bb2, ^bb11
^bb2:  // pred: ^bb1
  %7 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %8 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
  br ^bb3(%7 : index)
^bb3(%9: index):  // 2 preds: ^bb2, ^bb9
  %10 = cmpi slt, %9, %c128 : index
  cond_br %10, ^bb4, ^bb10
^bb4:  // pred: ^bb3
  %11 = affine.min affine_map<()[s0] -> (128, -s0 + 1)>()[%5]
  %12 = memref.subview %0[%5, %9] [%11, 128] [1, 1] : memref<1x128xf32> to memref<?x128xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
  %13 = memref.subview %1[%5, %9] [%11, 128] [1, 1] : memref<1x128xf32> to memref<?x128xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
  %14 = memref.subview %2[%5, %9] [%11, 128] [1, 1] : memref<1x128xf32> to memref<?x128xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
  br ^bb5(%c0 : index)
^bb5(%15: index):  // 2 preds: ^bb4, ^bb8
  %16 = cmpi slt, %15, %11 : index
  cond_br %16, ^bb6(%c0 : index), ^bb9
^bb6(%17: index):  // 2 preds: ^bb5, ^bb7
  %18 = cmpi slt, %17, %c128 : index
  cond_br %18, ^bb7, ^bb8
^bb7:  // pred: ^bb6
  %19 = memref.load %12[%15, %17] : memref<?x128xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
  %20 = memref.load %13[%15, %17] : memref<?x128xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
  %21 = addf %19, %20 : f32
  %22 = cmpf ogt, %21, %cst_0 : f32
  %23 = select %22, %21, %cst_0 : f32
  %24 = cmpf uno, %21, %cst_0 : f32
  %25 = select %24, %cst, %23 : f32
  memref.store %25, %14[%15, %17] : memref<?x128xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
  %26 = addi %17, %c1 : index
  br ^bb6(%26 : index)
^bb8:  // pred: ^bb6
  %27 = addi %15, %c1 : index
  br ^bb5(%27 : index)
^bb9:  // pred: ^bb5
  %28 = addi %9, %8 : index
  br ^bb3(%28 : index)
^bb10:  // pred: ^bb3
  %29 = addi %5, %4 : index
  br ^bb1(%29 : index)
^bb11:  // pred: ^bb1
  return
}

// *** IR Dump After TensorConstantBufferize ***
module  {
  func @predict_dispatch_1() {
    %cst = constant 0x7FC00000 : f32
    %cst_0 = constant 0.000000e+00 : f32
    %c128 = constant 128 : index
    %c0 = constant 0 : index
    %c1 = constant 1 : index
    %0 = hal.interface.binding.subspan @io::@s0b1_ro_external[%c0] : memref<1x128xf32>
    %1 = hal.interface.binding.subspan @io::@s0b0_ro_constant[%c0] : memref<1x128xf32>
    %2 = hal.interface.binding.subspan @io::@s0b2_xw_external[%c0] : memref<1x128xf32>
    %workgroup_id_x = hal.interface.workgroup.id[0] : index
    %workgroup_count_x = hal.interface.workgroup.count[0] : index
    %workgroup_id_y = hal.interface.workgroup.id[1] : index
    %workgroup_count_y = hal.interface.workgroup.count[1] : index
    %3 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_y]
    %4 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_y]
    br ^bb1(%3 : index)
  ^bb1(%5: index):  // 2 preds: ^bb0, ^bb10
    %6 = cmpi slt, %5, %c1 : index
    cond_br %6, ^bb2, ^bb11
  ^bb2:  // pred: ^bb1
    %7 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
    %8 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
    br ^bb3(%7 : index)
  ^bb3(%9: index):  // 2 preds: ^bb2, ^bb9
    %10 = cmpi slt, %9, %c128 : index
    cond_br %10, ^bb4, ^bb10
  ^bb4:  // pred: ^bb3
    %11 = affine.min affine_map<()[s0] -> (128, -s0 + 1)>()[%5]
    %12 = memref.subview %0[%5, %9] [%11, 128] [1, 1] : memref<1x128xf32> to memref<?x128xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
    %13 = memref.subview %1[%5, %9] [%11, 128] [1, 1] : memref<1x128xf32> to memref<?x128xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
    %14 = memref.subview %2[%5, %9] [%11, 128] [1, 1] : memref<1x128xf32> to memref<?x128xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
    br ^bb5(%c0 : index)
  ^bb5(%15: index):  // 2 preds: ^bb4, ^bb8
    %16 = cmpi slt, %15, %11 : index
    cond_br %16, ^bb6(%c0 : index), ^bb9
  ^bb6(%17: index):  // 2 preds: ^bb5, ^bb7
    %18 = cmpi slt, %17, %c128 : index
    cond_br %18, ^bb7, ^bb8
  ^bb7:  // pred: ^bb6
    %19 = memref.load %12[%15, %17] : memref<?x128xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
    %20 = memref.load %13[%15, %17] : memref<?x128xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
    %21 = addf %19, %20 : f32
    %22 = cmpf ogt, %21, %cst_0 : f32
    %23 = select %22, %21, %cst_0 : f32
    %24 = cmpf uno, %21, %cst_0 : f32
    %25 = select %24, %cst, %23 : f32
    memref.store %25, %14[%15, %17] : memref<?x128xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
    %26 = addi %17, %c1 : index
    br ^bb6(%26 : index)
  ^bb8:  // pred: ^bb6
    %27 = addi %15, %c1 : index
    br ^bb5(%27 : index)
  ^bb9:  // pred: ^bb5
    %28 = addi %9, %8 : index
    br ^bb3(%28 : index)
  ^bb10:  // pred: ^bb3
    %29 = addi %5, %4 : index
    br ^bb1(%29 : index)
  ^bb11:  // pred: ^bb1
    return
  }
  hal.interface @io attributes {sym_visibility = "private"} {
    hal.interface.binding @s0b0_ro_constant, set=0, binding=0, type="StorageBuffer", access="Read"
    hal.interface.binding @s0b1_ro_external, set=0, binding=1, type="StorageBuffer", access="Read"
    hal.interface.binding @s0b2_xw_external, set=0, binding=2, type="StorageBuffer", access="Write|Discard"
  }
}

// *** IR Dump After mlir::iree_compiler::`anonymous-namespace'::FoldTensorExtractOpPass ***
module  {
  func @predict_dispatch_1() {
    %cst = constant 0x7FC00000 : f32
    %cst_0 = constant 0.000000e+00 : f32
    %c128 = constant 128 : index
    %c0 = constant 0 : index
    %c1 = constant 1 : index
    %0 = hal.interface.binding.subspan @io::@s0b1_ro_external[%c0] : memref<1x128xf32>
    %1 = hal.interface.binding.subspan @io::@s0b0_ro_constant[%c0] : memref<1x128xf32>
    %2 = hal.interface.binding.subspan @io::@s0b2_xw_external[%c0] : memref<1x128xf32>
    %workgroup_id_x = hal.interface.workgroup.id[0] : index
    %workgroup_count_x = hal.interface.workgroup.count[0] : index
    %workgroup_id_y = hal.interface.workgroup.id[1] : index
    %workgroup_count_y = hal.interface.workgroup.count[1] : index
    %3 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_y]
    %4 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_y]
    br ^bb1(%3 : index)
  ^bb1(%5: index):  // 2 preds: ^bb0, ^bb10
    %6 = cmpi slt, %5, %c1 : index
    cond_br %6, ^bb2, ^bb11
  ^bb2:  // pred: ^bb1
    %7 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
    %8 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
    br ^bb3(%7 : index)
  ^bb3(%9: index):  // 2 preds: ^bb2, ^bb9
    %10 = cmpi slt, %9, %c128 : index
    cond_br %10, ^bb4, ^bb10
  ^bb4:  // pred: ^bb3
    %11 = affine.min affine_map<()[s0] -> (128, -s0 + 1)>()[%5]
    %12 = memref.subview %0[%5, %9] [%11, 128] [1, 1] : memref<1x128xf32> to memref<?x128xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
    %13 = memref.subview %1[%5, %9] [%11, 128] [1, 1] : memref<1x128xf32> to memref<?x128xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
    %14 = memref.subview %2[%5, %9] [%11, 128] [1, 1] : memref<1x128xf32> to memref<?x128xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
    br ^bb5(%c0 : index)
  ^bb5(%15: index):  // 2 preds: ^bb4, ^bb8
    %16 = cmpi slt, %15, %11 : index
    cond_br %16, ^bb6(%c0 : index), ^bb9
  ^bb6(%17: index):  // 2 preds: ^bb5, ^bb7
    %18 = cmpi slt, %17, %c128 : index
    cond_br %18, ^bb7, ^bb8
  ^bb7:  // pred: ^bb6
    %19 = memref.load %12[%15, %17] : memref<?x128xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
    %20 = memref.load %13[%15, %17] : memref<?x128xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
    %21 = addf %19, %20 : f32
    %22 = cmpf ogt, %21, %cst_0 : f32
    %23 = select %22, %21, %cst_0 : f32
    %24 = cmpf uno, %21, %cst_0 : f32
    %25 = select %24, %cst, %23 : f32
    memref.store %25, %14[%15, %17] : memref<?x128xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
    %26 = addi %17, %c1 : index
    br ^bb6(%26 : index)
  ^bb8:  // pred: ^bb6
    %27 = addi %15, %c1 : index
    br ^bb5(%27 : index)
  ^bb9:  // pred: ^bb5
    %28 = addi %9, %8 : index
    br ^bb3(%28 : index)
  ^bb10:  // pred: ^bb3
    %29 = addi %5, %4 : index
    br ^bb1(%29 : index)
  ^bb11:  // pred: ^bb1
    return
  }
  hal.interface @io attributes {sym_visibility = "private"} {
    hal.interface.binding @s0b0_ro_constant, set=0, binding=0, type="StorageBuffer", access="Read"
    hal.interface.binding @s0b1_ro_external, set=0, binding=1, type="StorageBuffer", access="Read"
    hal.interface.binding @s0b2_xw_external, set=0, binding=2, type="StorageBuffer", access="Write|Discard"
  }
}

// *** IR Dump After mlir::iree_compiler::`anonymous-namespace'::ConvertToLLVMPass ***
module  {
  llvm.func internal @predict_dispatch_1(%arg0: !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>, %arg1: !llvm.ptr<array<3 x i32>>) -> i32 {
    %0 = llvm.mlir.constant(0x7FC00000 : f32) : f32
    %1 = llvm.mlir.constant(0.000000e+00 : f32) : f32
    %2 = llvm.mlir.constant(128 : index) : i64
    %3 = llvm.mlir.constant(0 : index) : i64
    %4 = llvm.mlir.constant(1 : index) : i64
    %5 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
    %6 = llvm.extractvalue %5[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
    %7 = llvm.mlir.constant(1 : index) : i64
    %8 = llvm.getelementptr %6[%7] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
    %9 = llvm.load %8 : !llvm.ptr<ptr<i8>>
    %10 = llvm.getelementptr %9[%3] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
    %11 = llvm.bitcast %10 : !llvm.ptr<i8> to !llvm.ptr<f32>
    %12 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %13 = llvm.insertvalue %11, %12[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %14 = llvm.insertvalue %11, %13[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %15 = llvm.mlir.constant(0 : index) : i64
    %16 = llvm.insertvalue %15, %14[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %17 = llvm.mlir.constant(1 : index) : i64
    %18 = llvm.insertvalue %17, %16[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %19 = llvm.mlir.constant(128 : index) : i64
    %20 = llvm.insertvalue %19, %18[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %21 = llvm.mlir.constant(128 : index) : i64
    %22 = llvm.insertvalue %21, %20[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %23 = llvm.mlir.constant(1 : index) : i64
    %24 = llvm.insertvalue %23, %22[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %25 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
    %26 = llvm.extractvalue %25[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
    %27 = llvm.mlir.constant(0 : index) : i64
    %28 = llvm.getelementptr %26[%27] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
    %29 = llvm.load %28 : !llvm.ptr<ptr<i8>>
    %30 = llvm.getelementptr %29[%3] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
    %31 = llvm.bitcast %30 : !llvm.ptr<i8> to !llvm.ptr<f32>
    %32 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %33 = llvm.insertvalue %31, %32[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %34 = llvm.insertvalue %31, %33[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %35 = llvm.mlir.constant(0 : index) : i64
    %36 = llvm.insertvalue %35, %34[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %37 = llvm.mlir.constant(1 : index) : i64
    %38 = llvm.insertvalue %37, %36[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %39 = llvm.mlir.constant(128 : index) : i64
    %40 = llvm.insertvalue %39, %38[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %41 = llvm.mlir.constant(128 : index) : i64
    %42 = llvm.insertvalue %41, %40[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %43 = llvm.mlir.constant(1 : index) : i64
    %44 = llvm.insertvalue %43, %42[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %45 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
    %46 = llvm.extractvalue %45[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
    %47 = llvm.mlir.constant(2 : index) : i64
    %48 = llvm.getelementptr %46[%47] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
    %49 = llvm.load %48 : !llvm.ptr<ptr<i8>>
    %50 = llvm.getelementptr %49[%3] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
    %51 = llvm.bitcast %50 : !llvm.ptr<i8> to !llvm.ptr<f32>
    %52 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %53 = llvm.insertvalue %51, %52[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %54 = llvm.insertvalue %51, %53[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %55 = llvm.mlir.constant(0 : index) : i64
    %56 = llvm.insertvalue %55, %54[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %57 = llvm.mlir.constant(1 : index) : i64
    %58 = llvm.insertvalue %57, %56[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %59 = llvm.mlir.constant(128 : index) : i64
    %60 = llvm.insertvalue %59, %58[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %61 = llvm.mlir.constant(128 : index) : i64
    %62 = llvm.insertvalue %61, %60[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %63 = llvm.mlir.constant(1 : index) : i64
    %64 = llvm.insertvalue %63, %62[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %65 = llvm.load %arg1 : !llvm.ptr<array<3 x i32>>
    %66 = llvm.extractvalue %65[0] : !llvm.array<3 x i32>
    %67 = llvm.zext %66 : i32 to i64
    %68 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
    %69 = llvm.extractvalue %68[0] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
    %70 = llvm.extractvalue %69[0] : !llvm.array<3 x i32>
    %71 = llvm.zext %70 : i32 to i64
    %72 = llvm.load %arg1 : !llvm.ptr<array<3 x i32>>
    %73 = llvm.extractvalue %72[1] : !llvm.array<3 x i32>
    %74 = llvm.zext %73 : i32 to i64
    %75 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
    %76 = llvm.extractvalue %75[0] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
    %77 = llvm.extractvalue %76[1] : !llvm.array<3 x i32>
    %78 = llvm.zext %77 : i32 to i64
    %79 = llvm.mlir.constant(128 : index) : i64
    %80 = llvm.mul %74, %79  : i64
    %81 = llvm.mlir.constant(128 : index) : i64
    %82 = llvm.mul %78, %81  : i64
    llvm.br ^bb1(%80 : i64)
  ^bb1(%83: i64):  // 2 preds: ^bb0, ^bb10
    %84 = llvm.icmp "slt" %83, %4 : i64
    llvm.cond_br %84, ^bb2, ^bb11
  ^bb2:  // pred: ^bb1
    %85 = llvm.mlir.constant(128 : index) : i64
    %86 = llvm.mul %67, %85  : i64
    %87 = llvm.mlir.constant(128 : index) : i64
    %88 = llvm.mul %71, %87  : i64
    llvm.br ^bb3(%86 : i64)
  ^bb3(%89: i64):  // 2 preds: ^bb2, ^bb9
    %90 = llvm.icmp "slt" %89, %2 : i64
    llvm.cond_br %90, ^bb4, ^bb10
  ^bb4:  // pred: ^bb3
    %91 = llvm.mlir.constant(128 : index) : i64
    %92 = llvm.mlir.constant(-1 : index) : i64
    %93 = llvm.mul %83, %92  : i64
    %94 = llvm.mlir.constant(1 : index) : i64
    %95 = llvm.add %93, %94  : i64
    %96 = llvm.icmp "slt" %91, %95 : i64
    %97 = llvm.select %96, %91, %95 : i1, i64
    %98 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %99 = llvm.extractvalue %24[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %100 = llvm.bitcast %99 : !llvm.ptr<f32> to !llvm.ptr<f32>
    %101 = llvm.insertvalue %100, %98[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %102 = llvm.extractvalue %24[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %103 = llvm.bitcast %102 : !llvm.ptr<f32> to !llvm.ptr<f32>
    %104 = llvm.insertvalue %103, %101[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %105 = llvm.extractvalue %24[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %106 = llvm.extractvalue %24[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %107 = llvm.extractvalue %24[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %108 = llvm.mul %83, %105  : i64
    %109 = llvm.add %107, %108  : i64
    %110 = llvm.mul %89, %106  : i64
    %111 = llvm.add %109, %110  : i64
    %112 = llvm.insertvalue %111, %104[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %113 = llvm.mlir.constant(128 : i64) : i64
    %114 = llvm.mlir.constant(1 : i64) : i64
    %115 = llvm.insertvalue %113, %112[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %116 = llvm.insertvalue %114, %115[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %117 = llvm.mlir.constant(128 : i64) : i64
    %118 = llvm.insertvalue %97, %116[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %119 = llvm.insertvalue %117, %118[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %120 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %121 = llvm.extractvalue %44[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %122 = llvm.bitcast %121 : !llvm.ptr<f32> to !llvm.ptr<f32>
    %123 = llvm.insertvalue %122, %120[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %124 = llvm.extractvalue %44[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %125 = llvm.bitcast %124 : !llvm.ptr<f32> to !llvm.ptr<f32>
    %126 = llvm.insertvalue %125, %123[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %127 = llvm.extractvalue %44[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %128 = llvm.extractvalue %44[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %129 = llvm.extractvalue %44[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %130 = llvm.mul %83, %127  : i64
    %131 = llvm.add %129, %130  : i64
    %132 = llvm.mul %89, %128  : i64
    %133 = llvm.add %131, %132  : i64
    %134 = llvm.insertvalue %133, %126[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %135 = llvm.mlir.constant(128 : i64) : i64
    %136 = llvm.mlir.constant(1 : i64) : i64
    %137 = llvm.insertvalue %135, %134[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %138 = llvm.insertvalue %136, %137[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %139 = llvm.mlir.constant(128 : i64) : i64
    %140 = llvm.insertvalue %97, %138[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %141 = llvm.insertvalue %139, %140[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %142 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %143 = llvm.extractvalue %64[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %144 = llvm.bitcast %143 : !llvm.ptr<f32> to !llvm.ptr<f32>
    %145 = llvm.insertvalue %144, %142[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %146 = llvm.extractvalue %64[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %147 = llvm.bitcast %146 : !llvm.ptr<f32> to !llvm.ptr<f32>
    %148 = llvm.insertvalue %147, %145[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %149 = llvm.extractvalue %64[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %150 = llvm.extractvalue %64[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %151 = llvm.extractvalue %64[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %152 = llvm.mul %83, %149  : i64
    %153 = llvm.add %151, %152  : i64
    %154 = llvm.mul %89, %150  : i64
    %155 = llvm.add %153, %154  : i64
    %156 = llvm.insertvalue %155, %148[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %157 = llvm.mlir.constant(128 : i64) : i64
    %158 = llvm.mlir.constant(1 : i64) : i64
    %159 = llvm.insertvalue %157, %156[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %160 = llvm.insertvalue %158, %159[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %161 = llvm.mlir.constant(128 : i64) : i64
    %162 = llvm.insertvalue %97, %160[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %163 = llvm.insertvalue %161, %162[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    llvm.br ^bb5(%3 : i64)
  ^bb5(%164: i64):  // 2 preds: ^bb4, ^bb8
    %165 = llvm.icmp "slt" %164, %97 : i64
    llvm.cond_br %165, ^bb6(%3 : i64), ^bb9
  ^bb6(%166: i64):  // 2 preds: ^bb5, ^bb7
    %167 = llvm.icmp "slt" %166, %2 : i64
    llvm.cond_br %167, ^bb7, ^bb8
  ^bb7:  // pred: ^bb6
    %168 = llvm.extractvalue %119[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %169 = llvm.extractvalue %119[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %170 = llvm.mlir.constant(128 : index) : i64
    %171 = llvm.mul %164, %170  : i64
    %172 = llvm.add %169, %171  : i64
    %173 = llvm.add %172, %166  : i64
    %174 = llvm.getelementptr %168[%173] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %175 = llvm.load %174 : !llvm.ptr<f32>
    %176 = llvm.extractvalue %141[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %177 = llvm.extractvalue %141[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %178 = llvm.mlir.constant(128 : index) : i64
    %179 = llvm.mul %164, %178  : i64
    %180 = llvm.add %177, %179  : i64
    %181 = llvm.add %180, %166  : i64
    %182 = llvm.getelementptr %176[%181] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %183 = llvm.load %182 : !llvm.ptr<f32>
    %184 = llvm.fadd %175, %183  : f32
    %185 = llvm.fcmp "ogt" %184, %1 : f32
    %186 = llvm.select %185, %184, %1 : i1, f32
    %187 = llvm.fcmp "uno" %184, %1 : f32
    %188 = llvm.select %187, %0, %186 : i1, f32
    %189 = llvm.extractvalue %163[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %190 = llvm.extractvalue %163[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %191 = llvm.mlir.constant(128 : index) : i64
    %192 = llvm.mul %164, %191  : i64
    %193 = llvm.add %190, %192  : i64
    %194 = llvm.add %193, %166  : i64
    %195 = llvm.getelementptr %189[%194] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    llvm.store %188, %195 : !llvm.ptr<f32>
    %196 = llvm.add %166, %4  : i64
    llvm.br ^bb6(%196 : i64)
  ^bb8:  // pred: ^bb6
    %197 = llvm.add %164, %4  : i64
    llvm.br ^bb5(%197 : i64)
  ^bb9:  // pred: ^bb5
    %198 = llvm.add %89, %88  : i64
    llvm.br ^bb3(%198 : i64)
  ^bb10:  // pred: ^bb3
    %199 = llvm.add %83, %82  : i64
    llvm.br ^bb1(%199 : i64)
  ^bb11:  // pred: ^bb1
    %200 = llvm.mlir.constant(0 : i32) : i32
    llvm.return %200 : i32
  }
}

// *** IR Dump After Canonicalizer ***
module  {
  llvm.func internal @predict_dispatch_1(%arg0: !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>, %arg1: !llvm.ptr<array<3 x i32>>) -> i32 {
    %0 = llvm.mlir.constant(0x7FC00000 : f32) : f32
    %1 = llvm.mlir.constant(0.000000e+00 : f32) : f32
    %2 = llvm.mlir.constant(128 : index) : i64
    %3 = llvm.mlir.constant(0 : index) : i64
    %4 = llvm.mlir.constant(1 : index) : i64
    %5 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
    %6 = llvm.extractvalue %5[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
    %7 = llvm.mlir.constant(1 : index) : i64
    %8 = llvm.getelementptr %6[%7] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
    %9 = llvm.load %8 : !llvm.ptr<ptr<i8>>
    %10 = llvm.getelementptr %9[%3] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
    %11 = llvm.bitcast %10 : !llvm.ptr<i8> to !llvm.ptr<f32>
    %12 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %13 = llvm.insertvalue %11, %12[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %14 = llvm.insertvalue %11, %13[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %15 = llvm.mlir.constant(0 : index) : i64
    %16 = llvm.insertvalue %15, %14[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %17 = llvm.mlir.constant(1 : index) : i64
    %18 = llvm.insertvalue %17, %16[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %19 = llvm.mlir.constant(128 : index) : i64
    %20 = llvm.insertvalue %19, %18[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %21 = llvm.mlir.constant(128 : index) : i64
    %22 = llvm.insertvalue %21, %20[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %23 = llvm.mlir.constant(1 : index) : i64
    %24 = llvm.insertvalue %23, %22[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %25 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
    %26 = llvm.extractvalue %25[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
    %27 = llvm.mlir.constant(0 : index) : i64
    %28 = llvm.getelementptr %26[%27] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
    %29 = llvm.load %28 : !llvm.ptr<ptr<i8>>
    %30 = llvm.getelementptr %29[%3] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
    %31 = llvm.bitcast %30 : !llvm.ptr<i8> to !llvm.ptr<f32>
    %32 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %33 = llvm.insertvalue %31, %32[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %34 = llvm.insertvalue %31, %33[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %35 = llvm.mlir.constant(0 : index) : i64
    %36 = llvm.insertvalue %35, %34[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %37 = llvm.mlir.constant(1 : index) : i64
    %38 = llvm.insertvalue %37, %36[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %39 = llvm.mlir.constant(128 : index) : i64
    %40 = llvm.insertvalue %39, %38[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %41 = llvm.mlir.constant(128 : index) : i64
    %42 = llvm.insertvalue %41, %40[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %43 = llvm.mlir.constant(1 : index) : i64
    %44 = llvm.insertvalue %43, %42[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %45 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
    %46 = llvm.extractvalue %45[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
    %47 = llvm.mlir.constant(2 : index) : i64
    %48 = llvm.getelementptr %46[%47] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
    %49 = llvm.load %48 : !llvm.ptr<ptr<i8>>
    %50 = llvm.getelementptr %49[%3] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
    %51 = llvm.bitcast %50 : !llvm.ptr<i8> to !llvm.ptr<f32>
    %52 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %53 = llvm.insertvalue %51, %52[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %54 = llvm.insertvalue %51, %53[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %55 = llvm.mlir.constant(0 : index) : i64
    %56 = llvm.insertvalue %55, %54[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %57 = llvm.mlir.constant(1 : index) : i64
    %58 = llvm.insertvalue %57, %56[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %59 = llvm.mlir.constant(128 : index) : i64
    %60 = llvm.insertvalue %59, %58[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %61 = llvm.mlir.constant(128 : index) : i64
    %62 = llvm.insertvalue %61, %60[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %63 = llvm.mlir.constant(1 : index) : i64
    %64 = llvm.insertvalue %63, %62[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %65 = llvm.load %arg1 : !llvm.ptr<array<3 x i32>>
    %66 = llvm.extractvalue %65[0] : !llvm.array<3 x i32>
    %67 = llvm.zext %66 : i32 to i64
    %68 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
    %69 = llvm.extractvalue %68[0] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
    %70 = llvm.extractvalue %69[0] : !llvm.array<3 x i32>
    %71 = llvm.zext %70 : i32 to i64
    %72 = llvm.load %arg1 : !llvm.ptr<array<3 x i32>>
    %73 = llvm.extractvalue %72[1] : !llvm.array<3 x i32>
    %74 = llvm.zext %73 : i32 to i64
    %75 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
    %76 = llvm.extractvalue %75[0] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
    %77 = llvm.extractvalue %76[1] : !llvm.array<3 x i32>
    %78 = llvm.zext %77 : i32 to i64
    %79 = llvm.mlir.constant(128 : index) : i64
    %80 = llvm.mul %74, %79  : i64
    %81 = llvm.mlir.constant(128 : index) : i64
    %82 = llvm.mul %78, %81  : i64
    llvm.br ^bb1(%80 : i64)
  ^bb1(%83: i64):  // 2 preds: ^bb0, ^bb10
    %84 = llvm.icmp "slt" %83, %4 : i64
    llvm.cond_br %84, ^bb2, ^bb11
  ^bb2:  // pred: ^bb1
    %85 = llvm.mlir.constant(128 : index) : i64
    %86 = llvm.mul %67, %85  : i64
    %87 = llvm.mlir.constant(128 : index) : i64
    %88 = llvm.mul %71, %87  : i64
    llvm.br ^bb3(%86 : i64)
  ^bb3(%89: i64):  // 2 preds: ^bb2, ^bb9
    %90 = llvm.icmp "slt" %89, %2 : i64
    llvm.cond_br %90, ^bb4, ^bb10
  ^bb4:  // pred: ^bb3
    %91 = llvm.mlir.constant(128 : index) : i64
    %92 = llvm.mlir.constant(-1 : index) : i64
    %93 = llvm.mul %83, %92  : i64
    %94 = llvm.mlir.constant(1 : index) : i64
    %95 = llvm.add %93, %94  : i64
    %96 = llvm.icmp "slt" %91, %95 : i64
    %97 = llvm.select %96, %91, %95 : i1, i64
    %98 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %99 = llvm.extractvalue %24[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %100 = llvm.bitcast %99 : !llvm.ptr<f32> to !llvm.ptr<f32>
    %101 = llvm.insertvalue %100, %98[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %102 = llvm.extractvalue %24[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %103 = llvm.bitcast %102 : !llvm.ptr<f32> to !llvm.ptr<f32>
    %104 = llvm.insertvalue %103, %101[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %105 = llvm.extractvalue %24[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %106 = llvm.extractvalue %24[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %107 = llvm.extractvalue %24[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %108 = llvm.mul %83, %105  : i64
    %109 = llvm.add %107, %108  : i64
    %110 = llvm.mul %89, %106  : i64
    %111 = llvm.add %109, %110  : i64
    %112 = llvm.insertvalue %111, %104[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %113 = llvm.mlir.constant(128 : i64) : i64
    %114 = llvm.mlir.constant(1 : i64) : i64
    %115 = llvm.insertvalue %113, %112[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %116 = llvm.insertvalue %114, %115[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %117 = llvm.mlir.constant(128 : i64) : i64
    %118 = llvm.insertvalue %97, %116[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %119 = llvm.insertvalue %117, %118[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %120 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %121 = llvm.extractvalue %44[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %122 = llvm.bitcast %121 : !llvm.ptr<f32> to !llvm.ptr<f32>
    %123 = llvm.insertvalue %122, %120[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %124 = llvm.extractvalue %44[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %125 = llvm.bitcast %124 : !llvm.ptr<f32> to !llvm.ptr<f32>
    %126 = llvm.insertvalue %125, %123[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %127 = llvm.extractvalue %44[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %128 = llvm.extractvalue %44[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %129 = llvm.extractvalue %44[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %130 = llvm.mul %83, %127  : i64
    %131 = llvm.add %129, %130  : i64
    %132 = llvm.mul %89, %128  : i64
    %133 = llvm.add %131, %132  : i64
    %134 = llvm.insertvalue %133, %126[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %135 = llvm.mlir.constant(128 : i64) : i64
    %136 = llvm.mlir.constant(1 : i64) : i64
    %137 = llvm.insertvalue %135, %134[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %138 = llvm.insertvalue %136, %137[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %139 = llvm.mlir.constant(128 : i64) : i64
    %140 = llvm.insertvalue %97, %138[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %141 = llvm.insertvalue %139, %140[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %142 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %143 = llvm.extractvalue %64[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %144 = llvm.bitcast %143 : !llvm.ptr<f32> to !llvm.ptr<f32>
    %145 = llvm.insertvalue %144, %142[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %146 = llvm.extractvalue %64[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %147 = llvm.bitcast %146 : !llvm.ptr<f32> to !llvm.ptr<f32>
    %148 = llvm.insertvalue %147, %145[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %149 = llvm.extractvalue %64[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %150 = llvm.extractvalue %64[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %151 = llvm.extractvalue %64[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %152 = llvm.mul %83, %149  : i64
    %153 = llvm.add %151, %152  : i64
    %154 = llvm.mul %89, %150  : i64
    %155 = llvm.add %153, %154  : i64
    %156 = llvm.insertvalue %155, %148[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %157 = llvm.mlir.constant(128 : i64) : i64
    %158 = llvm.mlir.constant(1 : i64) : i64
    %159 = llvm.insertvalue %157, %156[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %160 = llvm.insertvalue %158, %159[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %161 = llvm.mlir.constant(128 : i64) : i64
    %162 = llvm.insertvalue %97, %160[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %163 = llvm.insertvalue %161, %162[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    llvm.br ^bb5(%3 : i64)
  ^bb5(%164: i64):  // 2 preds: ^bb4, ^bb8
    %165 = llvm.icmp "slt" %164, %97 : i64
    llvm.cond_br %165, ^bb6(%3 : i64), ^bb9
  ^bb6(%166: i64):  // 2 preds: ^bb5, ^bb7
    %167 = llvm.icmp "slt" %166, %2 : i64
    llvm.cond_br %167, ^bb7, ^bb8
  ^bb7:  // pred: ^bb6
    %168 = llvm.extractvalue %119[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %169 = llvm.extractvalue %119[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %170 = llvm.mlir.constant(128 : index) : i64
    %171 = llvm.mul %164, %170  : i64
    %172 = llvm.add %169, %171  : i64
    %173 = llvm.add %172, %166  : i64
    %174 = llvm.getelementptr %168[%173] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %175 = llvm.load %174 : !llvm.ptr<f32>
    %176 = llvm.extractvalue %141[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %177 = llvm.extractvalue %141[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %178 = llvm.mlir.constant(128 : index) : i64
    %179 = llvm.mul %164, %178  : i64
    %180 = llvm.add %177, %179  : i64
    %181 = llvm.add %180, %166  : i64
    %182 = llvm.getelementptr %176[%181] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %183 = llvm.load %182 : !llvm.ptr<f32>
    %184 = llvm.fadd %175, %183  : f32
    %185 = llvm.fcmp "ogt" %184, %1 : f32
    %186 = llvm.select %185, %184, %1 : i1, f32
    %187 = llvm.fcmp "uno" %184, %1 : f32
    %188 = llvm.select %187, %0, %186 : i1, f32
    %189 = llvm.extractvalue %163[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %190 = llvm.extractvalue %163[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %191 = llvm.mlir.constant(128 : index) : i64
    %192 = llvm.mul %164, %191  : i64
    %193 = llvm.add %190, %192  : i64
    %194 = llvm.add %193, %166  : i64
    %195 = llvm.getelementptr %189[%194] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    llvm.store %188, %195 : !llvm.ptr<f32>
    %196 = llvm.add %166, %4  : i64
    llvm.br ^bb6(%196 : i64)
  ^bb8:  // pred: ^bb6
    %197 = llvm.add %164, %4  : i64
    llvm.br ^bb5(%197 : i64)
  ^bb9:  // pred: ^bb5
    %198 = llvm.add %89, %88  : i64
    llvm.br ^bb3(%198 : i64)
  ^bb10:  // pred: ^bb3
    %199 = llvm.add %83, %82  : i64
    llvm.br ^bb1(%199 : i64)
  ^bb11:  // pred: ^bb1
    %200 = llvm.mlir.constant(0 : i32) : i32
    llvm.return %200 : i32
  }
}

// *** IR Dump After CSE ***
module  {
  llvm.func internal @predict_dispatch_1(%arg0: !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>, %arg1: !llvm.ptr<array<3 x i32>>) -> i32 {
    %0 = llvm.mlir.constant(0x7FC00000 : f32) : f32
    %1 = llvm.mlir.constant(0.000000e+00 : f32) : f32
    %2 = llvm.mlir.constant(128 : index) : i64
    %3 = llvm.mlir.constant(0 : index) : i64
    %4 = llvm.mlir.constant(1 : index) : i64
    %5 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
    %6 = llvm.extractvalue %5[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
    %7 = llvm.getelementptr %6[%4] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
    %8 = llvm.load %7 : !llvm.ptr<ptr<i8>>
    %9 = llvm.getelementptr %8[%3] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
    %10 = llvm.bitcast %9 : !llvm.ptr<i8> to !llvm.ptr<f32>
    %11 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %12 = llvm.insertvalue %10, %11[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %13 = llvm.insertvalue %10, %12[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %14 = llvm.insertvalue %3, %13[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %15 = llvm.insertvalue %4, %14[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %16 = llvm.insertvalue %2, %15[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %17 = llvm.insertvalue %2, %16[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %18 = llvm.insertvalue %4, %17[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %19 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
    %20 = llvm.extractvalue %19[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
    %21 = llvm.getelementptr %20[%3] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
    %22 = llvm.load %21 : !llvm.ptr<ptr<i8>>
    %23 = llvm.getelementptr %22[%3] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
    %24 = llvm.bitcast %23 : !llvm.ptr<i8> to !llvm.ptr<f32>
    %25 = llvm.insertvalue %24, %11[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %26 = llvm.insertvalue %24, %25[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %27 = llvm.insertvalue %3, %26[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %28 = llvm.insertvalue %4, %27[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %29 = llvm.insertvalue %2, %28[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %30 = llvm.insertvalue %2, %29[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %31 = llvm.insertvalue %4, %30[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %32 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
    %33 = llvm.extractvalue %32[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
    %34 = llvm.mlir.constant(2 : index) : i64
    %35 = llvm.getelementptr %33[%34] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
    %36 = llvm.load %35 : !llvm.ptr<ptr<i8>>
    %37 = llvm.getelementptr %36[%3] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
    %38 = llvm.bitcast %37 : !llvm.ptr<i8> to !llvm.ptr<f32>
    %39 = llvm.insertvalue %38, %11[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %40 = llvm.insertvalue %38, %39[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %41 = llvm.insertvalue %3, %40[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %42 = llvm.insertvalue %4, %41[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %43 = llvm.insertvalue %2, %42[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %44 = llvm.insertvalue %2, %43[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %45 = llvm.insertvalue %4, %44[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %46 = llvm.load %arg1 : !llvm.ptr<array<3 x i32>>
    %47 = llvm.extractvalue %46[0] : !llvm.array<3 x i32>
    %48 = llvm.zext %47 : i32 to i64
    %49 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
    %50 = llvm.extractvalue %49[0] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
    %51 = llvm.extractvalue %50[0] : !llvm.array<3 x i32>
    %52 = llvm.zext %51 : i32 to i64
    %53 = llvm.load %arg1 : !llvm.ptr<array<3 x i32>>
    %54 = llvm.extractvalue %53[1] : !llvm.array<3 x i32>
    %55 = llvm.zext %54 : i32 to i64
    %56 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
    %57 = llvm.extractvalue %56[0] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
    %58 = llvm.extractvalue %57[1] : !llvm.array<3 x i32>
    %59 = llvm.zext %58 : i32 to i64
    %60 = llvm.mul %55, %2  : i64
    %61 = llvm.mul %59, %2  : i64
    llvm.br ^bb1(%60 : i64)
  ^bb1(%62: i64):  // 2 preds: ^bb0, ^bb10
    %63 = llvm.icmp "slt" %62, %4 : i64
    llvm.cond_br %63, ^bb2, ^bb11
  ^bb2:  // pred: ^bb1
    %64 = llvm.mul %48, %2  : i64
    %65 = llvm.mul %52, %2  : i64
    llvm.br ^bb3(%64 : i64)
  ^bb3(%66: i64):  // 2 preds: ^bb2, ^bb9
    %67 = llvm.icmp "slt" %66, %2 : i64
    llvm.cond_br %67, ^bb4, ^bb10
  ^bb4:  // pred: ^bb3
    %68 = llvm.mlir.constant(-1 : index) : i64
    %69 = llvm.mul %62, %68  : i64
    %70 = llvm.add %69, %4  : i64
    %71 = llvm.icmp "slt" %2, %70 : i64
    %72 = llvm.select %71, %2, %70 : i1, i64
    %73 = llvm.extractvalue %18[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %74 = llvm.bitcast %73 : !llvm.ptr<f32> to !llvm.ptr<f32>
    %75 = llvm.insertvalue %74, %11[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %76 = llvm.extractvalue %18[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %77 = llvm.bitcast %76 : !llvm.ptr<f32> to !llvm.ptr<f32>
    %78 = llvm.insertvalue %77, %75[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %79 = llvm.extractvalue %18[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %80 = llvm.extractvalue %18[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %81 = llvm.extractvalue %18[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %82 = llvm.mul %62, %79  : i64
    %83 = llvm.add %81, %82  : i64
    %84 = llvm.mul %66, %80  : i64
    %85 = llvm.add %83, %84  : i64
    %86 = llvm.insertvalue %85, %78[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %87 = llvm.mlir.constant(128 : i64) : i64
    %88 = llvm.mlir.constant(1 : i64) : i64
    %89 = llvm.insertvalue %87, %86[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %90 = llvm.insertvalue %88, %89[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %91 = llvm.insertvalue %72, %90[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %92 = llvm.insertvalue %87, %91[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %93 = llvm.extractvalue %31[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %94 = llvm.bitcast %93 : !llvm.ptr<f32> to !llvm.ptr<f32>
    %95 = llvm.insertvalue %94, %11[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %96 = llvm.extractvalue %31[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %97 = llvm.bitcast %96 : !llvm.ptr<f32> to !llvm.ptr<f32>
    %98 = llvm.insertvalue %97, %95[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %99 = llvm.extractvalue %31[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %100 = llvm.extractvalue %31[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %101 = llvm.extractvalue %31[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %102 = llvm.mul %62, %99  : i64
    %103 = llvm.add %101, %102  : i64
    %104 = llvm.mul %66, %100  : i64
    %105 = llvm.add %103, %104  : i64
    %106 = llvm.insertvalue %105, %98[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %107 = llvm.insertvalue %87, %106[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %108 = llvm.insertvalue %88, %107[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %109 = llvm.insertvalue %72, %108[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %110 = llvm.insertvalue %87, %109[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %111 = llvm.extractvalue %45[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %112 = llvm.bitcast %111 : !llvm.ptr<f32> to !llvm.ptr<f32>
    %113 = llvm.insertvalue %112, %11[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %114 = llvm.extractvalue %45[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %115 = llvm.bitcast %114 : !llvm.ptr<f32> to !llvm.ptr<f32>
    %116 = llvm.insertvalue %115, %113[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %117 = llvm.extractvalue %45[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %118 = llvm.extractvalue %45[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %119 = llvm.extractvalue %45[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %120 = llvm.mul %62, %117  : i64
    %121 = llvm.add %119, %120  : i64
    %122 = llvm.mul %66, %118  : i64
    %123 = llvm.add %121, %122  : i64
    %124 = llvm.insertvalue %123, %116[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %125 = llvm.insertvalue %87, %124[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %126 = llvm.insertvalue %88, %125[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %127 = llvm.insertvalue %72, %126[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %128 = llvm.insertvalue %87, %127[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    llvm.br ^bb5(%3 : i64)
  ^bb5(%129: i64):  // 2 preds: ^bb4, ^bb8
    %130 = llvm.icmp "slt" %129, %72 : i64
    llvm.cond_br %130, ^bb6(%3 : i64), ^bb9
  ^bb6(%131: i64):  // 2 preds: ^bb5, ^bb7
    %132 = llvm.icmp "slt" %131, %2 : i64
    llvm.cond_br %132, ^bb7, ^bb8
  ^bb7:  // pred: ^bb6
    %133 = llvm.extractvalue %92[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %134 = llvm.extractvalue %92[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %135 = llvm.mul %129, %2  : i64
    %136 = llvm.add %134, %135  : i64
    %137 = llvm.add %136, %131  : i64
    %138 = llvm.getelementptr %133[%137] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %139 = llvm.load %138 : !llvm.ptr<f32>
    %140 = llvm.extractvalue %110[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %141 = llvm.extractvalue %110[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %142 = llvm.add %141, %135  : i64
    %143 = llvm.add %142, %131  : i64
    %144 = llvm.getelementptr %140[%143] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %145 = llvm.load %144 : !llvm.ptr<f32>
    %146 = llvm.fadd %139, %145  : f32
    %147 = llvm.fcmp "ogt" %146, %1 : f32
    %148 = llvm.select %147, %146, %1 : i1, f32
    %149 = llvm.fcmp "uno" %146, %1 : f32
    %150 = llvm.select %149, %0, %148 : i1, f32
    %151 = llvm.extractvalue %128[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %152 = llvm.extractvalue %128[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %153 = llvm.add %152, %135  : i64
    %154 = llvm.add %153, %131  : i64
    %155 = llvm.getelementptr %151[%154] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    llvm.store %150, %155 : !llvm.ptr<f32>
    %156 = llvm.add %131, %4  : i64
    llvm.br ^bb6(%156 : i64)
  ^bb8:  // pred: ^bb6
    %157 = llvm.add %129, %4  : i64
    llvm.br ^bb5(%157 : i64)
  ^bb9:  // pred: ^bb5
    %158 = llvm.add %66, %65  : i64
    llvm.br ^bb3(%158 : i64)
  ^bb10:  // pred: ^bb3
    %159 = llvm.add %62, %61  : i64
    llvm.br ^bb1(%159 : i64)
  ^bb11:  // pred: ^bb1
    %160 = llvm.mlir.constant(0 : i32) : i32
    llvm.return %160 : i32
  }
}

// *** IR Dump After mlir::iree_compiler::`anonymous-namespace'::LowerExecutableTargetPass ***
hal.executable.target @llvm_aot, filter="dylib*" {
  hal.executable.entry_point @predict_dispatch_1 attributes {interface = @io, ordinal = 0 : index} {
  ^bb0(%arg0: index, %arg1: index, %arg2: index):  // no predecessors
    %c1 = constant 1 : index
    %0 = affine.apply affine_map<()[s0] -> (s0 ceildiv 128)>()[%arg0]
    %1 = affine.apply affine_map<()[s0] -> (s0 ceildiv 128)>()[%arg1]
    hal.return %0, %1, %c1 : index, index, index
  }
  module  {
    llvm.func internal @predict_dispatch_1(%arg0: !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>, %arg1: !llvm.ptr<array<3 x i32>>) -> i32 {
      %0 = llvm.mlir.constant(0x7FC00000 : f32) : f32
      %1 = llvm.mlir.constant(0.000000e+00 : f32) : f32
      %2 = llvm.mlir.constant(128 : index) : i64
      %3 = llvm.mlir.constant(0 : index) : i64
      %4 = llvm.mlir.constant(1 : index) : i64
      %5 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
      %6 = llvm.extractvalue %5[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
      %7 = llvm.getelementptr %6[%4] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
      %8 = llvm.load %7 : !llvm.ptr<ptr<i8>>
      %9 = llvm.getelementptr %8[%3] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
      %10 = llvm.bitcast %9 : !llvm.ptr<i8> to !llvm.ptr<f32>
      %11 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %12 = llvm.insertvalue %10, %11[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %13 = llvm.insertvalue %10, %12[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %14 = llvm.insertvalue %3, %13[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %15 = llvm.insertvalue %4, %14[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %16 = llvm.insertvalue %2, %15[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %17 = llvm.insertvalue %2, %16[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %18 = llvm.insertvalue %4, %17[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %19 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
      %20 = llvm.extractvalue %19[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
      %21 = llvm.getelementptr %20[%3] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
      %22 = llvm.load %21 : !llvm.ptr<ptr<i8>>
      %23 = llvm.getelementptr %22[%3] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
      %24 = llvm.bitcast %23 : !llvm.ptr<i8> to !llvm.ptr<f32>
      %25 = llvm.insertvalue %24, %11[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %26 = llvm.insertvalue %24, %25[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %27 = llvm.insertvalue %3, %26[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %28 = llvm.insertvalue %4, %27[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %29 = llvm.insertvalue %2, %28[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %30 = llvm.insertvalue %2, %29[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %31 = llvm.insertvalue %4, %30[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %32 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
      %33 = llvm.extractvalue %32[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
      %34 = llvm.mlir.constant(2 : index) : i64
      %35 = llvm.getelementptr %33[%34] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
      %36 = llvm.load %35 : !llvm.ptr<ptr<i8>>
      %37 = llvm.getelementptr %36[%3] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
      %38 = llvm.bitcast %37 : !llvm.ptr<i8> to !llvm.ptr<f32>
      %39 = llvm.insertvalue %38, %11[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %40 = llvm.insertvalue %38, %39[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %41 = llvm.insertvalue %3, %40[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %42 = llvm.insertvalue %4, %41[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %43 = llvm.insertvalue %2, %42[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %44 = llvm.insertvalue %2, %43[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %45 = llvm.insertvalue %4, %44[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %46 = llvm.load %arg1 : !llvm.ptr<array<3 x i32>>
      %47 = llvm.extractvalue %46[0] : !llvm.array<3 x i32>
      %48 = llvm.zext %47 : i32 to i64
      %49 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
      %50 = llvm.extractvalue %49[0] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
      %51 = llvm.extractvalue %50[0] : !llvm.array<3 x i32>
      %52 = llvm.zext %51 : i32 to i64
      %53 = llvm.load %arg1 : !llvm.ptr<array<3 x i32>>
      %54 = llvm.extractvalue %53[1] : !llvm.array<3 x i32>
      %55 = llvm.zext %54 : i32 to i64
      %56 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
      %57 = llvm.extractvalue %56[0] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
      %58 = llvm.extractvalue %57[1] : !llvm.array<3 x i32>
      %59 = llvm.zext %58 : i32 to i64
      %60 = llvm.mul %55, %2  : i64
      %61 = llvm.mul %59, %2  : i64
      llvm.br ^bb1(%60 : i64)
    ^bb1(%62: i64):  // 2 preds: ^bb0, ^bb10
      %63 = llvm.icmp "slt" %62, %4 : i64
      llvm.cond_br %63, ^bb2, ^bb11
    ^bb2:  // pred: ^bb1
      %64 = llvm.mul %48, %2  : i64
      %65 = llvm.mul %52, %2  : i64
      llvm.br ^bb3(%64 : i64)
    ^bb3(%66: i64):  // 2 preds: ^bb2, ^bb9
      %67 = llvm.icmp "slt" %66, %2 : i64
      llvm.cond_br %67, ^bb4, ^bb10
    ^bb4:  // pred: ^bb3
      %68 = llvm.mlir.constant(-1 : index) : i64
      %69 = llvm.mul %62, %68  : i64
      %70 = llvm.add %69, %4  : i64
      %71 = llvm.icmp "slt" %2, %70 : i64
      %72 = llvm.select %71, %2, %70 : i1, i64
      %73 = llvm.extractvalue %18[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %74 = llvm.bitcast %73 : !llvm.ptr<f32> to !llvm.ptr<f32>
      %75 = llvm.insertvalue %74, %11[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %76 = llvm.extractvalue %18[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %77 = llvm.bitcast %76 : !llvm.ptr<f32> to !llvm.ptr<f32>
      %78 = llvm.insertvalue %77, %75[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %79 = llvm.extractvalue %18[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %80 = llvm.extractvalue %18[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %81 = llvm.extractvalue %18[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %82 = llvm.mul %62, %79  : i64
      %83 = llvm.add %81, %82  : i64
      %84 = llvm.mul %66, %80  : i64
      %85 = llvm.add %83, %84  : i64
      %86 = llvm.insertvalue %85, %78[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %87 = llvm.mlir.constant(128 : i64) : i64
      %88 = llvm.mlir.constant(1 : i64) : i64
      %89 = llvm.insertvalue %87, %86[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %90 = llvm.insertvalue %88, %89[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %91 = llvm.insertvalue %72, %90[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %92 = llvm.insertvalue %87, %91[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %93 = llvm.extractvalue %31[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %94 = llvm.bitcast %93 : !llvm.ptr<f32> to !llvm.ptr<f32>
      %95 = llvm.insertvalue %94, %11[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %96 = llvm.extractvalue %31[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %97 = llvm.bitcast %96 : !llvm.ptr<f32> to !llvm.ptr<f32>
      %98 = llvm.insertvalue %97, %95[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %99 = llvm.extractvalue %31[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %100 = llvm.extractvalue %31[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %101 = llvm.extractvalue %31[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %102 = llvm.mul %62, %99  : i64
      %103 = llvm.add %101, %102  : i64
      %104 = llvm.mul %66, %100  : i64
      %105 = llvm.add %103, %104  : i64
      %106 = llvm.insertvalue %105, %98[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %107 = llvm.insertvalue %87, %106[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %108 = llvm.insertvalue %88, %107[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %109 = llvm.insertvalue %72, %108[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %110 = llvm.insertvalue %87, %109[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %111 = llvm.extractvalue %45[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %112 = llvm.bitcast %111 : !llvm.ptr<f32> to !llvm.ptr<f32>
      %113 = llvm.insertvalue %112, %11[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %114 = llvm.extractvalue %45[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %115 = llvm.bitcast %114 : !llvm.ptr<f32> to !llvm.ptr<f32>
      %116 = llvm.insertvalue %115, %113[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %117 = llvm.extractvalue %45[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %118 = llvm.extractvalue %45[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %119 = llvm.extractvalue %45[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %120 = llvm.mul %62, %117  : i64
      %121 = llvm.add %119, %120  : i64
      %122 = llvm.mul %66, %118  : i64
      %123 = llvm.add %121, %122  : i64
      %124 = llvm.insertvalue %123, %116[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %125 = llvm.insertvalue %87, %124[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %126 = llvm.insertvalue %88, %125[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %127 = llvm.insertvalue %72, %126[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %128 = llvm.insertvalue %87, %127[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      llvm.br ^bb5(%3 : i64)
    ^bb5(%129: i64):  // 2 preds: ^bb4, ^bb8
      %130 = llvm.icmp "slt" %129, %72 : i64
      llvm.cond_br %130, ^bb6(%3 : i64), ^bb9
    ^bb6(%131: i64):  // 2 preds: ^bb5, ^bb7
      %132 = llvm.icmp "slt" %131, %2 : i64
      llvm.cond_br %132, ^bb7, ^bb8
    ^bb7:  // pred: ^bb6
      %133 = llvm.extractvalue %92[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %134 = llvm.extractvalue %92[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %135 = llvm.mul %129, %2  : i64
      %136 = llvm.add %134, %135  : i64
      %137 = llvm.add %136, %131  : i64
      %138 = llvm.getelementptr %133[%137] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
      %139 = llvm.load %138 : !llvm.ptr<f32>
      %140 = llvm.extractvalue %110[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %141 = llvm.extractvalue %110[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %142 = llvm.add %141, %135  : i64
      %143 = llvm.add %142, %131  : i64
      %144 = llvm.getelementptr %140[%143] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
      %145 = llvm.load %144 : !llvm.ptr<f32>
      %146 = llvm.fadd %139, %145  : f32
      %147 = llvm.fcmp "ogt" %146, %1 : f32
      %148 = llvm.select %147, %146, %1 : i1, f32
      %149 = llvm.fcmp "uno" %146, %1 : f32
      %150 = llvm.select %149, %0, %148 : i1, f32
      %151 = llvm.extractvalue %128[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %152 = llvm.extractvalue %128[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %153 = llvm.add %152, %135  : i64
      %154 = llvm.add %153, %131  : i64
      %155 = llvm.getelementptr %151[%154] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
      llvm.store %150, %155 : !llvm.ptr<f32>
      %156 = llvm.add %131, %4  : i64
      llvm.br ^bb6(%156 : i64)
    ^bb8:  // pred: ^bb6
      %157 = llvm.add %129, %4  : i64
      llvm.br ^bb5(%157 : i64)
    ^bb9:  // pred: ^bb5
      %158 = llvm.add %66, %65  : i64
      llvm.br ^bb3(%158 : i64)
    ^bb10:  // pred: ^bb3
      %159 = llvm.add %62, %61  : i64
      llvm.br ^bb1(%159 : i64)
    ^bb11:  // pred: ^bb1
      %160 = llvm.mlir.constant(0 : i32) : i32
      llvm.return %160 : i32
    }
  }
}

// *** IR Dump After mlir::iree_compiler::IREE::HAL::TranslateExecutablesPass ***
hal.executable.target @llvm_aot, filter="dylib*" {
  hal.executable.entry_point @predict_dispatch_1 attributes {interface = @io, ordinal = 0 : index} {
  ^bb0(%arg0: index, %arg1: index, %arg2: index):  // no predecessors
    %c1 = constant 1 : index
    %0 = affine.apply affine_map<()[s0] -> (s0 ceildiv 128)>()[%arg0]
    %1 = affine.apply affine_map<()[s0] -> (s0 ceildiv 128)>()[%arg1]
    hal.return %0, %1, %c1 : index, index, index
  }
  module  {
    llvm.func internal @predict_dispatch_1(%arg0: !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>, %arg1: !llvm.ptr<array<3 x i32>>) -> i32 {
      %0 = llvm.mlir.constant(0x7FC00000 : f32) : f32
      %1 = llvm.mlir.constant(0.000000e+00 : f32) : f32
      %2 = llvm.mlir.constant(128 : index) : i64
      %3 = llvm.mlir.constant(0 : index) : i64
      %4 = llvm.mlir.constant(1 : index) : i64
      %5 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
      %6 = llvm.extractvalue %5[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
      %7 = llvm.getelementptr %6[%4] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
      %8 = llvm.load %7 : !llvm.ptr<ptr<i8>>
      %9 = llvm.getelementptr %8[%3] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
      %10 = llvm.bitcast %9 : !llvm.ptr<i8> to !llvm.ptr<f32>
      %11 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %12 = llvm.insertvalue %10, %11[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %13 = llvm.insertvalue %10, %12[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %14 = llvm.insertvalue %3, %13[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %15 = llvm.insertvalue %4, %14[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %16 = llvm.insertvalue %2, %15[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %17 = llvm.insertvalue %2, %16[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %18 = llvm.insertvalue %4, %17[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %19 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
      %20 = llvm.extractvalue %19[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
      %21 = llvm.getelementptr %20[%3] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
      %22 = llvm.load %21 : !llvm.ptr<ptr<i8>>
      %23 = llvm.getelementptr %22[%3] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
      %24 = llvm.bitcast %23 : !llvm.ptr<i8> to !llvm.ptr<f32>
      %25 = llvm.insertvalue %24, %11[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %26 = llvm.insertvalue %24, %25[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %27 = llvm.insertvalue %3, %26[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %28 = llvm.insertvalue %4, %27[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %29 = llvm.insertvalue %2, %28[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %30 = llvm.insertvalue %2, %29[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %31 = llvm.insertvalue %4, %30[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %32 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
      %33 = llvm.extractvalue %32[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
      %34 = llvm.mlir.constant(2 : index) : i64
      %35 = llvm.getelementptr %33[%34] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
      %36 = llvm.load %35 : !llvm.ptr<ptr<i8>>
      %37 = llvm.getelementptr %36[%3] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
      %38 = llvm.bitcast %37 : !llvm.ptr<i8> to !llvm.ptr<f32>
      %39 = llvm.insertvalue %38, %11[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %40 = llvm.insertvalue %38, %39[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %41 = llvm.insertvalue %3, %40[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %42 = llvm.insertvalue %4, %41[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %43 = llvm.insertvalue %2, %42[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %44 = llvm.insertvalue %2, %43[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %45 = llvm.insertvalue %4, %44[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %46 = llvm.load %arg1 : !llvm.ptr<array<3 x i32>>
      %47 = llvm.extractvalue %46[0] : !llvm.array<3 x i32>
      %48 = llvm.zext %47 : i32 to i64
      %49 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
      %50 = llvm.extractvalue %49[0] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
      %51 = llvm.extractvalue %50[0] : !llvm.array<3 x i32>
      %52 = llvm.zext %51 : i32 to i64
      %53 = llvm.load %arg1 : !llvm.ptr<array<3 x i32>>
      %54 = llvm.extractvalue %53[1] : !llvm.array<3 x i32>
      %55 = llvm.zext %54 : i32 to i64
      %56 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
      %57 = llvm.extractvalue %56[0] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
      %58 = llvm.extractvalue %57[1] : !llvm.array<3 x i32>
      %59 = llvm.zext %58 : i32 to i64
      %60 = llvm.mul %55, %2  : i64
      %61 = llvm.mul %59, %2  : i64
      llvm.br ^bb1(%60 : i64)
    ^bb1(%62: i64):  // 2 preds: ^bb0, ^bb10
      %63 = llvm.icmp "slt" %62, %4 : i64
      llvm.cond_br %63, ^bb2, ^bb11
    ^bb2:  // pred: ^bb1
      %64 = llvm.mul %48, %2  : i64
      %65 = llvm.mul %52, %2  : i64
      llvm.br ^bb3(%64 : i64)
    ^bb3(%66: i64):  // 2 preds: ^bb2, ^bb9
      %67 = llvm.icmp "slt" %66, %2 : i64
      llvm.cond_br %67, ^bb4, ^bb10
    ^bb4:  // pred: ^bb3
      %68 = llvm.mlir.constant(-1 : index) : i64
      %69 = llvm.mul %62, %68  : i64
      %70 = llvm.add %69, %4  : i64
      %71 = llvm.icmp "slt" %2, %70 : i64
      %72 = llvm.select %71, %2, %70 : i1, i64
      %73 = llvm.extractvalue %18[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %74 = llvm.bitcast %73 : !llvm.ptr<f32> to !llvm.ptr<f32>
      %75 = llvm.insertvalue %74, %11[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %76 = llvm.extractvalue %18[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %77 = llvm.bitcast %76 : !llvm.ptr<f32> to !llvm.ptr<f32>
      %78 = llvm.insertvalue %77, %75[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %79 = llvm.extractvalue %18[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %80 = llvm.extractvalue %18[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %81 = llvm.extractvalue %18[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %82 = llvm.mul %62, %79  : i64
      %83 = llvm.add %81, %82  : i64
      %84 = llvm.mul %66, %80  : i64
      %85 = llvm.add %83, %84  : i64
      %86 = llvm.insertvalue %85, %78[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %87 = llvm.mlir.constant(128 : i64) : i64
      %88 = llvm.mlir.constant(1 : i64) : i64
      %89 = llvm.insertvalue %87, %86[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %90 = llvm.insertvalue %88, %89[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %91 = llvm.insertvalue %72, %90[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %92 = llvm.insertvalue %87, %91[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %93 = llvm.extractvalue %31[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %94 = llvm.bitcast %93 : !llvm.ptr<f32> to !llvm.ptr<f32>
      %95 = llvm.insertvalue %94, %11[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %96 = llvm.extractvalue %31[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %97 = llvm.bitcast %96 : !llvm.ptr<f32> to !llvm.ptr<f32>
      %98 = llvm.insertvalue %97, %95[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %99 = llvm.extractvalue %31[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %100 = llvm.extractvalue %31[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %101 = llvm.extractvalue %31[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %102 = llvm.mul %62, %99  : i64
      %103 = llvm.add %101, %102  : i64
      %104 = llvm.mul %66, %100  : i64
      %105 = llvm.add %103, %104  : i64
      %106 = llvm.insertvalue %105, %98[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %107 = llvm.insertvalue %87, %106[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %108 = llvm.insertvalue %88, %107[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %109 = llvm.insertvalue %72, %108[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %110 = llvm.insertvalue %87, %109[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %111 = llvm.extractvalue %45[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %112 = llvm.bitcast %111 : !llvm.ptr<f32> to !llvm.ptr<f32>
      %113 = llvm.insertvalue %112, %11[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %114 = llvm.extractvalue %45[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %115 = llvm.bitcast %114 : !llvm.ptr<f32> to !llvm.ptr<f32>
      %116 = llvm.insertvalue %115, %113[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %117 = llvm.extractvalue %45[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %118 = llvm.extractvalue %45[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %119 = llvm.extractvalue %45[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %120 = llvm.mul %62, %117  : i64
      %121 = llvm.add %119, %120  : i64
      %122 = llvm.mul %66, %118  : i64
      %123 = llvm.add %121, %122  : i64
      %124 = llvm.insertvalue %123, %116[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %125 = llvm.insertvalue %87, %124[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %126 = llvm.insertvalue %88, %125[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %127 = llvm.insertvalue %72, %126[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %128 = llvm.insertvalue %87, %127[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      llvm.br ^bb5(%3 : i64)
    ^bb5(%129: i64):  // 2 preds: ^bb4, ^bb8
      %130 = llvm.icmp "slt" %129, %72 : i64
      llvm.cond_br %130, ^bb6(%3 : i64), ^bb9
    ^bb6(%131: i64):  // 2 preds: ^bb5, ^bb7
      %132 = llvm.icmp "slt" %131, %2 : i64
      llvm.cond_br %132, ^bb7, ^bb8
    ^bb7:  // pred: ^bb6
      %133 = llvm.extractvalue %92[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %134 = llvm.extractvalue %92[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %135 = llvm.mul %129, %2  : i64
      %136 = llvm.add %134, %135  : i64
      %137 = llvm.add %136, %131  : i64
      %138 = llvm.getelementptr %133[%137] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
      %139 = llvm.load %138 : !llvm.ptr<f32>
      %140 = llvm.extractvalue %110[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %141 = llvm.extractvalue %110[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %142 = llvm.add %141, %135  : i64
      %143 = llvm.add %142, %131  : i64
      %144 = llvm.getelementptr %140[%143] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
      %145 = llvm.load %144 : !llvm.ptr<f32>
      %146 = llvm.fadd %139, %145  : f32
      %147 = llvm.fcmp "ogt" %146, %1 : f32
      %148 = llvm.select %147, %146, %1 : i1, f32
      %149 = llvm.fcmp "uno" %146, %1 : f32
      %150 = llvm.select %149, %0, %148 : i1, f32
      %151 = llvm.extractvalue %128[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %152 = llvm.extractvalue %128[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %153 = llvm.add %152, %135  : i64
      %154 = llvm.add %153, %131  : i64
      %155 = llvm.getelementptr %151[%154] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
      llvm.store %150, %155 : !llvm.ptr<f32>
      %156 = llvm.add %131, %4  : i64
      llvm.br ^bb6(%156 : i64)
    ^bb8:  // pred: ^bb6
      %157 = llvm.add %129, %4  : i64
      llvm.br ^bb5(%157 : i64)
    ^bb9:  // pred: ^bb5
      %158 = llvm.add %66, %65  : i64
      llvm.br ^bb3(%158 : i64)
    ^bb10:  // pred: ^bb3
      %159 = llvm.add %62, %61  : i64
      llvm.br ^bb1(%159 : i64)
    ^bb11:  // pred: ^bb1
      %160 = llvm.mlir.constant(0 : i32) : i32
      llvm.return %160 : i32
    }
  }
}

// *** IR Dump After mlir::iree_compiler::IREE::HAL::PropagateConstantWorkgroupInfoPass ***
hal.executable.target @llvm_aot, filter="dylib*" {
  hal.executable.entry_point @predict_dispatch_2 attributes {interface = @io, ordinal = 0 : index}
  module  {
    func @predict_dispatch_2() {
      %c0 = constant 0 : index
      %cst = constant 0.000000e+00 : f32
      %c1 = constant 1 : index
      %c10 = constant 10 : index
      %0 = hal.interface.binding.subspan @io::@s0b1_ro_external[%c0] : !flow.dispatch.tensor<readonly:1x128xf32>
      %1 = hal.interface.binding.subspan @io::@s0b0_ro_constant[%c0] : !flow.dispatch.tensor<readonly:128x10xf32>
      %2 = hal.interface.binding.subspan @io::@s0b2_xw_external[%c0] : !flow.dispatch.tensor<writeonly:1x10xf32>
      %workgroup_size_x = hal.interface.workgroup.size[0] : index
      %workgroup_size_y = hal.interface.workgroup.size[1] : index
      %workgroup_id_x = hal.interface.workgroup.id[0] : index
      %workgroup_count_x = hal.interface.workgroup.count[0] : index
      %workgroup_id_y = hal.interface.workgroup.id[1] : index
      %workgroup_count_y = hal.interface.workgroup.count[1] : index
      %3 = affine.apply affine_map<()[s0, s1] -> (s0 * s1)>()[%workgroup_id_y, %workgroup_size_y]
      %4 = affine.apply affine_map<()[s0, s1] -> (s0 * s1)>()[%workgroup_count_y, %workgroup_size_y]
      scf.for %arg0 = %3 to %c1 step %4 {
        %5 = affine.apply affine_map<()[s0, s1] -> (s0 * s1)>()[%workgroup_id_x, %workgroup_size_x]
        %6 = affine.apply affine_map<()[s0, s1] -> (s0 * s1)>()[%workgroup_count_x, %workgroup_size_x]
        scf.for %arg1 = %5 to %c10 step %6 {
          %7 = affine.min affine_map<(d0)[s0] -> (s0, -d0 + 1)>(%arg0)[%workgroup_size_y]
          %8 = flow.dispatch.tensor.load %0, offsets = [%arg0, 0], sizes = [%7, 128], strides = [1, 1] : !flow.dispatch.tensor<readonly:1x128xf32> -> tensor<?x128xf32>
          %9 = affine.min affine_map<(d0)[s0] -> (s0, -d0 + 10)>(%arg1)[%workgroup_size_x]
          %10 = flow.dispatch.tensor.load %1, offsets = [0, %arg1], sizes = [128, %9], strides = [1, 1] : !flow.dispatch.tensor<readonly:128x10xf32> -> tensor<128x?xf32>
          %11 = affine.min affine_map<(d0)[s0] -> (s0, -d0 + 1)>(%arg0)[%workgroup_size_y]
          %12 = affine.min affine_map<(d0)[s0] -> (s0, -d0 + 10)>(%arg1)[%workgroup_size_x]
          %13 = affine.min affine_map<(d0)[s0] -> (-d0 + 1, s0)>(%arg0)[%workgroup_size_y]
          %14 = affine.min affine_map<(d0)[s0] -> (-d0 + 10, s0)>(%arg1)[%workgroup_size_x]
          %15 = linalg.init_tensor [%13, %14] : tensor<?x?xf32>
          %16 = linalg.fill(%15, %cst) : tensor<?x?xf32>, f32 -> tensor<?x?xf32> 
          %17 = linalg.matmul {__internal_linalg_transform__ = "workgroup"} ins(%8, %10 : tensor<?x128xf32>, tensor<128x?xf32>) outs(%16 : tensor<?x?xf32>) -> tensor<?x?xf32>
          flow.dispatch.tensor.store %17, %2, offsets = [%arg0, %arg1], sizes = [%11, %12], strides = [1, 1] : tensor<?x?xf32> -> !flow.dispatch.tensor<writeonly:1x10xf32>
        }
      }
      return
    }
    hal.interface @io attributes {sym_visibility = "private"} {
      hal.interface.binding @s0b0_ro_constant, set=0, binding=0, type="StorageBuffer", access="Read"
      hal.interface.binding @s0b1_ro_external, set=0, binding=1, type="StorageBuffer", access="Read"
      hal.interface.binding @s0b2_xw_external, set=0, binding=2, type="StorageBuffer", access="Write|Discard"
    }
  }
}

// *** IR Dump After mlir::iree_compiler::`anonymous-namespace'::SetNumWorkgroupsPass ***
hal.executable.target @llvm_aot, filter="dylib*" {
  hal.executable.entry_point @predict_dispatch_2 attributes {interface = @io, ordinal = 0 : index} {
  ^bb0(%arg0: index, %arg1: index, %arg2: index):  // no predecessors
    %c1 = constant 1 : index
    %0 = affine.apply affine_map<()[s0] -> (s0 ceildiv 64)>()[%arg0]
    %1 = affine.apply affine_map<()[s0] -> (s0 ceildiv 4)>()[%arg1]
    hal.return %0, %1, %c1 : index, index, index
  }
  module  {
    func @predict_dispatch_2() {
      %c0 = constant 0 : index
      %cst = constant 0.000000e+00 : f32
      %c1 = constant 1 : index
      %c10 = constant 10 : index
      %c64 = constant 64 : index
      %c4 = constant 4 : index
      %0 = hal.interface.binding.subspan @io::@s0b1_ro_external[%c0] : !flow.dispatch.tensor<readonly:1x128xf32>
      %1 = hal.interface.binding.subspan @io::@s0b0_ro_constant[%c0] : !flow.dispatch.tensor<readonly:128x10xf32>
      %2 = hal.interface.binding.subspan @io::@s0b2_xw_external[%c0] : !flow.dispatch.tensor<writeonly:1x10xf32>
      %workgroup_id_x = hal.interface.workgroup.id[0] : index
      %workgroup_count_x = hal.interface.workgroup.count[0] : index
      %workgroup_id_y = hal.interface.workgroup.id[1] : index
      %workgroup_count_y = hal.interface.workgroup.count[1] : index
      %3 = affine.apply affine_map<()[s0, s1] -> (s0 * s1)>()[%workgroup_id_y, %c4]
      %4 = affine.apply affine_map<()[s0, s1] -> (s0 * s1)>()[%workgroup_count_y, %c4]
      scf.for %arg0 = %3 to %c1 step %4 {
        %5 = affine.apply affine_map<()[s0, s1] -> (s0 * s1)>()[%workgroup_id_x, %c64]
        %6 = affine.apply affine_map<()[s0, s1] -> (s0 * s1)>()[%workgroup_count_x, %c64]
        scf.for %arg1 = %5 to %c10 step %6 {
          %7 = affine.min affine_map<(d0) -> (4, -d0 + 1)>(%arg0)
          %8 = flow.dispatch.tensor.load %0, offsets = [%arg0, 0], sizes = [%7, 128], strides = [1, 1] : !flow.dispatch.tensor<readonly:1x128xf32> -> tensor<?x128xf32>
          %9 = affine.min affine_map<(d0) -> (64, -d0 + 10)>(%arg1)
          %10 = flow.dispatch.tensor.load %1, offsets = [0, %arg1], sizes = [128, %9], strides = [1, 1] : !flow.dispatch.tensor<readonly:128x10xf32> -> tensor<128x?xf32>
          %11 = affine.min affine_map<(d0) -> (4, -d0 + 1)>(%arg0)
          %12 = affine.min affine_map<(d0) -> (64, -d0 + 10)>(%arg1)
          %13 = affine.min affine_map<(d0) -> (-d0 + 1, 4)>(%arg0)
          %14 = affine.min affine_map<(d0) -> (-d0 + 10, 64)>(%arg1)
          %15 = linalg.init_tensor [%13, %14] : tensor<?x?xf32>
          %16 = linalg.fill(%15, %cst) {__internal_linalg_transform__ = "workgroup", lowering.config = {tileSizes = [[4, 64]]}} : tensor<?x?xf32>, f32 -> tensor<?x?xf32> 
          %17 = linalg.matmul {__internal_linalg_transform__ = "workgroup", lowering.config = {nativeVectorSize = [4, 4, 4], tileSizes = [[4, 64], [4, 32, 32], [4, 4, 4]]}} ins(%8, %10 : tensor<?x128xf32>, tensor<128x?xf32>) outs(%16 : tensor<?x?xf32>) -> tensor<?x?xf32>
          flow.dispatch.tensor.store %17, %2, offsets = [%arg0, %arg1], sizes = [%11, %12], strides = [1, 1] : tensor<?x?xf32> -> !flow.dispatch.tensor<writeonly:1x10xf32>
        }
      }
      return
    }
    hal.interface @io attributes {sym_visibility = "private"} {
      hal.interface.binding @s0b0_ro_constant, set=0, binding=0, type="StorageBuffer", access="Read"
      hal.interface.binding @s0b1_ro_external, set=0, binding=1, type="StorageBuffer", access="Read"
      hal.interface.binding @s0b2_xw_external, set=0, binding=2, type="StorageBuffer", access="Write|Discard"
    }
  }
}

// *** IR Dump After Canonicalizer ***
module  {
  func @predict_dispatch_2() {
    %c0 = constant 0 : index
    %cst = constant 0.000000e+00 : f32
    %c1 = constant 1 : index
    %c10 = constant 10 : index
    %0 = hal.interface.binding.subspan @io::@s0b1_ro_external[%c0] : !flow.dispatch.tensor<readonly:1x128xf32>
    %1 = hal.interface.binding.subspan @io::@s0b0_ro_constant[%c0] : !flow.dispatch.tensor<readonly:128x10xf32>
    %2 = hal.interface.binding.subspan @io::@s0b2_xw_external[%c0] : !flow.dispatch.tensor<writeonly:1x10xf32>
    %workgroup_id_x = hal.interface.workgroup.id[0] : index
    %workgroup_count_x = hal.interface.workgroup.count[0] : index
    %workgroup_id_y = hal.interface.workgroup.id[1] : index
    %workgroup_count_y = hal.interface.workgroup.count[1] : index
    %3 = affine.apply affine_map<()[s0] -> (s0 * 4)>()[%workgroup_id_y]
    %4 = affine.apply affine_map<()[s0] -> (s0 * 4)>()[%workgroup_count_y]
    scf.for %arg0 = %3 to %c1 step %4 {
      %5 = affine.apply affine_map<()[s0] -> (s0 * 64)>()[%workgroup_id_x]
      %6 = affine.apply affine_map<()[s0] -> (s0 * 64)>()[%workgroup_count_x]
      scf.for %arg1 = %5 to %c10 step %6 {
        %7 = affine.min affine_map<(d0) -> (4, -d0 + 1)>(%arg0)
        %8 = flow.dispatch.tensor.load %0, offsets = [%arg0, 0], sizes = [%7, 128], strides = [1, 1] : !flow.dispatch.tensor<readonly:1x128xf32> -> tensor<?x128xf32>
        %9 = affine.min affine_map<(d0) -> (64, -d0 + 10)>(%arg1)
        %10 = flow.dispatch.tensor.load %1, offsets = [0, %arg1], sizes = [128, %9], strides = [1, 1] : !flow.dispatch.tensor<readonly:128x10xf32> -> tensor<128x?xf32>
        %11 = affine.min affine_map<(d0) -> (4, -d0 + 1)>(%arg0)
        %12 = affine.min affine_map<(d0) -> (64, -d0 + 10)>(%arg1)
        %13 = affine.min affine_map<(d0) -> (-d0 + 1, 4)>(%arg0)
        %14 = affine.min affine_map<(d0) -> (-d0 + 10, 64)>(%arg1)
        %15 = linalg.init_tensor [%13, %14] : tensor<?x?xf32>
        %16 = linalg.fill(%15, %cst) {__internal_linalg_transform__ = "workgroup", lowering.config = {tileSizes = [[4, 64]]}} : tensor<?x?xf32>, f32 -> tensor<?x?xf32> 
        %17 = linalg.matmul {__internal_linalg_transform__ = "workgroup", lowering.config = {nativeVectorSize = [4, 4, 4], tileSizes = [[4, 64], [4, 32, 32], [4, 4, 4]]}} ins(%8, %10 : tensor<?x128xf32>, tensor<128x?xf32>) outs(%16 : tensor<?x?xf32>) -> tensor<?x?xf32>
        flow.dispatch.tensor.store %17, %2, offsets = [%arg0, %arg1], sizes = [%11, %12], strides = [1, 1] : tensor<?x?xf32> -> !flow.dispatch.tensor<writeonly:1x10xf32>
      }
    }
    return
  }
  hal.interface @io attributes {sym_visibility = "private"} {
    hal.interface.binding @s0b0_ro_constant, set=0, binding=0, type="StorageBuffer", access="Read"
    hal.interface.binding @s0b1_ro_external, set=0, binding=1, type="StorageBuffer", access="Read"
    hal.interface.binding @s0b2_xw_external, set=0, binding=2, type="StorageBuffer", access="Write|Discard"
  }
}

// *** IR Dump After mlir::iree_compiler::`anonymous-namespace'::LinalgBufferizePass ***
func @predict_dispatch_2() {
  %c0 = constant 0 : index
  %cst = constant 0.000000e+00 : f32
  %c1 = constant 1 : index
  %c10 = constant 10 : index
  %0 = hal.interface.binding.subspan @io::@s0b1_ro_external[%c0] : memref<1x128xf32>
  %1 = hal.interface.binding.subspan @io::@s0b1_ro_external[%c0] : !flow.dispatch.tensor<readonly:1x128xf32>
  %2 = hal.interface.binding.subspan @io::@s0b0_ro_constant[%c0] : memref<128x10xf32>
  %3 = hal.interface.binding.subspan @io::@s0b0_ro_constant[%c0] : !flow.dispatch.tensor<readonly:128x10xf32>
  %4 = hal.interface.binding.subspan @io::@s0b2_xw_external[%c0] : memref<1x10xf32>
  %5 = hal.interface.binding.subspan @io::@s0b2_xw_external[%c0] : !flow.dispatch.tensor<writeonly:1x10xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %6 = affine.apply affine_map<()[s0] -> (s0 * 4)>()[%workgroup_id_y]
  %7 = affine.apply affine_map<()[s0] -> (s0 * 4)>()[%workgroup_count_y]
  scf.for %arg0 = %6 to %c1 step %7 {
    %8 = affine.apply affine_map<()[s0] -> (s0 * 64)>()[%workgroup_id_x]
    %9 = affine.apply affine_map<()[s0] -> (s0 * 64)>()[%workgroup_count_x]
    scf.for %arg1 = %8 to %c10 step %9 {
      %10 = affine.min affine_map<(d0) -> (4, -d0 + 1)>(%arg0)
      %11 = memref.subview %0[%arg0, 0] [%10, 128] [1, 1] : memref<1x128xf32> to memref<?x128xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
      %12 = flow.dispatch.tensor.load %1, offsets = [%arg0, 0], sizes = [%10, 128], strides = [1, 1] : !flow.dispatch.tensor<readonly:1x128xf32> -> tensor<?x128xf32>
      %13 = affine.min affine_map<(d0) -> (64, -d0 + 10)>(%arg1)
      %14 = memref.subview %2[0, %arg1] [128, %13] [1, 1] : memref<128x10xf32> to memref<128x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
      %15 = flow.dispatch.tensor.load %3, offsets = [0, %arg1], sizes = [128, %13], strides = [1, 1] : !flow.dispatch.tensor<readonly:128x10xf32> -> tensor<128x?xf32>
      %16 = affine.min affine_map<(d0) -> (4, -d0 + 1)>(%arg0)
      %17 = affine.min affine_map<(d0) -> (64, -d0 + 10)>(%arg1)
      %18 = affine.min affine_map<(d0) -> (-d0 + 1, 4)>(%arg0)
      %19 = affine.min affine_map<(d0) -> (-d0 + 10, 64)>(%arg1)
      %20 = linalg.init_tensor [%18, %19] : tensor<?x?xf32>
      %21 = memref.subview %4[%arg0, %arg1] [%16, %17] [1, 1] : memref<1x10xf32> to memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
      linalg.fill(%21, %cst) {__internal_linalg_transform__ = "workgroup", lowering.config = {tileSizes = [[4, 64]]}} : memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>, f32 
      %22 = linalg.fill(%20, %cst) {__internal_linalg_transform__ = "workgroup", lowering.config = {tileSizes = [[4, 64]]}} : tensor<?x?xf32>, f32 -> tensor<?x?xf32> 
      linalg.matmul {__internal_linalg_transform__ = "workgroup", lowering.config = {nativeVectorSize = [4, 4, 4], tileSizes = [[4, 64], [4, 32, 32], [4, 4, 4]]}} ins(%11, %14 : memref<?x128xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>, memref<128x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>) outs(%21 : memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>)
      %23 = linalg.matmul {__internal_linalg_transform__ = "workgroup", lowering.config = {nativeVectorSize = [4, 4, 4], tileSizes = [[4, 64], [4, 32, 32], [4, 4, 4]]}} ins(%12, %15 : tensor<?x128xf32>, tensor<128x?xf32>) outs(%22 : tensor<?x?xf32>) -> tensor<?x?xf32>
    }
  }
  return
}

// *** IR Dump After Canonicalizer ***
func @predict_dispatch_2() {
  %c0 = constant 0 : index
  %cst = constant 0.000000e+00 : f32
  %c1 = constant 1 : index
  %c10 = constant 10 : index
  %0 = hal.interface.binding.subspan @io::@s0b1_ro_external[%c0] : memref<1x128xf32>
  %1 = hal.interface.binding.subspan @io::@s0b1_ro_external[%c0] : !flow.dispatch.tensor<readonly:1x128xf32>
  %2 = hal.interface.binding.subspan @io::@s0b0_ro_constant[%c0] : memref<128x10xf32>
  %3 = hal.interface.binding.subspan @io::@s0b0_ro_constant[%c0] : !flow.dispatch.tensor<readonly:128x10xf32>
  %4 = hal.interface.binding.subspan @io::@s0b2_xw_external[%c0] : memref<1x10xf32>
  %5 = hal.interface.binding.subspan @io::@s0b2_xw_external[%c0] : !flow.dispatch.tensor<writeonly:1x10xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %6 = affine.apply affine_map<()[s0] -> (s0 * 4)>()[%workgroup_id_y]
  %7 = affine.apply affine_map<()[s0] -> (s0 * 4)>()[%workgroup_count_y]
  scf.for %arg0 = %6 to %c1 step %7 {
    %8 = affine.apply affine_map<()[s0] -> (s0 * 64)>()[%workgroup_id_x]
    %9 = affine.apply affine_map<()[s0] -> (s0 * 64)>()[%workgroup_count_x]
    scf.for %arg1 = %8 to %c10 step %9 {
      %10 = affine.min affine_map<(d0) -> (4, -d0 + 1)>(%arg0)
      %11 = memref.subview %0[%arg0, 0] [%10, 128] [1, 1] : memref<1x128xf32> to memref<?x128xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
      %12 = affine.min affine_map<(d0) -> (64, -d0 + 10)>(%arg1)
      %13 = memref.subview %2[0, %arg1] [128, %12] [1, 1] : memref<128x10xf32> to memref<128x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
      %14 = affine.min affine_map<(d0) -> (4, -d0 + 1)>(%arg0)
      %15 = affine.min affine_map<(d0) -> (64, -d0 + 10)>(%arg1)
      %16 = memref.subview %4[%arg0, %arg1] [%14, %15] [1, 1] : memref<1x10xf32> to memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
      linalg.fill(%16, %cst) {__internal_linalg_transform__ = "workgroup", lowering.config = {tileSizes = [[4, 64]]}} : memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>, f32 
      linalg.matmul {__internal_linalg_transform__ = "workgroup", lowering.config = {nativeVectorSize = [4, 4, 4], tileSizes = [[4, 64], [4, 32, 32], [4, 4, 4]]}} ins(%11, %13 : memref<?x128xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>, memref<128x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>) outs(%16 : memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>)
    }
  }
  return
}

// *** IR Dump After CSE ***
func @predict_dispatch_2() {
  %c0 = constant 0 : index
  %cst = constant 0.000000e+00 : f32
  %c1 = constant 1 : index
  %c10 = constant 10 : index
  %0 = hal.interface.binding.subspan @io::@s0b1_ro_external[%c0] : memref<1x128xf32>
  %1 = hal.interface.binding.subspan @io::@s0b1_ro_external[%c0] : !flow.dispatch.tensor<readonly:1x128xf32>
  %2 = hal.interface.binding.subspan @io::@s0b0_ro_constant[%c0] : memref<128x10xf32>
  %3 = hal.interface.binding.subspan @io::@s0b0_ro_constant[%c0] : !flow.dispatch.tensor<readonly:128x10xf32>
  %4 = hal.interface.binding.subspan @io::@s0b2_xw_external[%c0] : memref<1x10xf32>
  %5 = hal.interface.binding.subspan @io::@s0b2_xw_external[%c0] : !flow.dispatch.tensor<writeonly:1x10xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %6 = affine.apply affine_map<()[s0] -> (s0 * 4)>()[%workgroup_id_y]
  %7 = affine.apply affine_map<()[s0] -> (s0 * 4)>()[%workgroup_count_y]
  scf.for %arg0 = %6 to %c1 step %7 {
    %8 = affine.apply affine_map<()[s0] -> (s0 * 64)>()[%workgroup_id_x]
    %9 = affine.apply affine_map<()[s0] -> (s0 * 64)>()[%workgroup_count_x]
    scf.for %arg1 = %8 to %c10 step %9 {
      %10 = affine.min affine_map<(d0) -> (4, -d0 + 1)>(%arg0)
      %11 = memref.subview %0[%arg0, 0] [%10, 128] [1, 1] : memref<1x128xf32> to memref<?x128xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
      %12 = affine.min affine_map<(d0) -> (64, -d0 + 10)>(%arg1)
      %13 = memref.subview %2[0, %arg1] [128, %12] [1, 1] : memref<128x10xf32> to memref<128x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
      %14 = memref.subview %4[%arg0, %arg1] [%10, %12] [1, 1] : memref<1x10xf32> to memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
      linalg.fill(%14, %cst) {__internal_linalg_transform__ = "workgroup", lowering.config = {tileSizes = [[4, 64]]}} : memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>, f32 
      linalg.matmul {__internal_linalg_transform__ = "workgroup", lowering.config = {nativeVectorSize = [4, 4, 4], tileSizes = [[4, 64], [4, 32, 32], [4, 4, 4]]}} ins(%11, %13 : memref<?x128xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>, memref<128x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>) outs(%14 : memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>)
    }
  }
  return
}

// *** IR Dump After mlir::iree_compiler::`anonymous-namespace'::BufferAllocViewCleanUpPass ***
func @predict_dispatch_2() {
  %c0 = constant 0 : index
  %cst = constant 0.000000e+00 : f32
  %c1 = constant 1 : index
  %c10 = constant 10 : index
  %0 = hal.interface.binding.subspan @io::@s0b1_ro_external[%c0] : memref<1x128xf32>
  %1 = hal.interface.binding.subspan @io::@s0b0_ro_constant[%c0] : memref<128x10xf32>
  %2 = hal.interface.binding.subspan @io::@s0b2_xw_external[%c0] : memref<1x10xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 4)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 4)>()[%workgroup_count_y]
  scf.for %arg0 = %3 to %c1 step %4 {
    %5 = affine.apply affine_map<()[s0] -> (s0 * 64)>()[%workgroup_id_x]
    %6 = affine.apply affine_map<()[s0] -> (s0 * 64)>()[%workgroup_count_x]
    scf.for %arg1 = %5 to %c10 step %6 {
      %7 = affine.min affine_map<(d0) -> (4, -d0 + 1)>(%arg0)
      %8 = memref.subview %0[%arg0, 0] [%7, 128] [1, 1] : memref<1x128xf32> to memref<?x128xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
      %9 = affine.min affine_map<(d0) -> (64, -d0 + 10)>(%arg1)
      %10 = memref.subview %1[0, %arg1] [128, %9] [1, 1] : memref<128x10xf32> to memref<128x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
      %11 = memref.subview %2[%arg0, %arg1] [%7, %9] [1, 1] : memref<1x10xf32> to memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
      linalg.fill(%11, %cst) {__internal_linalg_transform__ = "workgroup", lowering.config = {tileSizes = [[4, 64]]}} : memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>, f32 
      linalg.matmul {__internal_linalg_transform__ = "workgroup", lowering.config = {nativeVectorSize = [4, 4, 4], tileSizes = [[4, 64], [4, 32, 32], [4, 4, 4]]}} ins(%8, %10 : memref<?x128xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>, memref<128x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>) outs(%11 : memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>)
    }
  }
  return
}

// *** IR Dump After Canonicalizer ***
func @predict_dispatch_2() {
  %c0 = constant 0 : index
  %cst = constant 0.000000e+00 : f32
  %c1 = constant 1 : index
  %c10 = constant 10 : index
  %0 = hal.interface.binding.subspan @io::@s0b1_ro_external[%c0] : memref<1x128xf32>
  %1 = hal.interface.binding.subspan @io::@s0b0_ro_constant[%c0] : memref<128x10xf32>
  %2 = hal.interface.binding.subspan @io::@s0b2_xw_external[%c0] : memref<1x10xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 4)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 4)>()[%workgroup_count_y]
  scf.for %arg0 = %3 to %c1 step %4 {
    %5 = affine.apply affine_map<()[s0] -> (s0 * 64)>()[%workgroup_id_x]
    %6 = affine.apply affine_map<()[s0] -> (s0 * 64)>()[%workgroup_count_x]
    scf.for %arg1 = %5 to %c10 step %6 {
      %7 = affine.min affine_map<(d0) -> (4, -d0 + 1)>(%arg0)
      %8 = memref.subview %0[%arg0, 0] [%7, 128] [1, 1] : memref<1x128xf32> to memref<?x128xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
      %9 = affine.min affine_map<(d0) -> (64, -d0 + 10)>(%arg1)
      %10 = memref.subview %1[0, %arg1] [128, %9] [1, 1] : memref<128x10xf32> to memref<128x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
      %11 = memref.subview %2[%arg0, %arg1] [%7, %9] [1, 1] : memref<1x10xf32> to memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
      linalg.fill(%11, %cst) {__internal_linalg_transform__ = "workgroup", lowering.config = {tileSizes = [[4, 64]]}} : memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>, f32 
      linalg.matmul {__internal_linalg_transform__ = "workgroup", lowering.config = {nativeVectorSize = [4, 4, 4], tileSizes = [[4, 64], [4, 32, 32], [4, 4, 4]]}} ins(%8, %10 : memref<?x128xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>, memref<128x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>) outs(%11 : memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>)
    }
  }
  return
}

// *** IR Dump After mlir::iree_compiler::`anonymous-namespace'::TileAndVectorizeWorkgroups ***
func @predict_dispatch_2() {
  %cst = constant 0.000000e+00 : f32
  %c1 = constant 1 : index
  %c10 = constant 10 : index
  %c128 = constant 128 : index
  %c4 = constant 4 : index
  %c0 = constant 0 : index
  %c32 = constant 32 : index
  %0 = hal.interface.binding.subspan @io::@s0b1_ro_external[%c0] : memref<1x128xf32>
  %1 = hal.interface.binding.subspan @io::@s0b0_ro_constant[%c0] : memref<128x10xf32>
  %2 = hal.interface.binding.subspan @io::@s0b2_xw_external[%c0] : memref<1x10xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 4)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 4)>()[%workgroup_count_y]
  scf.for %arg0 = %3 to %c1 step %4 {
    %5 = affine.apply affine_map<()[s0] -> (s0 * 64)>()[%workgroup_id_x]
    %6 = affine.apply affine_map<()[s0] -> (s0 * 64)>()[%workgroup_count_x]
    scf.for %arg1 = %5 to %c10 step %6 {
      %7 = affine.min affine_map<(d0) -> (4, -d0 + 1)>(%arg0)
      %8 = memref.subview %0[%arg0, 0] [%7, 128] [1, 1] : memref<1x128xf32> to memref<?x128xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
      %9 = affine.min affine_map<(d0) -> (64, -d0 + 10)>(%arg1)
      %10 = memref.subview %1[0, %arg1] [128, %9] [1, 1] : memref<128x10xf32> to memref<128x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
      %11 = memref.subview %2[%arg0, %arg1] [%7, %9] [1, 1] : memref<1x10xf32> to memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
      linalg.fill(%11, %cst) {__internal_linalg_transform__ = "workgroup", lowering.config = {tileSizes = [[4, 64]]}} : memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>, f32 
      scf.for %arg2 = %c0 to %7 step %c4 {
        scf.for %arg3 = %c0 to %9 step %c32 {
          scf.for %arg4 = %c0 to %c128 step %c32 {
            %12 = affine.min affine_map<(d0, d1) -> (4, d0 - d1)>(%7, %arg2)
            %13 = memref.subview %8[%arg2, %arg4] [%12, 32] [1, 1] : memref<?x128xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>> to memref<?x32xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
            %14 = affine.min affine_map<(d0, d1) -> (32, d0 - d1)>(%9, %arg3)
            %15 = memref.subview %10[%arg4, %arg3] [32, %14] [1, 1] : memref<128x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>> to memref<32x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
            %16 = affine.min affine_map<(d0, d1) -> (4, d0 - d1)>(%7, %arg2)
            %17 = affine.min affine_map<(d0, d1) -> (32, d0 - d1)>(%9, %arg3)
            %18 = memref.subview %11[%arg2, %arg3] [%16, %17] [1, 1] : memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>> to memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
            scf.for %arg5 = %c0 to %12 step %c4 {
              scf.for %arg6 = %c0 to %14 step %c4 {
                scf.for %arg7 = %c0 to %c32 step %c4 {
                  %19 = affine.min affine_map<(d0, d1) -> (4, d0 - d1)>(%12, %arg5)
                  %20 = memref.subview %13[%arg5, %arg7] [%19, 4] [1, 1] : memref<?x32xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>> to memref<?x4xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
                  %21 = affine.min affine_map<(d0, d1) -> (4, d0 - d1)>(%14, %arg6)
                  %22 = memref.subview %15[%arg7, %arg6] [4, %21] [1, 1] : memref<32x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>> to memref<4x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
                  %23 = affine.min affine_map<(d0, d1) -> (4, d0 - d1)>(%16, %arg5)
                  %24 = affine.min affine_map<(d0, d1) -> (4, d0 - d1)>(%17, %arg6)
                  %25 = memref.subview %18[%arg5, %arg6] [%23, %24] [1, 1] : memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>> to memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
                  linalg.matmul {__internal_linalg_transform__ = "vectorize", lowering.config = {nativeVectorSize = [4, 4, 4], tileSizes = [[4, 64], [4, 32, 32], [4, 4, 4]]}} ins(%20, %22 : memref<?x4xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>, memref<4x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>) outs(%25 : memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>)
                }
              }
            }
          }
        }
      }
    }
  }
  return
}

// *** IR Dump After Canonicalizer ***
func @predict_dispatch_2() {
  %cst = constant 0.000000e+00 : f32
  %c1 = constant 1 : index
  %c10 = constant 10 : index
  %c128 = constant 128 : index
  %c4 = constant 4 : index
  %c0 = constant 0 : index
  %c32 = constant 32 : index
  %0 = hal.interface.binding.subspan @io::@s0b1_ro_external[%c0] : memref<1x128xf32>
  %1 = hal.interface.binding.subspan @io::@s0b0_ro_constant[%c0] : memref<128x10xf32>
  %2 = hal.interface.binding.subspan @io::@s0b2_xw_external[%c0] : memref<1x10xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 4)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 4)>()[%workgroup_count_y]
  scf.for %arg0 = %3 to %c1 step %4 {
    %5 = affine.apply affine_map<()[s0] -> (s0 * 64)>()[%workgroup_id_x]
    %6 = affine.apply affine_map<()[s0] -> (s0 * 64)>()[%workgroup_count_x]
    scf.for %arg1 = %5 to %c10 step %6 {
      %7 = affine.min affine_map<(d0) -> (4, -d0 + 1)>(%arg0)
      %8 = memref.subview %0[%arg0, 0] [%7, 128] [1, 1] : memref<1x128xf32> to memref<?x128xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
      %9 = affine.min affine_map<(d0) -> (64, -d0 + 10)>(%arg1)
      %10 = memref.subview %1[0, %arg1] [128, %9] [1, 1] : memref<128x10xf32> to memref<128x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
      %11 = memref.subview %2[%arg0, %arg1] [%7, %9] [1, 1] : memref<1x10xf32> to memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
      linalg.fill(%11, %cst) {__internal_linalg_transform__ = "workgroup", lowering.config = {tileSizes = [[4, 64]]}} : memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>, f32 
      scf.for %arg2 = %c0 to %7 step %c4 {
        scf.for %arg3 = %c0 to %9 step %c32 {
          scf.for %arg4 = %c0 to %c128 step %c32 {
            %12 = affine.min affine_map<(d0, d1) -> (4, d0 - d1)>(%7, %arg2)
            %13 = memref.subview %8[%arg2, %arg4] [%12, 32] [1, 1] : memref<?x128xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>> to memref<?x32xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
            %14 = affine.min affine_map<(d0, d1) -> (32, d0 - d1)>(%9, %arg3)
            %15 = memref.subview %10[%arg4, %arg3] [32, %14] [1, 1] : memref<128x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>> to memref<32x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
            %16 = affine.min affine_map<(d0, d1) -> (4, d0 - d1)>(%7, %arg2)
            %17 = affine.min affine_map<(d0, d1) -> (32, d0 - d1)>(%9, %arg3)
            %18 = memref.subview %11[%arg2, %arg3] [%16, %17] [1, 1] : memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>> to memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
            scf.for %arg5 = %c0 to %12 step %c4 {
              scf.for %arg6 = %c0 to %14 step %c4 {
                scf.for %arg7 = %c0 to %c32 step %c4 {
                  %19 = affine.min affine_map<(d0, d1) -> (4, d0 - d1)>(%12, %arg5)
                  %20 = memref.subview %13[%arg5, %arg7] [%19, 4] [1, 1] : memref<?x32xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>> to memref<?x4xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
                  %21 = affine.min affine_map<(d0, d1) -> (4, d0 - d1)>(%14, %arg6)
                  %22 = memref.subview %15[%arg7, %arg6] [4, %21] [1, 1] : memref<32x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>> to memref<4x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
                  %23 = affine.min affine_map<(d0, d1) -> (4, d0 - d1)>(%16, %arg5)
                  %24 = affine.min affine_map<(d0, d1) -> (4, d0 - d1)>(%17, %arg6)
                  %25 = memref.subview %18[%arg5, %arg6] [%23, %24] [1, 1] : memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>> to memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
                  linalg.matmul {__internal_linalg_transform__ = "vectorize", lowering.config = {nativeVectorSize = [4, 4, 4], tileSizes = [[4, 64], [4, 32, 32], [4, 4, 4]]}} ins(%20, %22 : memref<?x4xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>, memref<4x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>) outs(%25 : memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>)
                }
              }
            }
          }
        }
      }
    }
  }
  return
}

// *** IR Dump After mlir::iree_compiler::`anonymous-namespace'::ForOpCanonicalizationPass ***
func @predict_dispatch_2() {
  %cst = constant 0.000000e+00 : f32
  %c1 = constant 1 : index
  %c10 = constant 10 : index
  %c128 = constant 128 : index
  %c4 = constant 4 : index
  %c0 = constant 0 : index
  %c32 = constant 32 : index
  %0 = hal.interface.binding.subspan @io::@s0b1_ro_external[%c0] : memref<1x128xf32>
  %1 = hal.interface.binding.subspan @io::@s0b0_ro_constant[%c0] : memref<128x10xf32>
  %2 = hal.interface.binding.subspan @io::@s0b2_xw_external[%c0] : memref<1x10xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 4)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 4)>()[%workgroup_count_y]
  scf.for %arg0 = %3 to %c1 step %4 {
    %5 = affine.apply affine_map<()[s0] -> (s0 * 64)>()[%workgroup_id_x]
    %6 = affine.apply affine_map<()[s0] -> (s0 * 64)>()[%workgroup_count_x]
    scf.for %arg1 = %5 to %c10 step %6 {
      %7 = affine.min affine_map<(d0) -> (4, -d0 + 1)>(%arg0)
      %8 = memref.subview %0[%arg0, 0] [%7, 128] [1, 1] : memref<1x128xf32> to memref<?x128xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
      %9 = affine.min affine_map<(d0) -> (64, -d0 + 10)>(%arg1)
      %10 = memref.subview %1[0, %arg1] [128, %9] [1, 1] : memref<128x10xf32> to memref<128x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
      %11 = memref.subview %2[%arg0, %arg1] [%7, %9] [1, 1] : memref<1x10xf32> to memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
      linalg.fill(%11, %cst) {__internal_linalg_transform__ = "workgroup", lowering.config = {tileSizes = [[4, 64]]}} : memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>, f32 
      scf.for %arg2 = %c0 to %7 step %c4 {
        scf.for %arg3 = %c0 to %9 step %c32 {
          scf.for %arg4 = %c0 to %c128 step %c32 {
            %12 = affine.min affine_map<(d0, d1) -> (4, d0 - d1)>(%7, %arg2)
            %13 = memref.subview %8[%arg2, %arg4] [%12, 32] [1, 1] : memref<?x128xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>> to memref<?x32xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
            %14 = affine.min affine_map<(d0, d1) -> (32, d0 - d1)>(%9, %arg3)
            %15 = memref.subview %10[%arg4, %arg3] [32, %14] [1, 1] : memref<128x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>> to memref<32x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
            %16 = affine.min affine_map<(d0, d1) -> (4, d0 - d1)>(%7, %arg2)
            %17 = affine.min affine_map<(d0, d1) -> (32, d0 - d1)>(%9, %arg3)
            %18 = memref.subview %11[%arg2, %arg3] [%16, %17] [1, 1] : memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>> to memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
            scf.for %arg5 = %c0 to %12 step %c4 {
              scf.for %arg6 = %c0 to %14 step %c4 {
                scf.for %arg7 = %c0 to %c32 step %c4 {
                  %19 = affine.min affine_map<(d0, d1) -> (4, d0 - d1)>(%12, %arg5)
                  %20 = memref.subview %13[%arg5, %arg7] [%19, 4] [1, 1] : memref<?x32xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>> to memref<?x4xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
                  %21 = affine.min affine_map<(d0, d1) -> (4, d0 - d1)>(%14, %arg6)
                  %22 = memref.subview %15[%arg7, %arg6] [4, %21] [1, 1] : memref<32x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>> to memref<4x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
                  %23 = affine.min affine_map<(d0, d1) -> (4, d0 - d1)>(%16, %arg5)
                  %24 = affine.min affine_map<(d0, d1) -> (4, d0 - d1)>(%17, %arg6)
                  %25 = memref.subview %18[%arg5, %arg6] [%23, %24] [1, 1] : memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>> to memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
                  linalg.matmul {__internal_linalg_transform__ = "vectorize", lowering.config = {nativeVectorSize = [4, 4, 4], tileSizes = [[4, 64], [4, 32, 32], [4, 4, 4]]}} ins(%20, %22 : memref<?x4xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>, memref<4x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>) outs(%25 : memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>)
                }
              }
            }
          }
        }
      }
    }
  }
  return
}

// *** IR Dump After mlir::iree_compiler::`anonymous-namespace'::PlanConvLoopOrderPass ***
func @predict_dispatch_2() {
  %cst = constant 0.000000e+00 : f32
  %c1 = constant 1 : index
  %c10 = constant 10 : index
  %c128 = constant 128 : index
  %c4 = constant 4 : index
  %c0 = constant 0 : index
  %c32 = constant 32 : index
  %0 = hal.interface.binding.subspan @io::@s0b1_ro_external[%c0] : memref<1x128xf32>
  %1 = hal.interface.binding.subspan @io::@s0b0_ro_constant[%c0] : memref<128x10xf32>
  %2 = hal.interface.binding.subspan @io::@s0b2_xw_external[%c0] : memref<1x10xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 4)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 4)>()[%workgroup_count_y]
  scf.for %arg0 = %3 to %c1 step %4 {
    %5 = affine.apply affine_map<()[s0] -> (s0 * 64)>()[%workgroup_id_x]
    %6 = affine.apply affine_map<()[s0] -> (s0 * 64)>()[%workgroup_count_x]
    scf.for %arg1 = %5 to %c10 step %6 {
      %7 = affine.min affine_map<(d0) -> (4, -d0 + 1)>(%arg0)
      %8 = memref.subview %0[%arg0, 0] [%7, 128] [1, 1] : memref<1x128xf32> to memref<?x128xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
      %9 = affine.min affine_map<(d0) -> (64, -d0 + 10)>(%arg1)
      %10 = memref.subview %1[0, %arg1] [128, %9] [1, 1] : memref<128x10xf32> to memref<128x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
      %11 = memref.subview %2[%arg0, %arg1] [%7, %9] [1, 1] : memref<1x10xf32> to memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
      linalg.fill(%11, %cst) {__internal_linalg_transform__ = "workgroup", lowering.config = {tileSizes = [[4, 64]]}} : memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>, f32 
      scf.for %arg2 = %c0 to %7 step %c4 {
        scf.for %arg3 = %c0 to %9 step %c32 {
          scf.for %arg4 = %c0 to %c128 step %c32 {
            %12 = affine.min affine_map<(d0, d1) -> (4, d0 - d1)>(%7, %arg2)
            %13 = memref.subview %8[%arg2, %arg4] [%12, 32] [1, 1] : memref<?x128xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>> to memref<?x32xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
            %14 = affine.min affine_map<(d0, d1) -> (32, d0 - d1)>(%9, %arg3)
            %15 = memref.subview %10[%arg4, %arg3] [32, %14] [1, 1] : memref<128x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>> to memref<32x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
            %16 = affine.min affine_map<(d0, d1) -> (4, d0 - d1)>(%7, %arg2)
            %17 = affine.min affine_map<(d0, d1) -> (32, d0 - d1)>(%9, %arg3)
            %18 = memref.subview %11[%arg2, %arg3] [%16, %17] [1, 1] : memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>> to memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
            scf.for %arg5 = %c0 to %12 step %c4 {
              scf.for %arg6 = %c0 to %14 step %c4 {
                scf.for %arg7 = %c0 to %c32 step %c4 {
                  %19 = affine.min affine_map<(d0, d1) -> (4, d0 - d1)>(%12, %arg5)
                  %20 = memref.subview %13[%arg5, %arg7] [%19, 4] [1, 1] : memref<?x32xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>> to memref<?x4xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
                  %21 = affine.min affine_map<(d0, d1) -> (4, d0 - d1)>(%14, %arg6)
                  %22 = memref.subview %15[%arg7, %arg6] [4, %21] [1, 1] : memref<32x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>> to memref<4x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
                  %23 = affine.min affine_map<(d0, d1) -> (4, d0 - d1)>(%16, %arg5)
                  %24 = affine.min affine_map<(d0, d1) -> (4, d0 - d1)>(%17, %arg6)
                  %25 = memref.subview %18[%arg5, %arg6] [%23, %24] [1, 1] : memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>> to memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
                  linalg.matmul {__internal_linalg_transform__ = "vectorize", lowering.config = {nativeVectorSize = [4, 4, 4], tileSizes = [[4, 64], [4, 32, 32], [4, 4, 4]]}} ins(%20, %22 : memref<?x4xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>, memref<4x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>) outs(%25 : memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>)
                }
              }
            }
          }
        }
      }
    }
  }
  return
}

// *** IR Dump After LinalgLowerToLoops ***
func @predict_dispatch_2() {
  %cst = constant 0.000000e+00 : f32
  %c10 = constant 10 : index
  %c128 = constant 128 : index
  %c32 = constant 32 : index
  %c4 = constant 4 : index
  %c0 = constant 0 : index
  %c1 = constant 1 : index
  %0 = hal.interface.binding.subspan @io::@s0b1_ro_external[%c0] : memref<1x128xf32>
  %1 = hal.interface.binding.subspan @io::@s0b0_ro_constant[%c0] : memref<128x10xf32>
  %2 = hal.interface.binding.subspan @io::@s0b2_xw_external[%c0] : memref<1x10xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 4)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 4)>()[%workgroup_count_y]
  scf.for %arg0 = %3 to %c1 step %4 {
    %5 = affine.apply affine_map<()[s0] -> (s0 * 64)>()[%workgroup_id_x]
    %6 = affine.apply affine_map<()[s0] -> (s0 * 64)>()[%workgroup_count_x]
    scf.for %arg1 = %5 to %c10 step %6 {
      %7 = affine.min affine_map<(d0) -> (4, -d0 + 1)>(%arg0)
      %8 = memref.subview %0[%arg0, 0] [%7, 128] [1, 1] : memref<1x128xf32> to memref<?x128xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
      %9 = affine.min affine_map<(d0) -> (64, -d0 + 10)>(%arg1)
      %10 = memref.subview %1[0, %arg1] [128, %9] [1, 1] : memref<128x10xf32> to memref<128x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
      %11 = memref.subview %2[%arg0, %arg1] [%7, %9] [1, 1] : memref<1x10xf32> to memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
      scf.for %arg2 = %c0 to %7 step %c1 {
        scf.for %arg3 = %c0 to %9 step %c1 {
          memref.store %cst, %11[%arg2, %arg3] : memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
        }
      }
      scf.for %arg2 = %c0 to %7 step %c4 {
        scf.for %arg3 = %c0 to %9 step %c32 {
          scf.for %arg4 = %c0 to %c128 step %c32 {
            %12 = affine.min affine_map<(d0, d1) -> (4, d0 - d1)>(%7, %arg2)
            %13 = memref.subview %8[%arg2, %arg4] [%12, 32] [1, 1] : memref<?x128xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>> to memref<?x32xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
            %14 = affine.min affine_map<(d0, d1) -> (32, d0 - d1)>(%9, %arg3)
            %15 = memref.subview %10[%arg4, %arg3] [32, %14] [1, 1] : memref<128x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>> to memref<32x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
            %16 = affine.min affine_map<(d0, d1) -> (4, d0 - d1)>(%7, %arg2)
            %17 = affine.min affine_map<(d0, d1) -> (32, d0 - d1)>(%9, %arg3)
            %18 = memref.subview %11[%arg2, %arg3] [%16, %17] [1, 1] : memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>> to memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
            scf.for %arg5 = %c0 to %12 step %c4 {
              scf.for %arg6 = %c0 to %14 step %c4 {
                scf.for %arg7 = %c0 to %c32 step %c4 {
                  %19 = affine.min affine_map<(d0, d1) -> (4, d0 - d1)>(%12, %arg5)
                  %20 = memref.subview %13[%arg5, %arg7] [%19, 4] [1, 1] : memref<?x32xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>> to memref<?x4xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
                  %21 = affine.min affine_map<(d0, d1) -> (4, d0 - d1)>(%14, %arg6)
                  %22 = memref.subview %15[%arg7, %arg6] [4, %21] [1, 1] : memref<32x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>> to memref<4x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
                  %23 = affine.min affine_map<(d0, d1) -> (4, d0 - d1)>(%16, %arg5)
                  %24 = affine.min affine_map<(d0, d1) -> (4, d0 - d1)>(%17, %arg6)
                  %25 = memref.subview %18[%arg5, %arg6] [%23, %24] [1, 1] : memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>> to memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
                  scf.for %arg8 = %c0 to %19 step %c1 {
                    scf.for %arg9 = %c0 to %21 step %c1 {
                      scf.for %arg10 = %c0 to %c4 step %c1 {
                        %26 = memref.load %20[%arg8, %arg10] : memref<?x4xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
                        %27 = memref.load %22[%arg10, %arg9] : memref<4x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
                        %28 = memref.load %25[%arg8, %arg9] : memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
                        %29 = mulf %26, %27 : f32
                        %30 = addf %28, %29 : f32
                        memref.store %30, %25[%arg8, %arg9] : memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return
}

// *** IR Dump After Canonicalizer ***
func @predict_dispatch_2() {
  %cst = constant 0.000000e+00 : f32
  %c10 = constant 10 : index
  %c128 = constant 128 : index
  %c32 = constant 32 : index
  %c4 = constant 4 : index
  %c0 = constant 0 : index
  %c1 = constant 1 : index
  %0 = hal.interface.binding.subspan @io::@s0b1_ro_external[%c0] : memref<1x128xf32>
  %1 = hal.interface.binding.subspan @io::@s0b0_ro_constant[%c0] : memref<128x10xf32>
  %2 = hal.interface.binding.subspan @io::@s0b2_xw_external[%c0] : memref<1x10xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 4)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 4)>()[%workgroup_count_y]
  scf.for %arg0 = %3 to %c1 step %4 {
    %5 = affine.apply affine_map<()[s0] -> (s0 * 64)>()[%workgroup_id_x]
    %6 = affine.apply affine_map<()[s0] -> (s0 * 64)>()[%workgroup_count_x]
    scf.for %arg1 = %5 to %c10 step %6 {
      %7 = affine.min affine_map<(d0) -> (4, -d0 + 1)>(%arg0)
      %8 = memref.subview %0[%arg0, 0] [%7, 128] [1, 1] : memref<1x128xf32> to memref<?x128xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
      %9 = affine.min affine_map<(d0) -> (64, -d0 + 10)>(%arg1)
      %10 = memref.subview %1[0, %arg1] [128, %9] [1, 1] : memref<128x10xf32> to memref<128x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
      %11 = memref.subview %2[%arg0, %arg1] [%7, %9] [1, 1] : memref<1x10xf32> to memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
      scf.for %arg2 = %c0 to %7 step %c1 {
        scf.for %arg3 = %c0 to %9 step %c1 {
          memref.store %cst, %11[%arg2, %arg3] : memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
        }
      }
      scf.for %arg2 = %c0 to %7 step %c4 {
        scf.for %arg3 = %c0 to %9 step %c32 {
          scf.for %arg4 = %c0 to %c128 step %c32 {
            %12 = affine.min affine_map<(d0, d1) -> (4, d0 - d1)>(%7, %arg2)
            %13 = memref.subview %8[%arg2, %arg4] [%12, 32] [1, 1] : memref<?x128xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>> to memref<?x32xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
            %14 = affine.min affine_map<(d0, d1) -> (32, d0 - d1)>(%9, %arg3)
            %15 = memref.subview %10[%arg4, %arg3] [32, %14] [1, 1] : memref<128x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>> to memref<32x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
            %16 = affine.min affine_map<(d0, d1) -> (4, d0 - d1)>(%7, %arg2)
            %17 = affine.min affine_map<(d0, d1) -> (32, d0 - d1)>(%9, %arg3)
            %18 = memref.subview %11[%arg2, %arg3] [%16, %17] [1, 1] : memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>> to memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
            scf.for %arg5 = %c0 to %12 step %c4 {
              scf.for %arg6 = %c0 to %14 step %c4 {
                scf.for %arg7 = %c0 to %c32 step %c4 {
                  %19 = affine.min affine_map<(d0, d1) -> (4, d0 - d1)>(%12, %arg5)
                  %20 = memref.subview %13[%arg5, %arg7] [%19, 4] [1, 1] : memref<?x32xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>> to memref<?x4xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
                  %21 = affine.min affine_map<(d0, d1) -> (4, d0 - d1)>(%14, %arg6)
                  %22 = memref.subview %15[%arg7, %arg6] [4, %21] [1, 1] : memref<32x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>> to memref<4x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
                  %23 = affine.min affine_map<(d0, d1) -> (4, d0 - d1)>(%16, %arg5)
                  %24 = affine.min affine_map<(d0, d1) -> (4, d0 - d1)>(%17, %arg6)
                  %25 = memref.subview %18[%arg5, %arg6] [%23, %24] [1, 1] : memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>> to memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
                  scf.for %arg8 = %c0 to %19 step %c1 {
                    scf.for %arg9 = %c0 to %21 step %c1 {
                      scf.for %arg10 = %c0 to %c4 step %c1 {
                        %26 = memref.load %20[%arg8, %arg10] : memref<?x4xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
                        %27 = memref.load %22[%arg10, %arg9] : memref<4x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
                        %28 = memref.load %25[%arg8, %arg9] : memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
                        %29 = mulf %26, %27 : f32
                        %30 = addf %28, %29 : f32
                        memref.store %30, %25[%arg8, %arg9] : memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return
}

// *** IR Dump After CSE ***
func @predict_dispatch_2() {
  %cst = constant 0.000000e+00 : f32
  %c10 = constant 10 : index
  %c128 = constant 128 : index
  %c32 = constant 32 : index
  %c4 = constant 4 : index
  %c0 = constant 0 : index
  %c1 = constant 1 : index
  %0 = hal.interface.binding.subspan @io::@s0b1_ro_external[%c0] : memref<1x128xf32>
  %1 = hal.interface.binding.subspan @io::@s0b0_ro_constant[%c0] : memref<128x10xf32>
  %2 = hal.interface.binding.subspan @io::@s0b2_xw_external[%c0] : memref<1x10xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 4)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 4)>()[%workgroup_count_y]
  scf.for %arg0 = %3 to %c1 step %4 {
    %5 = affine.apply affine_map<()[s0] -> (s0 * 64)>()[%workgroup_id_x]
    %6 = affine.apply affine_map<()[s0] -> (s0 * 64)>()[%workgroup_count_x]
    scf.for %arg1 = %5 to %c10 step %6 {
      %7 = affine.min affine_map<(d0) -> (4, -d0 + 1)>(%arg0)
      %8 = memref.subview %0[%arg0, 0] [%7, 128] [1, 1] : memref<1x128xf32> to memref<?x128xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
      %9 = affine.min affine_map<(d0) -> (64, -d0 + 10)>(%arg1)
      %10 = memref.subview %1[0, %arg1] [128, %9] [1, 1] : memref<128x10xf32> to memref<128x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
      %11 = memref.subview %2[%arg0, %arg1] [%7, %9] [1, 1] : memref<1x10xf32> to memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
      scf.for %arg2 = %c0 to %7 step %c1 {
        scf.for %arg3 = %c0 to %9 step %c1 {
          memref.store %cst, %11[%arg2, %arg3] : memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
        }
      }
      scf.for %arg2 = %c0 to %7 step %c4 {
        scf.for %arg3 = %c0 to %9 step %c32 {
          scf.for %arg4 = %c0 to %c128 step %c32 {
            %12 = affine.min affine_map<(d0, d1) -> (4, d0 - d1)>(%7, %arg2)
            %13 = memref.subview %8[%arg2, %arg4] [%12, 32] [1, 1] : memref<?x128xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>> to memref<?x32xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
            %14 = affine.min affine_map<(d0, d1) -> (32, d0 - d1)>(%9, %arg3)
            %15 = memref.subview %10[%arg4, %arg3] [32, %14] [1, 1] : memref<128x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>> to memref<32x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
            %16 = memref.subview %11[%arg2, %arg3] [%12, %14] [1, 1] : memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>> to memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
            scf.for %arg5 = %c0 to %12 step %c4 {
              scf.for %arg6 = %c0 to %14 step %c4 {
                scf.for %arg7 = %c0 to %c32 step %c4 {
                  %17 = affine.min affine_map<(d0, d1) -> (4, d0 - d1)>(%12, %arg5)
                  %18 = memref.subview %13[%arg5, %arg7] [%17, 4] [1, 1] : memref<?x32xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>> to memref<?x4xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
                  %19 = affine.min affine_map<(d0, d1) -> (4, d0 - d1)>(%14, %arg6)
                  %20 = memref.subview %15[%arg7, %arg6] [4, %19] [1, 1] : memref<32x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>> to memref<4x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
                  %21 = memref.subview %16[%arg5, %arg6] [%17, %19] [1, 1] : memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>> to memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
                  scf.for %arg8 = %c0 to %17 step %c1 {
                    scf.for %arg9 = %c0 to %19 step %c1 {
                      scf.for %arg10 = %c0 to %c4 step %c1 {
                        %22 = memref.load %18[%arg8, %arg10] : memref<?x4xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
                        %23 = memref.load %20[%arg10, %arg9] : memref<4x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
                        %24 = memref.load %21[%arg8, %arg9] : memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
                        %25 = mulf %22, %23 : f32
                        %26 = addf %24, %25 : f32
                        memref.store %26, %21[%arg8, %arg9] : memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return
}

// *** IR Dump After SCFToStandard ***
func @predict_dispatch_2() {
  %cst = constant 0.000000e+00 : f32
  %c10 = constant 10 : index
  %c128 = constant 128 : index
  %c32 = constant 32 : index
  %c4 = constant 4 : index
  %c0 = constant 0 : index
  %c1 = constant 1 : index
  %0 = hal.interface.binding.subspan @io::@s0b1_ro_external[%c0] : memref<1x128xf32>
  %1 = hal.interface.binding.subspan @io::@s0b0_ro_constant[%c0] : memref<128x10xf32>
  %2 = hal.interface.binding.subspan @io::@s0b2_xw_external[%c0] : memref<1x10xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 4)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 4)>()[%workgroup_count_y]
  br ^bb1(%3 : index)
^bb1(%5: index):  // 2 preds: ^bb0, ^bb38
  %6 = cmpi slt, %5, %c1 : index
  cond_br %6, ^bb2, ^bb39
^bb2:  // pred: ^bb1
  %7 = affine.apply affine_map<()[s0] -> (s0 * 64)>()[%workgroup_id_x]
  %8 = affine.apply affine_map<()[s0] -> (s0 * 64)>()[%workgroup_count_x]
  br ^bb3(%7 : index)
^bb3(%9: index):  // 2 preds: ^bb2, ^bb37
  %10 = cmpi slt, %9, %c10 : index
  cond_br %10, ^bb4, ^bb38
^bb4:  // pred: ^bb3
  %11 = affine.min affine_map<(d0) -> (4, -d0 + 1)>(%5)
  %12 = memref.subview %0[%5, 0] [%11, 128] [1, 1] : memref<1x128xf32> to memref<?x128xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
  %13 = affine.min affine_map<(d0) -> (64, -d0 + 10)>(%9)
  %14 = memref.subview %1[0, %9] [128, %13] [1, 1] : memref<128x10xf32> to memref<128x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
  %15 = memref.subview %2[%5, %9] [%11, %13] [1, 1] : memref<1x10xf32> to memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
  br ^bb5(%c0 : index)
^bb5(%16: index):  // 2 preds: ^bb4, ^bb9
  %17 = cmpi slt, %16, %11 : index
  cond_br %17, ^bb6, ^bb10
^bb6:  // pred: ^bb5
  br ^bb7(%c0 : index)
^bb7(%18: index):  // 2 preds: ^bb6, ^bb8
  %19 = cmpi slt, %18, %13 : index
  cond_br %19, ^bb8, ^bb9
^bb8:  // pred: ^bb7
  memref.store %cst, %15[%16, %18] : memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
  %20 = addi %18, %c1 : index
  br ^bb7(%20 : index)
^bb9:  // pred: ^bb7
  %21 = addi %16, %c1 : index
  br ^bb5(%21 : index)
^bb10:  // pred: ^bb5
  br ^bb11(%c0 : index)
^bb11(%22: index):  // 2 preds: ^bb10, ^bb36
  %23 = cmpi slt, %22, %11 : index
  cond_br %23, ^bb12, ^bb37
^bb12:  // pred: ^bb11
  br ^bb13(%c0 : index)
^bb13(%24: index):  // 2 preds: ^bb12, ^bb35
  %25 = cmpi slt, %24, %13 : index
  cond_br %25, ^bb14, ^bb36
^bb14:  // pred: ^bb13
  br ^bb15(%c0 : index)
^bb15(%26: index):  // 2 preds: ^bb14, ^bb34
  %27 = cmpi slt, %26, %c128 : index
  cond_br %27, ^bb16, ^bb35
^bb16:  // pred: ^bb15
  %28 = affine.min affine_map<(d0, d1) -> (4, d0 - d1)>(%11, %22)
  %29 = memref.subview %12[%22, %26] [%28, 32] [1, 1] : memref<?x128xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>> to memref<?x32xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
  %30 = affine.min affine_map<(d0, d1) -> (32, d0 - d1)>(%13, %24)
  %31 = memref.subview %14[%26, %24] [32, %30] [1, 1] : memref<128x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>> to memref<32x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
  %32 = memref.subview %15[%22, %24] [%28, %30] [1, 1] : memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>> to memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
  br ^bb17(%c0 : index)
^bb17(%33: index):  // 2 preds: ^bb16, ^bb33
  %34 = cmpi slt, %33, %28 : index
  cond_br %34, ^bb18, ^bb34
^bb18:  // pred: ^bb17
  br ^bb19(%c0 : index)
^bb19(%35: index):  // 2 preds: ^bb18, ^bb32
  %36 = cmpi slt, %35, %30 : index
  cond_br %36, ^bb20, ^bb33
^bb20:  // pred: ^bb19
  br ^bb21(%c0 : index)
^bb21(%37: index):  // 2 preds: ^bb20, ^bb31
  %38 = cmpi slt, %37, %c32 : index
  cond_br %38, ^bb22, ^bb32
^bb22:  // pred: ^bb21
  %39 = affine.min affine_map<(d0, d1) -> (4, d0 - d1)>(%28, %33)
  %40 = memref.subview %29[%33, %37] [%39, 4] [1, 1] : memref<?x32xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>> to memref<?x4xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
  %41 = affine.min affine_map<(d0, d1) -> (4, d0 - d1)>(%30, %35)
  %42 = memref.subview %31[%37, %35] [4, %41] [1, 1] : memref<32x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>> to memref<4x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
  %43 = memref.subview %32[%33, %35] [%39, %41] [1, 1] : memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>> to memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
  br ^bb23(%c0 : index)
^bb23(%44: index):  // 2 preds: ^bb22, ^bb30
  %45 = cmpi slt, %44, %39 : index
  cond_br %45, ^bb24, ^bb31
^bb24:  // pred: ^bb23
  br ^bb25(%c0 : index)
^bb25(%46: index):  // 2 preds: ^bb24, ^bb29
  %47 = cmpi slt, %46, %41 : index
  cond_br %47, ^bb26, ^bb30
^bb26:  // pred: ^bb25
  br ^bb27(%c0 : index)
^bb27(%48: index):  // 2 preds: ^bb26, ^bb28
  %49 = cmpi slt, %48, %c4 : index
  cond_br %49, ^bb28, ^bb29
^bb28:  // pred: ^bb27
  %50 = memref.load %40[%44, %48] : memref<?x4xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
  %51 = memref.load %42[%48, %46] : memref<4x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
  %52 = memref.load %43[%44, %46] : memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
  %53 = mulf %50, %51 : f32
  %54 = addf %52, %53 : f32
  memref.store %54, %43[%44, %46] : memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
  %55 = addi %48, %c1 : index
  br ^bb27(%55 : index)
^bb29:  // pred: ^bb27
  %56 = addi %46, %c1 : index
  br ^bb25(%56 : index)
^bb30:  // pred: ^bb25
  %57 = addi %44, %c1 : index
  br ^bb23(%57 : index)
^bb31:  // pred: ^bb23
  %58 = addi %37, %c4 : index
  br ^bb21(%58 : index)
^bb32:  // pred: ^bb21
  %59 = addi %35, %c4 : index
  br ^bb19(%59 : index)
^bb33:  // pred: ^bb19
  %60 = addi %33, %c4 : index
  br ^bb17(%60 : index)
^bb34:  // pred: ^bb17
  %61 = addi %26, %c32 : index
  br ^bb15(%61 : index)
^bb35:  // pred: ^bb15
  %62 = addi %24, %c32 : index
  br ^bb13(%62 : index)
^bb36:  // pred: ^bb13
  %63 = addi %22, %c4 : index
  br ^bb11(%63 : index)
^bb37:  // pred: ^bb11
  %64 = addi %9, %8 : index
  br ^bb3(%64 : index)
^bb38:  // pred: ^bb3
  %65 = addi %5, %4 : index
  br ^bb1(%65 : index)
^bb39:  // pred: ^bb1
  return
}

// *** IR Dump After Canonicalizer ***
func @predict_dispatch_2() {
  %cst = constant 0.000000e+00 : f32
  %c10 = constant 10 : index
  %c128 = constant 128 : index
  %c32 = constant 32 : index
  %c4 = constant 4 : index
  %c0 = constant 0 : index
  %c1 = constant 1 : index
  %0 = hal.interface.binding.subspan @io::@s0b1_ro_external[%c0] : memref<1x128xf32>
  %1 = hal.interface.binding.subspan @io::@s0b0_ro_constant[%c0] : memref<128x10xf32>
  %2 = hal.interface.binding.subspan @io::@s0b2_xw_external[%c0] : memref<1x10xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 4)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 4)>()[%workgroup_count_y]
  br ^bb1(%3 : index)
^bb1(%5: index):  // 2 preds: ^bb0, ^bb30
  %6 = cmpi slt, %5, %c1 : index
  cond_br %6, ^bb2, ^bb31
^bb2:  // pred: ^bb1
  %7 = affine.apply affine_map<()[s0] -> (s0 * 64)>()[%workgroup_id_x]
  %8 = affine.apply affine_map<()[s0] -> (s0 * 64)>()[%workgroup_count_x]
  br ^bb3(%7 : index)
^bb3(%9: index):  // 2 preds: ^bb2, ^bb29
  %10 = cmpi slt, %9, %c10 : index
  cond_br %10, ^bb4, ^bb30
^bb4:  // pred: ^bb3
  %11 = affine.min affine_map<()[s0] -> (4, -s0 + 1)>()[%5]
  %12 = memref.subview %0[%5, 0] [%11, 128] [1, 1] : memref<1x128xf32> to memref<?x128xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
  %13 = affine.min affine_map<()[s0] -> (64, -s0 + 10)>()[%9]
  %14 = memref.subview %1[0, %9] [128, %13] [1, 1] : memref<128x10xf32> to memref<128x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
  %15 = memref.subview %2[%5, %9] [%11, %13] [1, 1] : memref<1x10xf32> to memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
  br ^bb5(%c0 : index)
^bb5(%16: index):  // 2 preds: ^bb4, ^bb8
  %17 = cmpi slt, %16, %11 : index
  cond_br %17, ^bb6(%c0 : index), ^bb9(%c0 : index)
^bb6(%18: index):  // 2 preds: ^bb5, ^bb7
  %19 = cmpi slt, %18, %13 : index
  cond_br %19, ^bb7, ^bb8
^bb7:  // pred: ^bb6
  memref.store %cst, %15[%16, %18] : memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
  %20 = addi %18, %c1 : index
  br ^bb6(%20 : index)
^bb8:  // pred: ^bb6
  %21 = addi %16, %c1 : index
  br ^bb5(%21 : index)
^bb9(%22: index):  // 2 preds: ^bb5, ^bb28
  %23 = cmpi slt, %22, %11 : index
  cond_br %23, ^bb10(%c0 : index), ^bb29
^bb10(%24: index):  // 2 preds: ^bb9, ^bb27
  %25 = cmpi slt, %24, %13 : index
  cond_br %25, ^bb11(%c0 : index), ^bb28
^bb11(%26: index):  // 2 preds: ^bb10, ^bb26
  %27 = cmpi slt, %26, %c128 : index
  cond_br %27, ^bb12, ^bb27
^bb12:  // pred: ^bb11
  %28 = affine.min affine_map<()[s0, s1] -> (4, s0 - s1)>()[%11, %22]
  %29 = memref.subview %12[%22, %26] [%28, 32] [1, 1] : memref<?x128xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>> to memref<?x32xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
  %30 = affine.min affine_map<()[s0, s1] -> (32, s0 - s1)>()[%13, %24]
  %31 = memref.subview %14[%26, %24] [32, %30] [1, 1] : memref<128x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>> to memref<32x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
  %32 = memref.subview %15[%22, %24] [%28, %30] [1, 1] : memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>> to memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
  br ^bb13(%c0 : index)
^bb13(%33: index):  // 2 preds: ^bb12, ^bb25
  %34 = cmpi slt, %33, %28 : index
  cond_br %34, ^bb14(%c0 : index), ^bb26
^bb14(%35: index):  // 2 preds: ^bb13, ^bb24
  %36 = cmpi slt, %35, %30 : index
  cond_br %36, ^bb15(%c0 : index), ^bb25
^bb15(%37: index):  // 2 preds: ^bb14, ^bb23
  %38 = cmpi slt, %37, %c32 : index
  cond_br %38, ^bb16, ^bb24
^bb16:  // pred: ^bb15
  %39 = affine.min affine_map<()[s0, s1] -> (4, s0 - s1)>()[%28, %33]
  %40 = memref.subview %29[%33, %37] [%39, 4] [1, 1] : memref<?x32xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>> to memref<?x4xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
  %41 = affine.min affine_map<()[s0, s1] -> (4, s0 - s1)>()[%30, %35]
  %42 = memref.subview %31[%37, %35] [4, %41] [1, 1] : memref<32x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>> to memref<4x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
  %43 = memref.subview %32[%33, %35] [%39, %41] [1, 1] : memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>> to memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
  br ^bb17(%c0 : index)
^bb17(%44: index):  // 2 preds: ^bb16, ^bb22
  %45 = cmpi slt, %44, %39 : index
  cond_br %45, ^bb18(%c0 : index), ^bb23
^bb18(%46: index):  // 2 preds: ^bb17, ^bb21
  %47 = cmpi slt, %46, %41 : index
  cond_br %47, ^bb19(%c0 : index), ^bb22
^bb19(%48: index):  // 2 preds: ^bb18, ^bb20
  %49 = cmpi slt, %48, %c4 : index
  cond_br %49, ^bb20, ^bb21
^bb20:  // pred: ^bb19
  %50 = memref.load %40[%44, %48] : memref<?x4xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
  %51 = memref.load %42[%48, %46] : memref<4x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
  %52 = memref.load %43[%44, %46] : memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
  %53 = mulf %50, %51 : f32
  %54 = addf %52, %53 : f32
  memref.store %54, %43[%44, %46] : memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
  %55 = addi %48, %c1 : index
  br ^bb19(%55 : index)
^bb21:  // pred: ^bb19
  %56 = addi %46, %c1 : index
  br ^bb18(%56 : index)
^bb22:  // pred: ^bb18
  %57 = addi %44, %c1 : index
  br ^bb17(%57 : index)
^bb23:  // pred: ^bb17
  %58 = addi %37, %c4 : index
  br ^bb15(%58 : index)
^bb24:  // pred: ^bb15
  %59 = addi %35, %c4 : index
  br ^bb14(%59 : index)
^bb25:  // pred: ^bb14
  %60 = addi %33, %c4 : index
  br ^bb13(%60 : index)
^bb26:  // pred: ^bb13
  %61 = addi %26, %c32 : index
  br ^bb11(%61 : index)
^bb27:  // pred: ^bb11
  %62 = addi %24, %c32 : index
  br ^bb10(%62 : index)
^bb28:  // pred: ^bb10
  %63 = addi %22, %c4 : index
  br ^bb9(%63 : index)
^bb29:  // pred: ^bb9
  %64 = addi %9, %8 : index
  br ^bb3(%64 : index)
^bb30:  // pred: ^bb3
  %65 = addi %5, %4 : index
  br ^bb1(%65 : index)
^bb31:  // pred: ^bb1
  return
}

// *** IR Dump After CSE ***
func @predict_dispatch_2() {
  %cst = constant 0.000000e+00 : f32
  %c10 = constant 10 : index
  %c128 = constant 128 : index
  %c32 = constant 32 : index
  %c4 = constant 4 : index
  %c0 = constant 0 : index
  %c1 = constant 1 : index
  %0 = hal.interface.binding.subspan @io::@s0b1_ro_external[%c0] : memref<1x128xf32>
  %1 = hal.interface.binding.subspan @io::@s0b0_ro_constant[%c0] : memref<128x10xf32>
  %2 = hal.interface.binding.subspan @io::@s0b2_xw_external[%c0] : memref<1x10xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 4)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 4)>()[%workgroup_count_y]
  br ^bb1(%3 : index)
^bb1(%5: index):  // 2 preds: ^bb0, ^bb30
  %6 = cmpi slt, %5, %c1 : index
  cond_br %6, ^bb2, ^bb31
^bb2:  // pred: ^bb1
  %7 = affine.apply affine_map<()[s0] -> (s0 * 64)>()[%workgroup_id_x]
  %8 = affine.apply affine_map<()[s0] -> (s0 * 64)>()[%workgroup_count_x]
  br ^bb3(%7 : index)
^bb3(%9: index):  // 2 preds: ^bb2, ^bb29
  %10 = cmpi slt, %9, %c10 : index
  cond_br %10, ^bb4, ^bb30
^bb4:  // pred: ^bb3
  %11 = affine.min affine_map<()[s0] -> (4, -s0 + 1)>()[%5]
  %12 = memref.subview %0[%5, 0] [%11, 128] [1, 1] : memref<1x128xf32> to memref<?x128xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
  %13 = affine.min affine_map<()[s0] -> (64, -s0 + 10)>()[%9]
  %14 = memref.subview %1[0, %9] [128, %13] [1, 1] : memref<128x10xf32> to memref<128x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
  %15 = memref.subview %2[%5, %9] [%11, %13] [1, 1] : memref<1x10xf32> to memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
  br ^bb5(%c0 : index)
^bb5(%16: index):  // 2 preds: ^bb4, ^bb8
  %17 = cmpi slt, %16, %11 : index
  cond_br %17, ^bb6(%c0 : index), ^bb9(%c0 : index)
^bb6(%18: index):  // 2 preds: ^bb5, ^bb7
  %19 = cmpi slt, %18, %13 : index
  cond_br %19, ^bb7, ^bb8
^bb7:  // pred: ^bb6
  memref.store %cst, %15[%16, %18] : memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
  %20 = addi %18, %c1 : index
  br ^bb6(%20 : index)
^bb8:  // pred: ^bb6
  %21 = addi %16, %c1 : index
  br ^bb5(%21 : index)
^bb9(%22: index):  // 2 preds: ^bb5, ^bb28
  %23 = cmpi slt, %22, %11 : index
  cond_br %23, ^bb10(%c0 : index), ^bb29
^bb10(%24: index):  // 2 preds: ^bb9, ^bb27
  %25 = cmpi slt, %24, %13 : index
  cond_br %25, ^bb11(%c0 : index), ^bb28
^bb11(%26: index):  // 2 preds: ^bb10, ^bb26
  %27 = cmpi slt, %26, %c128 : index
  cond_br %27, ^bb12, ^bb27
^bb12:  // pred: ^bb11
  %28 = affine.min affine_map<()[s0, s1] -> (4, s0 - s1)>()[%11, %22]
  %29 = memref.subview %12[%22, %26] [%28, 32] [1, 1] : memref<?x128xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>> to memref<?x32xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
  %30 = affine.min affine_map<()[s0, s1] -> (32, s0 - s1)>()[%13, %24]
  %31 = memref.subview %14[%26, %24] [32, %30] [1, 1] : memref<128x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>> to memref<32x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
  %32 = memref.subview %15[%22, %24] [%28, %30] [1, 1] : memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>> to memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
  br ^bb13(%c0 : index)
^bb13(%33: index):  // 2 preds: ^bb12, ^bb25
  %34 = cmpi slt, %33, %28 : index
  cond_br %34, ^bb14(%c0 : index), ^bb26
^bb14(%35: index):  // 2 preds: ^bb13, ^bb24
  %36 = cmpi slt, %35, %30 : index
  cond_br %36, ^bb15(%c0 : index), ^bb25
^bb15(%37: index):  // 2 preds: ^bb14, ^bb23
  %38 = cmpi slt, %37, %c32 : index
  cond_br %38, ^bb16, ^bb24
^bb16:  // pred: ^bb15
  %39 = affine.min affine_map<()[s0, s1] -> (4, s0 - s1)>()[%28, %33]
  %40 = memref.subview %29[%33, %37] [%39, 4] [1, 1] : memref<?x32xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>> to memref<?x4xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
  %41 = affine.min affine_map<()[s0, s1] -> (4, s0 - s1)>()[%30, %35]
  %42 = memref.subview %31[%37, %35] [4, %41] [1, 1] : memref<32x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>> to memref<4x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
  %43 = memref.subview %32[%33, %35] [%39, %41] [1, 1] : memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>> to memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
  br ^bb17(%c0 : index)
^bb17(%44: index):  // 2 preds: ^bb16, ^bb22
  %45 = cmpi slt, %44, %39 : index
  cond_br %45, ^bb18(%c0 : index), ^bb23
^bb18(%46: index):  // 2 preds: ^bb17, ^bb21
  %47 = cmpi slt, %46, %41 : index
  cond_br %47, ^bb19(%c0 : index), ^bb22
^bb19(%48: index):  // 2 preds: ^bb18, ^bb20
  %49 = cmpi slt, %48, %c4 : index
  cond_br %49, ^bb20, ^bb21
^bb20:  // pred: ^bb19
  %50 = memref.load %40[%44, %48] : memref<?x4xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
  %51 = memref.load %42[%48, %46] : memref<4x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
  %52 = memref.load %43[%44, %46] : memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
  %53 = mulf %50, %51 : f32
  %54 = addf %52, %53 : f32
  memref.store %54, %43[%44, %46] : memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
  %55 = addi %48, %c1 : index
  br ^bb19(%55 : index)
^bb21:  // pred: ^bb19
  %56 = addi %46, %c1 : index
  br ^bb18(%56 : index)
^bb22:  // pred: ^bb18
  %57 = addi %44, %c1 : index
  br ^bb17(%57 : index)
^bb23:  // pred: ^bb17
  %58 = addi %37, %c4 : index
  br ^bb15(%58 : index)
^bb24:  // pred: ^bb15
  %59 = addi %35, %c4 : index
  br ^bb14(%59 : index)
^bb25:  // pred: ^bb14
  %60 = addi %33, %c4 : index
  br ^bb13(%60 : index)
^bb26:  // pred: ^bb13
  %61 = addi %26, %c32 : index
  br ^bb11(%61 : index)
^bb27:  // pred: ^bb11
  %62 = addi %24, %c32 : index
  br ^bb10(%62 : index)
^bb28:  // pred: ^bb10
  %63 = addi %22, %c4 : index
  br ^bb9(%63 : index)
^bb29:  // pred: ^bb9
  %64 = addi %9, %8 : index
  br ^bb3(%64 : index)
^bb30:  // pred: ^bb3
  %65 = addi %5, %4 : index
  br ^bb1(%65 : index)
^bb31:  // pred: ^bb1
  return
}

// *** IR Dump After TensorConstantBufferize ***
module  {
  func @predict_dispatch_2() {
    %cst = constant 0.000000e+00 : f32
    %c10 = constant 10 : index
    %c128 = constant 128 : index
    %c32 = constant 32 : index
    %c4 = constant 4 : index
    %c0 = constant 0 : index
    %c1 = constant 1 : index
    %0 = hal.interface.binding.subspan @io::@s0b1_ro_external[%c0] : memref<1x128xf32>
    %1 = hal.interface.binding.subspan @io::@s0b0_ro_constant[%c0] : memref<128x10xf32>
    %2 = hal.interface.binding.subspan @io::@s0b2_xw_external[%c0] : memref<1x10xf32>
    %workgroup_id_x = hal.interface.workgroup.id[0] : index
    %workgroup_count_x = hal.interface.workgroup.count[0] : index
    %workgroup_id_y = hal.interface.workgroup.id[1] : index
    %workgroup_count_y = hal.interface.workgroup.count[1] : index
    %3 = affine.apply affine_map<()[s0] -> (s0 * 4)>()[%workgroup_id_y]
    %4 = affine.apply affine_map<()[s0] -> (s0 * 4)>()[%workgroup_count_y]
    br ^bb1(%3 : index)
  ^bb1(%5: index):  // 2 preds: ^bb0, ^bb30
    %6 = cmpi slt, %5, %c1 : index
    cond_br %6, ^bb2, ^bb31
  ^bb2:  // pred: ^bb1
    %7 = affine.apply affine_map<()[s0] -> (s0 * 64)>()[%workgroup_id_x]
    %8 = affine.apply affine_map<()[s0] -> (s0 * 64)>()[%workgroup_count_x]
    br ^bb3(%7 : index)
  ^bb3(%9: index):  // 2 preds: ^bb2, ^bb29
    %10 = cmpi slt, %9, %c10 : index
    cond_br %10, ^bb4, ^bb30
  ^bb4:  // pred: ^bb3
    %11 = affine.min affine_map<()[s0] -> (4, -s0 + 1)>()[%5]
    %12 = memref.subview %0[%5, 0] [%11, 128] [1, 1] : memref<1x128xf32> to memref<?x128xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
    %13 = affine.min affine_map<()[s0] -> (64, -s0 + 10)>()[%9]
    %14 = memref.subview %1[0, %9] [128, %13] [1, 1] : memref<128x10xf32> to memref<128x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
    %15 = memref.subview %2[%5, %9] [%11, %13] [1, 1] : memref<1x10xf32> to memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
    br ^bb5(%c0 : index)
  ^bb5(%16: index):  // 2 preds: ^bb4, ^bb8
    %17 = cmpi slt, %16, %11 : index
    cond_br %17, ^bb6(%c0 : index), ^bb9(%c0 : index)
  ^bb6(%18: index):  // 2 preds: ^bb5, ^bb7
    %19 = cmpi slt, %18, %13 : index
    cond_br %19, ^bb7, ^bb8
  ^bb7:  // pred: ^bb6
    memref.store %cst, %15[%16, %18] : memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
    %20 = addi %18, %c1 : index
    br ^bb6(%20 : index)
  ^bb8:  // pred: ^bb6
    %21 = addi %16, %c1 : index
    br ^bb5(%21 : index)
  ^bb9(%22: index):  // 2 preds: ^bb5, ^bb28
    %23 = cmpi slt, %22, %11 : index
    cond_br %23, ^bb10(%c0 : index), ^bb29
  ^bb10(%24: index):  // 2 preds: ^bb9, ^bb27
    %25 = cmpi slt, %24, %13 : index
    cond_br %25, ^bb11(%c0 : index), ^bb28
  ^bb11(%26: index):  // 2 preds: ^bb10, ^bb26
    %27 = cmpi slt, %26, %c128 : index
    cond_br %27, ^bb12, ^bb27
  ^bb12:  // pred: ^bb11
    %28 = affine.min affine_map<()[s0, s1] -> (4, s0 - s1)>()[%11, %22]
    %29 = memref.subview %12[%22, %26] [%28, 32] [1, 1] : memref<?x128xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>> to memref<?x32xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
    %30 = affine.min affine_map<()[s0, s1] -> (32, s0 - s1)>()[%13, %24]
    %31 = memref.subview %14[%26, %24] [32, %30] [1, 1] : memref<128x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>> to memref<32x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
    %32 = memref.subview %15[%22, %24] [%28, %30] [1, 1] : memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>> to memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
    br ^bb13(%c0 : index)
  ^bb13(%33: index):  // 2 preds: ^bb12, ^bb25
    %34 = cmpi slt, %33, %28 : index
    cond_br %34, ^bb14(%c0 : index), ^bb26
  ^bb14(%35: index):  // 2 preds: ^bb13, ^bb24
    %36 = cmpi slt, %35, %30 : index
    cond_br %36, ^bb15(%c0 : index), ^bb25
  ^bb15(%37: index):  // 2 preds: ^bb14, ^bb23
    %38 = cmpi slt, %37, %c32 : index
    cond_br %38, ^bb16, ^bb24
  ^bb16:  // pred: ^bb15
    %39 = affine.min affine_map<()[s0, s1] -> (4, s0 - s1)>()[%28, %33]
    %40 = memref.subview %29[%33, %37] [%39, 4] [1, 1] : memref<?x32xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>> to memref<?x4xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
    %41 = affine.min affine_map<()[s0, s1] -> (4, s0 - s1)>()[%30, %35]
    %42 = memref.subview %31[%37, %35] [4, %41] [1, 1] : memref<32x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>> to memref<4x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
    %43 = memref.subview %32[%33, %35] [%39, %41] [1, 1] : memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>> to memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
    br ^bb17(%c0 : index)
  ^bb17(%44: index):  // 2 preds: ^bb16, ^bb22
    %45 = cmpi slt, %44, %39 : index
    cond_br %45, ^bb18(%c0 : index), ^bb23
  ^bb18(%46: index):  // 2 preds: ^bb17, ^bb21
    %47 = cmpi slt, %46, %41 : index
    cond_br %47, ^bb19(%c0 : index), ^bb22
  ^bb19(%48: index):  // 2 preds: ^bb18, ^bb20
    %49 = cmpi slt, %48, %c4 : index
    cond_br %49, ^bb20, ^bb21
  ^bb20:  // pred: ^bb19
    %50 = memref.load %40[%44, %48] : memref<?x4xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
    %51 = memref.load %42[%48, %46] : memref<4x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
    %52 = memref.load %43[%44, %46] : memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
    %53 = mulf %50, %51 : f32
    %54 = addf %52, %53 : f32
    memref.store %54, %43[%44, %46] : memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
    %55 = addi %48, %c1 : index
    br ^bb19(%55 : index)
  ^bb21:  // pred: ^bb19
    %56 = addi %46, %c1 : index
    br ^bb18(%56 : index)
  ^bb22:  // pred: ^bb18
    %57 = addi %44, %c1 : index
    br ^bb17(%57 : index)
  ^bb23:  // pred: ^bb17
    %58 = addi %37, %c4 : index
    br ^bb15(%58 : index)
  ^bb24:  // pred: ^bb15
    %59 = addi %35, %c4 : index
    br ^bb14(%59 : index)
  ^bb25:  // pred: ^bb14
    %60 = addi %33, %c4 : index
    br ^bb13(%60 : index)
  ^bb26:  // pred: ^bb13
    %61 = addi %26, %c32 : index
    br ^bb11(%61 : index)
  ^bb27:  // pred: ^bb11
    %62 = addi %24, %c32 : index
    br ^bb10(%62 : index)
  ^bb28:  // pred: ^bb10
    %63 = addi %22, %c4 : index
    br ^bb9(%63 : index)
  ^bb29:  // pred: ^bb9
    %64 = addi %9, %8 : index
    br ^bb3(%64 : index)
  ^bb30:  // pred: ^bb3
    %65 = addi %5, %4 : index
    br ^bb1(%65 : index)
  ^bb31:  // pred: ^bb1
    return
  }
  hal.interface @io attributes {sym_visibility = "private"} {
    hal.interface.binding @s0b0_ro_constant, set=0, binding=0, type="StorageBuffer", access="Read"
    hal.interface.binding @s0b1_ro_external, set=0, binding=1, type="StorageBuffer", access="Read"
    hal.interface.binding @s0b2_xw_external, set=0, binding=2, type="StorageBuffer", access="Write|Discard"
  }
}

// *** IR Dump After mlir::iree_compiler::`anonymous-namespace'::FoldTensorExtractOpPass ***
module  {
  func @predict_dispatch_2() {
    %cst = constant 0.000000e+00 : f32
    %c10 = constant 10 : index
    %c128 = constant 128 : index
    %c32 = constant 32 : index
    %c4 = constant 4 : index
    %c0 = constant 0 : index
    %c1 = constant 1 : index
    %0 = hal.interface.binding.subspan @io::@s0b1_ro_external[%c0] : memref<1x128xf32>
    %1 = hal.interface.binding.subspan @io::@s0b0_ro_constant[%c0] : memref<128x10xf32>
    %2 = hal.interface.binding.subspan @io::@s0b2_xw_external[%c0] : memref<1x10xf32>
    %workgroup_id_x = hal.interface.workgroup.id[0] : index
    %workgroup_count_x = hal.interface.workgroup.count[0] : index
    %workgroup_id_y = hal.interface.workgroup.id[1] : index
    %workgroup_count_y = hal.interface.workgroup.count[1] : index
    %3 = affine.apply affine_map<()[s0] -> (s0 * 4)>()[%workgroup_id_y]
    %4 = affine.apply affine_map<()[s0] -> (s0 * 4)>()[%workgroup_count_y]
    br ^bb1(%3 : index)
  ^bb1(%5: index):  // 2 preds: ^bb0, ^bb30
    %6 = cmpi slt, %5, %c1 : index
    cond_br %6, ^bb2, ^bb31
  ^bb2:  // pred: ^bb1
    %7 = affine.apply affine_map<()[s0] -> (s0 * 64)>()[%workgroup_id_x]
    %8 = affine.apply affine_map<()[s0] -> (s0 * 64)>()[%workgroup_count_x]
    br ^bb3(%7 : index)
  ^bb3(%9: index):  // 2 preds: ^bb2, ^bb29
    %10 = cmpi slt, %9, %c10 : index
    cond_br %10, ^bb4, ^bb30
  ^bb4:  // pred: ^bb3
    %11 = affine.min affine_map<()[s0] -> (4, -s0 + 1)>()[%5]
    %12 = memref.subview %0[%5, 0] [%11, 128] [1, 1] : memref<1x128xf32> to memref<?x128xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
    %13 = affine.min affine_map<()[s0] -> (64, -s0 + 10)>()[%9]
    %14 = memref.subview %1[0, %9] [128, %13] [1, 1] : memref<128x10xf32> to memref<128x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
    %15 = memref.subview %2[%5, %9] [%11, %13] [1, 1] : memref<1x10xf32> to memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
    br ^bb5(%c0 : index)
  ^bb5(%16: index):  // 2 preds: ^bb4, ^bb8
    %17 = cmpi slt, %16, %11 : index
    cond_br %17, ^bb6(%c0 : index), ^bb9(%c0 : index)
  ^bb6(%18: index):  // 2 preds: ^bb5, ^bb7
    %19 = cmpi slt, %18, %13 : index
    cond_br %19, ^bb7, ^bb8
  ^bb7:  // pred: ^bb6
    memref.store %cst, %15[%16, %18] : memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
    %20 = addi %18, %c1 : index
    br ^bb6(%20 : index)
  ^bb8:  // pred: ^bb6
    %21 = addi %16, %c1 : index
    br ^bb5(%21 : index)
  ^bb9(%22: index):  // 2 preds: ^bb5, ^bb28
    %23 = cmpi slt, %22, %11 : index
    cond_br %23, ^bb10(%c0 : index), ^bb29
  ^bb10(%24: index):  // 2 preds: ^bb9, ^bb27
    %25 = cmpi slt, %24, %13 : index
    cond_br %25, ^bb11(%c0 : index), ^bb28
  ^bb11(%26: index):  // 2 preds: ^bb10, ^bb26
    %27 = cmpi slt, %26, %c128 : index
    cond_br %27, ^bb12, ^bb27
  ^bb12:  // pred: ^bb11
    %28 = affine.min affine_map<()[s0, s1] -> (4, s0 - s1)>()[%11, %22]
    %29 = memref.subview %12[%22, %26] [%28, 32] [1, 1] : memref<?x128xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>> to memref<?x32xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
    %30 = affine.min affine_map<()[s0, s1] -> (32, s0 - s1)>()[%13, %24]
    %31 = memref.subview %14[%26, %24] [32, %30] [1, 1] : memref<128x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>> to memref<32x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
    %32 = memref.subview %15[%22, %24] [%28, %30] [1, 1] : memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>> to memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
    br ^bb13(%c0 : index)
  ^bb13(%33: index):  // 2 preds: ^bb12, ^bb25
    %34 = cmpi slt, %33, %28 : index
    cond_br %34, ^bb14(%c0 : index), ^bb26
  ^bb14(%35: index):  // 2 preds: ^bb13, ^bb24
    %36 = cmpi slt, %35, %30 : index
    cond_br %36, ^bb15(%c0 : index), ^bb25
  ^bb15(%37: index):  // 2 preds: ^bb14, ^bb23
    %38 = cmpi slt, %37, %c32 : index
    cond_br %38, ^bb16, ^bb24
  ^bb16:  // pred: ^bb15
    %39 = affine.min affine_map<()[s0, s1] -> (4, s0 - s1)>()[%28, %33]
    %40 = memref.subview %29[%33, %37] [%39, 4] [1, 1] : memref<?x32xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>> to memref<?x4xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
    %41 = affine.min affine_map<()[s0, s1] -> (4, s0 - s1)>()[%30, %35]
    %42 = memref.subview %31[%37, %35] [4, %41] [1, 1] : memref<32x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>> to memref<4x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
    %43 = memref.subview %32[%33, %35] [%39, %41] [1, 1] : memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>> to memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
    br ^bb17(%c0 : index)
  ^bb17(%44: index):  // 2 preds: ^bb16, ^bb22
    %45 = cmpi slt, %44, %39 : index
    cond_br %45, ^bb18(%c0 : index), ^bb23
  ^bb18(%46: index):  // 2 preds: ^bb17, ^bb21
    %47 = cmpi slt, %46, %41 : index
    cond_br %47, ^bb19(%c0 : index), ^bb22
  ^bb19(%48: index):  // 2 preds: ^bb18, ^bb20
    %49 = cmpi slt, %48, %c4 : index
    cond_br %49, ^bb20, ^bb21
  ^bb20:  // pred: ^bb19
    %50 = memref.load %40[%44, %48] : memref<?x4xf32, affine_map<(d0, d1)[s0] -> (d0 * 128 + s0 + d1)>>
    %51 = memref.load %42[%48, %46] : memref<4x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
    %52 = memref.load %43[%44, %46] : memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
    %53 = mulf %50, %51 : f32
    %54 = addf %52, %53 : f32
    memref.store %54, %43[%44, %46] : memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
    %55 = addi %48, %c1 : index
    br ^bb19(%55 : index)
  ^bb21:  // pred: ^bb19
    %56 = addi %46, %c1 : index
    br ^bb18(%56 : index)
  ^bb22:  // pred: ^bb18
    %57 = addi %44, %c1 : index
    br ^bb17(%57 : index)
  ^bb23:  // pred: ^bb17
    %58 = addi %37, %c4 : index
    br ^bb15(%58 : index)
  ^bb24:  // pred: ^bb15
    %59 = addi %35, %c4 : index
    br ^bb14(%59 : index)
  ^bb25:  // pred: ^bb14
    %60 = addi %33, %c4 : index
    br ^bb13(%60 : index)
  ^bb26:  // pred: ^bb13
    %61 = addi %26, %c32 : index
    br ^bb11(%61 : index)
  ^bb27:  // pred: ^bb11
    %62 = addi %24, %c32 : index
    br ^bb10(%62 : index)
  ^bb28:  // pred: ^bb10
    %63 = addi %22, %c4 : index
    br ^bb9(%63 : index)
  ^bb29:  // pred: ^bb9
    %64 = addi %9, %8 : index
    br ^bb3(%64 : index)
  ^bb30:  // pred: ^bb3
    %65 = addi %5, %4 : index
    br ^bb1(%65 : index)
  ^bb31:  // pred: ^bb1
    return
  }
  hal.interface @io attributes {sym_visibility = "private"} {
    hal.interface.binding @s0b0_ro_constant, set=0, binding=0, type="StorageBuffer", access="Read"
    hal.interface.binding @s0b1_ro_external, set=0, binding=1, type="StorageBuffer", access="Read"
    hal.interface.binding @s0b2_xw_external, set=0, binding=2, type="StorageBuffer", access="Write|Discard"
  }
}

// *** IR Dump After mlir::iree_compiler::`anonymous-namespace'::ConvertToLLVMPass ***
module  {
  llvm.func internal @predict_dispatch_2(%arg0: !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>, %arg1: !llvm.ptr<array<3 x i32>>) -> i32 {
    %0 = llvm.mlir.constant(0.000000e+00 : f32) : f32
    %1 = llvm.mlir.constant(10 : index) : i64
    %2 = llvm.mlir.constant(128 : index) : i64
    %3 = llvm.mlir.constant(32 : index) : i64
    %4 = llvm.mlir.constant(4 : index) : i64
    %5 = llvm.mlir.constant(0 : index) : i64
    %6 = llvm.mlir.constant(1 : index) : i64
    %7 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
    %8 = llvm.extractvalue %7[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
    %9 = llvm.mlir.constant(1 : index) : i64
    %10 = llvm.getelementptr %8[%9] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
    %11 = llvm.load %10 : !llvm.ptr<ptr<i8>>
    %12 = llvm.getelementptr %11[%5] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
    %13 = llvm.bitcast %12 : !llvm.ptr<i8> to !llvm.ptr<f32>
    %14 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %15 = llvm.insertvalue %13, %14[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %16 = llvm.insertvalue %13, %15[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %17 = llvm.mlir.constant(0 : index) : i64
    %18 = llvm.insertvalue %17, %16[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %19 = llvm.mlir.constant(1 : index) : i64
    %20 = llvm.insertvalue %19, %18[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %21 = llvm.mlir.constant(128 : index) : i64
    %22 = llvm.insertvalue %21, %20[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %23 = llvm.mlir.constant(128 : index) : i64
    %24 = llvm.insertvalue %23, %22[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %25 = llvm.mlir.constant(1 : index) : i64
    %26 = llvm.insertvalue %25, %24[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %27 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
    %28 = llvm.extractvalue %27[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
    %29 = llvm.mlir.constant(0 : index) : i64
    %30 = llvm.getelementptr %28[%29] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
    %31 = llvm.load %30 : !llvm.ptr<ptr<i8>>
    %32 = llvm.getelementptr %31[%5] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
    %33 = llvm.bitcast %32 : !llvm.ptr<i8> to !llvm.ptr<f32>
    %34 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %35 = llvm.insertvalue %33, %34[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %36 = llvm.insertvalue %33, %35[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %37 = llvm.mlir.constant(0 : index) : i64
    %38 = llvm.insertvalue %37, %36[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %39 = llvm.mlir.constant(128 : index) : i64
    %40 = llvm.insertvalue %39, %38[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %41 = llvm.mlir.constant(10 : index) : i64
    %42 = llvm.insertvalue %41, %40[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %43 = llvm.mlir.constant(10 : index) : i64
    %44 = llvm.insertvalue %43, %42[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %45 = llvm.mlir.constant(1 : index) : i64
    %46 = llvm.insertvalue %45, %44[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %47 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
    %48 = llvm.extractvalue %47[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
    %49 = llvm.mlir.constant(2 : index) : i64
    %50 = llvm.getelementptr %48[%49] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
    %51 = llvm.load %50 : !llvm.ptr<ptr<i8>>
    %52 = llvm.getelementptr %51[%5] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
    %53 = llvm.bitcast %52 : !llvm.ptr<i8> to !llvm.ptr<f32>
    %54 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %55 = llvm.insertvalue %53, %54[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %56 = llvm.insertvalue %53, %55[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %57 = llvm.mlir.constant(0 : index) : i64
    %58 = llvm.insertvalue %57, %56[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %59 = llvm.mlir.constant(1 : index) : i64
    %60 = llvm.insertvalue %59, %58[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %61 = llvm.mlir.constant(10 : index) : i64
    %62 = llvm.insertvalue %61, %60[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %63 = llvm.mlir.constant(10 : index) : i64
    %64 = llvm.insertvalue %63, %62[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %65 = llvm.mlir.constant(1 : index) : i64
    %66 = llvm.insertvalue %65, %64[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %67 = llvm.load %arg1 : !llvm.ptr<array<3 x i32>>
    %68 = llvm.extractvalue %67[0] : !llvm.array<3 x i32>
    %69 = llvm.zext %68 : i32 to i64
    %70 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
    %71 = llvm.extractvalue %70[0] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
    %72 = llvm.extractvalue %71[0] : !llvm.array<3 x i32>
    %73 = llvm.zext %72 : i32 to i64
    %74 = llvm.load %arg1 : !llvm.ptr<array<3 x i32>>
    %75 = llvm.extractvalue %74[1] : !llvm.array<3 x i32>
    %76 = llvm.zext %75 : i32 to i64
    %77 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
    %78 = llvm.extractvalue %77[0] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
    %79 = llvm.extractvalue %78[1] : !llvm.array<3 x i32>
    %80 = llvm.zext %79 : i32 to i64
    %81 = llvm.mlir.constant(4 : index) : i64
    %82 = llvm.mul %76, %81  : i64
    %83 = llvm.mlir.constant(4 : index) : i64
    %84 = llvm.mul %80, %83  : i64
    llvm.br ^bb1(%82 : i64)
  ^bb1(%85: i64):  // 2 preds: ^bb0, ^bb30
    %86 = llvm.icmp "slt" %85, %6 : i64
    llvm.cond_br %86, ^bb2, ^bb31
  ^bb2:  // pred: ^bb1
    %87 = llvm.mlir.constant(64 : index) : i64
    %88 = llvm.mul %69, %87  : i64
    %89 = llvm.mlir.constant(64 : index) : i64
    %90 = llvm.mul %73, %89  : i64
    llvm.br ^bb3(%88 : i64)
  ^bb3(%91: i64):  // 2 preds: ^bb2, ^bb29
    %92 = llvm.icmp "slt" %91, %1 : i64
    llvm.cond_br %92, ^bb4, ^bb30
  ^bb4:  // pred: ^bb3
    %93 = llvm.mlir.constant(4 : index) : i64
    %94 = llvm.mlir.constant(-1 : index) : i64
    %95 = llvm.mul %85, %94  : i64
    %96 = llvm.mlir.constant(1 : index) : i64
    %97 = llvm.add %95, %96  : i64
    %98 = llvm.icmp "slt" %93, %97 : i64
    %99 = llvm.select %98, %93, %97 : i1, i64
    %100 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %101 = llvm.extractvalue %26[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %102 = llvm.bitcast %101 : !llvm.ptr<f32> to !llvm.ptr<f32>
    %103 = llvm.insertvalue %102, %100[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %104 = llvm.extractvalue %26[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %105 = llvm.bitcast %104 : !llvm.ptr<f32> to !llvm.ptr<f32>
    %106 = llvm.insertvalue %105, %103[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %107 = llvm.extractvalue %26[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %108 = llvm.extractvalue %26[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %109 = llvm.extractvalue %26[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %110 = llvm.mul %85, %107  : i64
    %111 = llvm.add %109, %110  : i64
    %112 = llvm.mlir.constant(0 : i64) : i64
    %113 = llvm.mul %112, %108  : i64
    %114 = llvm.add %111, %113  : i64
    %115 = llvm.insertvalue %114, %106[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %116 = llvm.mlir.constant(128 : i64) : i64
    %117 = llvm.mlir.constant(1 : i64) : i64
    %118 = llvm.insertvalue %116, %115[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %119 = llvm.insertvalue %117, %118[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %120 = llvm.mlir.constant(128 : i64) : i64
    %121 = llvm.insertvalue %99, %119[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %122 = llvm.insertvalue %120, %121[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %123 = llvm.mlir.constant(64 : index) : i64
    %124 = llvm.mlir.constant(-1 : index) : i64
    %125 = llvm.mul %91, %124  : i64
    %126 = llvm.mlir.constant(10 : index) : i64
    %127 = llvm.add %125, %126  : i64
    %128 = llvm.icmp "slt" %123, %127 : i64
    %129 = llvm.select %128, %123, %127 : i1, i64
    %130 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %131 = llvm.extractvalue %46[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %132 = llvm.bitcast %131 : !llvm.ptr<f32> to !llvm.ptr<f32>
    %133 = llvm.insertvalue %132, %130[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %134 = llvm.extractvalue %46[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %135 = llvm.bitcast %134 : !llvm.ptr<f32> to !llvm.ptr<f32>
    %136 = llvm.insertvalue %135, %133[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %137 = llvm.extractvalue %46[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %138 = llvm.extractvalue %46[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %139 = llvm.extractvalue %46[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %140 = llvm.mlir.constant(0 : i64) : i64
    %141 = llvm.mul %140, %137  : i64
    %142 = llvm.add %139, %141  : i64
    %143 = llvm.mul %91, %138  : i64
    %144 = llvm.add %142, %143  : i64
    %145 = llvm.insertvalue %144, %136[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %146 = llvm.mlir.constant(1 : i64) : i64
    %147 = llvm.insertvalue %129, %145[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %148 = llvm.insertvalue %146, %147[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %149 = llvm.mlir.constant(128 : i64) : i64
    %150 = llvm.mlir.constant(10 : i64) : i64
    %151 = llvm.insertvalue %149, %148[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %152 = llvm.insertvalue %150, %151[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %153 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %154 = llvm.extractvalue %66[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %155 = llvm.bitcast %154 : !llvm.ptr<f32> to !llvm.ptr<f32>
    %156 = llvm.insertvalue %155, %153[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %157 = llvm.extractvalue %66[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %158 = llvm.bitcast %157 : !llvm.ptr<f32> to !llvm.ptr<f32>
    %159 = llvm.insertvalue %158, %156[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %160 = llvm.extractvalue %66[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %161 = llvm.extractvalue %66[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %162 = llvm.extractvalue %66[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %163 = llvm.mul %85, %160  : i64
    %164 = llvm.add %162, %163  : i64
    %165 = llvm.mul %91, %161  : i64
    %166 = llvm.add %164, %165  : i64
    %167 = llvm.insertvalue %166, %159[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %168 = llvm.mlir.constant(1 : i64) : i64
    %169 = llvm.insertvalue %129, %167[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %170 = llvm.insertvalue %168, %169[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %171 = llvm.mlir.constant(10 : i64) : i64
    %172 = llvm.insertvalue %99, %170[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %173 = llvm.insertvalue %171, %172[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    llvm.br ^bb5(%5 : i64)
  ^bb5(%174: i64):  // 2 preds: ^bb4, ^bb8
    %175 = llvm.icmp "slt" %174, %99 : i64
    llvm.cond_br %175, ^bb6(%5 : i64), ^bb9(%5 : i64)
  ^bb6(%176: i64):  // 2 preds: ^bb5, ^bb7
    %177 = llvm.icmp "slt" %176, %129 : i64
    llvm.cond_br %177, ^bb7, ^bb8
  ^bb7:  // pred: ^bb6
    %178 = llvm.extractvalue %173[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %179 = llvm.extractvalue %173[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %180 = llvm.mlir.constant(10 : index) : i64
    %181 = llvm.mul %174, %180  : i64
    %182 = llvm.add %179, %181  : i64
    %183 = llvm.add %182, %176  : i64
    %184 = llvm.getelementptr %178[%183] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    llvm.store %0, %184 : !llvm.ptr<f32>
    %185 = llvm.add %176, %6  : i64
    llvm.br ^bb6(%185 : i64)
  ^bb8:  // pred: ^bb6
    %186 = llvm.add %174, %6  : i64
    llvm.br ^bb5(%186 : i64)
  ^bb9(%187: i64):  // 2 preds: ^bb5, ^bb28
    %188 = llvm.icmp "slt" %187, %99 : i64
    llvm.cond_br %188, ^bb10(%5 : i64), ^bb29
  ^bb10(%189: i64):  // 2 preds: ^bb9, ^bb27
    %190 = llvm.icmp "slt" %189, %129 : i64
    llvm.cond_br %190, ^bb11(%5 : i64), ^bb28
  ^bb11(%191: i64):  // 2 preds: ^bb10, ^bb26
    %192 = llvm.icmp "slt" %191, %2 : i64
    llvm.cond_br %192, ^bb12, ^bb27
  ^bb12:  // pred: ^bb11
    %193 = llvm.mlir.constant(4 : index) : i64
    %194 = llvm.mlir.constant(-1 : index) : i64
    %195 = llvm.mul %187, %194  : i64
    %196 = llvm.add %99, %195  : i64
    %197 = llvm.icmp "slt" %193, %196 : i64
    %198 = llvm.select %197, %193, %196 : i1, i64
    %199 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %200 = llvm.extractvalue %122[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %201 = llvm.bitcast %200 : !llvm.ptr<f32> to !llvm.ptr<f32>
    %202 = llvm.insertvalue %201, %199[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %203 = llvm.extractvalue %122[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %204 = llvm.bitcast %203 : !llvm.ptr<f32> to !llvm.ptr<f32>
    %205 = llvm.insertvalue %204, %202[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %206 = llvm.extractvalue %122[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %207 = llvm.extractvalue %122[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %208 = llvm.extractvalue %122[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %209 = llvm.mul %187, %206  : i64
    %210 = llvm.add %208, %209  : i64
    %211 = llvm.mul %191, %207  : i64
    %212 = llvm.add %210, %211  : i64
    %213 = llvm.insertvalue %212, %205[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %214 = llvm.mlir.constant(32 : i64) : i64
    %215 = llvm.mlir.constant(1 : i64) : i64
    %216 = llvm.insertvalue %214, %213[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %217 = llvm.insertvalue %215, %216[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %218 = llvm.mlir.constant(128 : i64) : i64
    %219 = llvm.insertvalue %198, %217[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %220 = llvm.insertvalue %218, %219[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %221 = llvm.mlir.constant(32 : index) : i64
    %222 = llvm.mlir.constant(-1 : index) : i64
    %223 = llvm.mul %189, %222  : i64
    %224 = llvm.add %129, %223  : i64
    %225 = llvm.icmp "slt" %221, %224 : i64
    %226 = llvm.select %225, %221, %224 : i1, i64
    %227 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %228 = llvm.extractvalue %152[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %229 = llvm.bitcast %228 : !llvm.ptr<f32> to !llvm.ptr<f32>
    %230 = llvm.insertvalue %229, %227[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %231 = llvm.extractvalue %152[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %232 = llvm.bitcast %231 : !llvm.ptr<f32> to !llvm.ptr<f32>
    %233 = llvm.insertvalue %232, %230[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %234 = llvm.extractvalue %152[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %235 = llvm.extractvalue %152[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %236 = llvm.extractvalue %152[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %237 = llvm.mul %191, %234  : i64
    %238 = llvm.add %236, %237  : i64
    %239 = llvm.mul %189, %235  : i64
    %240 = llvm.add %238, %239  : i64
    %241 = llvm.insertvalue %240, %233[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %242 = llvm.mlir.constant(1 : i64) : i64
    %243 = llvm.insertvalue %226, %241[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %244 = llvm.insertvalue %242, %243[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %245 = llvm.mlir.constant(32 : i64) : i64
    %246 = llvm.mlir.constant(10 : i64) : i64
    %247 = llvm.insertvalue %245, %244[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %248 = llvm.insertvalue %246, %247[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %249 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %250 = llvm.extractvalue %173[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %251 = llvm.bitcast %250 : !llvm.ptr<f32> to !llvm.ptr<f32>
    %252 = llvm.insertvalue %251, %249[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %253 = llvm.extractvalue %173[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %254 = llvm.bitcast %253 : !llvm.ptr<f32> to !llvm.ptr<f32>
    %255 = llvm.insertvalue %254, %252[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %256 = llvm.extractvalue %173[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %257 = llvm.extractvalue %173[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %258 = llvm.extractvalue %173[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %259 = llvm.mul %187, %256  : i64
    %260 = llvm.add %258, %259  : i64
    %261 = llvm.mul %189, %257  : i64
    %262 = llvm.add %260, %261  : i64
    %263 = llvm.insertvalue %262, %255[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %264 = llvm.mlir.constant(1 : i64) : i64
    %265 = llvm.insertvalue %226, %263[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %266 = llvm.insertvalue %264, %265[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %267 = llvm.mlir.constant(10 : i64) : i64
    %268 = llvm.insertvalue %198, %266[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %269 = llvm.insertvalue %267, %268[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    llvm.br ^bb13(%5 : i64)
  ^bb13(%270: i64):  // 2 preds: ^bb12, ^bb25
    %271 = llvm.icmp "slt" %270, %198 : i64
    llvm.cond_br %271, ^bb14(%5 : i64), ^bb26
  ^bb14(%272: i64):  // 2 preds: ^bb13, ^bb24
    %273 = llvm.icmp "slt" %272, %226 : i64
    llvm.cond_br %273, ^bb15(%5 : i64), ^bb25
  ^bb15(%274: i64):  // 2 preds: ^bb14, ^bb23
    %275 = llvm.icmp "slt" %274, %3 : i64
    llvm.cond_br %275, ^bb16, ^bb24
  ^bb16:  // pred: ^bb15
    %276 = llvm.mlir.constant(4 : index) : i64
    %277 = llvm.mlir.constant(-1 : index) : i64
    %278 = llvm.mul %270, %277  : i64
    %279 = llvm.add %198, %278  : i64
    %280 = llvm.icmp "slt" %276, %279 : i64
    %281 = llvm.select %280, %276, %279 : i1, i64
    %282 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %283 = llvm.extractvalue %220[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %284 = llvm.bitcast %283 : !llvm.ptr<f32> to !llvm.ptr<f32>
    %285 = llvm.insertvalue %284, %282[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %286 = llvm.extractvalue %220[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %287 = llvm.bitcast %286 : !llvm.ptr<f32> to !llvm.ptr<f32>
    %288 = llvm.insertvalue %287, %285[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %289 = llvm.extractvalue %220[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %290 = llvm.extractvalue %220[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %291 = llvm.extractvalue %220[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %292 = llvm.mul %270, %289  : i64
    %293 = llvm.add %291, %292  : i64
    %294 = llvm.mul %274, %290  : i64
    %295 = llvm.add %293, %294  : i64
    %296 = llvm.insertvalue %295, %288[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %297 = llvm.mlir.constant(4 : i64) : i64
    %298 = llvm.mlir.constant(1 : i64) : i64
    %299 = llvm.insertvalue %297, %296[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %300 = llvm.insertvalue %298, %299[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %301 = llvm.mlir.constant(128 : i64) : i64
    %302 = llvm.insertvalue %281, %300[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %303 = llvm.insertvalue %301, %302[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %304 = llvm.mlir.constant(4 : index) : i64
    %305 = llvm.mlir.constant(-1 : index) : i64
    %306 = llvm.mul %272, %305  : i64
    %307 = llvm.add %226, %306  : i64
    %308 = llvm.icmp "slt" %304, %307 : i64
    %309 = llvm.select %308, %304, %307 : i1, i64
    %310 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %311 = llvm.extractvalue %248[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %312 = llvm.bitcast %311 : !llvm.ptr<f32> to !llvm.ptr<f32>
    %313 = llvm.insertvalue %312, %310[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %314 = llvm.extractvalue %248[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %315 = llvm.bitcast %314 : !llvm.ptr<f32> to !llvm.ptr<f32>
    %316 = llvm.insertvalue %315, %313[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %317 = llvm.extractvalue %248[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %318 = llvm.extractvalue %248[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %319 = llvm.extractvalue %248[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %320 = llvm.mul %274, %317  : i64
    %321 = llvm.add %319, %320  : i64
    %322 = llvm.mul %272, %318  : i64
    %323 = llvm.add %321, %322  : i64
    %324 = llvm.insertvalue %323, %316[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %325 = llvm.mlir.constant(1 : i64) : i64
    %326 = llvm.insertvalue %309, %324[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %327 = llvm.insertvalue %325, %326[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %328 = llvm.mlir.constant(4 : i64) : i64
    %329 = llvm.mlir.constant(10 : i64) : i64
    %330 = llvm.insertvalue %328, %327[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %331 = llvm.insertvalue %329, %330[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %332 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %333 = llvm.extractvalue %269[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %334 = llvm.bitcast %333 : !llvm.ptr<f32> to !llvm.ptr<f32>
    %335 = llvm.insertvalue %334, %332[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %336 = llvm.extractvalue %269[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %337 = llvm.bitcast %336 : !llvm.ptr<f32> to !llvm.ptr<f32>
    %338 = llvm.insertvalue %337, %335[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %339 = llvm.extractvalue %269[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %340 = llvm.extractvalue %269[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %341 = llvm.extractvalue %269[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %342 = llvm.mul %270, %339  : i64
    %343 = llvm.add %341, %342  : i64
    %344 = llvm.mul %272, %340  : i64
    %345 = llvm.add %343, %344  : i64
    %346 = llvm.insertvalue %345, %338[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %347 = llvm.mlir.constant(1 : i64) : i64
    %348 = llvm.insertvalue %309, %346[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %349 = llvm.insertvalue %347, %348[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %350 = llvm.mlir.constant(10 : i64) : i64
    %351 = llvm.insertvalue %281, %349[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %352 = llvm.insertvalue %350, %351[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    llvm.br ^bb17(%5 : i64)
  ^bb17(%353: i64):  // 2 preds: ^bb16, ^bb22
    %354 = llvm.icmp "slt" %353, %281 : i64
    llvm.cond_br %354, ^bb18(%5 : i64), ^bb23
  ^bb18(%355: i64):  // 2 preds: ^bb17, ^bb21
    %356 = llvm.icmp "slt" %355, %309 : i64
    llvm.cond_br %356, ^bb19(%5 : i64), ^bb22
  ^bb19(%357: i64):  // 2 preds: ^bb18, ^bb20
    %358 = llvm.icmp "slt" %357, %4 : i64
    llvm.cond_br %358, ^bb20, ^bb21
  ^bb20:  // pred: ^bb19
    %359 = llvm.extractvalue %303[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %360 = llvm.extractvalue %303[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %361 = llvm.mlir.constant(128 : index) : i64
    %362 = llvm.mul %353, %361  : i64
    %363 = llvm.add %360, %362  : i64
    %364 = llvm.add %363, %357  : i64
    %365 = llvm.getelementptr %359[%364] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %366 = llvm.load %365 : !llvm.ptr<f32>
    %367 = llvm.extractvalue %331[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %368 = llvm.extractvalue %331[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %369 = llvm.mlir.constant(10 : index) : i64
    %370 = llvm.mul %357, %369  : i64
    %371 = llvm.add %368, %370  : i64
    %372 = llvm.add %371, %355  : i64
    %373 = llvm.getelementptr %367[%372] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %374 = llvm.load %373 : !llvm.ptr<f32>
    %375 = llvm.extractvalue %352[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %376 = llvm.extractvalue %352[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %377 = llvm.mlir.constant(10 : index) : i64
    %378 = llvm.mul %353, %377  : i64
    %379 = llvm.add %376, %378  : i64
    %380 = llvm.add %379, %355  : i64
    %381 = llvm.getelementptr %375[%380] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %382 = llvm.load %381 : !llvm.ptr<f32>
    %383 = llvm.fmul %366, %374  : f32
    %384 = llvm.fadd %382, %383  : f32
    %385 = llvm.extractvalue %352[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %386 = llvm.extractvalue %352[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %387 = llvm.mlir.constant(10 : index) : i64
    %388 = llvm.mul %353, %387  : i64
    %389 = llvm.add %386, %388  : i64
    %390 = llvm.add %389, %355  : i64
    %391 = llvm.getelementptr %385[%390] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    llvm.store %384, %391 : !llvm.ptr<f32>
    %392 = llvm.add %357, %6  : i64
    llvm.br ^bb19(%392 : i64)
  ^bb21:  // pred: ^bb19
    %393 = llvm.add %355, %6  : i64
    llvm.br ^bb18(%393 : i64)
  ^bb22:  // pred: ^bb18
    %394 = llvm.add %353, %6  : i64
    llvm.br ^bb17(%394 : i64)
  ^bb23:  // pred: ^bb17
    %395 = llvm.add %274, %4  : i64
    llvm.br ^bb15(%395 : i64)
  ^bb24:  // pred: ^bb15
    %396 = llvm.add %272, %4  : i64
    llvm.br ^bb14(%396 : i64)
  ^bb25:  // pred: ^bb14
    %397 = llvm.add %270, %4  : i64
    llvm.br ^bb13(%397 : i64)
  ^bb26:  // pred: ^bb13
    %398 = llvm.add %191, %3  : i64
    llvm.br ^bb11(%398 : i64)
  ^bb27:  // pred: ^bb11
    %399 = llvm.add %189, %3  : i64
    llvm.br ^bb10(%399 : i64)
  ^bb28:  // pred: ^bb10
    %400 = llvm.add %187, %4  : i64
    llvm.br ^bb9(%400 : i64)
  ^bb29:  // pred: ^bb9
    %401 = llvm.add %91, %90  : i64
    llvm.br ^bb3(%401 : i64)
  ^bb30:  // pred: ^bb3
    %402 = llvm.add %85, %84  : i64
    llvm.br ^bb1(%402 : i64)
  ^bb31:  // pred: ^bb1
    %403 = llvm.mlir.constant(0 : i32) : i32
    llvm.return %403 : i32
  }
}

// *** IR Dump After Canonicalizer ***
module  {
  llvm.func internal @predict_dispatch_2(%arg0: !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>, %arg1: !llvm.ptr<array<3 x i32>>) -> i32 {
    %0 = llvm.mlir.constant(0.000000e+00 : f32) : f32
    %1 = llvm.mlir.constant(10 : index) : i64
    %2 = llvm.mlir.constant(128 : index) : i64
    %3 = llvm.mlir.constant(32 : index) : i64
    %4 = llvm.mlir.constant(4 : index) : i64
    %5 = llvm.mlir.constant(0 : index) : i64
    %6 = llvm.mlir.constant(1 : index) : i64
    %7 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
    %8 = llvm.extractvalue %7[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
    %9 = llvm.mlir.constant(1 : index) : i64
    %10 = llvm.getelementptr %8[%9] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
    %11 = llvm.load %10 : !llvm.ptr<ptr<i8>>
    %12 = llvm.getelementptr %11[%5] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
    %13 = llvm.bitcast %12 : !llvm.ptr<i8> to !llvm.ptr<f32>
    %14 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %15 = llvm.insertvalue %13, %14[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %16 = llvm.insertvalue %13, %15[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %17 = llvm.mlir.constant(0 : index) : i64
    %18 = llvm.insertvalue %17, %16[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %19 = llvm.mlir.constant(1 : index) : i64
    %20 = llvm.insertvalue %19, %18[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %21 = llvm.mlir.constant(128 : index) : i64
    %22 = llvm.insertvalue %21, %20[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %23 = llvm.mlir.constant(128 : index) : i64
    %24 = llvm.insertvalue %23, %22[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %25 = llvm.mlir.constant(1 : index) : i64
    %26 = llvm.insertvalue %25, %24[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %27 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
    %28 = llvm.extractvalue %27[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
    %29 = llvm.mlir.constant(0 : index) : i64
    %30 = llvm.getelementptr %28[%29] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
    %31 = llvm.load %30 : !llvm.ptr<ptr<i8>>
    %32 = llvm.getelementptr %31[%5] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
    %33 = llvm.bitcast %32 : !llvm.ptr<i8> to !llvm.ptr<f32>
    %34 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %35 = llvm.insertvalue %33, %34[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %36 = llvm.insertvalue %33, %35[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %37 = llvm.mlir.constant(0 : index) : i64
    %38 = llvm.insertvalue %37, %36[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %39 = llvm.mlir.constant(128 : index) : i64
    %40 = llvm.insertvalue %39, %38[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %41 = llvm.mlir.constant(10 : index) : i64
    %42 = llvm.insertvalue %41, %40[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %43 = llvm.mlir.constant(10 : index) : i64
    %44 = llvm.insertvalue %43, %42[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %45 = llvm.mlir.constant(1 : index) : i64
    %46 = llvm.insertvalue %45, %44[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %47 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
    %48 = llvm.extractvalue %47[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
    %49 = llvm.mlir.constant(2 : index) : i64
    %50 = llvm.getelementptr %48[%49] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
    %51 = llvm.load %50 : !llvm.ptr<ptr<i8>>
    %52 = llvm.getelementptr %51[%5] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
    %53 = llvm.bitcast %52 : !llvm.ptr<i8> to !llvm.ptr<f32>
    %54 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %55 = llvm.insertvalue %53, %54[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %56 = llvm.insertvalue %53, %55[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %57 = llvm.mlir.constant(0 : index) : i64
    %58 = llvm.insertvalue %57, %56[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %59 = llvm.mlir.constant(1 : index) : i64
    %60 = llvm.insertvalue %59, %58[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %61 = llvm.mlir.constant(10 : index) : i64
    %62 = llvm.insertvalue %61, %60[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %63 = llvm.mlir.constant(10 : index) : i64
    %64 = llvm.insertvalue %63, %62[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %65 = llvm.mlir.constant(1 : index) : i64
    %66 = llvm.insertvalue %65, %64[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %67 = llvm.load %arg1 : !llvm.ptr<array<3 x i32>>
    %68 = llvm.extractvalue %67[0] : !llvm.array<3 x i32>
    %69 = llvm.zext %68 : i32 to i64
    %70 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
    %71 = llvm.extractvalue %70[0] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
    %72 = llvm.extractvalue %71[0] : !llvm.array<3 x i32>
    %73 = llvm.zext %72 : i32 to i64
    %74 = llvm.load %arg1 : !llvm.ptr<array<3 x i32>>
    %75 = llvm.extractvalue %74[1] : !llvm.array<3 x i32>
    %76 = llvm.zext %75 : i32 to i64
    %77 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
    %78 = llvm.extractvalue %77[0] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
    %79 = llvm.extractvalue %78[1] : !llvm.array<3 x i32>
    %80 = llvm.zext %79 : i32 to i64
    %81 = llvm.mlir.constant(4 : index) : i64
    %82 = llvm.mul %76, %81  : i64
    %83 = llvm.mlir.constant(4 : index) : i64
    %84 = llvm.mul %80, %83  : i64
    llvm.br ^bb1(%82 : i64)
  ^bb1(%85: i64):  // 2 preds: ^bb0, ^bb30
    %86 = llvm.icmp "slt" %85, %6 : i64
    llvm.cond_br %86, ^bb2, ^bb31
  ^bb2:  // pred: ^bb1
    %87 = llvm.mlir.constant(64 : index) : i64
    %88 = llvm.mul %69, %87  : i64
    %89 = llvm.mlir.constant(64 : index) : i64
    %90 = llvm.mul %73, %89  : i64
    llvm.br ^bb3(%88 : i64)
  ^bb3(%91: i64):  // 2 preds: ^bb2, ^bb29
    %92 = llvm.icmp "slt" %91, %1 : i64
    llvm.cond_br %92, ^bb4, ^bb30
  ^bb4:  // pred: ^bb3
    %93 = llvm.mlir.constant(4 : index) : i64
    %94 = llvm.mlir.constant(-1 : index) : i64
    %95 = llvm.mul %85, %94  : i64
    %96 = llvm.mlir.constant(1 : index) : i64
    %97 = llvm.add %95, %96  : i64
    %98 = llvm.icmp "slt" %93, %97 : i64
    %99 = llvm.select %98, %93, %97 : i1, i64
    %100 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %101 = llvm.extractvalue %26[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %102 = llvm.bitcast %101 : !llvm.ptr<f32> to !llvm.ptr<f32>
    %103 = llvm.insertvalue %102, %100[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %104 = llvm.extractvalue %26[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %105 = llvm.bitcast %104 : !llvm.ptr<f32> to !llvm.ptr<f32>
    %106 = llvm.insertvalue %105, %103[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %107 = llvm.extractvalue %26[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %108 = llvm.extractvalue %26[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %109 = llvm.extractvalue %26[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %110 = llvm.mul %85, %107  : i64
    %111 = llvm.add %109, %110  : i64
    %112 = llvm.mlir.constant(0 : i64) : i64
    %113 = llvm.mul %112, %108  : i64
    %114 = llvm.add %111, %113  : i64
    %115 = llvm.insertvalue %114, %106[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %116 = llvm.mlir.constant(128 : i64) : i64
    %117 = llvm.mlir.constant(1 : i64) : i64
    %118 = llvm.insertvalue %116, %115[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %119 = llvm.insertvalue %117, %118[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %120 = llvm.mlir.constant(128 : i64) : i64
    %121 = llvm.insertvalue %99, %119[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %122 = llvm.insertvalue %120, %121[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %123 = llvm.mlir.constant(64 : index) : i64
    %124 = llvm.mlir.constant(-1 : index) : i64
    %125 = llvm.mul %91, %124  : i64
    %126 = llvm.mlir.constant(10 : index) : i64
    %127 = llvm.add %125, %126  : i64
    %128 = llvm.icmp "slt" %123, %127 : i64
    %129 = llvm.select %128, %123, %127 : i1, i64
    %130 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %131 = llvm.extractvalue %46[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %132 = llvm.bitcast %131 : !llvm.ptr<f32> to !llvm.ptr<f32>
    %133 = llvm.insertvalue %132, %130[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %134 = llvm.extractvalue %46[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %135 = llvm.bitcast %134 : !llvm.ptr<f32> to !llvm.ptr<f32>
    %136 = llvm.insertvalue %135, %133[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %137 = llvm.extractvalue %46[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %138 = llvm.extractvalue %46[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %139 = llvm.extractvalue %46[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %140 = llvm.mlir.constant(0 : i64) : i64
    %141 = llvm.mul %140, %137  : i64
    %142 = llvm.add %139, %141  : i64
    %143 = llvm.mul %91, %138  : i64
    %144 = llvm.add %142, %143  : i64
    %145 = llvm.insertvalue %144, %136[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %146 = llvm.mlir.constant(1 : i64) : i64
    %147 = llvm.insertvalue %129, %145[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %148 = llvm.insertvalue %146, %147[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %149 = llvm.mlir.constant(128 : i64) : i64
    %150 = llvm.mlir.constant(10 : i64) : i64
    %151 = llvm.insertvalue %149, %148[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %152 = llvm.insertvalue %150, %151[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %153 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %154 = llvm.extractvalue %66[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %155 = llvm.bitcast %154 : !llvm.ptr<f32> to !llvm.ptr<f32>
    %156 = llvm.insertvalue %155, %153[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %157 = llvm.extractvalue %66[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %158 = llvm.bitcast %157 : !llvm.ptr<f32> to !llvm.ptr<f32>
    %159 = llvm.insertvalue %158, %156[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %160 = llvm.extractvalue %66[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %161 = llvm.extractvalue %66[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %162 = llvm.extractvalue %66[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %163 = llvm.mul %85, %160  : i64
    %164 = llvm.add %162, %163  : i64
    %165 = llvm.mul %91, %161  : i64
    %166 = llvm.add %164, %165  : i64
    %167 = llvm.insertvalue %166, %159[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %168 = llvm.mlir.constant(1 : i64) : i64
    %169 = llvm.insertvalue %129, %167[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %170 = llvm.insertvalue %168, %169[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %171 = llvm.mlir.constant(10 : i64) : i64
    %172 = llvm.insertvalue %99, %170[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %173 = llvm.insertvalue %171, %172[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    llvm.br ^bb5(%5 : i64)
  ^bb5(%174: i64):  // 2 preds: ^bb4, ^bb8
    %175 = llvm.icmp "slt" %174, %99 : i64
    llvm.cond_br %175, ^bb6(%5 : i64), ^bb9(%5 : i64)
  ^bb6(%176: i64):  // 2 preds: ^bb5, ^bb7
    %177 = llvm.icmp "slt" %176, %129 : i64
    llvm.cond_br %177, ^bb7, ^bb8
  ^bb7:  // pred: ^bb6
    %178 = llvm.extractvalue %173[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %179 = llvm.extractvalue %173[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %180 = llvm.mlir.constant(10 : index) : i64
    %181 = llvm.mul %174, %180  : i64
    %182 = llvm.add %179, %181  : i64
    %183 = llvm.add %182, %176  : i64
    %184 = llvm.getelementptr %178[%183] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    llvm.store %0, %184 : !llvm.ptr<f32>
    %185 = llvm.add %176, %6  : i64
    llvm.br ^bb6(%185 : i64)
  ^bb8:  // pred: ^bb6
    %186 = llvm.add %174, %6  : i64
    llvm.br ^bb5(%186 : i64)
  ^bb9(%187: i64):  // 2 preds: ^bb5, ^bb28
    %188 = llvm.icmp "slt" %187, %99 : i64
    llvm.cond_br %188, ^bb10(%5 : i64), ^bb29
  ^bb10(%189: i64):  // 2 preds: ^bb9, ^bb27
    %190 = llvm.icmp "slt" %189, %129 : i64
    llvm.cond_br %190, ^bb11(%5 : i64), ^bb28
  ^bb11(%191: i64):  // 2 preds: ^bb10, ^bb26
    %192 = llvm.icmp "slt" %191, %2 : i64
    llvm.cond_br %192, ^bb12, ^bb27
  ^bb12:  // pred: ^bb11
    %193 = llvm.mlir.constant(4 : index) : i64
    %194 = llvm.mlir.constant(-1 : index) : i64
    %195 = llvm.mul %187, %194  : i64
    %196 = llvm.add %99, %195  : i64
    %197 = llvm.icmp "slt" %193, %196 : i64
    %198 = llvm.select %197, %193, %196 : i1, i64
    %199 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %200 = llvm.extractvalue %122[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %201 = llvm.bitcast %200 : !llvm.ptr<f32> to !llvm.ptr<f32>
    %202 = llvm.insertvalue %201, %199[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %203 = llvm.extractvalue %122[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %204 = llvm.bitcast %203 : !llvm.ptr<f32> to !llvm.ptr<f32>
    %205 = llvm.insertvalue %204, %202[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %206 = llvm.extractvalue %122[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %207 = llvm.extractvalue %122[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %208 = llvm.extractvalue %122[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %209 = llvm.mul %187, %206  : i64
    %210 = llvm.add %208, %209  : i64
    %211 = llvm.mul %191, %207  : i64
    %212 = llvm.add %210, %211  : i64
    %213 = llvm.insertvalue %212, %205[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %214 = llvm.mlir.constant(32 : i64) : i64
    %215 = llvm.mlir.constant(1 : i64) : i64
    %216 = llvm.insertvalue %214, %213[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %217 = llvm.insertvalue %215, %216[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %218 = llvm.mlir.constant(128 : i64) : i64
    %219 = llvm.insertvalue %198, %217[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %220 = llvm.insertvalue %218, %219[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %221 = llvm.mlir.constant(32 : index) : i64
    %222 = llvm.mlir.constant(-1 : index) : i64
    %223 = llvm.mul %189, %222  : i64
    %224 = llvm.add %129, %223  : i64
    %225 = llvm.icmp "slt" %221, %224 : i64
    %226 = llvm.select %225, %221, %224 : i1, i64
    %227 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %228 = llvm.extractvalue %152[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %229 = llvm.bitcast %228 : !llvm.ptr<f32> to !llvm.ptr<f32>
    %230 = llvm.insertvalue %229, %227[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %231 = llvm.extractvalue %152[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %232 = llvm.bitcast %231 : !llvm.ptr<f32> to !llvm.ptr<f32>
    %233 = llvm.insertvalue %232, %230[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %234 = llvm.extractvalue %152[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %235 = llvm.extractvalue %152[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %236 = llvm.extractvalue %152[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %237 = llvm.mul %191, %234  : i64
    %238 = llvm.add %236, %237  : i64
    %239 = llvm.mul %189, %235  : i64
    %240 = llvm.add %238, %239  : i64
    %241 = llvm.insertvalue %240, %233[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %242 = llvm.mlir.constant(1 : i64) : i64
    %243 = llvm.insertvalue %226, %241[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %244 = llvm.insertvalue %242, %243[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %245 = llvm.mlir.constant(32 : i64) : i64
    %246 = llvm.mlir.constant(10 : i64) : i64
    %247 = llvm.insertvalue %245, %244[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %248 = llvm.insertvalue %246, %247[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %249 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %250 = llvm.extractvalue %173[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %251 = llvm.bitcast %250 : !llvm.ptr<f32> to !llvm.ptr<f32>
    %252 = llvm.insertvalue %251, %249[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %253 = llvm.extractvalue %173[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %254 = llvm.bitcast %253 : !llvm.ptr<f32> to !llvm.ptr<f32>
    %255 = llvm.insertvalue %254, %252[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %256 = llvm.extractvalue %173[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %257 = llvm.extractvalue %173[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %258 = llvm.extractvalue %173[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %259 = llvm.mul %187, %256  : i64
    %260 = llvm.add %258, %259  : i64
    %261 = llvm.mul %189, %257  : i64
    %262 = llvm.add %260, %261  : i64
    %263 = llvm.insertvalue %262, %255[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %264 = llvm.mlir.constant(1 : i64) : i64
    %265 = llvm.insertvalue %226, %263[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %266 = llvm.insertvalue %264, %265[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %267 = llvm.mlir.constant(10 : i64) : i64
    %268 = llvm.insertvalue %198, %266[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %269 = llvm.insertvalue %267, %268[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    llvm.br ^bb13(%5 : i64)
  ^bb13(%270: i64):  // 2 preds: ^bb12, ^bb25
    %271 = llvm.icmp "slt" %270, %198 : i64
    llvm.cond_br %271, ^bb14(%5 : i64), ^bb26
  ^bb14(%272: i64):  // 2 preds: ^bb13, ^bb24
    %273 = llvm.icmp "slt" %272, %226 : i64
    llvm.cond_br %273, ^bb15(%5 : i64), ^bb25
  ^bb15(%274: i64):  // 2 preds: ^bb14, ^bb23
    %275 = llvm.icmp "slt" %274, %3 : i64
    llvm.cond_br %275, ^bb16, ^bb24
  ^bb16:  // pred: ^bb15
    %276 = llvm.mlir.constant(4 : index) : i64
    %277 = llvm.mlir.constant(-1 : index) : i64
    %278 = llvm.mul %270, %277  : i64
    %279 = llvm.add %198, %278  : i64
    %280 = llvm.icmp "slt" %276, %279 : i64
    %281 = llvm.select %280, %276, %279 : i1, i64
    %282 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %283 = llvm.extractvalue %220[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %284 = llvm.bitcast %283 : !llvm.ptr<f32> to !llvm.ptr<f32>
    %285 = llvm.insertvalue %284, %282[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %286 = llvm.extractvalue %220[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %287 = llvm.bitcast %286 : !llvm.ptr<f32> to !llvm.ptr<f32>
    %288 = llvm.insertvalue %287, %285[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %289 = llvm.extractvalue %220[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %290 = llvm.extractvalue %220[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %291 = llvm.extractvalue %220[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %292 = llvm.mul %270, %289  : i64
    %293 = llvm.add %291, %292  : i64
    %294 = llvm.mul %274, %290  : i64
    %295 = llvm.add %293, %294  : i64
    %296 = llvm.insertvalue %295, %288[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %297 = llvm.mlir.constant(4 : i64) : i64
    %298 = llvm.mlir.constant(1 : i64) : i64
    %299 = llvm.insertvalue %297, %296[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %300 = llvm.insertvalue %298, %299[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %301 = llvm.mlir.constant(128 : i64) : i64
    %302 = llvm.insertvalue %281, %300[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %303 = llvm.insertvalue %301, %302[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %304 = llvm.mlir.constant(4 : index) : i64
    %305 = llvm.mlir.constant(-1 : index) : i64
    %306 = llvm.mul %272, %305  : i64
    %307 = llvm.add %226, %306  : i64
    %308 = llvm.icmp "slt" %304, %307 : i64
    %309 = llvm.select %308, %304, %307 : i1, i64
    %310 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %311 = llvm.extractvalue %248[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %312 = llvm.bitcast %311 : !llvm.ptr<f32> to !llvm.ptr<f32>
    %313 = llvm.insertvalue %312, %310[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %314 = llvm.extractvalue %248[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %315 = llvm.bitcast %314 : !llvm.ptr<f32> to !llvm.ptr<f32>
    %316 = llvm.insertvalue %315, %313[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %317 = llvm.extractvalue %248[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %318 = llvm.extractvalue %248[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %319 = llvm.extractvalue %248[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %320 = llvm.mul %274, %317  : i64
    %321 = llvm.add %319, %320  : i64
    %322 = llvm.mul %272, %318  : i64
    %323 = llvm.add %321, %322  : i64
    %324 = llvm.insertvalue %323, %316[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %325 = llvm.mlir.constant(1 : i64) : i64
    %326 = llvm.insertvalue %309, %324[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %327 = llvm.insertvalue %325, %326[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %328 = llvm.mlir.constant(4 : i64) : i64
    %329 = llvm.mlir.constant(10 : i64) : i64
    %330 = llvm.insertvalue %328, %327[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %331 = llvm.insertvalue %329, %330[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %332 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %333 = llvm.extractvalue %269[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %334 = llvm.bitcast %333 : !llvm.ptr<f32> to !llvm.ptr<f32>
    %335 = llvm.insertvalue %334, %332[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %336 = llvm.extractvalue %269[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %337 = llvm.bitcast %336 : !llvm.ptr<f32> to !llvm.ptr<f32>
    %338 = llvm.insertvalue %337, %335[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %339 = llvm.extractvalue %269[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %340 = llvm.extractvalue %269[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %341 = llvm.extractvalue %269[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %342 = llvm.mul %270, %339  : i64
    %343 = llvm.add %341, %342  : i64
    %344 = llvm.mul %272, %340  : i64
    %345 = llvm.add %343, %344  : i64
    %346 = llvm.insertvalue %345, %338[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %347 = llvm.mlir.constant(1 : i64) : i64
    %348 = llvm.insertvalue %309, %346[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %349 = llvm.insertvalue %347, %348[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %350 = llvm.mlir.constant(10 : i64) : i64
    %351 = llvm.insertvalue %281, %349[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %352 = llvm.insertvalue %350, %351[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    llvm.br ^bb17(%5 : i64)
  ^bb17(%353: i64):  // 2 preds: ^bb16, ^bb22
    %354 = llvm.icmp "slt" %353, %281 : i64
    llvm.cond_br %354, ^bb18(%5 : i64), ^bb23
  ^bb18(%355: i64):  // 2 preds: ^bb17, ^bb21
    %356 = llvm.icmp "slt" %355, %309 : i64
    llvm.cond_br %356, ^bb19(%5 : i64), ^bb22
  ^bb19(%357: i64):  // 2 preds: ^bb18, ^bb20
    %358 = llvm.icmp "slt" %357, %4 : i64
    llvm.cond_br %358, ^bb20, ^bb21
  ^bb20:  // pred: ^bb19
    %359 = llvm.extractvalue %303[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %360 = llvm.extractvalue %303[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %361 = llvm.mlir.constant(128 : index) : i64
    %362 = llvm.mul %353, %361  : i64
    %363 = llvm.add %360, %362  : i64
    %364 = llvm.add %363, %357  : i64
    %365 = llvm.getelementptr %359[%364] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %366 = llvm.load %365 : !llvm.ptr<f32>
    %367 = llvm.extractvalue %331[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %368 = llvm.extractvalue %331[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %369 = llvm.mlir.constant(10 : index) : i64
    %370 = llvm.mul %357, %369  : i64
    %371 = llvm.add %368, %370  : i64
    %372 = llvm.add %371, %355  : i64
    %373 = llvm.getelementptr %367[%372] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %374 = llvm.load %373 : !llvm.ptr<f32>
    %375 = llvm.extractvalue %352[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %376 = llvm.extractvalue %352[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %377 = llvm.mlir.constant(10 : index) : i64
    %378 = llvm.mul %353, %377  : i64
    %379 = llvm.add %376, %378  : i64
    %380 = llvm.add %379, %355  : i64
    %381 = llvm.getelementptr %375[%380] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %382 = llvm.load %381 : !llvm.ptr<f32>
    %383 = llvm.fmul %366, %374  : f32
    %384 = llvm.fadd %382, %383  : f32
    %385 = llvm.extractvalue %352[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %386 = llvm.extractvalue %352[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %387 = llvm.mlir.constant(10 : index) : i64
    %388 = llvm.mul %353, %387  : i64
    %389 = llvm.add %386, %388  : i64
    %390 = llvm.add %389, %355  : i64
    %391 = llvm.getelementptr %385[%390] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    llvm.store %384, %391 : !llvm.ptr<f32>
    %392 = llvm.add %357, %6  : i64
    llvm.br ^bb19(%392 : i64)
  ^bb21:  // pred: ^bb19
    %393 = llvm.add %355, %6  : i64
    llvm.br ^bb18(%393 : i64)
  ^bb22:  // pred: ^bb18
    %394 = llvm.add %353, %6  : i64
    llvm.br ^bb17(%394 : i64)
  ^bb23:  // pred: ^bb17
    %395 = llvm.add %274, %4  : i64
    llvm.br ^bb15(%395 : i64)
  ^bb24:  // pred: ^bb15
    %396 = llvm.add %272, %4  : i64
    llvm.br ^bb14(%396 : i64)
  ^bb25:  // pred: ^bb14
    %397 = llvm.add %270, %4  : i64
    llvm.br ^bb13(%397 : i64)
  ^bb26:  // pred: ^bb13
    %398 = llvm.add %191, %3  : i64
    llvm.br ^bb11(%398 : i64)
  ^bb27:  // pred: ^bb11
    %399 = llvm.add %189, %3  : i64
    llvm.br ^bb10(%399 : i64)
  ^bb28:  // pred: ^bb10
    %400 = llvm.add %187, %4  : i64
    llvm.br ^bb9(%400 : i64)
  ^bb29:  // pred: ^bb9
    %401 = llvm.add %91, %90  : i64
    llvm.br ^bb3(%401 : i64)
  ^bb30:  // pred: ^bb3
    %402 = llvm.add %85, %84  : i64
    llvm.br ^bb1(%402 : i64)
  ^bb31:  // pred: ^bb1
    %403 = llvm.mlir.constant(0 : i32) : i32
    llvm.return %403 : i32
  }
}

// *** IR Dump After CSE ***
module  {
  llvm.func internal @predict_dispatch_2(%arg0: !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>, %arg1: !llvm.ptr<array<3 x i32>>) -> i32 {
    %0 = llvm.mlir.constant(0.000000e+00 : f32) : f32
    %1 = llvm.mlir.constant(10 : index) : i64
    %2 = llvm.mlir.constant(128 : index) : i64
    %3 = llvm.mlir.constant(32 : index) : i64
    %4 = llvm.mlir.constant(4 : index) : i64
    %5 = llvm.mlir.constant(0 : index) : i64
    %6 = llvm.mlir.constant(1 : index) : i64
    %7 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
    %8 = llvm.extractvalue %7[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
    %9 = llvm.getelementptr %8[%6] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
    %10 = llvm.load %9 : !llvm.ptr<ptr<i8>>
    %11 = llvm.getelementptr %10[%5] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
    %12 = llvm.bitcast %11 : !llvm.ptr<i8> to !llvm.ptr<f32>
    %13 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %14 = llvm.insertvalue %12, %13[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %15 = llvm.insertvalue %12, %14[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %16 = llvm.insertvalue %5, %15[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %17 = llvm.insertvalue %6, %16[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %18 = llvm.insertvalue %2, %17[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %19 = llvm.insertvalue %2, %18[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %20 = llvm.insertvalue %6, %19[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %21 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
    %22 = llvm.extractvalue %21[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
    %23 = llvm.getelementptr %22[%5] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
    %24 = llvm.load %23 : !llvm.ptr<ptr<i8>>
    %25 = llvm.getelementptr %24[%5] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
    %26 = llvm.bitcast %25 : !llvm.ptr<i8> to !llvm.ptr<f32>
    %27 = llvm.insertvalue %26, %13[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %28 = llvm.insertvalue %26, %27[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %29 = llvm.insertvalue %5, %28[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %30 = llvm.insertvalue %2, %29[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %31 = llvm.insertvalue %1, %30[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %32 = llvm.insertvalue %1, %31[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %33 = llvm.insertvalue %6, %32[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %34 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
    %35 = llvm.extractvalue %34[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
    %36 = llvm.mlir.constant(2 : index) : i64
    %37 = llvm.getelementptr %35[%36] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
    %38 = llvm.load %37 : !llvm.ptr<ptr<i8>>
    %39 = llvm.getelementptr %38[%5] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
    %40 = llvm.bitcast %39 : !llvm.ptr<i8> to !llvm.ptr<f32>
    %41 = llvm.insertvalue %40, %13[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %42 = llvm.insertvalue %40, %41[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %43 = llvm.insertvalue %5, %42[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %44 = llvm.insertvalue %6, %43[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %45 = llvm.insertvalue %1, %44[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %46 = llvm.insertvalue %1, %45[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %47 = llvm.insertvalue %6, %46[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %48 = llvm.load %arg1 : !llvm.ptr<array<3 x i32>>
    %49 = llvm.extractvalue %48[0] : !llvm.array<3 x i32>
    %50 = llvm.zext %49 : i32 to i64
    %51 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
    %52 = llvm.extractvalue %51[0] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
    %53 = llvm.extractvalue %52[0] : !llvm.array<3 x i32>
    %54 = llvm.zext %53 : i32 to i64
    %55 = llvm.load %arg1 : !llvm.ptr<array<3 x i32>>
    %56 = llvm.extractvalue %55[1] : !llvm.array<3 x i32>
    %57 = llvm.zext %56 : i32 to i64
    %58 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
    %59 = llvm.extractvalue %58[0] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
    %60 = llvm.extractvalue %59[1] : !llvm.array<3 x i32>
    %61 = llvm.zext %60 : i32 to i64
    %62 = llvm.mul %57, %4  : i64
    %63 = llvm.mul %61, %4  : i64
    llvm.br ^bb1(%62 : i64)
  ^bb1(%64: i64):  // 2 preds: ^bb0, ^bb30
    %65 = llvm.icmp "slt" %64, %6 : i64
    llvm.cond_br %65, ^bb2, ^bb31
  ^bb2:  // pred: ^bb1
    %66 = llvm.mlir.constant(64 : index) : i64
    %67 = llvm.mul %50, %66  : i64
    %68 = llvm.mul %54, %66  : i64
    llvm.br ^bb3(%67 : i64)
  ^bb3(%69: i64):  // 2 preds: ^bb2, ^bb29
    %70 = llvm.icmp "slt" %69, %1 : i64
    llvm.cond_br %70, ^bb4, ^bb30
  ^bb4:  // pred: ^bb3
    %71 = llvm.mlir.constant(-1 : index) : i64
    %72 = llvm.mul %64, %71  : i64
    %73 = llvm.add %72, %6  : i64
    %74 = llvm.icmp "slt" %4, %73 : i64
    %75 = llvm.select %74, %4, %73 : i1, i64
    %76 = llvm.extractvalue %20[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %77 = llvm.bitcast %76 : !llvm.ptr<f32> to !llvm.ptr<f32>
    %78 = llvm.insertvalue %77, %13[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %79 = llvm.extractvalue %20[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %80 = llvm.bitcast %79 : !llvm.ptr<f32> to !llvm.ptr<f32>
    %81 = llvm.insertvalue %80, %78[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %82 = llvm.extractvalue %20[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %83 = llvm.extractvalue %20[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %84 = llvm.extractvalue %20[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %85 = llvm.mul %64, %82  : i64
    %86 = llvm.add %84, %85  : i64
    %87 = llvm.mlir.constant(0 : i64) : i64
    %88 = llvm.mul %87, %83  : i64
    %89 = llvm.add %86, %88  : i64
    %90 = llvm.insertvalue %89, %81[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %91 = llvm.mlir.constant(128 : i64) : i64
    %92 = llvm.mlir.constant(1 : i64) : i64
    %93 = llvm.insertvalue %91, %90[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %94 = llvm.insertvalue %92, %93[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %95 = llvm.insertvalue %75, %94[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %96 = llvm.insertvalue %91, %95[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %97 = llvm.mul %69, %71  : i64
    %98 = llvm.add %97, %1  : i64
    %99 = llvm.icmp "slt" %66, %98 : i64
    %100 = llvm.select %99, %66, %98 : i1, i64
    %101 = llvm.extractvalue %33[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %102 = llvm.bitcast %101 : !llvm.ptr<f32> to !llvm.ptr<f32>
    %103 = llvm.insertvalue %102, %13[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %104 = llvm.extractvalue %33[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %105 = llvm.bitcast %104 : !llvm.ptr<f32> to !llvm.ptr<f32>
    %106 = llvm.insertvalue %105, %103[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %107 = llvm.extractvalue %33[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %108 = llvm.extractvalue %33[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %109 = llvm.extractvalue %33[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %110 = llvm.mul %87, %107  : i64
    %111 = llvm.add %109, %110  : i64
    %112 = llvm.mul %69, %108  : i64
    %113 = llvm.add %111, %112  : i64
    %114 = llvm.insertvalue %113, %106[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %115 = llvm.insertvalue %100, %114[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %116 = llvm.insertvalue %92, %115[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %117 = llvm.mlir.constant(10 : i64) : i64
    %118 = llvm.insertvalue %91, %116[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %119 = llvm.insertvalue %117, %118[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %120 = llvm.extractvalue %47[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %121 = llvm.bitcast %120 : !llvm.ptr<f32> to !llvm.ptr<f32>
    %122 = llvm.insertvalue %121, %13[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %123 = llvm.extractvalue %47[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %124 = llvm.bitcast %123 : !llvm.ptr<f32> to !llvm.ptr<f32>
    %125 = llvm.insertvalue %124, %122[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %126 = llvm.extractvalue %47[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %127 = llvm.extractvalue %47[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %128 = llvm.extractvalue %47[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %129 = llvm.mul %64, %126  : i64
    %130 = llvm.add %128, %129  : i64
    %131 = llvm.mul %69, %127  : i64
    %132 = llvm.add %130, %131  : i64
    %133 = llvm.insertvalue %132, %125[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %134 = llvm.insertvalue %100, %133[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %135 = llvm.insertvalue %92, %134[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %136 = llvm.insertvalue %75, %135[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %137 = llvm.insertvalue %117, %136[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    llvm.br ^bb5(%5 : i64)
  ^bb5(%138: i64):  // 2 preds: ^bb4, ^bb8
    %139 = llvm.icmp "slt" %138, %75 : i64
    llvm.cond_br %139, ^bb6(%5 : i64), ^bb9(%5 : i64)
  ^bb6(%140: i64):  // 2 preds: ^bb5, ^bb7
    %141 = llvm.icmp "slt" %140, %100 : i64
    llvm.cond_br %141, ^bb7, ^bb8
  ^bb7:  // pred: ^bb6
    %142 = llvm.extractvalue %137[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %143 = llvm.extractvalue %137[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %144 = llvm.mul %138, %1  : i64
    %145 = llvm.add %143, %144  : i64
    %146 = llvm.add %145, %140  : i64
    %147 = llvm.getelementptr %142[%146] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    llvm.store %0, %147 : !llvm.ptr<f32>
    %148 = llvm.add %140, %6  : i64
    llvm.br ^bb6(%148 : i64)
  ^bb8:  // pred: ^bb6
    %149 = llvm.add %138, %6  : i64
    llvm.br ^bb5(%149 : i64)
  ^bb9(%150: i64):  // 2 preds: ^bb5, ^bb28
    %151 = llvm.icmp "slt" %150, %75 : i64
    llvm.cond_br %151, ^bb10(%5 : i64), ^bb29
  ^bb10(%152: i64):  // 2 preds: ^bb9, ^bb27
    %153 = llvm.icmp "slt" %152, %100 : i64
    llvm.cond_br %153, ^bb11(%5 : i64), ^bb28
  ^bb11(%154: i64):  // 2 preds: ^bb10, ^bb26
    %155 = llvm.icmp "slt" %154, %2 : i64
    llvm.cond_br %155, ^bb12, ^bb27
  ^bb12:  // pred: ^bb11
    %156 = llvm.mul %150, %71  : i64
    %157 = llvm.add %75, %156  : i64
    %158 = llvm.icmp "slt" %4, %157 : i64
    %159 = llvm.select %158, %4, %157 : i1, i64
    %160 = llvm.extractvalue %96[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %161 = llvm.bitcast %160 : !llvm.ptr<f32> to !llvm.ptr<f32>
    %162 = llvm.insertvalue %161, %13[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %163 = llvm.extractvalue %96[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %164 = llvm.bitcast %163 : !llvm.ptr<f32> to !llvm.ptr<f32>
    %165 = llvm.insertvalue %164, %162[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %166 = llvm.extractvalue %96[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %167 = llvm.extractvalue %96[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %168 = llvm.extractvalue %96[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %169 = llvm.mul %150, %166  : i64
    %170 = llvm.add %168, %169  : i64
    %171 = llvm.mul %154, %167  : i64
    %172 = llvm.add %170, %171  : i64
    %173 = llvm.insertvalue %172, %165[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %174 = llvm.mlir.constant(32 : i64) : i64
    %175 = llvm.insertvalue %174, %173[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %176 = llvm.insertvalue %92, %175[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %177 = llvm.insertvalue %159, %176[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %178 = llvm.insertvalue %91, %177[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %179 = llvm.mul %152, %71  : i64
    %180 = llvm.add %100, %179  : i64
    %181 = llvm.icmp "slt" %3, %180 : i64
    %182 = llvm.select %181, %3, %180 : i1, i64
    %183 = llvm.extractvalue %119[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %184 = llvm.bitcast %183 : !llvm.ptr<f32> to !llvm.ptr<f32>
    %185 = llvm.insertvalue %184, %13[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %186 = llvm.extractvalue %119[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %187 = llvm.bitcast %186 : !llvm.ptr<f32> to !llvm.ptr<f32>
    %188 = llvm.insertvalue %187, %185[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %189 = llvm.extractvalue %119[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %190 = llvm.extractvalue %119[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %191 = llvm.extractvalue %119[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %192 = llvm.mul %154, %189  : i64
    %193 = llvm.add %191, %192  : i64
    %194 = llvm.mul %152, %190  : i64
    %195 = llvm.add %193, %194  : i64
    %196 = llvm.insertvalue %195, %188[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %197 = llvm.insertvalue %182, %196[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %198 = llvm.insertvalue %92, %197[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %199 = llvm.insertvalue %174, %198[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %200 = llvm.insertvalue %117, %199[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %201 = llvm.extractvalue %137[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %202 = llvm.bitcast %201 : !llvm.ptr<f32> to !llvm.ptr<f32>
    %203 = llvm.insertvalue %202, %13[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %204 = llvm.extractvalue %137[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %205 = llvm.bitcast %204 : !llvm.ptr<f32> to !llvm.ptr<f32>
    %206 = llvm.insertvalue %205, %203[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %207 = llvm.extractvalue %137[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %208 = llvm.extractvalue %137[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %209 = llvm.extractvalue %137[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %210 = llvm.mul %150, %207  : i64
    %211 = llvm.add %209, %210  : i64
    %212 = llvm.mul %152, %208  : i64
    %213 = llvm.add %211, %212  : i64
    %214 = llvm.insertvalue %213, %206[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %215 = llvm.insertvalue %182, %214[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %216 = llvm.insertvalue %92, %215[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %217 = llvm.insertvalue %159, %216[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %218 = llvm.insertvalue %117, %217[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    llvm.br ^bb13(%5 : i64)
  ^bb13(%219: i64):  // 2 preds: ^bb12, ^bb25
    %220 = llvm.icmp "slt" %219, %159 : i64
    llvm.cond_br %220, ^bb14(%5 : i64), ^bb26
  ^bb14(%221: i64):  // 2 preds: ^bb13, ^bb24
    %222 = llvm.icmp "slt" %221, %182 : i64
    llvm.cond_br %222, ^bb15(%5 : i64), ^bb25
  ^bb15(%223: i64):  // 2 preds: ^bb14, ^bb23
    %224 = llvm.icmp "slt" %223, %3 : i64
    llvm.cond_br %224, ^bb16, ^bb24
  ^bb16:  // pred: ^bb15
    %225 = llvm.mul %219, %71  : i64
    %226 = llvm.add %159, %225  : i64
    %227 = llvm.icmp "slt" %4, %226 : i64
    %228 = llvm.select %227, %4, %226 : i1, i64
    %229 = llvm.extractvalue %178[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %230 = llvm.bitcast %229 : !llvm.ptr<f32> to !llvm.ptr<f32>
    %231 = llvm.insertvalue %230, %13[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %232 = llvm.extractvalue %178[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %233 = llvm.bitcast %232 : !llvm.ptr<f32> to !llvm.ptr<f32>
    %234 = llvm.insertvalue %233, %231[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %235 = llvm.extractvalue %178[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %236 = llvm.extractvalue %178[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %237 = llvm.extractvalue %178[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %238 = llvm.mul %219, %235  : i64
    %239 = llvm.add %237, %238  : i64
    %240 = llvm.mul %223, %236  : i64
    %241 = llvm.add %239, %240  : i64
    %242 = llvm.insertvalue %241, %234[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %243 = llvm.mlir.constant(4 : i64) : i64
    %244 = llvm.insertvalue %243, %242[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %245 = llvm.insertvalue %92, %244[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %246 = llvm.insertvalue %228, %245[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %247 = llvm.insertvalue %91, %246[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %248 = llvm.mul %221, %71  : i64
    %249 = llvm.add %182, %248  : i64
    %250 = llvm.icmp "slt" %4, %249 : i64
    %251 = llvm.select %250, %4, %249 : i1, i64
    %252 = llvm.extractvalue %200[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %253 = llvm.bitcast %252 : !llvm.ptr<f32> to !llvm.ptr<f32>
    %254 = llvm.insertvalue %253, %13[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %255 = llvm.extractvalue %200[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %256 = llvm.bitcast %255 : !llvm.ptr<f32> to !llvm.ptr<f32>
    %257 = llvm.insertvalue %256, %254[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %258 = llvm.extractvalue %200[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %259 = llvm.extractvalue %200[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %260 = llvm.extractvalue %200[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %261 = llvm.mul %223, %258  : i64
    %262 = llvm.add %260, %261  : i64
    %263 = llvm.mul %221, %259  : i64
    %264 = llvm.add %262, %263  : i64
    %265 = llvm.insertvalue %264, %257[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %266 = llvm.insertvalue %251, %265[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %267 = llvm.insertvalue %92, %266[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %268 = llvm.insertvalue %243, %267[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %269 = llvm.insertvalue %117, %268[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %270 = llvm.extractvalue %218[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %271 = llvm.bitcast %270 : !llvm.ptr<f32> to !llvm.ptr<f32>
    %272 = llvm.insertvalue %271, %13[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %273 = llvm.extractvalue %218[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %274 = llvm.bitcast %273 : !llvm.ptr<f32> to !llvm.ptr<f32>
    %275 = llvm.insertvalue %274, %272[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %276 = llvm.extractvalue %218[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %277 = llvm.extractvalue %218[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %278 = llvm.extractvalue %218[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %279 = llvm.mul %219, %276  : i64
    %280 = llvm.add %278, %279  : i64
    %281 = llvm.mul %221, %277  : i64
    %282 = llvm.add %280, %281  : i64
    %283 = llvm.insertvalue %282, %275[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %284 = llvm.insertvalue %251, %283[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %285 = llvm.insertvalue %92, %284[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %286 = llvm.insertvalue %228, %285[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %287 = llvm.insertvalue %117, %286[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    llvm.br ^bb17(%5 : i64)
  ^bb17(%288: i64):  // 2 preds: ^bb16, ^bb22
    %289 = llvm.icmp "slt" %288, %228 : i64
    llvm.cond_br %289, ^bb18(%5 : i64), ^bb23
  ^bb18(%290: i64):  // 2 preds: ^bb17, ^bb21
    %291 = llvm.icmp "slt" %290, %251 : i64
    llvm.cond_br %291, ^bb19(%5 : i64), ^bb22
  ^bb19(%292: i64):  // 2 preds: ^bb18, ^bb20
    %293 = llvm.icmp "slt" %292, %4 : i64
    llvm.cond_br %293, ^bb20, ^bb21
  ^bb20:  // pred: ^bb19
    %294 = llvm.extractvalue %247[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %295 = llvm.extractvalue %247[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %296 = llvm.mul %288, %2  : i64
    %297 = llvm.add %295, %296  : i64
    %298 = llvm.add %297, %292  : i64
    %299 = llvm.getelementptr %294[%298] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %300 = llvm.load %299 : !llvm.ptr<f32>
    %301 = llvm.extractvalue %269[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %302 = llvm.extractvalue %269[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %303 = llvm.mul %292, %1  : i64
    %304 = llvm.add %302, %303  : i64
    %305 = llvm.add %304, %290  : i64
    %306 = llvm.getelementptr %301[%305] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %307 = llvm.load %306 : !llvm.ptr<f32>
    %308 = llvm.extractvalue %287[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %309 = llvm.extractvalue %287[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %310 = llvm.mul %288, %1  : i64
    %311 = llvm.add %309, %310  : i64
    %312 = llvm.add %311, %290  : i64
    %313 = llvm.getelementptr %308[%312] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %314 = llvm.load %313 : !llvm.ptr<f32>
    %315 = llvm.fmul %300, %307  : f32
    %316 = llvm.fadd %314, %315  : f32
    llvm.store %316, %313 : !llvm.ptr<f32>
    %317 = llvm.add %292, %6  : i64
    llvm.br ^bb19(%317 : i64)
  ^bb21:  // pred: ^bb19
    %318 = llvm.add %290, %6  : i64
    llvm.br ^bb18(%318 : i64)
  ^bb22:  // pred: ^bb18
    %319 = llvm.add %288, %6  : i64
    llvm.br ^bb17(%319 : i64)
  ^bb23:  // pred: ^bb17
    %320 = llvm.add %223, %4  : i64
    llvm.br ^bb15(%320 : i64)
  ^bb24:  // pred: ^bb15
    %321 = llvm.add %221, %4  : i64
    llvm.br ^bb14(%321 : i64)
  ^bb25:  // pred: ^bb14
    %322 = llvm.add %219, %4  : i64
    llvm.br ^bb13(%322 : i64)
  ^bb26:  // pred: ^bb13
    %323 = llvm.add %154, %3  : i64
    llvm.br ^bb11(%323 : i64)
  ^bb27:  // pred: ^bb11
    %324 = llvm.add %152, %3  : i64
    llvm.br ^bb10(%324 : i64)
  ^bb28:  // pred: ^bb10
    %325 = llvm.add %150, %4  : i64
    llvm.br ^bb9(%325 : i64)
  ^bb29:  // pred: ^bb9
    %326 = llvm.add %69, %68  : i64
    llvm.br ^bb3(%326 : i64)
  ^bb30:  // pred: ^bb3
    %327 = llvm.add %64, %63  : i64
    llvm.br ^bb1(%327 : i64)
  ^bb31:  // pred: ^bb1
    %328 = llvm.mlir.constant(0 : i32) : i32
    llvm.return %328 : i32
  }
}

// *** IR Dump After mlir::iree_compiler::`anonymous-namespace'::LowerExecutableTargetPass ***
hal.executable.target @llvm_aot, filter="dylib*" {
  hal.executable.entry_point @predict_dispatch_2 attributes {interface = @io, ordinal = 0 : index} {
  ^bb0(%arg0: index, %arg1: index, %arg2: index):  // no predecessors
    %c1 = constant 1 : index
    %0 = affine.apply affine_map<()[s0] -> (s0 ceildiv 64)>()[%arg0]
    %1 = affine.apply affine_map<()[s0] -> (s0 ceildiv 4)>()[%arg1]
    hal.return %0, %1, %c1 : index, index, index
  }
  module  {
    llvm.func internal @predict_dispatch_2(%arg0: !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>, %arg1: !llvm.ptr<array<3 x i32>>) -> i32 {
      %0 = llvm.mlir.constant(0.000000e+00 : f32) : f32
      %1 = llvm.mlir.constant(10 : index) : i64
      %2 = llvm.mlir.constant(128 : index) : i64
      %3 = llvm.mlir.constant(32 : index) : i64
      %4 = llvm.mlir.constant(4 : index) : i64
      %5 = llvm.mlir.constant(0 : index) : i64
      %6 = llvm.mlir.constant(1 : index) : i64
      %7 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
      %8 = llvm.extractvalue %7[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
      %9 = llvm.getelementptr %8[%6] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
      %10 = llvm.load %9 : !llvm.ptr<ptr<i8>>
      %11 = llvm.getelementptr %10[%5] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
      %12 = llvm.bitcast %11 : !llvm.ptr<i8> to !llvm.ptr<f32>
      %13 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %14 = llvm.insertvalue %12, %13[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %15 = llvm.insertvalue %12, %14[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %16 = llvm.insertvalue %5, %15[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %17 = llvm.insertvalue %6, %16[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %18 = llvm.insertvalue %2, %17[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %19 = llvm.insertvalue %2, %18[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %20 = llvm.insertvalue %6, %19[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %21 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
      %22 = llvm.extractvalue %21[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
      %23 = llvm.getelementptr %22[%5] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
      %24 = llvm.load %23 : !llvm.ptr<ptr<i8>>
      %25 = llvm.getelementptr %24[%5] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
      %26 = llvm.bitcast %25 : !llvm.ptr<i8> to !llvm.ptr<f32>
      %27 = llvm.insertvalue %26, %13[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %28 = llvm.insertvalue %26, %27[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %29 = llvm.insertvalue %5, %28[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %30 = llvm.insertvalue %2, %29[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %31 = llvm.insertvalue %1, %30[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %32 = llvm.insertvalue %1, %31[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %33 = llvm.insertvalue %6, %32[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %34 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
      %35 = llvm.extractvalue %34[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
      %36 = llvm.mlir.constant(2 : index) : i64
      %37 = llvm.getelementptr %35[%36] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
      %38 = llvm.load %37 : !llvm.ptr<ptr<i8>>
      %39 = llvm.getelementptr %38[%5] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
      %40 = llvm.bitcast %39 : !llvm.ptr<i8> to !llvm.ptr<f32>
      %41 = llvm.insertvalue %40, %13[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %42 = llvm.insertvalue %40, %41[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %43 = llvm.insertvalue %5, %42[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %44 = llvm.insertvalue %6, %43[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %45 = llvm.insertvalue %1, %44[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %46 = llvm.insertvalue %1, %45[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %47 = llvm.insertvalue %6, %46[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %48 = llvm.load %arg1 : !llvm.ptr<array<3 x i32>>
      %49 = llvm.extractvalue %48[0] : !llvm.array<3 x i32>
      %50 = llvm.zext %49 : i32 to i64
      %51 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
      %52 = llvm.extractvalue %51[0] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
      %53 = llvm.extractvalue %52[0] : !llvm.array<3 x i32>
      %54 = llvm.zext %53 : i32 to i64
      %55 = llvm.load %arg1 : !llvm.ptr<array<3 x i32>>
      %56 = llvm.extractvalue %55[1] : !llvm.array<3 x i32>
      %57 = llvm.zext %56 : i32 to i64
      %58 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
      %59 = llvm.extractvalue %58[0] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
      %60 = llvm.extractvalue %59[1] : !llvm.array<3 x i32>
      %61 = llvm.zext %60 : i32 to i64
      %62 = llvm.mul %57, %4  : i64
      %63 = llvm.mul %61, %4  : i64
      llvm.br ^bb1(%62 : i64)
    ^bb1(%64: i64):  // 2 preds: ^bb0, ^bb30
      %65 = llvm.icmp "slt" %64, %6 : i64
      llvm.cond_br %65, ^bb2, ^bb31
    ^bb2:  // pred: ^bb1
      %66 = llvm.mlir.constant(64 : index) : i64
      %67 = llvm.mul %50, %66  : i64
      %68 = llvm.mul %54, %66  : i64
      llvm.br ^bb3(%67 : i64)
    ^bb3(%69: i64):  // 2 preds: ^bb2, ^bb29
      %70 = llvm.icmp "slt" %69, %1 : i64
      llvm.cond_br %70, ^bb4, ^bb30
    ^bb4:  // pred: ^bb3
      %71 = llvm.mlir.constant(-1 : index) : i64
      %72 = llvm.mul %64, %71  : i64
      %73 = llvm.add %72, %6  : i64
      %74 = llvm.icmp "slt" %4, %73 : i64
      %75 = llvm.select %74, %4, %73 : i1, i64
      %76 = llvm.extractvalue %20[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %77 = llvm.bitcast %76 : !llvm.ptr<f32> to !llvm.ptr<f32>
      %78 = llvm.insertvalue %77, %13[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %79 = llvm.extractvalue %20[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %80 = llvm.bitcast %79 : !llvm.ptr<f32> to !llvm.ptr<f32>
      %81 = llvm.insertvalue %80, %78[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %82 = llvm.extractvalue %20[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %83 = llvm.extractvalue %20[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %84 = llvm.extractvalue %20[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %85 = llvm.mul %64, %82  : i64
      %86 = llvm.add %84, %85  : i64
      %87 = llvm.mlir.constant(0 : i64) : i64
      %88 = llvm.mul %87, %83  : i64
      %89 = llvm.add %86, %88  : i64
      %90 = llvm.insertvalue %89, %81[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %91 = llvm.mlir.constant(128 : i64) : i64
      %92 = llvm.mlir.constant(1 : i64) : i64
      %93 = llvm.insertvalue %91, %90[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %94 = llvm.insertvalue %92, %93[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %95 = llvm.insertvalue %75, %94[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %96 = llvm.insertvalue %91, %95[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %97 = llvm.mul %69, %71  : i64
      %98 = llvm.add %97, %1  : i64
      %99 = llvm.icmp "slt" %66, %98 : i64
      %100 = llvm.select %99, %66, %98 : i1, i64
      %101 = llvm.extractvalue %33[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %102 = llvm.bitcast %101 : !llvm.ptr<f32> to !llvm.ptr<f32>
      %103 = llvm.insertvalue %102, %13[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %104 = llvm.extractvalue %33[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %105 = llvm.bitcast %104 : !llvm.ptr<f32> to !llvm.ptr<f32>
      %106 = llvm.insertvalue %105, %103[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %107 = llvm.extractvalue %33[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %108 = llvm.extractvalue %33[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %109 = llvm.extractvalue %33[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %110 = llvm.mul %87, %107  : i64
      %111 = llvm.add %109, %110  : i64
      %112 = llvm.mul %69, %108  : i64
      %113 = llvm.add %111, %112  : i64
      %114 = llvm.insertvalue %113, %106[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %115 = llvm.insertvalue %100, %114[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %116 = llvm.insertvalue %92, %115[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %117 = llvm.mlir.constant(10 : i64) : i64
      %118 = llvm.insertvalue %91, %116[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %119 = llvm.insertvalue %117, %118[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %120 = llvm.extractvalue %47[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %121 = llvm.bitcast %120 : !llvm.ptr<f32> to !llvm.ptr<f32>
      %122 = llvm.insertvalue %121, %13[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %123 = llvm.extractvalue %47[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %124 = llvm.bitcast %123 : !llvm.ptr<f32> to !llvm.ptr<f32>
      %125 = llvm.insertvalue %124, %122[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %126 = llvm.extractvalue %47[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %127 = llvm.extractvalue %47[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %128 = llvm.extractvalue %47[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %129 = llvm.mul %64, %126  : i64
      %130 = llvm.add %128, %129  : i64
      %131 = llvm.mul %69, %127  : i64
      %132 = llvm.add %130, %131  : i64
      %133 = llvm.insertvalue %132, %125[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %134 = llvm.insertvalue %100, %133[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %135 = llvm.insertvalue %92, %134[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %136 = llvm.insertvalue %75, %135[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %137 = llvm.insertvalue %117, %136[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      llvm.br ^bb5(%5 : i64)
    ^bb5(%138: i64):  // 2 preds: ^bb4, ^bb8
      %139 = llvm.icmp "slt" %138, %75 : i64
      llvm.cond_br %139, ^bb6(%5 : i64), ^bb9(%5 : i64)
    ^bb6(%140: i64):  // 2 preds: ^bb5, ^bb7
      %141 = llvm.icmp "slt" %140, %100 : i64
      llvm.cond_br %141, ^bb7, ^bb8
    ^bb7:  // pred: ^bb6
      %142 = llvm.extractvalue %137[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %143 = llvm.extractvalue %137[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %144 = llvm.mul %138, %1  : i64
      %145 = llvm.add %143, %144  : i64
      %146 = llvm.add %145, %140  : i64
      %147 = llvm.getelementptr %142[%146] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
      llvm.store %0, %147 : !llvm.ptr<f32>
      %148 = llvm.add %140, %6  : i64
      llvm.br ^bb6(%148 : i64)
    ^bb8:  // pred: ^bb6
      %149 = llvm.add %138, %6  : i64
      llvm.br ^bb5(%149 : i64)
    ^bb9(%150: i64):  // 2 preds: ^bb5, ^bb28
      %151 = llvm.icmp "slt" %150, %75 : i64
      llvm.cond_br %151, ^bb10(%5 : i64), ^bb29
    ^bb10(%152: i64):  // 2 preds: ^bb9, ^bb27
      %153 = llvm.icmp "slt" %152, %100 : i64
      llvm.cond_br %153, ^bb11(%5 : i64), ^bb28
    ^bb11(%154: i64):  // 2 preds: ^bb10, ^bb26
      %155 = llvm.icmp "slt" %154, %2 : i64
      llvm.cond_br %155, ^bb12, ^bb27
    ^bb12:  // pred: ^bb11
      %156 = llvm.mul %150, %71  : i64
      %157 = llvm.add %75, %156  : i64
      %158 = llvm.icmp "slt" %4, %157 : i64
      %159 = llvm.select %158, %4, %157 : i1, i64
      %160 = llvm.extractvalue %96[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %161 = llvm.bitcast %160 : !llvm.ptr<f32> to !llvm.ptr<f32>
      %162 = llvm.insertvalue %161, %13[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %163 = llvm.extractvalue %96[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %164 = llvm.bitcast %163 : !llvm.ptr<f32> to !llvm.ptr<f32>
      %165 = llvm.insertvalue %164, %162[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %166 = llvm.extractvalue %96[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %167 = llvm.extractvalue %96[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %168 = llvm.extractvalue %96[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %169 = llvm.mul %150, %166  : i64
      %170 = llvm.add %168, %169  : i64
      %171 = llvm.mul %154, %167  : i64
      %172 = llvm.add %170, %171  : i64
      %173 = llvm.insertvalue %172, %165[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %174 = llvm.mlir.constant(32 : i64) : i64
      %175 = llvm.insertvalue %174, %173[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %176 = llvm.insertvalue %92, %175[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %177 = llvm.insertvalue %159, %176[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %178 = llvm.insertvalue %91, %177[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %179 = llvm.mul %152, %71  : i64
      %180 = llvm.add %100, %179  : i64
      %181 = llvm.icmp "slt" %3, %180 : i64
      %182 = llvm.select %181, %3, %180 : i1, i64
      %183 = llvm.extractvalue %119[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %184 = llvm.bitcast %183 : !llvm.ptr<f32> to !llvm.ptr<f32>
      %185 = llvm.insertvalue %184, %13[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %186 = llvm.extractvalue %119[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %187 = llvm.bitcast %186 : !llvm.ptr<f32> to !llvm.ptr<f32>
      %188 = llvm.insertvalue %187, %185[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %189 = llvm.extractvalue %119[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %190 = llvm.extractvalue %119[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %191 = llvm.extractvalue %119[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %192 = llvm.mul %154, %189  : i64
      %193 = llvm.add %191, %192  : i64
      %194 = llvm.mul %152, %190  : i64
      %195 = llvm.add %193, %194  : i64
      %196 = llvm.insertvalue %195, %188[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %197 = llvm.insertvalue %182, %196[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %198 = llvm.insertvalue %92, %197[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %199 = llvm.insertvalue %174, %198[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %200 = llvm.insertvalue %117, %199[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %201 = llvm.extractvalue %137[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %202 = llvm.bitcast %201 : !llvm.ptr<f32> to !llvm.ptr<f32>
      %203 = llvm.insertvalue %202, %13[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %204 = llvm.extractvalue %137[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %205 = llvm.bitcast %204 : !llvm.ptr<f32> to !llvm.ptr<f32>
      %206 = llvm.insertvalue %205, %203[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %207 = llvm.extractvalue %137[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %208 = llvm.extractvalue %137[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %209 = llvm.extractvalue %137[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %210 = llvm.mul %150, %207  : i64
      %211 = llvm.add %209, %210  : i64
      %212 = llvm.mul %152, %208  : i64
      %213 = llvm.add %211, %212  : i64
      %214 = llvm.insertvalue %213, %206[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %215 = llvm.insertvalue %182, %214[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %216 = llvm.insertvalue %92, %215[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %217 = llvm.insertvalue %159, %216[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %218 = llvm.insertvalue %117, %217[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      llvm.br ^bb13(%5 : i64)
    ^bb13(%219: i64):  // 2 preds: ^bb12, ^bb25
      %220 = llvm.icmp "slt" %219, %159 : i64
      llvm.cond_br %220, ^bb14(%5 : i64), ^bb26
    ^bb14(%221: i64):  // 2 preds: ^bb13, ^bb24
      %222 = llvm.icmp "slt" %221, %182 : i64
      llvm.cond_br %222, ^bb15(%5 : i64), ^bb25
    ^bb15(%223: i64):  // 2 preds: ^bb14, ^bb23
      %224 = llvm.icmp "slt" %223, %3 : i64
      llvm.cond_br %224, ^bb16, ^bb24
    ^bb16:  // pred: ^bb15
      %225 = llvm.mul %219, %71  : i64
      %226 = llvm.add %159, %225  : i64
      %227 = llvm.icmp "slt" %4, %226 : i64
      %228 = llvm.select %227, %4, %226 : i1, i64
      %229 = llvm.extractvalue %178[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %230 = llvm.bitcast %229 : !llvm.ptr<f32> to !llvm.ptr<f32>
      %231 = llvm.insertvalue %230, %13[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %232 = llvm.extractvalue %178[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %233 = llvm.bitcast %232 : !llvm.ptr<f32> to !llvm.ptr<f32>
      %234 = llvm.insertvalue %233, %231[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %235 = llvm.extractvalue %178[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %236 = llvm.extractvalue %178[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %237 = llvm.extractvalue %178[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %238 = llvm.mul %219, %235  : i64
      %239 = llvm.add %237, %238  : i64
      %240 = llvm.mul %223, %236  : i64
      %241 = llvm.add %239, %240  : i64
      %242 = llvm.insertvalue %241, %234[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %243 = llvm.mlir.constant(4 : i64) : i64
      %244 = llvm.insertvalue %243, %242[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %245 = llvm.insertvalue %92, %244[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %246 = llvm.insertvalue %228, %245[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %247 = llvm.insertvalue %91, %246[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %248 = llvm.mul %221, %71  : i64
      %249 = llvm.add %182, %248  : i64
      %250 = llvm.icmp "slt" %4, %249 : i64
      %251 = llvm.select %250, %4, %249 : i1, i64
      %252 = llvm.extractvalue %200[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %253 = llvm.bitcast %252 : !llvm.ptr<f32> to !llvm.ptr<f32>
      %254 = llvm.insertvalue %253, %13[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %255 = llvm.extractvalue %200[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %256 = llvm.bitcast %255 : !llvm.ptr<f32> to !llvm.ptr<f32>
      %257 = llvm.insertvalue %256, %254[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %258 = llvm.extractvalue %200[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %259 = llvm.extractvalue %200[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %260 = llvm.extractvalue %200[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %261 = llvm.mul %223, %258  : i64
      %262 = llvm.add %260, %261  : i64
      %263 = llvm.mul %221, %259  : i64
      %264 = llvm.add %262, %263  : i64
      %265 = llvm.insertvalue %264, %257[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %266 = llvm.insertvalue %251, %265[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %267 = llvm.insertvalue %92, %266[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %268 = llvm.insertvalue %243, %267[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %269 = llvm.insertvalue %117, %268[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %270 = llvm.extractvalue %218[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %271 = llvm.bitcast %270 : !llvm.ptr<f32> to !llvm.ptr<f32>
      %272 = llvm.insertvalue %271, %13[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %273 = llvm.extractvalue %218[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %274 = llvm.bitcast %273 : !llvm.ptr<f32> to !llvm.ptr<f32>
      %275 = llvm.insertvalue %274, %272[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %276 = llvm.extractvalue %218[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %277 = llvm.extractvalue %218[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %278 = llvm.extractvalue %218[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %279 = llvm.mul %219, %276  : i64
      %280 = llvm.add %278, %279  : i64
      %281 = llvm.mul %221, %277  : i64
      %282 = llvm.add %280, %281  : i64
      %283 = llvm.insertvalue %282, %275[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %284 = llvm.insertvalue %251, %283[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %285 = llvm.insertvalue %92, %284[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %286 = llvm.insertvalue %228, %285[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %287 = llvm.insertvalue %117, %286[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      llvm.br ^bb17(%5 : i64)
    ^bb17(%288: i64):  // 2 preds: ^bb16, ^bb22
      %289 = llvm.icmp "slt" %288, %228 : i64
      llvm.cond_br %289, ^bb18(%5 : i64), ^bb23
    ^bb18(%290: i64):  // 2 preds: ^bb17, ^bb21
      %291 = llvm.icmp "slt" %290, %251 : i64
      llvm.cond_br %291, ^bb19(%5 : i64), ^bb22
    ^bb19(%292: i64):  // 2 preds: ^bb18, ^bb20
      %293 = llvm.icmp "slt" %292, %4 : i64
      llvm.cond_br %293, ^bb20, ^bb21
    ^bb20:  // pred: ^bb19
      %294 = llvm.extractvalue %247[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %295 = llvm.extractvalue %247[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %296 = llvm.mul %288, %2  : i64
      %297 = llvm.add %295, %296  : i64
      %298 = llvm.add %297, %292  : i64
      %299 = llvm.getelementptr %294[%298] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
      %300 = llvm.load %299 : !llvm.ptr<f32>
      %301 = llvm.extractvalue %269[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %302 = llvm.extractvalue %269[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %303 = llvm.mul %292, %1  : i64
      %304 = llvm.add %302, %303  : i64
      %305 = llvm.add %304, %290  : i64
      %306 = llvm.getelementptr %301[%305] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
      %307 = llvm.load %306 : !llvm.ptr<f32>
      %308 = llvm.extractvalue %287[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %309 = llvm.extractvalue %287[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %310 = llvm.mul %288, %1  : i64
      %311 = llvm.add %309, %310  : i64
      %312 = llvm.add %311, %290  : i64
      %313 = llvm.getelementptr %308[%312] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
      %314 = llvm.load %313 : !llvm.ptr<f32>
      %315 = llvm.fmul %300, %307  : f32
      %316 = llvm.fadd %314, %315  : f32
      llvm.store %316, %313 : !llvm.ptr<f32>
      %317 = llvm.add %292, %6  : i64
      llvm.br ^bb19(%317 : i64)
    ^bb21:  // pred: ^bb19
      %318 = llvm.add %290, %6  : i64
      llvm.br ^bb18(%318 : i64)
    ^bb22:  // pred: ^bb18
      %319 = llvm.add %288, %6  : i64
      llvm.br ^bb17(%319 : i64)
    ^bb23:  // pred: ^bb17
      %320 = llvm.add %223, %4  : i64
      llvm.br ^bb15(%320 : i64)
    ^bb24:  // pred: ^bb15
      %321 = llvm.add %221, %4  : i64
      llvm.br ^bb14(%321 : i64)
    ^bb25:  // pred: ^bb14
      %322 = llvm.add %219, %4  : i64
      llvm.br ^bb13(%322 : i64)
    ^bb26:  // pred: ^bb13
      %323 = llvm.add %154, %3  : i64
      llvm.br ^bb11(%323 : i64)
    ^bb27:  // pred: ^bb11
      %324 = llvm.add %152, %3  : i64
      llvm.br ^bb10(%324 : i64)
    ^bb28:  // pred: ^bb10
      %325 = llvm.add %150, %4  : i64
      llvm.br ^bb9(%325 : i64)
    ^bb29:  // pred: ^bb9
      %326 = llvm.add %69, %68  : i64
      llvm.br ^bb3(%326 : i64)
    ^bb30:  // pred: ^bb3
      %327 = llvm.add %64, %63  : i64
      llvm.br ^bb1(%327 : i64)
    ^bb31:  // pred: ^bb1
      %328 = llvm.mlir.constant(0 : i32) : i32
      llvm.return %328 : i32
    }
  }
}

// *** IR Dump After mlir::iree_compiler::IREE::HAL::TranslateExecutablesPass ***
hal.executable.target @llvm_aot, filter="dylib*" {
  hal.executable.entry_point @predict_dispatch_2 attributes {interface = @io, ordinal = 0 : index} {
  ^bb0(%arg0: index, %arg1: index, %arg2: index):  // no predecessors
    %c1 = constant 1 : index
    %0 = affine.apply affine_map<()[s0] -> (s0 ceildiv 64)>()[%arg0]
    %1 = affine.apply affine_map<()[s0] -> (s0 ceildiv 4)>()[%arg1]
    hal.return %0, %1, %c1 : index, index, index
  }
  module  {
    llvm.func internal @predict_dispatch_2(%arg0: !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>, %arg1: !llvm.ptr<array<3 x i32>>) -> i32 {
      %0 = llvm.mlir.constant(0.000000e+00 : f32) : f32
      %1 = llvm.mlir.constant(10 : index) : i64
      %2 = llvm.mlir.constant(128 : index) : i64
      %3 = llvm.mlir.constant(32 : index) : i64
      %4 = llvm.mlir.constant(4 : index) : i64
      %5 = llvm.mlir.constant(0 : index) : i64
      %6 = llvm.mlir.constant(1 : index) : i64
      %7 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
      %8 = llvm.extractvalue %7[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
      %9 = llvm.getelementptr %8[%6] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
      %10 = llvm.load %9 : !llvm.ptr<ptr<i8>>
      %11 = llvm.getelementptr %10[%5] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
      %12 = llvm.bitcast %11 : !llvm.ptr<i8> to !llvm.ptr<f32>
      %13 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %14 = llvm.insertvalue %12, %13[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %15 = llvm.insertvalue %12, %14[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %16 = llvm.insertvalue %5, %15[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %17 = llvm.insertvalue %6, %16[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %18 = llvm.insertvalue %2, %17[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %19 = llvm.insertvalue %2, %18[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %20 = llvm.insertvalue %6, %19[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %21 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
      %22 = llvm.extractvalue %21[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
      %23 = llvm.getelementptr %22[%5] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
      %24 = llvm.load %23 : !llvm.ptr<ptr<i8>>
      %25 = llvm.getelementptr %24[%5] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
      %26 = llvm.bitcast %25 : !llvm.ptr<i8> to !llvm.ptr<f32>
      %27 = llvm.insertvalue %26, %13[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %28 = llvm.insertvalue %26, %27[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %29 = llvm.insertvalue %5, %28[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %30 = llvm.insertvalue %2, %29[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %31 = llvm.insertvalue %1, %30[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %32 = llvm.insertvalue %1, %31[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %33 = llvm.insertvalue %6, %32[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %34 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
      %35 = llvm.extractvalue %34[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
      %36 = llvm.mlir.constant(2 : index) : i64
      %37 = llvm.getelementptr %35[%36] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
      %38 = llvm.load %37 : !llvm.ptr<ptr<i8>>
      %39 = llvm.getelementptr %38[%5] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
      %40 = llvm.bitcast %39 : !llvm.ptr<i8> to !llvm.ptr<f32>
      %41 = llvm.insertvalue %40, %13[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %42 = llvm.insertvalue %40, %41[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %43 = llvm.insertvalue %5, %42[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %44 = llvm.insertvalue %6, %43[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %45 = llvm.insertvalue %1, %44[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %46 = llvm.insertvalue %1, %45[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %47 = llvm.insertvalue %6, %46[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %48 = llvm.load %arg1 : !llvm.ptr<array<3 x i32>>
      %49 = llvm.extractvalue %48[0] : !llvm.array<3 x i32>
      %50 = llvm.zext %49 : i32 to i64
      %51 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
      %52 = llvm.extractvalue %51[0] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
      %53 = llvm.extractvalue %52[0] : !llvm.array<3 x i32>
      %54 = llvm.zext %53 : i32 to i64
      %55 = llvm.load %arg1 : !llvm.ptr<array<3 x i32>>
      %56 = llvm.extractvalue %55[1] : !llvm.array<3 x i32>
      %57 = llvm.zext %56 : i32 to i64
      %58 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
      %59 = llvm.extractvalue %58[0] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
      %60 = llvm.extractvalue %59[1] : !llvm.array<3 x i32>
      %61 = llvm.zext %60 : i32 to i64
      %62 = llvm.mul %57, %4  : i64
      %63 = llvm.mul %61, %4  : i64
      llvm.br ^bb1(%62 : i64)
    ^bb1(%64: i64):  // 2 preds: ^bb0, ^bb30
      %65 = llvm.icmp "slt" %64, %6 : i64
      llvm.cond_br %65, ^bb2, ^bb31
    ^bb2:  // pred: ^bb1
      %66 = llvm.mlir.constant(64 : index) : i64
      %67 = llvm.mul %50, %66  : i64
      %68 = llvm.mul %54, %66  : i64
      llvm.br ^bb3(%67 : i64)
    ^bb3(%69: i64):  // 2 preds: ^bb2, ^bb29
      %70 = llvm.icmp "slt" %69, %1 : i64
      llvm.cond_br %70, ^bb4, ^bb30
    ^bb4:  // pred: ^bb3
      %71 = llvm.mlir.constant(-1 : index) : i64
      %72 = llvm.mul %64, %71  : i64
      %73 = llvm.add %72, %6  : i64
      %74 = llvm.icmp "slt" %4, %73 : i64
      %75 = llvm.select %74, %4, %73 : i1, i64
      %76 = llvm.extractvalue %20[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %77 = llvm.bitcast %76 : !llvm.ptr<f32> to !llvm.ptr<f32>
      %78 = llvm.insertvalue %77, %13[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %79 = llvm.extractvalue %20[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %80 = llvm.bitcast %79 : !llvm.ptr<f32> to !llvm.ptr<f32>
      %81 = llvm.insertvalue %80, %78[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %82 = llvm.extractvalue %20[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %83 = llvm.extractvalue %20[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %84 = llvm.extractvalue %20[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %85 = llvm.mul %64, %82  : i64
      %86 = llvm.add %84, %85  : i64
      %87 = llvm.mlir.constant(0 : i64) : i64
      %88 = llvm.mul %87, %83  : i64
      %89 = llvm.add %86, %88  : i64
      %90 = llvm.insertvalue %89, %81[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %91 = llvm.mlir.constant(128 : i64) : i64
      %92 = llvm.mlir.constant(1 : i64) : i64
      %93 = llvm.insertvalue %91, %90[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %94 = llvm.insertvalue %92, %93[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %95 = llvm.insertvalue %75, %94[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %96 = llvm.insertvalue %91, %95[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %97 = llvm.mul %69, %71  : i64
      %98 = llvm.add %97, %1  : i64
      %99 = llvm.icmp "slt" %66, %98 : i64
      %100 = llvm.select %99, %66, %98 : i1, i64
      %101 = llvm.extractvalue %33[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %102 = llvm.bitcast %101 : !llvm.ptr<f32> to !llvm.ptr<f32>
      %103 = llvm.insertvalue %102, %13[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %104 = llvm.extractvalue %33[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %105 = llvm.bitcast %104 : !llvm.ptr<f32> to !llvm.ptr<f32>
      %106 = llvm.insertvalue %105, %103[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %107 = llvm.extractvalue %33[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %108 = llvm.extractvalue %33[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %109 = llvm.extractvalue %33[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %110 = llvm.mul %87, %107  : i64
      %111 = llvm.add %109, %110  : i64
      %112 = llvm.mul %69, %108  : i64
      %113 = llvm.add %111, %112  : i64
      %114 = llvm.insertvalue %113, %106[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %115 = llvm.insertvalue %100, %114[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %116 = llvm.insertvalue %92, %115[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %117 = llvm.mlir.constant(10 : i64) : i64
      %118 = llvm.insertvalue %91, %116[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %119 = llvm.insertvalue %117, %118[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %120 = llvm.extractvalue %47[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %121 = llvm.bitcast %120 : !llvm.ptr<f32> to !llvm.ptr<f32>
      %122 = llvm.insertvalue %121, %13[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %123 = llvm.extractvalue %47[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %124 = llvm.bitcast %123 : !llvm.ptr<f32> to !llvm.ptr<f32>
      %125 = llvm.insertvalue %124, %122[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %126 = llvm.extractvalue %47[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %127 = llvm.extractvalue %47[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %128 = llvm.extractvalue %47[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %129 = llvm.mul %64, %126  : i64
      %130 = llvm.add %128, %129  : i64
      %131 = llvm.mul %69, %127  : i64
      %132 = llvm.add %130, %131  : i64
      %133 = llvm.insertvalue %132, %125[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %134 = llvm.insertvalue %100, %133[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %135 = llvm.insertvalue %92, %134[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %136 = llvm.insertvalue %75, %135[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %137 = llvm.insertvalue %117, %136[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      llvm.br ^bb5(%5 : i64)
    ^bb5(%138: i64):  // 2 preds: ^bb4, ^bb8
      %139 = llvm.icmp "slt" %138, %75 : i64
      llvm.cond_br %139, ^bb6(%5 : i64), ^bb9(%5 : i64)
    ^bb6(%140: i64):  // 2 preds: ^bb5, ^bb7
      %141 = llvm.icmp "slt" %140, %100 : i64
      llvm.cond_br %141, ^bb7, ^bb8
    ^bb7:  // pred: ^bb6
      %142 = llvm.extractvalue %137[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %143 = llvm.extractvalue %137[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %144 = llvm.mul %138, %1  : i64
      %145 = llvm.add %143, %144  : i64
      %146 = llvm.add %145, %140  : i64
      %147 = llvm.getelementptr %142[%146] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
      llvm.store %0, %147 : !llvm.ptr<f32>
      %148 = llvm.add %140, %6  : i64
      llvm.br ^bb6(%148 : i64)
    ^bb8:  // pred: ^bb6
      %149 = llvm.add %138, %6  : i64
      llvm.br ^bb5(%149 : i64)
    ^bb9(%150: i64):  // 2 preds: ^bb5, ^bb28
      %151 = llvm.icmp "slt" %150, %75 : i64
      llvm.cond_br %151, ^bb10(%5 : i64), ^bb29
    ^bb10(%152: i64):  // 2 preds: ^bb9, ^bb27
      %153 = llvm.icmp "slt" %152, %100 : i64
      llvm.cond_br %153, ^bb11(%5 : i64), ^bb28
    ^bb11(%154: i64):  // 2 preds: ^bb10, ^bb26
      %155 = llvm.icmp "slt" %154, %2 : i64
      llvm.cond_br %155, ^bb12, ^bb27
    ^bb12:  // pred: ^bb11
      %156 = llvm.mul %150, %71  : i64
      %157 = llvm.add %75, %156  : i64
      %158 = llvm.icmp "slt" %4, %157 : i64
      %159 = llvm.select %158, %4, %157 : i1, i64
      %160 = llvm.extractvalue %96[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %161 = llvm.bitcast %160 : !llvm.ptr<f32> to !llvm.ptr<f32>
      %162 = llvm.insertvalue %161, %13[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %163 = llvm.extractvalue %96[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %164 = llvm.bitcast %163 : !llvm.ptr<f32> to !llvm.ptr<f32>
      %165 = llvm.insertvalue %164, %162[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %166 = llvm.extractvalue %96[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %167 = llvm.extractvalue %96[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %168 = llvm.extractvalue %96[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %169 = llvm.mul %150, %166  : i64
      %170 = llvm.add %168, %169  : i64
      %171 = llvm.mul %154, %167  : i64
      %172 = llvm.add %170, %171  : i64
      %173 = llvm.insertvalue %172, %165[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %174 = llvm.mlir.constant(32 : i64) : i64
      %175 = llvm.insertvalue %174, %173[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %176 = llvm.insertvalue %92, %175[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %177 = llvm.insertvalue %159, %176[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %178 = llvm.insertvalue %91, %177[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %179 = llvm.mul %152, %71  : i64
      %180 = llvm.add %100, %179  : i64
      %181 = llvm.icmp "slt" %3, %180 : i64
      %182 = llvm.select %181, %3, %180 : i1, i64
      %183 = llvm.extractvalue %119[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %184 = llvm.bitcast %183 : !llvm.ptr<f32> to !llvm.ptr<f32>
      %185 = llvm.insertvalue %184, %13[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %186 = llvm.extractvalue %119[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %187 = llvm.bitcast %186 : !llvm.ptr<f32> to !llvm.ptr<f32>
      %188 = llvm.insertvalue %187, %185[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %189 = llvm.extractvalue %119[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %190 = llvm.extractvalue %119[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %191 = llvm.extractvalue %119[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %192 = llvm.mul %154, %189  : i64
      %193 = llvm.add %191, %192  : i64
      %194 = llvm.mul %152, %190  : i64
      %195 = llvm.add %193, %194  : i64
      %196 = llvm.insertvalue %195, %188[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %197 = llvm.insertvalue %182, %196[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %198 = llvm.insertvalue %92, %197[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %199 = llvm.insertvalue %174, %198[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %200 = llvm.insertvalue %117, %199[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %201 = llvm.extractvalue %137[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %202 = llvm.bitcast %201 : !llvm.ptr<f32> to !llvm.ptr<f32>
      %203 = llvm.insertvalue %202, %13[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %204 = llvm.extractvalue %137[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %205 = llvm.bitcast %204 : !llvm.ptr<f32> to !llvm.ptr<f32>
      %206 = llvm.insertvalue %205, %203[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %207 = llvm.extractvalue %137[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %208 = llvm.extractvalue %137[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %209 = llvm.extractvalue %137[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %210 = llvm.mul %150, %207  : i64
      %211 = llvm.add %209, %210  : i64
      %212 = llvm.mul %152, %208  : i64
      %213 = llvm.add %211, %212  : i64
      %214 = llvm.insertvalue %213, %206[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %215 = llvm.insertvalue %182, %214[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %216 = llvm.insertvalue %92, %215[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %217 = llvm.insertvalue %159, %216[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %218 = llvm.insertvalue %117, %217[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      llvm.br ^bb13(%5 : i64)
    ^bb13(%219: i64):  // 2 preds: ^bb12, ^bb25
      %220 = llvm.icmp "slt" %219, %159 : i64
      llvm.cond_br %220, ^bb14(%5 : i64), ^bb26
    ^bb14(%221: i64):  // 2 preds: ^bb13, ^bb24
      %222 = llvm.icmp "slt" %221, %182 : i64
      llvm.cond_br %222, ^bb15(%5 : i64), ^bb25
    ^bb15(%223: i64):  // 2 preds: ^bb14, ^bb23
      %224 = llvm.icmp "slt" %223, %3 : i64
      llvm.cond_br %224, ^bb16, ^bb24
    ^bb16:  // pred: ^bb15
      %225 = llvm.mul %219, %71  : i64
      %226 = llvm.add %159, %225  : i64
      %227 = llvm.icmp "slt" %4, %226 : i64
      %228 = llvm.select %227, %4, %226 : i1, i64
      %229 = llvm.extractvalue %178[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %230 = llvm.bitcast %229 : !llvm.ptr<f32> to !llvm.ptr<f32>
      %231 = llvm.insertvalue %230, %13[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %232 = llvm.extractvalue %178[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %233 = llvm.bitcast %232 : !llvm.ptr<f32> to !llvm.ptr<f32>
      %234 = llvm.insertvalue %233, %231[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %235 = llvm.extractvalue %178[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %236 = llvm.extractvalue %178[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %237 = llvm.extractvalue %178[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %238 = llvm.mul %219, %235  : i64
      %239 = llvm.add %237, %238  : i64
      %240 = llvm.mul %223, %236  : i64
      %241 = llvm.add %239, %240  : i64
      %242 = llvm.insertvalue %241, %234[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %243 = llvm.mlir.constant(4 : i64) : i64
      %244 = llvm.insertvalue %243, %242[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %245 = llvm.insertvalue %92, %244[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %246 = llvm.insertvalue %228, %245[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %247 = llvm.insertvalue %91, %246[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %248 = llvm.mul %221, %71  : i64
      %249 = llvm.add %182, %248  : i64
      %250 = llvm.icmp "slt" %4, %249 : i64
      %251 = llvm.select %250, %4, %249 : i1, i64
      %252 = llvm.extractvalue %200[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %253 = llvm.bitcast %252 : !llvm.ptr<f32> to !llvm.ptr<f32>
      %254 = llvm.insertvalue %253, %13[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %255 = llvm.extractvalue %200[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %256 = llvm.bitcast %255 : !llvm.ptr<f32> to !llvm.ptr<f32>
      %257 = llvm.insertvalue %256, %254[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %258 = llvm.extractvalue %200[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %259 = llvm.extractvalue %200[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %260 = llvm.extractvalue %200[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %261 = llvm.mul %223, %258  : i64
      %262 = llvm.add %260, %261  : i64
      %263 = llvm.mul %221, %259  : i64
      %264 = llvm.add %262, %263  : i64
      %265 = llvm.insertvalue %264, %257[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %266 = llvm.insertvalue %251, %265[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %267 = llvm.insertvalue %92, %266[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %268 = llvm.insertvalue %243, %267[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %269 = llvm.insertvalue %117, %268[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %270 = llvm.extractvalue %218[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %271 = llvm.bitcast %270 : !llvm.ptr<f32> to !llvm.ptr<f32>
      %272 = llvm.insertvalue %271, %13[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %273 = llvm.extractvalue %218[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %274 = llvm.bitcast %273 : !llvm.ptr<f32> to !llvm.ptr<f32>
      %275 = llvm.insertvalue %274, %272[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %276 = llvm.extractvalue %218[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %277 = llvm.extractvalue %218[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %278 = llvm.extractvalue %218[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %279 = llvm.mul %219, %276  : i64
      %280 = llvm.add %278, %279  : i64
      %281 = llvm.mul %221, %277  : i64
      %282 = llvm.add %280, %281  : i64
      %283 = llvm.insertvalue %282, %275[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %284 = llvm.insertvalue %251, %283[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %285 = llvm.insertvalue %92, %284[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %286 = llvm.insertvalue %228, %285[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %287 = llvm.insertvalue %117, %286[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      llvm.br ^bb17(%5 : i64)
    ^bb17(%288: i64):  // 2 preds: ^bb16, ^bb22
      %289 = llvm.icmp "slt" %288, %228 : i64
      llvm.cond_br %289, ^bb18(%5 : i64), ^bb23
    ^bb18(%290: i64):  // 2 preds: ^bb17, ^bb21
      %291 = llvm.icmp "slt" %290, %251 : i64
      llvm.cond_br %291, ^bb19(%5 : i64), ^bb22
    ^bb19(%292: i64):  // 2 preds: ^bb18, ^bb20
      %293 = llvm.icmp "slt" %292, %4 : i64
      llvm.cond_br %293, ^bb20, ^bb21
    ^bb20:  // pred: ^bb19
      %294 = llvm.extractvalue %247[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %295 = llvm.extractvalue %247[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %296 = llvm.mul %288, %2  : i64
      %297 = llvm.add %295, %296  : i64
      %298 = llvm.add %297, %292  : i64
      %299 = llvm.getelementptr %294[%298] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
      %300 = llvm.load %299 : !llvm.ptr<f32>
      %301 = llvm.extractvalue %269[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %302 = llvm.extractvalue %269[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %303 = llvm.mul %292, %1  : i64
      %304 = llvm.add %302, %303  : i64
      %305 = llvm.add %304, %290  : i64
      %306 = llvm.getelementptr %301[%305] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
      %307 = llvm.load %306 : !llvm.ptr<f32>
      %308 = llvm.extractvalue %287[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %309 = llvm.extractvalue %287[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %310 = llvm.mul %288, %1  : i64
      %311 = llvm.add %309, %310  : i64
      %312 = llvm.add %311, %290  : i64
      %313 = llvm.getelementptr %308[%312] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
      %314 = llvm.load %313 : !llvm.ptr<f32>
      %315 = llvm.fmul %300, %307  : f32
      %316 = llvm.fadd %314, %315  : f32
      llvm.store %316, %313 : !llvm.ptr<f32>
      %317 = llvm.add %292, %6  : i64
      llvm.br ^bb19(%317 : i64)
    ^bb21:  // pred: ^bb19
      %318 = llvm.add %290, %6  : i64
      llvm.br ^bb18(%318 : i64)
    ^bb22:  // pred: ^bb18
      %319 = llvm.add %288, %6  : i64
      llvm.br ^bb17(%319 : i64)
    ^bb23:  // pred: ^bb17
      %320 = llvm.add %223, %4  : i64
      llvm.br ^bb15(%320 : i64)
    ^bb24:  // pred: ^bb15
      %321 = llvm.add %221, %4  : i64
      llvm.br ^bb14(%321 : i64)
    ^bb25:  // pred: ^bb14
      %322 = llvm.add %219, %4  : i64
      llvm.br ^bb13(%322 : i64)
    ^bb26:  // pred: ^bb13
      %323 = llvm.add %154, %3  : i64
      llvm.br ^bb11(%323 : i64)
    ^bb27:  // pred: ^bb11
      %324 = llvm.add %152, %3  : i64
      llvm.br ^bb10(%324 : i64)
    ^bb28:  // pred: ^bb10
      %325 = llvm.add %150, %4  : i64
      llvm.br ^bb9(%325 : i64)
    ^bb29:  // pred: ^bb9
      %326 = llvm.add %69, %68  : i64
      llvm.br ^bb3(%326 : i64)
    ^bb30:  // pred: ^bb3
      %327 = llvm.add %64, %63  : i64
      llvm.br ^bb1(%327 : i64)
    ^bb31:  // pred: ^bb1
      %328 = llvm.mlir.constant(0 : i32) : i32
      llvm.return %328 : i32
    }
  }
}

// *** IR Dump After mlir::iree_compiler::IREE::HAL::PropagateConstantWorkgroupInfoPass ***
hal.executable.target @llvm_aot, filter="dylib*" {
  hal.executable.entry_point @predict_dispatch_3 attributes {interface = @io, ordinal = 0 : index}
  module  {
    func @predict_dispatch_3() {
      %c0 = constant 0 : index
      %cst = constant opaque<"_", "0xDEADBEEF"> : tensor<1x10xf32>
      %c1 = constant 1 : index
      %c10 = constant 10 : index
      %0 = hal.interface.binding.subspan @io::@s0b0_ro_external[%c0] : !flow.dispatch.tensor<readonly:1x10xf32>
      %1 = hal.interface.binding.subspan @io::@s0b1_xw_external[%c0] : !flow.dispatch.tensor<writeonly:10xf32>
      %workgroup_size_x = hal.interface.workgroup.size[0] : index
      %workgroup_size_y = hal.interface.workgroup.size[1] : index
      %workgroup_id_x = hal.interface.workgroup.id[0] : index
      %workgroup_count_x = hal.interface.workgroup.count[0] : index
      %workgroup_id_y = hal.interface.workgroup.id[1] : index
      %workgroup_count_y = hal.interface.workgroup.count[1] : index
      %2 = affine.apply affine_map<()[s0, s1] -> (s0 * s1)>()[%workgroup_id_y, %workgroup_size_y]
      %3 = affine.apply affine_map<()[s0, s1] -> (s0 * s1)>()[%workgroup_count_y, %workgroup_size_y]
      scf.for %arg0 = %2 to %c1 step %3 {
        %4 = affine.apply affine_map<()[s0, s1] -> (s0 * s1)>()[%workgroup_id_x, %workgroup_size_x]
        %5 = affine.apply affine_map<()[s0, s1] -> (s0 * s1)>()[%workgroup_count_x, %workgroup_size_x]
        scf.for %arg1 = %4 to %c10 step %5 {
          %6 = affine.min affine_map<(d0)[s0] -> (s0, -d0 + 1)>(%arg0)[%workgroup_size_y]
          %7 = affine.min affine_map<(d0)[s0] -> (s0, -d0 + 10)>(%arg1)[%workgroup_size_x]
          %8 = flow.dispatch.tensor.load %0, offsets = [%arg0, %arg1], sizes = [%6, %7], strides = [1, 1] : !flow.dispatch.tensor<readonly:1x10xf32> -> tensor<?x?xf32>
          %9 = affine.min affine_map<(d0)[s0] -> (s0, -d0 + 1)>(%arg0)[%workgroup_size_y]
          %10 = affine.min affine_map<(d0)[s0] -> (s0, -d0 + 10)>(%arg1)[%workgroup_size_x]
          %11 = subtensor %cst[%arg0, %arg1] [%9, %10] [1, 1] : tensor<1x10xf32> to tensor<?x?xf32>
          %12 = affine.min affine_map<(d0)[s0] -> (s0, -d0 + 10)>(%arg1)[%workgroup_size_x]
          %13 = linalg.init_tensor [%12] : tensor<?xf32>
          %14 = linalg.generic {indexing_maps = [affine_map<(d0, d1) -> (d0, d1)>, affine_map<(d0, d1) -> (d0, d1)>, affine_map<(d0, d1) -> (d1)>], iterator_types = ["parallel", "parallel"]} ins(%8, %11 : tensor<?x?xf32>, tensor<?x?xf32>) outs(%13 : tensor<?xf32>) attrs =  {__internal_linalg_transform__ = "workgroup"} {
          ^bb0(%arg2: f32, %arg3: f32, %arg4: f32):  // no predecessors
            %15 = addf %arg2, %arg3 : f32
            linalg.yield %15 : f32
          } -> tensor<?xf32>
          flow.dispatch.tensor.store %14, %1, offsets = [%arg1], sizes = [%12], strides = [1] : tensor<?xf32> -> !flow.dispatch.tensor<writeonly:10xf32>
        }
      }
      return
    }
    hal.interface @io attributes {sym_visibility = "private"} {
      hal.interface.binding @s0b0_ro_external, set=0, binding=0, type="StorageBuffer", access="Read"
      hal.interface.binding @s0b1_xw_external, set=0, binding=1, type="StorageBuffer", access="Write|Discard"
    }
  }
}

// *** IR Dump After mlir::iree_compiler::`anonymous-namespace'::SetNumWorkgroupsPass ***
hal.executable.target @llvm_aot, filter="dylib*" {
  hal.executable.entry_point @predict_dispatch_3 attributes {interface = @io, ordinal = 0 : index} {
  ^bb0(%arg0: index, %arg1: index, %arg2: index):  // no predecessors
    %c1 = constant 1 : index
    %0 = affine.apply affine_map<()[s0] -> (s0 ceildiv 128)>()[%arg0]
    %1 = affine.apply affine_map<()[s0] -> (s0 ceildiv 128)>()[%arg1]
    hal.return %0, %1, %c1 : index, index, index
  }
  module  {
    func @predict_dispatch_3() {
      %c0 = constant 0 : index
      %cst = constant opaque<"_", "0xDEADBEEF"> : tensor<1x10xf32>
      %c1 = constant 1 : index
      %c10 = constant 10 : index
      %c128 = constant 128 : index
      %0 = hal.interface.binding.subspan @io::@s0b0_ro_external[%c0] : !flow.dispatch.tensor<readonly:1x10xf32>
      %1 = hal.interface.binding.subspan @io::@s0b1_xw_external[%c0] : !flow.dispatch.tensor<writeonly:10xf32>
      %workgroup_id_x = hal.interface.workgroup.id[0] : index
      %workgroup_count_x = hal.interface.workgroup.count[0] : index
      %workgroup_id_y = hal.interface.workgroup.id[1] : index
      %workgroup_count_y = hal.interface.workgroup.count[1] : index
      %2 = affine.apply affine_map<()[s0, s1] -> (s0 * s1)>()[%workgroup_id_y, %c128]
      %3 = affine.apply affine_map<()[s0, s1] -> (s0 * s1)>()[%workgroup_count_y, %c128]
      scf.for %arg0 = %2 to %c1 step %3 {
        %4 = affine.apply affine_map<()[s0, s1] -> (s0 * s1)>()[%workgroup_id_x, %c128]
        %5 = affine.apply affine_map<()[s0, s1] -> (s0 * s1)>()[%workgroup_count_x, %c128]
        scf.for %arg1 = %4 to %c10 step %5 {
          %6 = affine.min affine_map<(d0) -> (128, -d0 + 1)>(%arg0)
          %7 = affine.min affine_map<(d0) -> (128, -d0 + 10)>(%arg1)
          %8 = flow.dispatch.tensor.load %0, offsets = [%arg0, %arg1], sizes = [%6, %7], strides = [1, 1] : !flow.dispatch.tensor<readonly:1x10xf32> -> tensor<?x?xf32>
          %9 = affine.min affine_map<(d0) -> (128, -d0 + 1)>(%arg0)
          %10 = affine.min affine_map<(d0) -> (128, -d0 + 10)>(%arg1)
          %11 = subtensor %cst[%arg0, %arg1] [%9, %10] [1, 1] : tensor<1x10xf32> to tensor<?x?xf32>
          %12 = affine.min affine_map<(d0) -> (128, -d0 + 10)>(%arg1)
          %13 = linalg.init_tensor [%12] : tensor<?xf32>
          %14 = linalg.generic {indexing_maps = [affine_map<(d0, d1) -> (d0, d1)>, affine_map<(d0, d1) -> (d0, d1)>, affine_map<(d0, d1) -> (d1)>], iterator_types = ["parallel", "parallel"]} ins(%8, %11 : tensor<?x?xf32>, tensor<?x?xf32>) outs(%13 : tensor<?xf32>) attrs =  {__internal_linalg_transform__ = "workgroup", lowering.config = {tileSizes = [[128, 128]]}} {
          ^bb0(%arg2: f32, %arg3: f32, %arg4: f32):  // no predecessors
            %15 = addf %arg2, %arg3 : f32
            linalg.yield %15 : f32
          } -> tensor<?xf32>
          flow.dispatch.tensor.store %14, %1, offsets = [%arg1], sizes = [%12], strides = [1] : tensor<?xf32> -> !flow.dispatch.tensor<writeonly:10xf32>
        }
      }
      return
    }
    hal.interface @io attributes {sym_visibility = "private"} {
      hal.interface.binding @s0b0_ro_external, set=0, binding=0, type="StorageBuffer", access="Read"
      hal.interface.binding @s0b1_xw_external, set=0, binding=1, type="StorageBuffer", access="Write|Discard"
    }
  }
}

// *** IR Dump After Canonicalizer ***
module  {
  func @predict_dispatch_3() {
    %c0 = constant 0 : index
    %cst = constant opaque<"_", "0xDEADBEEF"> : tensor<1x10xf32>
    %c1 = constant 1 : index
    %c10 = constant 10 : index
    %0 = hal.interface.binding.subspan @io::@s0b0_ro_external[%c0] : !flow.dispatch.tensor<readonly:1x10xf32>
    %1 = hal.interface.binding.subspan @io::@s0b1_xw_external[%c0] : !flow.dispatch.tensor<writeonly:10xf32>
    %workgroup_id_x = hal.interface.workgroup.id[0] : index
    %workgroup_count_x = hal.interface.workgroup.count[0] : index
    %workgroup_id_y = hal.interface.workgroup.id[1] : index
    %workgroup_count_y = hal.interface.workgroup.count[1] : index
    %2 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_y]
    %3 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_y]
    scf.for %arg0 = %2 to %c1 step %3 {
      %4 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
      %5 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
      scf.for %arg1 = %4 to %c10 step %5 {
        %6 = affine.min affine_map<(d0) -> (128, -d0 + 1)>(%arg0)
        %7 = affine.min affine_map<(d0) -> (128, -d0 + 10)>(%arg1)
        %8 = flow.dispatch.tensor.load %0, offsets = [%arg0, %arg1], sizes = [%6, %7], strides = [1, 1] : !flow.dispatch.tensor<readonly:1x10xf32> -> tensor<?x?xf32>
        %9 = affine.min affine_map<(d0) -> (128, -d0 + 1)>(%arg0)
        %10 = affine.min affine_map<(d0) -> (128, -d0 + 10)>(%arg1)
        %11 = subtensor %cst[%arg0, %arg1] [%9, %10] [1, 1] : tensor<1x10xf32> to tensor<?x?xf32>
        %12 = affine.min affine_map<(d0) -> (128, -d0 + 10)>(%arg1)
        %13 = linalg.init_tensor [%12] : tensor<?xf32>
        %14 = linalg.generic {indexing_maps = [affine_map<(d0, d1) -> (d0, d1)>, affine_map<(d0, d1) -> (d0, d1)>, affine_map<(d0, d1) -> (d1)>], iterator_types = ["parallel", "parallel"]} ins(%8, %11 : tensor<?x?xf32>, tensor<?x?xf32>) outs(%13 : tensor<?xf32>) attrs =  {__internal_linalg_transform__ = "workgroup", lowering.config = {tileSizes = [[128, 128]]}} {
        ^bb0(%arg2: f32, %arg3: f32, %arg4: f32):  // no predecessors
          %15 = addf %arg2, %arg3 : f32
          linalg.yield %15 : f32
        } -> tensor<?xf32>
        flow.dispatch.tensor.store %14, %1, offsets = [%arg1], sizes = [%12], strides = [1] : tensor<?xf32> -> !flow.dispatch.tensor<writeonly:10xf32>
      }
    }
    return
  }
  hal.interface @io attributes {sym_visibility = "private"} {
    hal.interface.binding @s0b0_ro_external, set=0, binding=0, type="StorageBuffer", access="Read"
    hal.interface.binding @s0b1_xw_external, set=0, binding=1, type="StorageBuffer", access="Write|Discard"
  }
}

// *** IR Dump After mlir::iree_compiler::`anonymous-namespace'::LinalgBufferizePass ***
func @predict_dispatch_3() {
  %c0 = constant 0 : index
  %cst = constant opaque<"_", "0xDEADBEEF"> : tensor<1x10xf32>
  %0 = memref.buffer_cast %cst : memref<1x10xf32>
  %c1 = constant 1 : index
  %c10 = constant 10 : index
  %1 = hal.interface.binding.subspan @io::@s0b0_ro_external[%c0] : memref<1x10xf32>
  %2 = hal.interface.binding.subspan @io::@s0b0_ro_external[%c0] : !flow.dispatch.tensor<readonly:1x10xf32>
  %3 = hal.interface.binding.subspan @io::@s0b1_xw_external[%c0] : memref<10xf32>
  %4 = hal.interface.binding.subspan @io::@s0b1_xw_external[%c0] : !flow.dispatch.tensor<writeonly:10xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %5 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_y]
  %6 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_y]
  scf.for %arg0 = %5 to %c1 step %6 {
    %7 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
    %8 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
    scf.for %arg1 = %7 to %c10 step %8 {
      %9 = affine.min affine_map<(d0) -> (128, -d0 + 1)>(%arg0)
      %10 = affine.min affine_map<(d0) -> (128, -d0 + 10)>(%arg1)
      %11 = memref.subview %1[%arg0, %arg1] [%9, %10] [1, 1] : memref<1x10xf32> to memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
      %12 = flow.dispatch.tensor.load %2, offsets = [%arg0, %arg1], sizes = [%9, %10], strides = [1, 1] : !flow.dispatch.tensor<readonly:1x10xf32> -> tensor<?x?xf32>
      %13 = affine.min affine_map<(d0) -> (128, -d0 + 1)>(%arg0)
      %14 = affine.min affine_map<(d0) -> (128, -d0 + 10)>(%arg1)
      %15 = memref.subview %0[%arg0, %arg1] [%13, %14] [1, 1] : memref<1x10xf32> to memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
      %16 = subtensor %cst[%arg0, %arg1] [%13, %14] [1, 1] : tensor<1x10xf32> to tensor<?x?xf32>
      %17 = affine.min affine_map<(d0) -> (128, -d0 + 10)>(%arg1)
      %18 = linalg.init_tensor [%17] : tensor<?xf32>
      %19 = memref.subview %3[%arg1] [%17] [1] : memref<10xf32> to memref<?xf32, affine_map<(d0)[s0] -> (d0 + s0)>>
      linalg.generic {indexing_maps = [affine_map<(d0, d1) -> (d0, d1)>, affine_map<(d0, d1) -> (d0, d1)>, affine_map<(d0, d1) -> (d1)>], iterator_types = ["parallel", "parallel"]} ins(%11, %15 : memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>, memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>) outs(%19 : memref<?xf32, affine_map<(d0)[s0] -> (d0 + s0)>>) attrs =  {__internal_linalg_transform__ = "workgroup", lowering.config = {tileSizes = [[128, 128]]}} {
      ^bb0(%arg2: f32, %arg3: f32, %arg4: f32):  // no predecessors
        %21 = addf %arg2, %arg3 : f32
        linalg.yield %21 : f32
      }
      %20 = linalg.generic {indexing_maps = [affine_map<(d0, d1) -> (d0, d1)>, affine_map<(d0, d1) -> (d0, d1)>, affine_map<(d0, d1) -> (d1)>], iterator_types = ["parallel", "parallel"]} ins(%12, %16 : tensor<?x?xf32>, tensor<?x?xf32>) outs(%18 : tensor<?xf32>) attrs =  {__internal_linalg_transform__ = "workgroup", lowering.config = {tileSizes = [[128, 128]]}} {
      ^bb0(%arg2: f32, %arg3: f32, %arg4: f32):  // no predecessors
        %21 = addf %arg2, %arg3 : f32
        linalg.yield %21 : f32
      } -> tensor<?xf32>
    }
  }
  return
}

// *** IR Dump After Canonicalizer ***
func @predict_dispatch_3() {
  %c0 = constant 0 : index
  %cst = constant opaque<"_", "0xDEADBEEF"> : tensor<1x10xf32>
  %c1 = constant 1 : index
  %c10 = constant 10 : index
  %0 = memref.buffer_cast %cst : memref<1x10xf32>
  %1 = hal.interface.binding.subspan @io::@s0b0_ro_external[%c0] : memref<1x10xf32>
  %2 = hal.interface.binding.subspan @io::@s0b0_ro_external[%c0] : !flow.dispatch.tensor<readonly:1x10xf32>
  %3 = hal.interface.binding.subspan @io::@s0b1_xw_external[%c0] : memref<10xf32>
  %4 = hal.interface.binding.subspan @io::@s0b1_xw_external[%c0] : !flow.dispatch.tensor<writeonly:10xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %5 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_y]
  %6 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_y]
  scf.for %arg0 = %5 to %c1 step %6 {
    %7 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
    %8 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
    scf.for %arg1 = %7 to %c10 step %8 {
      %9 = affine.min affine_map<(d0) -> (128, -d0 + 1)>(%arg0)
      %10 = affine.min affine_map<(d0) -> (128, -d0 + 10)>(%arg1)
      %11 = memref.subview %1[%arg0, %arg1] [%9, %10] [1, 1] : memref<1x10xf32> to memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
      %12 = affine.min affine_map<(d0) -> (128, -d0 + 1)>(%arg0)
      %13 = affine.min affine_map<(d0) -> (128, -d0 + 10)>(%arg1)
      %14 = memref.subview %0[%arg0, %arg1] [%12, %13] [1, 1] : memref<1x10xf32> to memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
      %15 = affine.min affine_map<(d0) -> (128, -d0 + 10)>(%arg1)
      %16 = memref.subview %3[%arg1] [%15] [1] : memref<10xf32> to memref<?xf32, affine_map<(d0)[s0] -> (d0 + s0)>>
      linalg.generic {indexing_maps = [affine_map<(d0, d1) -> (d0, d1)>, affine_map<(d0, d1) -> (d0, d1)>, affine_map<(d0, d1) -> (d1)>], iterator_types = ["parallel", "parallel"]} ins(%11, %14 : memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>, memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>) outs(%16 : memref<?xf32, affine_map<(d0)[s0] -> (d0 + s0)>>) attrs =  {__internal_linalg_transform__ = "workgroup", lowering.config = {tileSizes = [[128, 128]]}} {
      ^bb0(%arg2: f32, %arg3: f32, %arg4: f32):  // no predecessors
        %17 = addf %arg2, %arg3 : f32
        linalg.yield %17 : f32
      }
    }
  }
  return
}

// *** IR Dump After CSE ***
func @predict_dispatch_3() {
  %c0 = constant 0 : index
  %cst = constant opaque<"_", "0xDEADBEEF"> : tensor<1x10xf32>
  %c1 = constant 1 : index
  %c10 = constant 10 : index
  %0 = memref.buffer_cast %cst : memref<1x10xf32>
  %1 = hal.interface.binding.subspan @io::@s0b0_ro_external[%c0] : memref<1x10xf32>
  %2 = hal.interface.binding.subspan @io::@s0b0_ro_external[%c0] : !flow.dispatch.tensor<readonly:1x10xf32>
  %3 = hal.interface.binding.subspan @io::@s0b1_xw_external[%c0] : memref<10xf32>
  %4 = hal.interface.binding.subspan @io::@s0b1_xw_external[%c0] : !flow.dispatch.tensor<writeonly:10xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %5 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_y]
  %6 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_y]
  scf.for %arg0 = %5 to %c1 step %6 {
    %7 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
    %8 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
    scf.for %arg1 = %7 to %c10 step %8 {
      %9 = affine.min affine_map<(d0) -> (128, -d0 + 1)>(%arg0)
      %10 = affine.min affine_map<(d0) -> (128, -d0 + 10)>(%arg1)
      %11 = memref.subview %1[%arg0, %arg1] [%9, %10] [1, 1] : memref<1x10xf32> to memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
      %12 = memref.subview %0[%arg0, %arg1] [%9, %10] [1, 1] : memref<1x10xf32> to memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
      %13 = memref.subview %3[%arg1] [%10] [1] : memref<10xf32> to memref<?xf32, affine_map<(d0)[s0] -> (d0 + s0)>>
      linalg.generic {indexing_maps = [affine_map<(d0, d1) -> (d0, d1)>, affine_map<(d0, d1) -> (d0, d1)>, affine_map<(d0, d1) -> (d1)>], iterator_types = ["parallel", "parallel"]} ins(%11, %12 : memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>, memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>) outs(%13 : memref<?xf32, affine_map<(d0)[s0] -> (d0 + s0)>>) attrs =  {__internal_linalg_transform__ = "workgroup", lowering.config = {tileSizes = [[128, 128]]}} {
      ^bb0(%arg2: f32, %arg3: f32, %arg4: f32):  // no predecessors
        %14 = addf %arg2, %arg3 : f32
        linalg.yield %14 : f32
      }
    }
  }
  return
}

// *** IR Dump After mlir::iree_compiler::`anonymous-namespace'::BufferAllocViewCleanUpPass ***
func @predict_dispatch_3() {
  %c0 = constant 0 : index
  %cst = constant opaque<"_", "0xDEADBEEF"> : tensor<1x10xf32>
  %c1 = constant 1 : index
  %c10 = constant 10 : index
  %0 = memref.buffer_cast %cst : memref<1x10xf32>
  %1 = hal.interface.binding.subspan @io::@s0b0_ro_external[%c0] : memref<1x10xf32>
  %2 = hal.interface.binding.subspan @io::@s0b1_xw_external[%c0] : memref<10xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_y]
  scf.for %arg0 = %3 to %c1 step %4 {
    %5 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
    %6 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
    scf.for %arg1 = %5 to %c10 step %6 {
      %7 = affine.min affine_map<(d0) -> (128, -d0 + 1)>(%arg0)
      %8 = affine.min affine_map<(d0) -> (128, -d0 + 10)>(%arg1)
      %9 = memref.subview %1[%arg0, %arg1] [%7, %8] [1, 1] : memref<1x10xf32> to memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
      %10 = memref.subview %0[%arg0, %arg1] [%7, %8] [1, 1] : memref<1x10xf32> to memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
      %11 = memref.subview %2[%arg1] [%8] [1] : memref<10xf32> to memref<?xf32, affine_map<(d0)[s0] -> (d0 + s0)>>
      linalg.generic {indexing_maps = [affine_map<(d0, d1) -> (d0, d1)>, affine_map<(d0, d1) -> (d0, d1)>, affine_map<(d0, d1) -> (d1)>], iterator_types = ["parallel", "parallel"]} ins(%9, %10 : memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>, memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>) outs(%11 : memref<?xf32, affine_map<(d0)[s0] -> (d0 + s0)>>) attrs =  {__internal_linalg_transform__ = "workgroup", lowering.config = {tileSizes = [[128, 128]]}} {
      ^bb0(%arg2: f32, %arg3: f32, %arg4: f32):  // no predecessors
        %12 = addf %arg2, %arg3 : f32
        linalg.yield %12 : f32
      }
    }
  }
  return
}

// *** IR Dump After Canonicalizer ***
func @predict_dispatch_3() {
  %c0 = constant 0 : index
  %cst = constant opaque<"_", "0xDEADBEEF"> : tensor<1x10xf32>
  %c1 = constant 1 : index
  %c10 = constant 10 : index
  %0 = memref.buffer_cast %cst : memref<1x10xf32>
  %1 = hal.interface.binding.subspan @io::@s0b0_ro_external[%c0] : memref<1x10xf32>
  %2 = hal.interface.binding.subspan @io::@s0b1_xw_external[%c0] : memref<10xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_y]
  scf.for %arg0 = %3 to %c1 step %4 {
    %5 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
    %6 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
    scf.for %arg1 = %5 to %c10 step %6 {
      %7 = affine.min affine_map<(d0) -> (128, -d0 + 1)>(%arg0)
      %8 = affine.min affine_map<(d0) -> (128, -d0 + 10)>(%arg1)
      %9 = memref.subview %1[%arg0, %arg1] [%7, %8] [1, 1] : memref<1x10xf32> to memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
      %10 = memref.subview %0[%arg0, %arg1] [%7, %8] [1, 1] : memref<1x10xf32> to memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
      %11 = memref.subview %2[%arg1] [%8] [1] : memref<10xf32> to memref<?xf32, affine_map<(d0)[s0] -> (d0 + s0)>>
      linalg.generic {indexing_maps = [affine_map<(d0, d1) -> (d0, d1)>, affine_map<(d0, d1) -> (d0, d1)>, affine_map<(d0, d1) -> (d1)>], iterator_types = ["parallel", "parallel"]} ins(%9, %10 : memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>, memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>) outs(%11 : memref<?xf32, affine_map<(d0)[s0] -> (d0 + s0)>>) attrs =  {__internal_linalg_transform__ = "workgroup", lowering.config = {tileSizes = [[128, 128]]}} {
      ^bb0(%arg2: f32, %arg3: f32, %arg4: f32):  // no predecessors
        %12 = addf %arg2, %arg3 : f32
        linalg.yield %12 : f32
      }
    }
  }
  return
}

// *** IR Dump After mlir::iree_compiler::`anonymous-namespace'::TileAndVectorizeWorkgroups ***
func @predict_dispatch_3() {
  %c0 = constant 0 : index
  %cst = constant opaque<"_", "0xDEADBEEF"> : tensor<1x10xf32>
  %c1 = constant 1 : index
  %c10 = constant 10 : index
  %0 = memref.buffer_cast %cst : memref<1x10xf32>
  %1 = hal.interface.binding.subspan @io::@s0b0_ro_external[%c0] : memref<1x10xf32>
  %2 = hal.interface.binding.subspan @io::@s0b1_xw_external[%c0] : memref<10xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_y]
  scf.for %arg0 = %3 to %c1 step %4 {
    %5 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
    %6 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
    scf.for %arg1 = %5 to %c10 step %6 {
      %7 = affine.min affine_map<(d0) -> (128, -d0 + 1)>(%arg0)
      %8 = affine.min affine_map<(d0) -> (128, -d0 + 10)>(%arg1)
      %9 = memref.subview %1[%arg0, %arg1] [%7, %8] [1, 1] : memref<1x10xf32> to memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
      %10 = memref.subview %0[%arg0, %arg1] [%7, %8] [1, 1] : memref<1x10xf32> to memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
      %11 = memref.subview %2[%arg1] [%8] [1] : memref<10xf32> to memref<?xf32, affine_map<(d0)[s0] -> (d0 + s0)>>
      linalg.generic {indexing_maps = [affine_map<(d0, d1) -> (d0, d1)>, affine_map<(d0, d1) -> (d0, d1)>, affine_map<(d0, d1) -> (d1)>], iterator_types = ["parallel", "parallel"]} ins(%9, %10 : memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>, memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>) outs(%11 : memref<?xf32, affine_map<(d0)[s0] -> (d0 + s0)>>) attrs =  {__internal_linalg_transform__ = "workgroup", lowering.config = {tileSizes = [[128, 128]]}} {
      ^bb0(%arg2: f32, %arg3: f32, %arg4: f32):  // no predecessors
        %12 = addf %arg2, %arg3 : f32
        linalg.yield %12 : f32
      }
    }
  }
  return
}

// *** IR Dump After Canonicalizer ***
func @predict_dispatch_3() {
  %c0 = constant 0 : index
  %cst = constant opaque<"_", "0xDEADBEEF"> : tensor<1x10xf32>
  %c1 = constant 1 : index
  %c10 = constant 10 : index
  %0 = memref.buffer_cast %cst : memref<1x10xf32>
  %1 = hal.interface.binding.subspan @io::@s0b0_ro_external[%c0] : memref<1x10xf32>
  %2 = hal.interface.binding.subspan @io::@s0b1_xw_external[%c0] : memref<10xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_y]
  scf.for %arg0 = %3 to %c1 step %4 {
    %5 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
    %6 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
    scf.for %arg1 = %5 to %c10 step %6 {
      %7 = affine.min affine_map<(d0) -> (128, -d0 + 1)>(%arg0)
      %8 = affine.min affine_map<(d0) -> (128, -d0 + 10)>(%arg1)
      %9 = memref.subview %1[%arg0, %arg1] [%7, %8] [1, 1] : memref<1x10xf32> to memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
      %10 = memref.subview %0[%arg0, %arg1] [%7, %8] [1, 1] : memref<1x10xf32> to memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
      %11 = memref.subview %2[%arg1] [%8] [1] : memref<10xf32> to memref<?xf32, affine_map<(d0)[s0] -> (d0 + s0)>>
      linalg.generic {indexing_maps = [affine_map<(d0, d1) -> (d0, d1)>, affine_map<(d0, d1) -> (d0, d1)>, affine_map<(d0, d1) -> (d1)>], iterator_types = ["parallel", "parallel"]} ins(%9, %10 : memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>, memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>) outs(%11 : memref<?xf32, affine_map<(d0)[s0] -> (d0 + s0)>>) attrs =  {__internal_linalg_transform__ = "workgroup", lowering.config = {tileSizes = [[128, 128]]}} {
      ^bb0(%arg2: f32, %arg3: f32, %arg4: f32):  // no predecessors
        %12 = addf %arg2, %arg3 : f32
        linalg.yield %12 : f32
      }
    }
  }
  return
}

// *** IR Dump After mlir::iree_compiler::`anonymous-namespace'::ForOpCanonicalizationPass ***
func @predict_dispatch_3() {
  %c0 = constant 0 : index
  %cst = constant opaque<"_", "0xDEADBEEF"> : tensor<1x10xf32>
  %c1 = constant 1 : index
  %c10 = constant 10 : index
  %0 = memref.buffer_cast %cst : memref<1x10xf32>
  %1 = hal.interface.binding.subspan @io::@s0b0_ro_external[%c0] : memref<1x10xf32>
  %2 = hal.interface.binding.subspan @io::@s0b1_xw_external[%c0] : memref<10xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_y]
  scf.for %arg0 = %3 to %c1 step %4 {
    %5 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
    %6 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
    scf.for %arg1 = %5 to %c10 step %6 {
      %7 = affine.min affine_map<(d0) -> (128, -d0 + 1)>(%arg0)
      %8 = affine.min affine_map<(d0) -> (128, -d0 + 10)>(%arg1)
      %9 = memref.subview %1[%arg0, %arg1] [%7, %8] [1, 1] : memref<1x10xf32> to memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
      %10 = memref.subview %0[%arg0, %arg1] [%7, %8] [1, 1] : memref<1x10xf32> to memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
      %11 = memref.subview %2[%arg1] [%8] [1] : memref<10xf32> to memref<?xf32, affine_map<(d0)[s0] -> (d0 + s0)>>
      linalg.generic {indexing_maps = [affine_map<(d0, d1) -> (d0, d1)>, affine_map<(d0, d1) -> (d0, d1)>, affine_map<(d0, d1) -> (d1)>], iterator_types = ["parallel", "parallel"]} ins(%9, %10 : memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>, memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>) outs(%11 : memref<?xf32, affine_map<(d0)[s0] -> (d0 + s0)>>) attrs =  {__internal_linalg_transform__ = "workgroup", lowering.config = {tileSizes = [[128, 128]]}} {
      ^bb0(%arg2: f32, %arg3: f32, %arg4: f32):  // no predecessors
        %12 = addf %arg2, %arg3 : f32
        linalg.yield %12 : f32
      }
    }
  }
  return
}

// *** IR Dump After mlir::iree_compiler::`anonymous-namespace'::PlanConvLoopOrderPass ***
func @predict_dispatch_3() {
  %c0 = constant 0 : index
  %cst = constant opaque<"_", "0xDEADBEEF"> : tensor<1x10xf32>
  %c1 = constant 1 : index
  %c10 = constant 10 : index
  %0 = memref.buffer_cast %cst : memref<1x10xf32>
  %1 = hal.interface.binding.subspan @io::@s0b0_ro_external[%c0] : memref<1x10xf32>
  %2 = hal.interface.binding.subspan @io::@s0b1_xw_external[%c0] : memref<10xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_y]
  scf.for %arg0 = %3 to %c1 step %4 {
    %5 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
    %6 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
    scf.for %arg1 = %5 to %c10 step %6 {
      %7 = affine.min affine_map<(d0) -> (128, -d0 + 1)>(%arg0)
      %8 = affine.min affine_map<(d0) -> (128, -d0 + 10)>(%arg1)
      %9 = memref.subview %1[%arg0, %arg1] [%7, %8] [1, 1] : memref<1x10xf32> to memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
      %10 = memref.subview %0[%arg0, %arg1] [%7, %8] [1, 1] : memref<1x10xf32> to memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
      %11 = memref.subview %2[%arg1] [%8] [1] : memref<10xf32> to memref<?xf32, affine_map<(d0)[s0] -> (d0 + s0)>>
      linalg.generic {indexing_maps = [affine_map<(d0, d1) -> (d0, d1)>, affine_map<(d0, d1) -> (d0, d1)>, affine_map<(d0, d1) -> (d1)>], iterator_types = ["parallel", "parallel"]} ins(%9, %10 : memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>, memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>) outs(%11 : memref<?xf32, affine_map<(d0)[s0] -> (d0 + s0)>>) attrs =  {__internal_linalg_transform__ = "workgroup", lowering.config = {tileSizes = [[128, 128]]}} {
      ^bb0(%arg2: f32, %arg3: f32, %arg4: f32):  // no predecessors
        %12 = addf %arg2, %arg3 : f32
        linalg.yield %12 : f32
      }
    }
  }
  return
}

// *** IR Dump After LinalgLowerToLoops ***
func @predict_dispatch_3() {
  %cst = constant opaque<"_", "0xDEADBEEF"> : tensor<1x10xf32>
  %c10 = constant 10 : index
  %c0 = constant 0 : index
  %c1 = constant 1 : index
  %0 = memref.buffer_cast %cst : memref<1x10xf32>
  %1 = hal.interface.binding.subspan @io::@s0b0_ro_external[%c0] : memref<1x10xf32>
  %2 = hal.interface.binding.subspan @io::@s0b1_xw_external[%c0] : memref<10xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_y]
  scf.for %arg0 = %3 to %c1 step %4 {
    %5 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
    %6 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
    scf.for %arg1 = %5 to %c10 step %6 {
      %7 = affine.min affine_map<(d0) -> (128, -d0 + 1)>(%arg0)
      %8 = affine.min affine_map<(d0) -> (128, -d0 + 10)>(%arg1)
      %9 = memref.subview %1[%arg0, %arg1] [%7, %8] [1, 1] : memref<1x10xf32> to memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
      %10 = memref.subview %0[%arg0, %arg1] [%7, %8] [1, 1] : memref<1x10xf32> to memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
      %11 = memref.subview %2[%arg1] [%8] [1] : memref<10xf32> to memref<?xf32, affine_map<(d0)[s0] -> (d0 + s0)>>
      scf.for %arg2 = %c0 to %7 step %c1 {
        scf.for %arg3 = %c0 to %8 step %c1 {
          %12 = memref.load %9[%arg2, %arg3] : memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
          %13 = memref.load %10[%arg2, %arg3] : memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
          %14 = addf %12, %13 : f32
          memref.store %14, %11[%arg3] : memref<?xf32, affine_map<(d0)[s0] -> (d0 + s0)>>
        }
      }
    }
  }
  return
}

// *** IR Dump After Canonicalizer ***
func @predict_dispatch_3() {
  %cst = constant opaque<"_", "0xDEADBEEF"> : tensor<1x10xf32>
  %c10 = constant 10 : index
  %c0 = constant 0 : index
  %c1 = constant 1 : index
  %0 = memref.buffer_cast %cst : memref<1x10xf32>
  %1 = hal.interface.binding.subspan @io::@s0b0_ro_external[%c0] : memref<1x10xf32>
  %2 = hal.interface.binding.subspan @io::@s0b1_xw_external[%c0] : memref<10xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_y]
  scf.for %arg0 = %3 to %c1 step %4 {
    %5 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
    %6 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
    scf.for %arg1 = %5 to %c10 step %6 {
      %7 = affine.min affine_map<(d0) -> (128, -d0 + 1)>(%arg0)
      %8 = affine.min affine_map<(d0) -> (128, -d0 + 10)>(%arg1)
      %9 = memref.subview %1[%arg0, %arg1] [%7, %8] [1, 1] : memref<1x10xf32> to memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
      %10 = memref.subview %0[%arg0, %arg1] [%7, %8] [1, 1] : memref<1x10xf32> to memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
      %11 = memref.subview %2[%arg1] [%8] [1] : memref<10xf32> to memref<?xf32, affine_map<(d0)[s0] -> (d0 + s0)>>
      scf.for %arg2 = %c0 to %7 step %c1 {
        scf.for %arg3 = %c0 to %8 step %c1 {
          %12 = memref.load %9[%arg2, %arg3] : memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
          %13 = memref.load %10[%arg2, %arg3] : memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
          %14 = addf %12, %13 : f32
          memref.store %14, %11[%arg3] : memref<?xf32, affine_map<(d0)[s0] -> (d0 + s0)>>
        }
      }
    }
  }
  return
}

// *** IR Dump After CSE ***
func @predict_dispatch_3() {
  %cst = constant opaque<"_", "0xDEADBEEF"> : tensor<1x10xf32>
  %c10 = constant 10 : index
  %c0 = constant 0 : index
  %c1 = constant 1 : index
  %0 = memref.buffer_cast %cst : memref<1x10xf32>
  %1 = hal.interface.binding.subspan @io::@s0b0_ro_external[%c0] : memref<1x10xf32>
  %2 = hal.interface.binding.subspan @io::@s0b1_xw_external[%c0] : memref<10xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_y]
  scf.for %arg0 = %3 to %c1 step %4 {
    %5 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
    %6 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
    scf.for %arg1 = %5 to %c10 step %6 {
      %7 = affine.min affine_map<(d0) -> (128, -d0 + 1)>(%arg0)
      %8 = affine.min affine_map<(d0) -> (128, -d0 + 10)>(%arg1)
      %9 = memref.subview %1[%arg0, %arg1] [%7, %8] [1, 1] : memref<1x10xf32> to memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
      %10 = memref.subview %0[%arg0, %arg1] [%7, %8] [1, 1] : memref<1x10xf32> to memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
      %11 = memref.subview %2[%arg1] [%8] [1] : memref<10xf32> to memref<?xf32, affine_map<(d0)[s0] -> (d0 + s0)>>
      scf.for %arg2 = %c0 to %7 step %c1 {
        scf.for %arg3 = %c0 to %8 step %c1 {
          %12 = memref.load %9[%arg2, %arg3] : memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
          %13 = memref.load %10[%arg2, %arg3] : memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
          %14 = addf %12, %13 : f32
          memref.store %14, %11[%arg3] : memref<?xf32, affine_map<(d0)[s0] -> (d0 + s0)>>
        }
      }
    }
  }
  return
}

// *** IR Dump After SCFToStandard ***
func @predict_dispatch_3() {
  %cst = constant opaque<"_", "0xDEADBEEF"> : tensor<1x10xf32>
  %c10 = constant 10 : index
  %c0 = constant 0 : index
  %c1 = constant 1 : index
  %0 = memref.buffer_cast %cst : memref<1x10xf32>
  %1 = hal.interface.binding.subspan @io::@s0b0_ro_external[%c0] : memref<1x10xf32>
  %2 = hal.interface.binding.subspan @io::@s0b1_xw_external[%c0] : memref<10xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_y]
  br ^bb1(%3 : index)
^bb1(%5: index):  // 2 preds: ^bb0, ^bb11
  %6 = cmpi slt, %5, %c1 : index
  cond_br %6, ^bb2, ^bb12
^bb2:  // pred: ^bb1
  %7 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %8 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
  br ^bb3(%7 : index)
^bb3(%9: index):  // 2 preds: ^bb2, ^bb10
  %10 = cmpi slt, %9, %c10 : index
  cond_br %10, ^bb4, ^bb11
^bb4:  // pred: ^bb3
  %11 = affine.min affine_map<(d0) -> (128, -d0 + 1)>(%5)
  %12 = affine.min affine_map<(d0) -> (128, -d0 + 10)>(%9)
  %13 = memref.subview %1[%5, %9] [%11, %12] [1, 1] : memref<1x10xf32> to memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
  %14 = memref.subview %0[%5, %9] [%11, %12] [1, 1] : memref<1x10xf32> to memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
  %15 = memref.subview %2[%9] [%12] [1] : memref<10xf32> to memref<?xf32, affine_map<(d0)[s0] -> (d0 + s0)>>
  br ^bb5(%c0 : index)
^bb5(%16: index):  // 2 preds: ^bb4, ^bb9
  %17 = cmpi slt, %16, %11 : index
  cond_br %17, ^bb6, ^bb10
^bb6:  // pred: ^bb5
  br ^bb7(%c0 : index)
^bb7(%18: index):  // 2 preds: ^bb6, ^bb8
  %19 = cmpi slt, %18, %12 : index
  cond_br %19, ^bb8, ^bb9
^bb8:  // pred: ^bb7
  %20 = memref.load %13[%16, %18] : memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
  %21 = memref.load %14[%16, %18] : memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
  %22 = addf %20, %21 : f32
  memref.store %22, %15[%18] : memref<?xf32, affine_map<(d0)[s0] -> (d0 + s0)>>
  %23 = addi %18, %c1 : index
  br ^bb7(%23 : index)
^bb9:  // pred: ^bb7
  %24 = addi %16, %c1 : index
  br ^bb5(%24 : index)
^bb10:  // pred: ^bb5
  %25 = addi %9, %8 : index
  br ^bb3(%25 : index)
^bb11:  // pred: ^bb3
  %26 = addi %5, %4 : index
  br ^bb1(%26 : index)
^bb12:  // pred: ^bb1
  return
}

// *** IR Dump After Canonicalizer ***
func @predict_dispatch_3() {
  %cst = constant opaque<"_", "0xDEADBEEF"> : tensor<1x10xf32>
  %c10 = constant 10 : index
  %c0 = constant 0 : index
  %c1 = constant 1 : index
  %0 = memref.buffer_cast %cst : memref<1x10xf32>
  %1 = hal.interface.binding.subspan @io::@s0b0_ro_external[%c0] : memref<1x10xf32>
  %2 = hal.interface.binding.subspan @io::@s0b1_xw_external[%c0] : memref<10xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_y]
  br ^bb1(%3 : index)
^bb1(%5: index):  // 2 preds: ^bb0, ^bb10
  %6 = cmpi slt, %5, %c1 : index
  cond_br %6, ^bb2, ^bb11
^bb2:  // pred: ^bb1
  %7 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %8 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
  br ^bb3(%7 : index)
^bb3(%9: index):  // 2 preds: ^bb2, ^bb9
  %10 = cmpi slt, %9, %c10 : index
  cond_br %10, ^bb4, ^bb10
^bb4:  // pred: ^bb3
  %11 = affine.min affine_map<()[s0] -> (128, -s0 + 1)>()[%5]
  %12 = affine.min affine_map<()[s0] -> (128, -s0 + 10)>()[%9]
  %13 = memref.subview %1[%5, %9] [%11, %12] [1, 1] : memref<1x10xf32> to memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
  %14 = memref.subview %0[%5, %9] [%11, %12] [1, 1] : memref<1x10xf32> to memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
  %15 = memref.subview %2[%9] [%12] [1] : memref<10xf32> to memref<?xf32, affine_map<(d0)[s0] -> (d0 + s0)>>
  br ^bb5(%c0 : index)
^bb5(%16: index):  // 2 preds: ^bb4, ^bb8
  %17 = cmpi slt, %16, %11 : index
  cond_br %17, ^bb6(%c0 : index), ^bb9
^bb6(%18: index):  // 2 preds: ^bb5, ^bb7
  %19 = cmpi slt, %18, %12 : index
  cond_br %19, ^bb7, ^bb8
^bb7:  // pred: ^bb6
  %20 = memref.load %13[%16, %18] : memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
  %21 = memref.load %14[%16, %18] : memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
  %22 = addf %20, %21 : f32
  memref.store %22, %15[%18] : memref<?xf32, affine_map<(d0)[s0] -> (d0 + s0)>>
  %23 = addi %18, %c1 : index
  br ^bb6(%23 : index)
^bb8:  // pred: ^bb6
  %24 = addi %16, %c1 : index
  br ^bb5(%24 : index)
^bb9:  // pred: ^bb5
  %25 = addi %9, %8 : index
  br ^bb3(%25 : index)
^bb10:  // pred: ^bb3
  %26 = addi %5, %4 : index
  br ^bb1(%26 : index)
^bb11:  // pred: ^bb1
  return
}

// *** IR Dump After CSE ***
func @predict_dispatch_3() {
  %cst = constant opaque<"_", "0xDEADBEEF"> : tensor<1x10xf32>
  %c10 = constant 10 : index
  %c0 = constant 0 : index
  %c1 = constant 1 : index
  %0 = memref.buffer_cast %cst : memref<1x10xf32>
  %1 = hal.interface.binding.subspan @io::@s0b0_ro_external[%c0] : memref<1x10xf32>
  %2 = hal.interface.binding.subspan @io::@s0b1_xw_external[%c0] : memref<10xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_y]
  br ^bb1(%3 : index)
^bb1(%5: index):  // 2 preds: ^bb0, ^bb10
  %6 = cmpi slt, %5, %c1 : index
  cond_br %6, ^bb2, ^bb11
^bb2:  // pred: ^bb1
  %7 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %8 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
  br ^bb3(%7 : index)
^bb3(%9: index):  // 2 preds: ^bb2, ^bb9
  %10 = cmpi slt, %9, %c10 : index
  cond_br %10, ^bb4, ^bb10
^bb4:  // pred: ^bb3
  %11 = affine.min affine_map<()[s0] -> (128, -s0 + 1)>()[%5]
  %12 = affine.min affine_map<()[s0] -> (128, -s0 + 10)>()[%9]
  %13 = memref.subview %1[%5, %9] [%11, %12] [1, 1] : memref<1x10xf32> to memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
  %14 = memref.subview %0[%5, %9] [%11, %12] [1, 1] : memref<1x10xf32> to memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
  %15 = memref.subview %2[%9] [%12] [1] : memref<10xf32> to memref<?xf32, affine_map<(d0)[s0] -> (d0 + s0)>>
  br ^bb5(%c0 : index)
^bb5(%16: index):  // 2 preds: ^bb4, ^bb8
  %17 = cmpi slt, %16, %11 : index
  cond_br %17, ^bb6(%c0 : index), ^bb9
^bb6(%18: index):  // 2 preds: ^bb5, ^bb7
  %19 = cmpi slt, %18, %12 : index
  cond_br %19, ^bb7, ^bb8
^bb7:  // pred: ^bb6
  %20 = memref.load %13[%16, %18] : memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
  %21 = memref.load %14[%16, %18] : memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
  %22 = addf %20, %21 : f32
  memref.store %22, %15[%18] : memref<?xf32, affine_map<(d0)[s0] -> (d0 + s0)>>
  %23 = addi %18, %c1 : index
  br ^bb6(%23 : index)
^bb8:  // pred: ^bb6
  %24 = addi %16, %c1 : index
  br ^bb5(%24 : index)
^bb9:  // pred: ^bb5
  %25 = addi %9, %8 : index
  br ^bb3(%25 : index)
^bb10:  // pred: ^bb3
  %26 = addi %5, %4 : index
  br ^bb1(%26 : index)
^bb11:  // pred: ^bb1
  return
}

// *** IR Dump After TensorConstantBufferize ***
module  {
  memref.global "private" constant @__constant_1x10xf32 : memref<1x10xf32> = opaque<"_", "0xDEADBEEF">
  func @predict_dispatch_3() {
    %0 = memref.get_global @__constant_1x10xf32 : memref<1x10xf32>
    %1 = memref.tensor_load %0 : memref<1x10xf32>
    %c10 = constant 10 : index
    %c0 = constant 0 : index
    %c1 = constant 1 : index
    %2 = memref.buffer_cast %1 : memref<1x10xf32>
    %3 = hal.interface.binding.subspan @io::@s0b0_ro_external[%c0] : memref<1x10xf32>
    %4 = hal.interface.binding.subspan @io::@s0b1_xw_external[%c0] : memref<10xf32>
    %workgroup_id_x = hal.interface.workgroup.id[0] : index
    %workgroup_count_x = hal.interface.workgroup.count[0] : index
    %workgroup_id_y = hal.interface.workgroup.id[1] : index
    %workgroup_count_y = hal.interface.workgroup.count[1] : index
    %5 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_y]
    %6 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_y]
    br ^bb1(%5 : index)
  ^bb1(%7: index):  // 2 preds: ^bb0, ^bb10
    %8 = cmpi slt, %7, %c1 : index
    cond_br %8, ^bb2, ^bb11
  ^bb2:  // pred: ^bb1
    %9 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
    %10 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
    br ^bb3(%9 : index)
  ^bb3(%11: index):  // 2 preds: ^bb2, ^bb9
    %12 = cmpi slt, %11, %c10 : index
    cond_br %12, ^bb4, ^bb10
  ^bb4:  // pred: ^bb3
    %13 = affine.min affine_map<()[s0] -> (128, -s0 + 1)>()[%7]
    %14 = affine.min affine_map<()[s0] -> (128, -s0 + 10)>()[%11]
    %15 = memref.subview %3[%7, %11] [%13, %14] [1, 1] : memref<1x10xf32> to memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
    %16 = memref.subview %2[%7, %11] [%13, %14] [1, 1] : memref<1x10xf32> to memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
    %17 = memref.subview %4[%11] [%14] [1] : memref<10xf32> to memref<?xf32, affine_map<(d0)[s0] -> (d0 + s0)>>
    br ^bb5(%c0 : index)
  ^bb5(%18: index):  // 2 preds: ^bb4, ^bb8
    %19 = cmpi slt, %18, %13 : index
    cond_br %19, ^bb6(%c0 : index), ^bb9
  ^bb6(%20: index):  // 2 preds: ^bb5, ^bb7
    %21 = cmpi slt, %20, %14 : index
    cond_br %21, ^bb7, ^bb8
  ^bb7:  // pred: ^bb6
    %22 = memref.load %15[%18, %20] : memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
    %23 = memref.load %16[%18, %20] : memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
    %24 = addf %22, %23 : f32
    memref.store %24, %17[%20] : memref<?xf32, affine_map<(d0)[s0] -> (d0 + s0)>>
    %25 = addi %20, %c1 : index
    br ^bb6(%25 : index)
  ^bb8:  // pred: ^bb6
    %26 = addi %18, %c1 : index
    br ^bb5(%26 : index)
  ^bb9:  // pred: ^bb5
    %27 = addi %11, %10 : index
    br ^bb3(%27 : index)
  ^bb10:  // pred: ^bb3
    %28 = addi %7, %6 : index
    br ^bb1(%28 : index)
  ^bb11:  // pred: ^bb1
    return
  }
  hal.interface @io attributes {sym_visibility = "private"} {
    hal.interface.binding @s0b0_ro_external, set=0, binding=0, type="StorageBuffer", access="Read"
    hal.interface.binding @s0b1_xw_external, set=0, binding=1, type="StorageBuffer", access="Write|Discard"
  }
}

// *** IR Dump After mlir::iree_compiler::`anonymous-namespace'::FoldTensorExtractOpPass ***
module  {
  memref.global "private" constant @__constant_1x10xf32 : memref<1x10xf32> = opaque<"_", "0xDEADBEEF">
  func @predict_dispatch_3() {
    %c10 = constant 10 : index
    %c0 = constant 0 : index
    %c1 = constant 1 : index
    %0 = memref.get_global @__constant_1x10xf32 : memref<1x10xf32>
    %1 = hal.interface.binding.subspan @io::@s0b0_ro_external[%c0] : memref<1x10xf32>
    %2 = hal.interface.binding.subspan @io::@s0b1_xw_external[%c0] : memref<10xf32>
    %workgroup_id_x = hal.interface.workgroup.id[0] : index
    %workgroup_count_x = hal.interface.workgroup.count[0] : index
    %workgroup_id_y = hal.interface.workgroup.id[1] : index
    %workgroup_count_y = hal.interface.workgroup.count[1] : index
    %3 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_y]
    %4 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_y]
    br ^bb1(%3 : index)
  ^bb1(%5: index):  // 2 preds: ^bb0, ^bb10
    %6 = cmpi slt, %5, %c1 : index
    cond_br %6, ^bb2, ^bb11
  ^bb2:  // pred: ^bb1
    %7 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
    %8 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
    br ^bb3(%7 : index)
  ^bb3(%9: index):  // 2 preds: ^bb2, ^bb9
    %10 = cmpi slt, %9, %c10 : index
    cond_br %10, ^bb4, ^bb10
  ^bb4:  // pred: ^bb3
    %11 = affine.min affine_map<()[s0] -> (128, -s0 + 1)>()[%5]
    %12 = affine.min affine_map<()[s0] -> (128, -s0 + 10)>()[%9]
    %13 = memref.subview %1[%5, %9] [%11, %12] [1, 1] : memref<1x10xf32> to memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
    %14 = memref.subview %0[%5, %9] [%11, %12] [1, 1] : memref<1x10xf32> to memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
    %15 = memref.subview %2[%9] [%12] [1] : memref<10xf32> to memref<?xf32, affine_map<(d0)[s0] -> (d0 + s0)>>
    br ^bb5(%c0 : index)
  ^bb5(%16: index):  // 2 preds: ^bb4, ^bb8
    %17 = cmpi slt, %16, %11 : index
    cond_br %17, ^bb6(%c0 : index), ^bb9
  ^bb6(%18: index):  // 2 preds: ^bb5, ^bb7
    %19 = cmpi slt, %18, %12 : index
    cond_br %19, ^bb7, ^bb8
  ^bb7:  // pred: ^bb6
    %20 = memref.load %13[%16, %18] : memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
    %21 = memref.load %14[%16, %18] : memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
    %22 = addf %20, %21 : f32
    memref.store %22, %15[%18] : memref<?xf32, affine_map<(d0)[s0] -> (d0 + s0)>>
    %23 = addi %18, %c1 : index
    br ^bb6(%23 : index)
  ^bb8:  // pred: ^bb6
    %24 = addi %16, %c1 : index
    br ^bb5(%24 : index)
  ^bb9:  // pred: ^bb5
    %25 = addi %9, %8 : index
    br ^bb3(%25 : index)
  ^bb10:  // pred: ^bb3
    %26 = addi %5, %4 : index
    br ^bb1(%26 : index)
  ^bb11:  // pred: ^bb1
    return
  }
  hal.interface @io attributes {sym_visibility = "private"} {
    hal.interface.binding @s0b0_ro_external, set=0, binding=0, type="StorageBuffer", access="Read"
    hal.interface.binding @s0b1_xw_external, set=0, binding=1, type="StorageBuffer", access="Write|Discard"
  }
}

// *** IR Dump After mlir::iree_compiler::`anonymous-namespace'::ConvertToLLVMPass ***
module  {
  llvm.mlir.global private constant @__constant_1x10xf32(opaque<"_", "0xDEADBEEF"> : tensor<1x10xf32>) : !llvm.array<1 x array<10 x f32>>
  llvm.func internal @predict_dispatch_3(%arg0: !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>, %arg1: !llvm.ptr<array<3 x i32>>) -> i32 {
    %0 = llvm.mlir.constant(10 : index) : i64
    %1 = llvm.mlir.constant(0 : index) : i64
    %2 = llvm.mlir.constant(1 : index) : i64
    %3 = llvm.mlir.constant(1 : index) : i64
    %4 = llvm.mlir.constant(10 : index) : i64
    %5 = llvm.mlir.constant(1 : index) : i64
    %6 = llvm.mlir.constant(10 : index) : i64
    %7 = llvm.mlir.null : !llvm.ptr<f32>
    %8 = llvm.getelementptr %7[%6] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %9 = llvm.ptrtoint %8 : !llvm.ptr<f32> to i64
    %10 = llvm.mlir.addressof @__constant_1x10xf32 : !llvm.ptr<array<1 x array<10 x f32>>>
    %11 = llvm.mlir.constant(0 : index) : i64
    %12 = llvm.getelementptr %10[%11, %11, %11] : (!llvm.ptr<array<1 x array<10 x f32>>>, i64, i64, i64) -> !llvm.ptr<f32>
    %13 = llvm.mlir.constant(3735928559 : index) : i64
    %14 = llvm.inttoptr %13 : i64 to !llvm.ptr<f32>
    %15 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %16 = llvm.insertvalue %14, %15[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %17 = llvm.insertvalue %12, %16[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %18 = llvm.mlir.constant(0 : index) : i64
    %19 = llvm.insertvalue %18, %17[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %20 = llvm.insertvalue %3, %19[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %21 = llvm.insertvalue %4, %20[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %22 = llvm.insertvalue %4, %21[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %23 = llvm.insertvalue %5, %22[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %24 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
    %25 = llvm.extractvalue %24[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
    %26 = llvm.mlir.constant(0 : index) : i64
    %27 = llvm.getelementptr %25[%26] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
    %28 = llvm.load %27 : !llvm.ptr<ptr<i8>>
    %29 = llvm.getelementptr %28[%1] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
    %30 = llvm.bitcast %29 : !llvm.ptr<i8> to !llvm.ptr<f32>
    %31 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %32 = llvm.insertvalue %30, %31[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %33 = llvm.insertvalue %30, %32[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %34 = llvm.mlir.constant(0 : index) : i64
    %35 = llvm.insertvalue %34, %33[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %36 = llvm.mlir.constant(1 : index) : i64
    %37 = llvm.insertvalue %36, %35[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %38 = llvm.mlir.constant(10 : index) : i64
    %39 = llvm.insertvalue %38, %37[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %40 = llvm.mlir.constant(10 : index) : i64
    %41 = llvm.insertvalue %40, %39[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %42 = llvm.mlir.constant(1 : index) : i64
    %43 = llvm.insertvalue %42, %41[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %44 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
    %45 = llvm.extractvalue %44[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
    %46 = llvm.mlir.constant(1 : index) : i64
    %47 = llvm.getelementptr %45[%46] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
    %48 = llvm.load %47 : !llvm.ptr<ptr<i8>>
    %49 = llvm.getelementptr %48[%1] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
    %50 = llvm.bitcast %49 : !llvm.ptr<i8> to !llvm.ptr<f32>
    %51 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
    %52 = llvm.insertvalue %50, %51[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
    %53 = llvm.insertvalue %50, %52[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
    %54 = llvm.mlir.constant(0 : index) : i64
    %55 = llvm.insertvalue %54, %53[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
    %56 = llvm.mlir.constant(10 : index) : i64
    %57 = llvm.insertvalue %56, %55[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
    %58 = llvm.mlir.constant(1 : index) : i64
    %59 = llvm.insertvalue %58, %57[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
    %60 = llvm.load %arg1 : !llvm.ptr<array<3 x i32>>
    %61 = llvm.extractvalue %60[0] : !llvm.array<3 x i32>
    %62 = llvm.zext %61 : i32 to i64
    %63 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
    %64 = llvm.extractvalue %63[0] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
    %65 = llvm.extractvalue %64[0] : !llvm.array<3 x i32>
    %66 = llvm.zext %65 : i32 to i64
    %67 = llvm.load %arg1 : !llvm.ptr<array<3 x i32>>
    %68 = llvm.extractvalue %67[1] : !llvm.array<3 x i32>
    %69 = llvm.zext %68 : i32 to i64
    %70 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
    %71 = llvm.extractvalue %70[0] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
    %72 = llvm.extractvalue %71[1] : !llvm.array<3 x i32>
    %73 = llvm.zext %72 : i32 to i64
    %74 = llvm.mlir.constant(128 : index) : i64
    %75 = llvm.mul %69, %74  : i64
    %76 = llvm.mlir.constant(128 : index) : i64
    %77 = llvm.mul %73, %76  : i64
    llvm.br ^bb1(%75 : i64)
  ^bb1(%78: i64):  // 2 preds: ^bb0, ^bb10
    %79 = llvm.icmp "slt" %78, %2 : i64
    llvm.cond_br %79, ^bb2, ^bb11
  ^bb2:  // pred: ^bb1
    %80 = llvm.mlir.constant(128 : index) : i64
    %81 = llvm.mul %62, %80  : i64
    %82 = llvm.mlir.constant(128 : index) : i64
    %83 = llvm.mul %66, %82  : i64
    llvm.br ^bb3(%81 : i64)
  ^bb3(%84: i64):  // 2 preds: ^bb2, ^bb9
    %85 = llvm.icmp "slt" %84, %0 : i64
    llvm.cond_br %85, ^bb4, ^bb10
  ^bb4:  // pred: ^bb3
    %86 = llvm.mlir.constant(128 : index) : i64
    %87 = llvm.mlir.constant(-1 : index) : i64
    %88 = llvm.mul %78, %87  : i64
    %89 = llvm.mlir.constant(1 : index) : i64
    %90 = llvm.add %88, %89  : i64
    %91 = llvm.icmp "slt" %86, %90 : i64
    %92 = llvm.select %91, %86, %90 : i1, i64
    %93 = llvm.mlir.constant(128 : index) : i64
    %94 = llvm.mlir.constant(-1 : index) : i64
    %95 = llvm.mul %84, %94  : i64
    %96 = llvm.mlir.constant(10 : index) : i64
    %97 = llvm.add %95, %96  : i64
    %98 = llvm.icmp "slt" %93, %97 : i64
    %99 = llvm.select %98, %93, %97 : i1, i64
    %100 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %101 = llvm.extractvalue %43[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %102 = llvm.bitcast %101 : !llvm.ptr<f32> to !llvm.ptr<f32>
    %103 = llvm.insertvalue %102, %100[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %104 = llvm.extractvalue %43[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %105 = llvm.bitcast %104 : !llvm.ptr<f32> to !llvm.ptr<f32>
    %106 = llvm.insertvalue %105, %103[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %107 = llvm.extractvalue %43[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %108 = llvm.extractvalue %43[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %109 = llvm.extractvalue %43[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %110 = llvm.mul %78, %107  : i64
    %111 = llvm.add %109, %110  : i64
    %112 = llvm.mul %84, %108  : i64
    %113 = llvm.add %111, %112  : i64
    %114 = llvm.insertvalue %113, %106[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %115 = llvm.mlir.constant(1 : i64) : i64
    %116 = llvm.insertvalue %99, %114[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %117 = llvm.insertvalue %115, %116[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %118 = llvm.mlir.constant(10 : i64) : i64
    %119 = llvm.insertvalue %92, %117[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %120 = llvm.insertvalue %118, %119[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %121 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %122 = llvm.extractvalue %23[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %123 = llvm.bitcast %122 : !llvm.ptr<f32> to !llvm.ptr<f32>
    %124 = llvm.insertvalue %123, %121[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %125 = llvm.extractvalue %23[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %126 = llvm.bitcast %125 : !llvm.ptr<f32> to !llvm.ptr<f32>
    %127 = llvm.insertvalue %126, %124[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %128 = llvm.extractvalue %23[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %129 = llvm.extractvalue %23[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %130 = llvm.extractvalue %23[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %131 = llvm.mul %78, %128  : i64
    %132 = llvm.add %130, %131  : i64
    %133 = llvm.mul %84, %129  : i64
    %134 = llvm.add %132, %133  : i64
    %135 = llvm.insertvalue %134, %127[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %136 = llvm.mlir.constant(1 : i64) : i64
    %137 = llvm.insertvalue %99, %135[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %138 = llvm.insertvalue %136, %137[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %139 = llvm.mlir.constant(10 : i64) : i64
    %140 = llvm.insertvalue %92, %138[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %141 = llvm.insertvalue %139, %140[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %142 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
    %143 = llvm.extractvalue %59[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
    %144 = llvm.bitcast %143 : !llvm.ptr<f32> to !llvm.ptr<f32>
    %145 = llvm.insertvalue %144, %142[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
    %146 = llvm.extractvalue %59[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
    %147 = llvm.bitcast %146 : !llvm.ptr<f32> to !llvm.ptr<f32>
    %148 = llvm.insertvalue %147, %145[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
    %149 = llvm.extractvalue %59[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
    %150 = llvm.extractvalue %59[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
    %151 = llvm.mul %84, %149  : i64
    %152 = llvm.add %150, %151  : i64
    %153 = llvm.insertvalue %152, %148[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
    %154 = llvm.mlir.constant(1 : i64) : i64
    %155 = llvm.insertvalue %99, %153[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
    %156 = llvm.insertvalue %154, %155[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
    llvm.br ^bb5(%1 : i64)
  ^bb5(%157: i64):  // 2 preds: ^bb4, ^bb8
    %158 = llvm.icmp "slt" %157, %92 : i64
    llvm.cond_br %158, ^bb6(%1 : i64), ^bb9
  ^bb6(%159: i64):  // 2 preds: ^bb5, ^bb7
    %160 = llvm.icmp "slt" %159, %99 : i64
    llvm.cond_br %160, ^bb7, ^bb8
  ^bb7:  // pred: ^bb6
    %161 = llvm.extractvalue %120[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %162 = llvm.extractvalue %120[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %163 = llvm.mlir.constant(10 : index) : i64
    %164 = llvm.mul %157, %163  : i64
    %165 = llvm.add %162, %164  : i64
    %166 = llvm.add %165, %159  : i64
    %167 = llvm.getelementptr %161[%166] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %168 = llvm.load %167 : !llvm.ptr<f32>
    %169 = llvm.extractvalue %141[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %170 = llvm.extractvalue %141[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %171 = llvm.mlir.constant(10 : index) : i64
    %172 = llvm.mul %157, %171  : i64
    %173 = llvm.add %170, %172  : i64
    %174 = llvm.add %173, %159  : i64
    %175 = llvm.getelementptr %169[%174] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %176 = llvm.load %175 : !llvm.ptr<f32>
    %177 = llvm.fadd %168, %176  : f32
    %178 = llvm.extractvalue %156[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
    %179 = llvm.extractvalue %156[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
    %180 = llvm.add %179, %159  : i64
    %181 = llvm.getelementptr %178[%180] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    llvm.store %177, %181 : !llvm.ptr<f32>
    %182 = llvm.add %159, %2  : i64
    llvm.br ^bb6(%182 : i64)
  ^bb8:  // pred: ^bb6
    %183 = llvm.add %157, %2  : i64
    llvm.br ^bb5(%183 : i64)
  ^bb9:  // pred: ^bb5
    %184 = llvm.add %84, %83  : i64
    llvm.br ^bb3(%184 : i64)
  ^bb10:  // pred: ^bb3
    %185 = llvm.add %78, %77  : i64
    llvm.br ^bb1(%185 : i64)
  ^bb11:  // pred: ^bb1
    %186 = llvm.mlir.constant(0 : i32) : i32
    llvm.return %186 : i32
  }
}

// *** IR Dump After Canonicalizer ***
module  {
  llvm.mlir.global private constant @__constant_1x10xf32(opaque<"_", "0xDEADBEEF"> : tensor<1x10xf32>) : !llvm.array<1 x array<10 x f32>>
  llvm.func internal @predict_dispatch_3(%arg0: !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>, %arg1: !llvm.ptr<array<3 x i32>>) -> i32 {
    %0 = llvm.mlir.constant(10 : index) : i64
    %1 = llvm.mlir.constant(0 : index) : i64
    %2 = llvm.mlir.constant(1 : index) : i64
    %3 = llvm.mlir.constant(1 : index) : i64
    %4 = llvm.mlir.constant(10 : index) : i64
    %5 = llvm.mlir.constant(1 : index) : i64
    %6 = llvm.mlir.addressof @__constant_1x10xf32 : !llvm.ptr<array<1 x array<10 x f32>>>
    %7 = llvm.mlir.constant(0 : index) : i64
    %8 = llvm.getelementptr %6[%7, %7, %7] : (!llvm.ptr<array<1 x array<10 x f32>>>, i64, i64, i64) -> !llvm.ptr<f32>
    %9 = llvm.mlir.constant(3735928559 : index) : i64
    %10 = llvm.inttoptr %9 : i64 to !llvm.ptr<f32>
    %11 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %12 = llvm.insertvalue %10, %11[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %13 = llvm.insertvalue %8, %12[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %14 = llvm.mlir.constant(0 : index) : i64
    %15 = llvm.insertvalue %14, %13[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %16 = llvm.insertvalue %3, %15[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %17 = llvm.insertvalue %4, %16[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %18 = llvm.insertvalue %4, %17[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %19 = llvm.insertvalue %5, %18[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %20 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
    %21 = llvm.extractvalue %20[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
    %22 = llvm.mlir.constant(0 : index) : i64
    %23 = llvm.getelementptr %21[%22] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
    %24 = llvm.load %23 : !llvm.ptr<ptr<i8>>
    %25 = llvm.getelementptr %24[%1] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
    %26 = llvm.bitcast %25 : !llvm.ptr<i8> to !llvm.ptr<f32>
    %27 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %28 = llvm.insertvalue %26, %27[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %29 = llvm.insertvalue %26, %28[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %30 = llvm.mlir.constant(0 : index) : i64
    %31 = llvm.insertvalue %30, %29[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %32 = llvm.mlir.constant(1 : index) : i64
    %33 = llvm.insertvalue %32, %31[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %34 = llvm.mlir.constant(10 : index) : i64
    %35 = llvm.insertvalue %34, %33[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %36 = llvm.mlir.constant(10 : index) : i64
    %37 = llvm.insertvalue %36, %35[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %38 = llvm.mlir.constant(1 : index) : i64
    %39 = llvm.insertvalue %38, %37[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %40 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
    %41 = llvm.extractvalue %40[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
    %42 = llvm.mlir.constant(1 : index) : i64
    %43 = llvm.getelementptr %41[%42] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
    %44 = llvm.load %43 : !llvm.ptr<ptr<i8>>
    %45 = llvm.getelementptr %44[%1] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
    %46 = llvm.bitcast %45 : !llvm.ptr<i8> to !llvm.ptr<f32>
    %47 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
    %48 = llvm.insertvalue %46, %47[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
    %49 = llvm.insertvalue %46, %48[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
    %50 = llvm.mlir.constant(0 : index) : i64
    %51 = llvm.insertvalue %50, %49[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
    %52 = llvm.mlir.constant(10 : index) : i64
    %53 = llvm.insertvalue %52, %51[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
    %54 = llvm.mlir.constant(1 : index) : i64
    %55 = llvm.insertvalue %54, %53[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
    %56 = llvm.load %arg1 : !llvm.ptr<array<3 x i32>>
    %57 = llvm.extractvalue %56[0] : !llvm.array<3 x i32>
    %58 = llvm.zext %57 : i32 to i64
    %59 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
    %60 = llvm.extractvalue %59[0] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
    %61 = llvm.extractvalue %60[0] : !llvm.array<3 x i32>
    %62 = llvm.zext %61 : i32 to i64
    %63 = llvm.load %arg1 : !llvm.ptr<array<3 x i32>>
    %64 = llvm.extractvalue %63[1] : !llvm.array<3 x i32>
    %65 = llvm.zext %64 : i32 to i64
    %66 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
    %67 = llvm.extractvalue %66[0] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
    %68 = llvm.extractvalue %67[1] : !llvm.array<3 x i32>
    %69 = llvm.zext %68 : i32 to i64
    %70 = llvm.mlir.constant(128 : index) : i64
    %71 = llvm.mul %65, %70  : i64
    %72 = llvm.mlir.constant(128 : index) : i64
    %73 = llvm.mul %69, %72  : i64
    llvm.br ^bb1(%71 : i64)
  ^bb1(%74: i64):  // 2 preds: ^bb0, ^bb10
    %75 = llvm.icmp "slt" %74, %2 : i64
    llvm.cond_br %75, ^bb2, ^bb11
  ^bb2:  // pred: ^bb1
    %76 = llvm.mlir.constant(128 : index) : i64
    %77 = llvm.mul %58, %76  : i64
    %78 = llvm.mlir.constant(128 : index) : i64
    %79 = llvm.mul %62, %78  : i64
    llvm.br ^bb3(%77 : i64)
  ^bb3(%80: i64):  // 2 preds: ^bb2, ^bb9
    %81 = llvm.icmp "slt" %80, %0 : i64
    llvm.cond_br %81, ^bb4, ^bb10
  ^bb4:  // pred: ^bb3
    %82 = llvm.mlir.constant(128 : index) : i64
    %83 = llvm.mlir.constant(-1 : index) : i64
    %84 = llvm.mul %74, %83  : i64
    %85 = llvm.mlir.constant(1 : index) : i64
    %86 = llvm.add %84, %85  : i64
    %87 = llvm.icmp "slt" %82, %86 : i64
    %88 = llvm.select %87, %82, %86 : i1, i64
    %89 = llvm.mlir.constant(128 : index) : i64
    %90 = llvm.mlir.constant(-1 : index) : i64
    %91 = llvm.mul %80, %90  : i64
    %92 = llvm.mlir.constant(10 : index) : i64
    %93 = llvm.add %91, %92  : i64
    %94 = llvm.icmp "slt" %89, %93 : i64
    %95 = llvm.select %94, %89, %93 : i1, i64
    %96 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %97 = llvm.extractvalue %39[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %98 = llvm.bitcast %97 : !llvm.ptr<f32> to !llvm.ptr<f32>
    %99 = llvm.insertvalue %98, %96[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %100 = llvm.extractvalue %39[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %101 = llvm.bitcast %100 : !llvm.ptr<f32> to !llvm.ptr<f32>
    %102 = llvm.insertvalue %101, %99[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %103 = llvm.extractvalue %39[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %104 = llvm.extractvalue %39[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %105 = llvm.extractvalue %39[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %106 = llvm.mul %74, %103  : i64
    %107 = llvm.add %105, %106  : i64
    %108 = llvm.mul %80, %104  : i64
    %109 = llvm.add %107, %108  : i64
    %110 = llvm.insertvalue %109, %102[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %111 = llvm.mlir.constant(1 : i64) : i64
    %112 = llvm.insertvalue %95, %110[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %113 = llvm.insertvalue %111, %112[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %114 = llvm.mlir.constant(10 : i64) : i64
    %115 = llvm.insertvalue %88, %113[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %116 = llvm.insertvalue %114, %115[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %117 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %118 = llvm.extractvalue %19[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %119 = llvm.bitcast %118 : !llvm.ptr<f32> to !llvm.ptr<f32>
    %120 = llvm.insertvalue %119, %117[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %121 = llvm.extractvalue %19[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %122 = llvm.bitcast %121 : !llvm.ptr<f32> to !llvm.ptr<f32>
    %123 = llvm.insertvalue %122, %120[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %124 = llvm.extractvalue %19[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %125 = llvm.extractvalue %19[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %126 = llvm.extractvalue %19[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %127 = llvm.mul %74, %124  : i64
    %128 = llvm.add %126, %127  : i64
    %129 = llvm.mul %80, %125  : i64
    %130 = llvm.add %128, %129  : i64
    %131 = llvm.insertvalue %130, %123[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %132 = llvm.mlir.constant(1 : i64) : i64
    %133 = llvm.insertvalue %95, %131[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %134 = llvm.insertvalue %132, %133[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %135 = llvm.mlir.constant(10 : i64) : i64
    %136 = llvm.insertvalue %88, %134[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %137 = llvm.insertvalue %135, %136[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %138 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
    %139 = llvm.extractvalue %55[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
    %140 = llvm.bitcast %139 : !llvm.ptr<f32> to !llvm.ptr<f32>
    %141 = llvm.insertvalue %140, %138[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
    %142 = llvm.extractvalue %55[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
    %143 = llvm.bitcast %142 : !llvm.ptr<f32> to !llvm.ptr<f32>
    %144 = llvm.insertvalue %143, %141[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
    %145 = llvm.extractvalue %55[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
    %146 = llvm.extractvalue %55[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
    %147 = llvm.mul %80, %145  : i64
    %148 = llvm.add %146, %147  : i64
    %149 = llvm.insertvalue %148, %144[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
    %150 = llvm.mlir.constant(1 : i64) : i64
    %151 = llvm.insertvalue %95, %149[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
    %152 = llvm.insertvalue %150, %151[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
    llvm.br ^bb5(%1 : i64)
  ^bb5(%153: i64):  // 2 preds: ^bb4, ^bb8
    %154 = llvm.icmp "slt" %153, %88 : i64
    llvm.cond_br %154, ^bb6(%1 : i64), ^bb9
  ^bb6(%155: i64):  // 2 preds: ^bb5, ^bb7
    %156 = llvm.icmp "slt" %155, %95 : i64
    llvm.cond_br %156, ^bb7, ^bb8
  ^bb7:  // pred: ^bb6
    %157 = llvm.extractvalue %116[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %158 = llvm.extractvalue %116[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %159 = llvm.mlir.constant(10 : index) : i64
    %160 = llvm.mul %153, %159  : i64
    %161 = llvm.add %158, %160  : i64
    %162 = llvm.add %161, %155  : i64
    %163 = llvm.getelementptr %157[%162] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %164 = llvm.load %163 : !llvm.ptr<f32>
    %165 = llvm.extractvalue %137[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %166 = llvm.extractvalue %137[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %167 = llvm.mlir.constant(10 : index) : i64
    %168 = llvm.mul %153, %167  : i64
    %169 = llvm.add %166, %168  : i64
    %170 = llvm.add %169, %155  : i64
    %171 = llvm.getelementptr %165[%170] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %172 = llvm.load %171 : !llvm.ptr<f32>
    %173 = llvm.fadd %164, %172  : f32
    %174 = llvm.extractvalue %152[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
    %175 = llvm.extractvalue %152[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
    %176 = llvm.add %175, %155  : i64
    %177 = llvm.getelementptr %174[%176] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    llvm.store %173, %177 : !llvm.ptr<f32>
    %178 = llvm.add %155, %2  : i64
    llvm.br ^bb6(%178 : i64)
  ^bb8:  // pred: ^bb6
    %179 = llvm.add %153, %2  : i64
    llvm.br ^bb5(%179 : i64)
  ^bb9:  // pred: ^bb5
    %180 = llvm.add %80, %79  : i64
    llvm.br ^bb3(%180 : i64)
  ^bb10:  // pred: ^bb3
    %181 = llvm.add %74, %73  : i64
    llvm.br ^bb1(%181 : i64)
  ^bb11:  // pred: ^bb1
    %182 = llvm.mlir.constant(0 : i32) : i32
    llvm.return %182 : i32
  }
}

// *** IR Dump After CSE ***
module  {
  llvm.mlir.global private constant @__constant_1x10xf32(opaque<"_", "0xDEADBEEF"> : tensor<1x10xf32>) : !llvm.array<1 x array<10 x f32>>
  llvm.func internal @predict_dispatch_3(%arg0: !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>, %arg1: !llvm.ptr<array<3 x i32>>) -> i32 {
    %0 = llvm.mlir.constant(10 : index) : i64
    %1 = llvm.mlir.constant(0 : index) : i64
    %2 = llvm.mlir.constant(1 : index) : i64
    %3 = llvm.mlir.addressof @__constant_1x10xf32 : !llvm.ptr<array<1 x array<10 x f32>>>
    %4 = llvm.getelementptr %3[%1, %1, %1] : (!llvm.ptr<array<1 x array<10 x f32>>>, i64, i64, i64) -> !llvm.ptr<f32>
    %5 = llvm.mlir.constant(3735928559 : index) : i64
    %6 = llvm.inttoptr %5 : i64 to !llvm.ptr<f32>
    %7 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %8 = llvm.insertvalue %6, %7[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %9 = llvm.insertvalue %4, %8[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %10 = llvm.insertvalue %1, %9[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %11 = llvm.insertvalue %2, %10[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %12 = llvm.insertvalue %0, %11[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %13 = llvm.insertvalue %0, %12[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %14 = llvm.insertvalue %2, %13[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %15 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
    %16 = llvm.extractvalue %15[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
    %17 = llvm.getelementptr %16[%1] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
    %18 = llvm.load %17 : !llvm.ptr<ptr<i8>>
    %19 = llvm.getelementptr %18[%1] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
    %20 = llvm.bitcast %19 : !llvm.ptr<i8> to !llvm.ptr<f32>
    %21 = llvm.insertvalue %20, %7[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %22 = llvm.insertvalue %20, %21[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %23 = llvm.insertvalue %1, %22[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %24 = llvm.insertvalue %2, %23[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %25 = llvm.insertvalue %0, %24[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %26 = llvm.insertvalue %0, %25[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %27 = llvm.insertvalue %2, %26[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %28 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
    %29 = llvm.extractvalue %28[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
    %30 = llvm.getelementptr %29[%2] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
    %31 = llvm.load %30 : !llvm.ptr<ptr<i8>>
    %32 = llvm.getelementptr %31[%1] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
    %33 = llvm.bitcast %32 : !llvm.ptr<i8> to !llvm.ptr<f32>
    %34 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
    %35 = llvm.insertvalue %33, %34[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
    %36 = llvm.insertvalue %33, %35[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
    %37 = llvm.insertvalue %1, %36[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
    %38 = llvm.insertvalue %0, %37[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
    %39 = llvm.insertvalue %2, %38[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
    %40 = llvm.load %arg1 : !llvm.ptr<array<3 x i32>>
    %41 = llvm.extractvalue %40[0] : !llvm.array<3 x i32>
    %42 = llvm.zext %41 : i32 to i64
    %43 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
    %44 = llvm.extractvalue %43[0] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
    %45 = llvm.extractvalue %44[0] : !llvm.array<3 x i32>
    %46 = llvm.zext %45 : i32 to i64
    %47 = llvm.load %arg1 : !llvm.ptr<array<3 x i32>>
    %48 = llvm.extractvalue %47[1] : !llvm.array<3 x i32>
    %49 = llvm.zext %48 : i32 to i64
    %50 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
    %51 = llvm.extractvalue %50[0] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
    %52 = llvm.extractvalue %51[1] : !llvm.array<3 x i32>
    %53 = llvm.zext %52 : i32 to i64
    %54 = llvm.mlir.constant(128 : index) : i64
    %55 = llvm.mul %49, %54  : i64
    %56 = llvm.mul %53, %54  : i64
    llvm.br ^bb1(%55 : i64)
  ^bb1(%57: i64):  // 2 preds: ^bb0, ^bb10
    %58 = llvm.icmp "slt" %57, %2 : i64
    llvm.cond_br %58, ^bb2, ^bb11
  ^bb2:  // pred: ^bb1
    %59 = llvm.mul %42, %54  : i64
    %60 = llvm.mul %46, %54  : i64
    llvm.br ^bb3(%59 : i64)
  ^bb3(%61: i64):  // 2 preds: ^bb2, ^bb9
    %62 = llvm.icmp "slt" %61, %0 : i64
    llvm.cond_br %62, ^bb4, ^bb10
  ^bb4:  // pred: ^bb3
    %63 = llvm.mlir.constant(-1 : index) : i64
    %64 = llvm.mul %57, %63  : i64
    %65 = llvm.add %64, %2  : i64
    %66 = llvm.icmp "slt" %54, %65 : i64
    %67 = llvm.select %66, %54, %65 : i1, i64
    %68 = llvm.mul %61, %63  : i64
    %69 = llvm.add %68, %0  : i64
    %70 = llvm.icmp "slt" %54, %69 : i64
    %71 = llvm.select %70, %54, %69 : i1, i64
    %72 = llvm.extractvalue %27[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %73 = llvm.bitcast %72 : !llvm.ptr<f32> to !llvm.ptr<f32>
    %74 = llvm.insertvalue %73, %7[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %75 = llvm.extractvalue %27[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %76 = llvm.bitcast %75 : !llvm.ptr<f32> to !llvm.ptr<f32>
    %77 = llvm.insertvalue %76, %74[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %78 = llvm.extractvalue %27[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %79 = llvm.extractvalue %27[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %80 = llvm.extractvalue %27[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %81 = llvm.mul %57, %78  : i64
    %82 = llvm.add %80, %81  : i64
    %83 = llvm.mul %61, %79  : i64
    %84 = llvm.add %82, %83  : i64
    %85 = llvm.insertvalue %84, %77[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %86 = llvm.mlir.constant(1 : i64) : i64
    %87 = llvm.insertvalue %71, %85[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %88 = llvm.insertvalue %86, %87[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %89 = llvm.mlir.constant(10 : i64) : i64
    %90 = llvm.insertvalue %67, %88[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %91 = llvm.insertvalue %89, %90[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %92 = llvm.extractvalue %14[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %93 = llvm.bitcast %92 : !llvm.ptr<f32> to !llvm.ptr<f32>
    %94 = llvm.insertvalue %93, %7[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %95 = llvm.extractvalue %14[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %96 = llvm.bitcast %95 : !llvm.ptr<f32> to !llvm.ptr<f32>
    %97 = llvm.insertvalue %96, %94[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %98 = llvm.extractvalue %14[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %99 = llvm.extractvalue %14[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %100 = llvm.extractvalue %14[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %101 = llvm.mul %57, %98  : i64
    %102 = llvm.add %100, %101  : i64
    %103 = llvm.mul %61, %99  : i64
    %104 = llvm.add %102, %103  : i64
    %105 = llvm.insertvalue %104, %97[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %106 = llvm.insertvalue %71, %105[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %107 = llvm.insertvalue %86, %106[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %108 = llvm.insertvalue %67, %107[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %109 = llvm.insertvalue %89, %108[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %110 = llvm.extractvalue %39[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
    %111 = llvm.bitcast %110 : !llvm.ptr<f32> to !llvm.ptr<f32>
    %112 = llvm.insertvalue %111, %34[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
    %113 = llvm.extractvalue %39[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
    %114 = llvm.bitcast %113 : !llvm.ptr<f32> to !llvm.ptr<f32>
    %115 = llvm.insertvalue %114, %112[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
    %116 = llvm.extractvalue %39[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
    %117 = llvm.extractvalue %39[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
    %118 = llvm.mul %61, %116  : i64
    %119 = llvm.add %117, %118  : i64
    %120 = llvm.insertvalue %119, %115[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
    %121 = llvm.insertvalue %71, %120[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
    %122 = llvm.insertvalue %86, %121[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
    llvm.br ^bb5(%1 : i64)
  ^bb5(%123: i64):  // 2 preds: ^bb4, ^bb8
    %124 = llvm.icmp "slt" %123, %67 : i64
    llvm.cond_br %124, ^bb6(%1 : i64), ^bb9
  ^bb6(%125: i64):  // 2 preds: ^bb5, ^bb7
    %126 = llvm.icmp "slt" %125, %71 : i64
    llvm.cond_br %126, ^bb7, ^bb8
  ^bb7:  // pred: ^bb6
    %127 = llvm.extractvalue %91[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %128 = llvm.extractvalue %91[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %129 = llvm.mul %123, %0  : i64
    %130 = llvm.add %128, %129  : i64
    %131 = llvm.add %130, %125  : i64
    %132 = llvm.getelementptr %127[%131] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %133 = llvm.load %132 : !llvm.ptr<f32>
    %134 = llvm.extractvalue %109[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %135 = llvm.extractvalue %109[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %136 = llvm.add %135, %129  : i64
    %137 = llvm.add %136, %125  : i64
    %138 = llvm.getelementptr %134[%137] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %139 = llvm.load %138 : !llvm.ptr<f32>
    %140 = llvm.fadd %133, %139  : f32
    %141 = llvm.extractvalue %122[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
    %142 = llvm.extractvalue %122[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
    %143 = llvm.add %142, %125  : i64
    %144 = llvm.getelementptr %141[%143] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    llvm.store %140, %144 : !llvm.ptr<f32>
    %145 = llvm.add %125, %2  : i64
    llvm.br ^bb6(%145 : i64)
  ^bb8:  // pred: ^bb6
    %146 = llvm.add %123, %2  : i64
    llvm.br ^bb5(%146 : i64)
  ^bb9:  // pred: ^bb5
    %147 = llvm.add %61, %60  : i64
    llvm.br ^bb3(%147 : i64)
  ^bb10:  // pred: ^bb3
    %148 = llvm.add %57, %56  : i64
    llvm.br ^bb1(%148 : i64)
  ^bb11:  // pred: ^bb1
    %149 = llvm.mlir.constant(0 : i32) : i32
    llvm.return %149 : i32
  }
}

// *** IR Dump After mlir::iree_compiler::`anonymous-namespace'::LowerExecutableTargetPass ***
hal.executable.target @llvm_aot, filter="dylib*" {
  hal.executable.entry_point @predict_dispatch_3 attributes {interface = @io, ordinal = 0 : index} {
  ^bb0(%arg0: index, %arg1: index, %arg2: index):  // no predecessors
    %c1 = constant 1 : index
    %0 = affine.apply affine_map<()[s0] -> (s0 ceildiv 128)>()[%arg0]
    %1 = affine.apply affine_map<()[s0] -> (s0 ceildiv 128)>()[%arg1]
    hal.return %0, %1, %c1 : index, index, index
  }
  module  {
    llvm.mlir.global private constant @__constant_1x10xf32(opaque<"_", "0xDEADBEEF"> : tensor<1x10xf32>) : !llvm.array<1 x array<10 x f32>>
    llvm.func internal @predict_dispatch_3(%arg0: !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>, %arg1: !llvm.ptr<array<3 x i32>>) -> i32 {
      %0 = llvm.mlir.constant(10 : index) : i64
      %1 = llvm.mlir.constant(0 : index) : i64
      %2 = llvm.mlir.constant(1 : index) : i64
      %3 = llvm.mlir.addressof @__constant_1x10xf32 : !llvm.ptr<array<1 x array<10 x f32>>>
      %4 = llvm.getelementptr %3[%1, %1, %1] : (!llvm.ptr<array<1 x array<10 x f32>>>, i64, i64, i64) -> !llvm.ptr<f32>
      %5 = llvm.mlir.constant(3735928559 : index) : i64
      %6 = llvm.inttoptr %5 : i64 to !llvm.ptr<f32>
      %7 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %8 = llvm.insertvalue %6, %7[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %9 = llvm.insertvalue %4, %8[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %10 = llvm.insertvalue %1, %9[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %11 = llvm.insertvalue %2, %10[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %12 = llvm.insertvalue %0, %11[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %13 = llvm.insertvalue %0, %12[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %14 = llvm.insertvalue %2, %13[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %15 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
      %16 = llvm.extractvalue %15[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
      %17 = llvm.getelementptr %16[%1] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
      %18 = llvm.load %17 : !llvm.ptr<ptr<i8>>
      %19 = llvm.getelementptr %18[%1] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
      %20 = llvm.bitcast %19 : !llvm.ptr<i8> to !llvm.ptr<f32>
      %21 = llvm.insertvalue %20, %7[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %22 = llvm.insertvalue %20, %21[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %23 = llvm.insertvalue %1, %22[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %24 = llvm.insertvalue %2, %23[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %25 = llvm.insertvalue %0, %24[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %26 = llvm.insertvalue %0, %25[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %27 = llvm.insertvalue %2, %26[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %28 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
      %29 = llvm.extractvalue %28[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
      %30 = llvm.getelementptr %29[%2] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
      %31 = llvm.load %30 : !llvm.ptr<ptr<i8>>
      %32 = llvm.getelementptr %31[%1] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
      %33 = llvm.bitcast %32 : !llvm.ptr<i8> to !llvm.ptr<f32>
      %34 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
      %35 = llvm.insertvalue %33, %34[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
      %36 = llvm.insertvalue %33, %35[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
      %37 = llvm.insertvalue %1, %36[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
      %38 = llvm.insertvalue %0, %37[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
      %39 = llvm.insertvalue %2, %38[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
      %40 = llvm.load %arg1 : !llvm.ptr<array<3 x i32>>
      %41 = llvm.extractvalue %40[0] : !llvm.array<3 x i32>
      %42 = llvm.zext %41 : i32 to i64
      %43 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
      %44 = llvm.extractvalue %43[0] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
      %45 = llvm.extractvalue %44[0] : !llvm.array<3 x i32>
      %46 = llvm.zext %45 : i32 to i64
      %47 = llvm.load %arg1 : !llvm.ptr<array<3 x i32>>
      %48 = llvm.extractvalue %47[1] : !llvm.array<3 x i32>
      %49 = llvm.zext %48 : i32 to i64
      %50 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
      %51 = llvm.extractvalue %50[0] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
      %52 = llvm.extractvalue %51[1] : !llvm.array<3 x i32>
      %53 = llvm.zext %52 : i32 to i64
      %54 = llvm.mlir.constant(128 : index) : i64
      %55 = llvm.mul %49, %54  : i64
      %56 = llvm.mul %53, %54  : i64
      llvm.br ^bb1(%55 : i64)
    ^bb1(%57: i64):  // 2 preds: ^bb0, ^bb10
      %58 = llvm.icmp "slt" %57, %2 : i64
      llvm.cond_br %58, ^bb2, ^bb11
    ^bb2:  // pred: ^bb1
      %59 = llvm.mul %42, %54  : i64
      %60 = llvm.mul %46, %54  : i64
      llvm.br ^bb3(%59 : i64)
    ^bb3(%61: i64):  // 2 preds: ^bb2, ^bb9
      %62 = llvm.icmp "slt" %61, %0 : i64
      llvm.cond_br %62, ^bb4, ^bb10
    ^bb4:  // pred: ^bb3
      %63 = llvm.mlir.constant(-1 : index) : i64
      %64 = llvm.mul %57, %63  : i64
      %65 = llvm.add %64, %2  : i64
      %66 = llvm.icmp "slt" %54, %65 : i64
      %67 = llvm.select %66, %54, %65 : i1, i64
      %68 = llvm.mul %61, %63  : i64
      %69 = llvm.add %68, %0  : i64
      %70 = llvm.icmp "slt" %54, %69 : i64
      %71 = llvm.select %70, %54, %69 : i1, i64
      %72 = llvm.extractvalue %27[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %73 = llvm.bitcast %72 : !llvm.ptr<f32> to !llvm.ptr<f32>
      %74 = llvm.insertvalue %73, %7[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %75 = llvm.extractvalue %27[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %76 = llvm.bitcast %75 : !llvm.ptr<f32> to !llvm.ptr<f32>
      %77 = llvm.insertvalue %76, %74[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %78 = llvm.extractvalue %27[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %79 = llvm.extractvalue %27[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %80 = llvm.extractvalue %27[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %81 = llvm.mul %57, %78  : i64
      %82 = llvm.add %80, %81  : i64
      %83 = llvm.mul %61, %79  : i64
      %84 = llvm.add %82, %83  : i64
      %85 = llvm.insertvalue %84, %77[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %86 = llvm.mlir.constant(1 : i64) : i64
      %87 = llvm.insertvalue %71, %85[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %88 = llvm.insertvalue %86, %87[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %89 = llvm.mlir.constant(10 : i64) : i64
      %90 = llvm.insertvalue %67, %88[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %91 = llvm.insertvalue %89, %90[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %92 = llvm.extractvalue %14[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %93 = llvm.bitcast %92 : !llvm.ptr<f32> to !llvm.ptr<f32>
      %94 = llvm.insertvalue %93, %7[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %95 = llvm.extractvalue %14[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %96 = llvm.bitcast %95 : !llvm.ptr<f32> to !llvm.ptr<f32>
      %97 = llvm.insertvalue %96, %94[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %98 = llvm.extractvalue %14[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %99 = llvm.extractvalue %14[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %100 = llvm.extractvalue %14[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %101 = llvm.mul %57, %98  : i64
      %102 = llvm.add %100, %101  : i64
      %103 = llvm.mul %61, %99  : i64
      %104 = llvm.add %102, %103  : i64
      %105 = llvm.insertvalue %104, %97[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %106 = llvm.insertvalue %71, %105[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %107 = llvm.insertvalue %86, %106[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %108 = llvm.insertvalue %67, %107[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %109 = llvm.insertvalue %89, %108[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %110 = llvm.extractvalue %39[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
      %111 = llvm.bitcast %110 : !llvm.ptr<f32> to !llvm.ptr<f32>
      %112 = llvm.insertvalue %111, %34[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
      %113 = llvm.extractvalue %39[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
      %114 = llvm.bitcast %113 : !llvm.ptr<f32> to !llvm.ptr<f32>
      %115 = llvm.insertvalue %114, %112[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
      %116 = llvm.extractvalue %39[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
      %117 = llvm.extractvalue %39[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
      %118 = llvm.mul %61, %116  : i64
      %119 = llvm.add %117, %118  : i64
      %120 = llvm.insertvalue %119, %115[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
      %121 = llvm.insertvalue %71, %120[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
      %122 = llvm.insertvalue %86, %121[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
      llvm.br ^bb5(%1 : i64)
    ^bb5(%123: i64):  // 2 preds: ^bb4, ^bb8
      %124 = llvm.icmp "slt" %123, %67 : i64
      llvm.cond_br %124, ^bb6(%1 : i64), ^bb9
    ^bb6(%125: i64):  // 2 preds: ^bb5, ^bb7
      %126 = llvm.icmp "slt" %125, %71 : i64
      llvm.cond_br %126, ^bb7, ^bb8
    ^bb7:  // pred: ^bb6
      %127 = llvm.extractvalue %91[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %128 = llvm.extractvalue %91[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %129 = llvm.mul %123, %0  : i64
      %130 = llvm.add %128, %129  : i64
      %131 = llvm.add %130, %125  : i64
      %132 = llvm.getelementptr %127[%131] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
      %133 = llvm.load %132 : !llvm.ptr<f32>
      %134 = llvm.extractvalue %109[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %135 = llvm.extractvalue %109[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %136 = llvm.add %135, %129  : i64
      %137 = llvm.add %136, %125  : i64
      %138 = llvm.getelementptr %134[%137] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
      %139 = llvm.load %138 : !llvm.ptr<f32>
      %140 = llvm.fadd %133, %139  : f32
      %141 = llvm.extractvalue %122[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
      %142 = llvm.extractvalue %122[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
      %143 = llvm.add %142, %125  : i64
      %144 = llvm.getelementptr %141[%143] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
      llvm.store %140, %144 : !llvm.ptr<f32>
      %145 = llvm.add %125, %2  : i64
      llvm.br ^bb6(%145 : i64)
    ^bb8:  // pred: ^bb6
      %146 = llvm.add %123, %2  : i64
      llvm.br ^bb5(%146 : i64)
    ^bb9:  // pred: ^bb5
      %147 = llvm.add %61, %60  : i64
      llvm.br ^bb3(%147 : i64)
    ^bb10:  // pred: ^bb3
      %148 = llvm.add %57, %56  : i64
      llvm.br ^bb1(%148 : i64)
    ^bb11:  // pred: ^bb1
      %149 = llvm.mlir.constant(0 : i32) : i32
      llvm.return %149 : i32
    }
  }
}

// *** IR Dump After mlir::iree_compiler::IREE::HAL::TranslateExecutablesPass ***
hal.executable.target @llvm_aot, filter="dylib*" {
  hal.executable.entry_point @predict_dispatch_3 attributes {interface = @io, ordinal = 0 : index} {
  ^bb0(%arg0: index, %arg1: index, %arg2: index):  // no predecessors
    %c1 = constant 1 : index
    %0 = affine.apply affine_map<()[s0] -> (s0 ceildiv 128)>()[%arg0]
    %1 = affine.apply affine_map<()[s0] -> (s0 ceildiv 128)>()[%arg1]
    hal.return %0, %1, %c1 : index, index, index
  }
  module  {
    llvm.mlir.global private constant @__constant_1x10xf32(opaque<"_", "0xDEADBEEF"> : tensor<1x10xf32>) : !llvm.array<1 x array<10 x f32>>
    llvm.func internal @predict_dispatch_3(%arg0: !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>, %arg1: !llvm.ptr<array<3 x i32>>) -> i32 {
      %0 = llvm.mlir.constant(10 : index) : i64
      %1 = llvm.mlir.constant(0 : index) : i64
      %2 = llvm.mlir.constant(1 : index) : i64
      %3 = llvm.mlir.addressof @__constant_1x10xf32 : !llvm.ptr<array<1 x array<10 x f32>>>
      %4 = llvm.getelementptr %3[%1, %1, %1] : (!llvm.ptr<array<1 x array<10 x f32>>>, i64, i64, i64) -> !llvm.ptr<f32>
      %5 = llvm.mlir.constant(3735928559 : index) : i64
      %6 = llvm.inttoptr %5 : i64 to !llvm.ptr<f32>
      %7 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %8 = llvm.insertvalue %6, %7[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %9 = llvm.insertvalue %4, %8[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %10 = llvm.insertvalue %1, %9[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %11 = llvm.insertvalue %2, %10[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %12 = llvm.insertvalue %0, %11[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %13 = llvm.insertvalue %0, %12[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %14 = llvm.insertvalue %2, %13[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %15 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
      %16 = llvm.extractvalue %15[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
      %17 = llvm.getelementptr %16[%1] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
      %18 = llvm.load %17 : !llvm.ptr<ptr<i8>>
      %19 = llvm.getelementptr %18[%1] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
      %20 = llvm.bitcast %19 : !llvm.ptr<i8> to !llvm.ptr<f32>
      %21 = llvm.insertvalue %20, %7[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %22 = llvm.insertvalue %20, %21[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %23 = llvm.insertvalue %1, %22[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %24 = llvm.insertvalue %2, %23[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %25 = llvm.insertvalue %0, %24[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %26 = llvm.insertvalue %0, %25[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %27 = llvm.insertvalue %2, %26[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %28 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
      %29 = llvm.extractvalue %28[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
      %30 = llvm.getelementptr %29[%2] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
      %31 = llvm.load %30 : !llvm.ptr<ptr<i8>>
      %32 = llvm.getelementptr %31[%1] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
      %33 = llvm.bitcast %32 : !llvm.ptr<i8> to !llvm.ptr<f32>
      %34 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
      %35 = llvm.insertvalue %33, %34[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
      %36 = llvm.insertvalue %33, %35[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
      %37 = llvm.insertvalue %1, %36[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
      %38 = llvm.insertvalue %0, %37[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
      %39 = llvm.insertvalue %2, %38[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
      %40 = llvm.load %arg1 : !llvm.ptr<array<3 x i32>>
      %41 = llvm.extractvalue %40[0] : !llvm.array<3 x i32>
      %42 = llvm.zext %41 : i32 to i64
      %43 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
      %44 = llvm.extractvalue %43[0] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
      %45 = llvm.extractvalue %44[0] : !llvm.array<3 x i32>
      %46 = llvm.zext %45 : i32 to i64
      %47 = llvm.load %arg1 : !llvm.ptr<array<3 x i32>>
      %48 = llvm.extractvalue %47[1] : !llvm.array<3 x i32>
      %49 = llvm.zext %48 : i32 to i64
      %50 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
      %51 = llvm.extractvalue %50[0] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
      %52 = llvm.extractvalue %51[1] : !llvm.array<3 x i32>
      %53 = llvm.zext %52 : i32 to i64
      %54 = llvm.mlir.constant(128 : index) : i64
      %55 = llvm.mul %49, %54  : i64
      %56 = llvm.mul %53, %54  : i64
      llvm.br ^bb1(%55 : i64)
    ^bb1(%57: i64):  // 2 preds: ^bb0, ^bb10
      %58 = llvm.icmp "slt" %57, %2 : i64
      llvm.cond_br %58, ^bb2, ^bb11
    ^bb2:  // pred: ^bb1
      %59 = llvm.mul %42, %54  : i64
      %60 = llvm.mul %46, %54  : i64
      llvm.br ^bb3(%59 : i64)
    ^bb3(%61: i64):  // 2 preds: ^bb2, ^bb9
      %62 = llvm.icmp "slt" %61, %0 : i64
      llvm.cond_br %62, ^bb4, ^bb10
    ^bb4:  // pred: ^bb3
      %63 = llvm.mlir.constant(-1 : index) : i64
      %64 = llvm.mul %57, %63  : i64
      %65 = llvm.add %64, %2  : i64
      %66 = llvm.icmp "slt" %54, %65 : i64
      %67 = llvm.select %66, %54, %65 : i1, i64
      %68 = llvm.mul %61, %63  : i64
      %69 = llvm.add %68, %0  : i64
      %70 = llvm.icmp "slt" %54, %69 : i64
      %71 = llvm.select %70, %54, %69 : i1, i64
      %72 = llvm.extractvalue %27[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %73 = llvm.bitcast %72 : !llvm.ptr<f32> to !llvm.ptr<f32>
      %74 = llvm.insertvalue %73, %7[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %75 = llvm.extractvalue %27[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %76 = llvm.bitcast %75 : !llvm.ptr<f32> to !llvm.ptr<f32>
      %77 = llvm.insertvalue %76, %74[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %78 = llvm.extractvalue %27[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %79 = llvm.extractvalue %27[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %80 = llvm.extractvalue %27[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %81 = llvm.mul %57, %78  : i64
      %82 = llvm.add %80, %81  : i64
      %83 = llvm.mul %61, %79  : i64
      %84 = llvm.add %82, %83  : i64
      %85 = llvm.insertvalue %84, %77[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %86 = llvm.mlir.constant(1 : i64) : i64
      %87 = llvm.insertvalue %71, %85[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %88 = llvm.insertvalue %86, %87[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %89 = llvm.mlir.constant(10 : i64) : i64
      %90 = llvm.insertvalue %67, %88[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %91 = llvm.insertvalue %89, %90[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %92 = llvm.extractvalue %14[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %93 = llvm.bitcast %92 : !llvm.ptr<f32> to !llvm.ptr<f32>
      %94 = llvm.insertvalue %93, %7[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %95 = llvm.extractvalue %14[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %96 = llvm.bitcast %95 : !llvm.ptr<f32> to !llvm.ptr<f32>
      %97 = llvm.insertvalue %96, %94[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %98 = llvm.extractvalue %14[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %99 = llvm.extractvalue %14[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %100 = llvm.extractvalue %14[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %101 = llvm.mul %57, %98  : i64
      %102 = llvm.add %100, %101  : i64
      %103 = llvm.mul %61, %99  : i64
      %104 = llvm.add %102, %103  : i64
      %105 = llvm.insertvalue %104, %97[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %106 = llvm.insertvalue %71, %105[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %107 = llvm.insertvalue %86, %106[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %108 = llvm.insertvalue %67, %107[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %109 = llvm.insertvalue %89, %108[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %110 = llvm.extractvalue %39[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
      %111 = llvm.bitcast %110 : !llvm.ptr<f32> to !llvm.ptr<f32>
      %112 = llvm.insertvalue %111, %34[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
      %113 = llvm.extractvalue %39[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
      %114 = llvm.bitcast %113 : !llvm.ptr<f32> to !llvm.ptr<f32>
      %115 = llvm.insertvalue %114, %112[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
      %116 = llvm.extractvalue %39[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
      %117 = llvm.extractvalue %39[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
      %118 = llvm.mul %61, %116  : i64
      %119 = llvm.add %117, %118  : i64
      %120 = llvm.insertvalue %119, %115[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
      %121 = llvm.insertvalue %71, %120[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
      %122 = llvm.insertvalue %86, %121[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
      llvm.br ^bb5(%1 : i64)
    ^bb5(%123: i64):  // 2 preds: ^bb4, ^bb8
      %124 = llvm.icmp "slt" %123, %67 : i64
      llvm.cond_br %124, ^bb6(%1 : i64), ^bb9
    ^bb6(%125: i64):  // 2 preds: ^bb5, ^bb7
      %126 = llvm.icmp "slt" %125, %71 : i64
      llvm.cond_br %126, ^bb7, ^bb8
    ^bb7:  // pred: ^bb6
      %127 = llvm.extractvalue %91[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %128 = llvm.extractvalue %91[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %129 = llvm.mul %123, %0  : i64
      %130 = llvm.add %128, %129  : i64
      %131 = llvm.add %130, %125  : i64
      %132 = llvm.getelementptr %127[%131] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
      %133 = llvm.load %132 : !llvm.ptr<f32>
      %134 = llvm.extractvalue %109[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %135 = llvm.extractvalue %109[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %136 = llvm.add %135, %129  : i64
      %137 = llvm.add %136, %125  : i64
      %138 = llvm.getelementptr %134[%137] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
      %139 = llvm.load %138 : !llvm.ptr<f32>
      %140 = llvm.fadd %133, %139  : f32
      %141 = llvm.extractvalue %122[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
      %142 = llvm.extractvalue %122[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
      %143 = llvm.add %142, %125  : i64
      %144 = llvm.getelementptr %141[%143] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
      llvm.store %140, %144 : !llvm.ptr<f32>
      %145 = llvm.add %125, %2  : i64
      llvm.br ^bb6(%145 : i64)
    ^bb8:  // pred: ^bb6
      %146 = llvm.add %123, %2  : i64
      llvm.br ^bb5(%146 : i64)
    ^bb9:  // pred: ^bb5
      %147 = llvm.add %61, %60  : i64
      llvm.br ^bb3(%147 : i64)
    ^bb10:  // pred: ^bb3
      %148 = llvm.add %57, %56  : i64
      llvm.br ^bb1(%148 : i64)
    ^bb11:  // pred: ^bb1
      %149 = llvm.mlir.constant(0 : i32) : i32
      llvm.return %149 : i32
    }
  }
}

// *** IR Dump After mlir::iree_compiler::IREE::HAL::PropagateConstantWorkgroupInfoPass ***
hal.executable.target @llvm_aot, filter="dylib*" {
  hal.executable.entry_point @predict_dispatch_4 attributes {interface = @io, ordinal = 0 : index}
  module  {
    func @predict_dispatch_4() {
      %c0 = constant 0 : index
      %cst = constant 0x7FC00000 : f32
      %cst_0 = constant 0xFF800000 : f32
      %0 = hal.interface.binding.subspan @io::@s0b0_ro_external[%c0] : !flow.dispatch.tensor<readonly:10xf32>
      %1 = hal.interface.binding.subspan @io::@s0b1_xw_external[%c0] : !flow.dispatch.tensor<writeonly:f32>
      %2 = flow.dispatch.tensor.load %0, offsets = [], sizes = [], strides = [] : !flow.dispatch.tensor<readonly:10xf32> -> tensor<10xf32>
      %3 = linalg.init_tensor [] : tensor<f32>
      %4 = linalg.fill(%3, %cst_0) : tensor<f32>, f32 -> tensor<f32> 
      %5 = linalg.generic {indexing_maps = [affine_map<(d0) -> (d0)>, affine_map<(d0) -> ()>], iterator_types = ["reduction"]} ins(%2 : tensor<10xf32>) outs(%4 : tensor<f32>) {
      ^bb0(%arg0: f32, %arg1: f32):  // no predecessors
        %6 = cmpf ogt, %arg0, %arg1 : f32
        %7 = select %6, %arg0, %arg1 : f32
        %8 = cmpf uno, %arg0, %arg1 : f32
        %9 = select %8, %cst, %7 : f32
        linalg.yield %9 : f32
      } -> tensor<f32>
      flow.dispatch.tensor.store %5, %1, offsets = [], sizes = [], strides = [] : tensor<f32> -> !flow.dispatch.tensor<writeonly:f32>
      return
    }
    hal.interface @io attributes {sym_visibility = "private"} {
      hal.interface.binding @s0b0_ro_external, set=0, binding=0, type="StorageBuffer", access="Read"
      hal.interface.binding @s0b1_xw_external, set=0, binding=1, type="StorageBuffer", access="Write|Discard"
    }
  }
}

// *** IR Dump After mlir::iree_compiler::`anonymous-namespace'::SetNumWorkgroupsPass ***
hal.executable.target @llvm_aot, filter="dylib*" {
  hal.executable.entry_point @predict_dispatch_4 attributes {interface = @io, ordinal = 0 : index} {
  ^bb0(%arg0: index, %arg1: index, %arg2: index):  // no predecessors
    %c1 = constant 1 : index
    hal.return %c1, %c1, %c1 : index, index, index
  }
  module  {
    func @predict_dispatch_4() {
      %c0 = constant 0 : index
      %cst = constant 0x7FC00000 : f32
      %cst_0 = constant 0xFF800000 : f32
      %0 = hal.interface.binding.subspan @io::@s0b0_ro_external[%c0] : !flow.dispatch.tensor<readonly:10xf32>
      %1 = hal.interface.binding.subspan @io::@s0b1_xw_external[%c0] : !flow.dispatch.tensor<writeonly:f32>
      %2 = flow.dispatch.tensor.load %0, offsets = [], sizes = [], strides = [] : !flow.dispatch.tensor<readonly:10xf32> -> tensor<10xf32>
      %3 = linalg.init_tensor [] : tensor<f32>
      %4 = linalg.fill(%3, %cst_0) : tensor<f32>, f32 -> tensor<f32> 
      %5 = linalg.generic {indexing_maps = [affine_map<(d0) -> (d0)>, affine_map<(d0) -> ()>], iterator_types = ["reduction"]} ins(%2 : tensor<10xf32>) outs(%4 : tensor<f32>) {
      ^bb0(%arg0: f32, %arg1: f32):  // no predecessors
        %6 = cmpf ogt, %arg0, %arg1 : f32
        %7 = select %6, %arg0, %arg1 : f32
        %8 = cmpf uno, %arg0, %arg1 : f32
        %9 = select %8, %cst, %7 : f32
        linalg.yield %9 : f32
      } -> tensor<f32>
      flow.dispatch.tensor.store %5, %1, offsets = [], sizes = [], strides = [] : tensor<f32> -> !flow.dispatch.tensor<writeonly:f32>
      return
    }
    hal.interface @io attributes {sym_visibility = "private"} {
      hal.interface.binding @s0b0_ro_external, set=0, binding=0, type="StorageBuffer", access="Read"
      hal.interface.binding @s0b1_xw_external, set=0, binding=1, type="StorageBuffer", access="Write|Discard"
    }
  }
}

// *** IR Dump After Canonicalizer ***
module  {
  func @predict_dispatch_4() {
    %c0 = constant 0 : index
    %cst = constant 0x7FC00000 : f32
    %cst_0 = constant 0xFF800000 : f32
    %0 = hal.interface.binding.subspan @io::@s0b0_ro_external[%c0] : !flow.dispatch.tensor<readonly:10xf32>
    %1 = hal.interface.binding.subspan @io::@s0b1_xw_external[%c0] : !flow.dispatch.tensor<writeonly:f32>
    %2 = flow.dispatch.tensor.load %0, offsets = [], sizes = [], strides = [] : !flow.dispatch.tensor<readonly:10xf32> -> tensor<10xf32>
    %3 = linalg.init_tensor [] : tensor<f32>
    %4 = linalg.fill(%3, %cst_0) : tensor<f32>, f32 -> tensor<f32> 
    %5 = linalg.generic {indexing_maps = [affine_map<(d0) -> (d0)>, affine_map<(d0) -> ()>], iterator_types = ["reduction"]} ins(%2 : tensor<10xf32>) outs(%4 : tensor<f32>) {
    ^bb0(%arg0: f32, %arg1: f32):  // no predecessors
      %6 = cmpf ogt, %arg0, %arg1 : f32
      %7 = select %6, %arg0, %arg1 : f32
      %8 = cmpf uno, %arg0, %arg1 : f32
      %9 = select %8, %cst, %7 : f32
      linalg.yield %9 : f32
    } -> tensor<f32>
    flow.dispatch.tensor.store %5, %1, offsets = [], sizes = [], strides = [] : tensor<f32> -> !flow.dispatch.tensor<writeonly:f32>
    return
  }
  hal.interface @io attributes {sym_visibility = "private"} {
    hal.interface.binding @s0b0_ro_external, set=0, binding=0, type="StorageBuffer", access="Read"
    hal.interface.binding @s0b1_xw_external, set=0, binding=1, type="StorageBuffer", access="Write|Discard"
  }
}

// *** IR Dump After mlir::iree_compiler::`anonymous-namespace'::LinalgBufferizePass ***
func @predict_dispatch_4() {
  %c0 = constant 0 : index
  %cst = constant 0x7FC00000 : f32
  %cst_0 = constant 0xFF800000 : f32
  %0 = hal.interface.binding.subspan @io::@s0b0_ro_external[%c0] : memref<10xf32>
  %1 = hal.interface.binding.subspan @io::@s0b0_ro_external[%c0] : !flow.dispatch.tensor<readonly:10xf32>
  %2 = hal.interface.binding.subspan @io::@s0b1_xw_external[%c0] : memref<f32>
  %3 = hal.interface.binding.subspan @io::@s0b1_xw_external[%c0] : !flow.dispatch.tensor<writeonly:f32>
  %4 = flow.dispatch.tensor.load %1, offsets = [], sizes = [], strides = [] : !flow.dispatch.tensor<readonly:10xf32> -> tensor<10xf32>
  %5 = linalg.init_tensor [] : tensor<f32>
  linalg.fill(%2, %cst_0) : memref<f32>, f32 
  %6 = linalg.fill(%5, %cst_0) : tensor<f32>, f32 -> tensor<f32> 
  linalg.generic {indexing_maps = [affine_map<(d0) -> (d0)>, affine_map<(d0) -> ()>], iterator_types = ["reduction"]} ins(%0 : memref<10xf32>) outs(%2 : memref<f32>) {
  ^bb0(%arg0: f32, %arg1: f32):  // no predecessors
    %8 = cmpf ogt, %arg0, %arg1 : f32
    %9 = select %8, %arg0, %arg1 : f32
    %10 = cmpf uno, %arg0, %arg1 : f32
    %11 = select %10, %cst, %9 : f32
    linalg.yield %11 : f32
  }
  %7 = linalg.generic {indexing_maps = [affine_map<(d0) -> (d0)>, affine_map<(d0) -> ()>], iterator_types = ["reduction"]} ins(%4 : tensor<10xf32>) outs(%6 : tensor<f32>) {
  ^bb0(%arg0: f32, %arg1: f32):  // no predecessors
    %8 = cmpf ogt, %arg0, %arg1 : f32
    %9 = select %8, %arg0, %arg1 : f32
    %10 = cmpf uno, %arg0, %arg1 : f32
    %11 = select %10, %cst, %9 : f32
    linalg.yield %11 : f32
  } -> tensor<f32>
  return
}

// *** IR Dump After Canonicalizer ***
func @predict_dispatch_4() {
  %c0 = constant 0 : index
  %cst = constant 0x7FC00000 : f32
  %cst_0 = constant 0xFF800000 : f32
  %0 = hal.interface.binding.subspan @io::@s0b0_ro_external[%c0] : memref<10xf32>
  %1 = hal.interface.binding.subspan @io::@s0b0_ro_external[%c0] : !flow.dispatch.tensor<readonly:10xf32>
  %2 = hal.interface.binding.subspan @io::@s0b1_xw_external[%c0] : memref<f32>
  %3 = hal.interface.binding.subspan @io::@s0b1_xw_external[%c0] : !flow.dispatch.tensor<writeonly:f32>
  linalg.fill(%2, %cst_0) : memref<f32>, f32 
  linalg.generic {indexing_maps = [affine_map<(d0) -> (d0)>, affine_map<(d0) -> ()>], iterator_types = ["reduction"]} ins(%0 : memref<10xf32>) outs(%2 : memref<f32>) {
  ^bb0(%arg0: f32, %arg1: f32):  // no predecessors
    %4 = cmpf ogt, %arg0, %arg1 : f32
    %5 = select %4, %arg0, %arg1 : f32
    %6 = cmpf uno, %arg0, %arg1 : f32
    %7 = select %6, %cst, %5 : f32
    linalg.yield %7 : f32
  }
  return
}

// *** IR Dump After CSE ***
func @predict_dispatch_4() {
  %c0 = constant 0 : index
  %cst = constant 0x7FC00000 : f32
  %cst_0 = constant 0xFF800000 : f32
  %0 = hal.interface.binding.subspan @io::@s0b0_ro_external[%c0] : memref<10xf32>
  %1 = hal.interface.binding.subspan @io::@s0b0_ro_external[%c0] : !flow.dispatch.tensor<readonly:10xf32>
  %2 = hal.interface.binding.subspan @io::@s0b1_xw_external[%c0] : memref<f32>
  %3 = hal.interface.binding.subspan @io::@s0b1_xw_external[%c0] : !flow.dispatch.tensor<writeonly:f32>
  linalg.fill(%2, %cst_0) : memref<f32>, f32 
  linalg.generic {indexing_maps = [affine_map<(d0) -> (d0)>, affine_map<(d0) -> ()>], iterator_types = ["reduction"]} ins(%0 : memref<10xf32>) outs(%2 : memref<f32>) {
  ^bb0(%arg0: f32, %arg1: f32):  // no predecessors
    %4 = cmpf ogt, %arg0, %arg1 : f32
    %5 = select %4, %arg0, %arg1 : f32
    %6 = cmpf uno, %arg0, %arg1 : f32
    %7 = select %6, %cst, %5 : f32
    linalg.yield %7 : f32
  }
  return
}

// *** IR Dump After mlir::iree_compiler::`anonymous-namespace'::BufferAllocViewCleanUpPass ***
func @predict_dispatch_4() {
  %c0 = constant 0 : index
  %cst = constant 0x7FC00000 : f32
  %cst_0 = constant 0xFF800000 : f32
  %0 = hal.interface.binding.subspan @io::@s0b0_ro_external[%c0] : memref<10xf32>
  %1 = hal.interface.binding.subspan @io::@s0b1_xw_external[%c0] : memref<f32>
  linalg.fill(%1, %cst_0) : memref<f32>, f32 
  linalg.generic {indexing_maps = [affine_map<(d0) -> (d0)>, affine_map<(d0) -> ()>], iterator_types = ["reduction"]} ins(%0 : memref<10xf32>) outs(%1 : memref<f32>) {
  ^bb0(%arg0: f32, %arg1: f32):  // no predecessors
    %2 = cmpf ogt, %arg0, %arg1 : f32
    %3 = select %2, %arg0, %arg1 : f32
    %4 = cmpf uno, %arg0, %arg1 : f32
    %5 = select %4, %cst, %3 : f32
    linalg.yield %5 : f32
  }
  return
}

// *** IR Dump After mlir::iree_compiler::`anonymous-namespace'::PlanConvLoopOrderPass ***
func @predict_dispatch_4() {
  %c0 = constant 0 : index
  %cst = constant 0x7FC00000 : f32
  %cst_0 = constant 0xFF800000 : f32
  %0 = hal.interface.binding.subspan @io::@s0b0_ro_external[%c0] : memref<10xf32>
  %1 = hal.interface.binding.subspan @io::@s0b1_xw_external[%c0] : memref<f32>
  linalg.fill(%1, %cst_0) : memref<f32>, f32 
  linalg.generic {indexing_maps = [affine_map<(d0) -> (d0)>, affine_map<(d0) -> ()>], iterator_types = ["reduction"]} ins(%0 : memref<10xf32>) outs(%1 : memref<f32>) {
  ^bb0(%arg0: f32, %arg1: f32):  // no predecessors
    %2 = cmpf ogt, %arg0, %arg1 : f32
    %3 = select %2, %arg0, %arg1 : f32
    %4 = cmpf uno, %arg0, %arg1 : f32
    %5 = select %4, %cst, %3 : f32
    linalg.yield %5 : f32
  }
  return
}

// *** IR Dump After LinalgLowerToLoops ***
func @predict_dispatch_4() {
  %cst = constant 0x7FC00000 : f32
  %cst_0 = constant 0xFF800000 : f32
  %c10 = constant 10 : index
  %c0 = constant 0 : index
  %c1 = constant 1 : index
  %0 = hal.interface.binding.subspan @io::@s0b0_ro_external[%c0] : memref<10xf32>
  %1 = hal.interface.binding.subspan @io::@s0b1_xw_external[%c0] : memref<f32>
  memref.store %cst_0, %1[] : memref<f32>
  scf.for %arg0 = %c0 to %c10 step %c1 {
    %2 = memref.load %0[%arg0] : memref<10xf32>
    %3 = memref.load %1[] : memref<f32>
    %4 = cmpf ogt, %2, %3 : f32
    %5 = select %4, %2, %3 : f32
    %6 = cmpf uno, %2, %3 : f32
    %7 = select %6, %cst, %5 : f32
    memref.store %7, %1[] : memref<f32>
  }
  return
}

// *** IR Dump After Canonicalizer ***
func @predict_dispatch_4() {
  %cst = constant 0x7FC00000 : f32
  %cst_0 = constant 0xFF800000 : f32
  %c10 = constant 10 : index
  %c0 = constant 0 : index
  %c1 = constant 1 : index
  %0 = hal.interface.binding.subspan @io::@s0b0_ro_external[%c0] : memref<10xf32>
  %1 = hal.interface.binding.subspan @io::@s0b1_xw_external[%c0] : memref<f32>
  memref.store %cst_0, %1[] : memref<f32>
  scf.for %arg0 = %c0 to %c10 step %c1 {
    %2 = memref.load %0[%arg0] : memref<10xf32>
    %3 = memref.load %1[] : memref<f32>
    %4 = cmpf ogt, %2, %3 : f32
    %5 = select %4, %2, %3 : f32
    %6 = cmpf uno, %2, %3 : f32
    %7 = select %6, %cst, %5 : f32
    memref.store %7, %1[] : memref<f32>
  }
  return
}

// *** IR Dump After CSE ***
func @predict_dispatch_4() {
  %cst = constant 0x7FC00000 : f32
  %cst_0 = constant 0xFF800000 : f32
  %c10 = constant 10 : index
  %c0 = constant 0 : index
  %c1 = constant 1 : index
  %0 = hal.interface.binding.subspan @io::@s0b0_ro_external[%c0] : memref<10xf32>
  %1 = hal.interface.binding.subspan @io::@s0b1_xw_external[%c0] : memref<f32>
  memref.store %cst_0, %1[] : memref<f32>
  scf.for %arg0 = %c0 to %c10 step %c1 {
    %2 = memref.load %0[%arg0] : memref<10xf32>
    %3 = memref.load %1[] : memref<f32>
    %4 = cmpf ogt, %2, %3 : f32
    %5 = select %4, %2, %3 : f32
    %6 = cmpf uno, %2, %3 : f32
    %7 = select %6, %cst, %5 : f32
    memref.store %7, %1[] : memref<f32>
  }
  return
}

// *** IR Dump After SCFToStandard ***
func @predict_dispatch_4() {
  %cst = constant 0x7FC00000 : f32
  %cst_0 = constant 0xFF800000 : f32
  %c10 = constant 10 : index
  %c0 = constant 0 : index
  %c1 = constant 1 : index
  %0 = hal.interface.binding.subspan @io::@s0b0_ro_external[%c0] : memref<10xf32>
  %1 = hal.interface.binding.subspan @io::@s0b1_xw_external[%c0] : memref<f32>
  memref.store %cst_0, %1[] : memref<f32>
  br ^bb1(%c0 : index)
^bb1(%2: index):  // 2 preds: ^bb0, ^bb2
  %3 = cmpi slt, %2, %c10 : index
  cond_br %3, ^bb2, ^bb3
^bb2:  // pred: ^bb1
  %4 = memref.load %0[%2] : memref<10xf32>
  %5 = memref.load %1[] : memref<f32>
  %6 = cmpf ogt, %4, %5 : f32
  %7 = select %6, %4, %5 : f32
  %8 = cmpf uno, %4, %5 : f32
  %9 = select %8, %cst, %7 : f32
  memref.store %9, %1[] : memref<f32>
  %10 = addi %2, %c1 : index
  br ^bb1(%10 : index)
^bb3:  // pred: ^bb1
  return
}

// *** IR Dump After Canonicalizer ***
func @predict_dispatch_4() {
  %cst = constant 0x7FC00000 : f32
  %cst_0 = constant 0xFF800000 : f32
  %c10 = constant 10 : index
  %c0 = constant 0 : index
  %c1 = constant 1 : index
  %0 = hal.interface.binding.subspan @io::@s0b0_ro_external[%c0] : memref<10xf32>
  %1 = hal.interface.binding.subspan @io::@s0b1_xw_external[%c0] : memref<f32>
  memref.store %cst_0, %1[] : memref<f32>
  br ^bb1(%c0 : index)
^bb1(%2: index):  // 2 preds: ^bb0, ^bb2
  %3 = cmpi slt, %2, %c10 : index
  cond_br %3, ^bb2, ^bb3
^bb2:  // pred: ^bb1
  %4 = memref.load %0[%2] : memref<10xf32>
  %5 = memref.load %1[] : memref<f32>
  %6 = cmpf ogt, %4, %5 : f32
  %7 = select %6, %4, %5 : f32
  %8 = cmpf uno, %4, %5 : f32
  %9 = select %8, %cst, %7 : f32
  memref.store %9, %1[] : memref<f32>
  %10 = addi %2, %c1 : index
  br ^bb1(%10 : index)
^bb3:  // pred: ^bb1
  return
}

// *** IR Dump After CSE ***
func @predict_dispatch_4() {
  %cst = constant 0x7FC00000 : f32
  %cst_0 = constant 0xFF800000 : f32
  %c10 = constant 10 : index
  %c0 = constant 0 : index
  %c1 = constant 1 : index
  %0 = hal.interface.binding.subspan @io::@s0b0_ro_external[%c0] : memref<10xf32>
  %1 = hal.interface.binding.subspan @io::@s0b1_xw_external[%c0] : memref<f32>
  memref.store %cst_0, %1[] : memref<f32>
  br ^bb1(%c0 : index)
^bb1(%2: index):  // 2 preds: ^bb0, ^bb2
  %3 = cmpi slt, %2, %c10 : index
  cond_br %3, ^bb2, ^bb3
^bb2:  // pred: ^bb1
  %4 = memref.load %0[%2] : memref<10xf32>
  %5 = memref.load %1[] : memref<f32>
  %6 = cmpf ogt, %4, %5 : f32
  %7 = select %6, %4, %5 : f32
  %8 = cmpf uno, %4, %5 : f32
  %9 = select %8, %cst, %7 : f32
  memref.store %9, %1[] : memref<f32>
  %10 = addi %2, %c1 : index
  br ^bb1(%10 : index)
^bb3:  // pred: ^bb1
  return
}

// *** IR Dump After TensorConstantBufferize ***
module  {
  func @predict_dispatch_4() {
    %cst = constant 0x7FC00000 : f32
    %cst_0 = constant 0xFF800000 : f32
    %c10 = constant 10 : index
    %c0 = constant 0 : index
    %c1 = constant 1 : index
    %0 = hal.interface.binding.subspan @io::@s0b0_ro_external[%c0] : memref<10xf32>
    %1 = hal.interface.binding.subspan @io::@s0b1_xw_external[%c0] : memref<f32>
    memref.store %cst_0, %1[] : memref<f32>
    br ^bb1(%c0 : index)
  ^bb1(%2: index):  // 2 preds: ^bb0, ^bb2
    %3 = cmpi slt, %2, %c10 : index
    cond_br %3, ^bb2, ^bb3
  ^bb2:  // pred: ^bb1
    %4 = memref.load %0[%2] : memref<10xf32>
    %5 = memref.load %1[] : memref<f32>
    %6 = cmpf ogt, %4, %5 : f32
    %7 = select %6, %4, %5 : f32
    %8 = cmpf uno, %4, %5 : f32
    %9 = select %8, %cst, %7 : f32
    memref.store %9, %1[] : memref<f32>
    %10 = addi %2, %c1 : index
    br ^bb1(%10 : index)
  ^bb3:  // pred: ^bb1
    return
  }
  hal.interface @io attributes {sym_visibility = "private"} {
    hal.interface.binding @s0b0_ro_external, set=0, binding=0, type="StorageBuffer", access="Read"
    hal.interface.binding @s0b1_xw_external, set=0, binding=1, type="StorageBuffer", access="Write|Discard"
  }
}

// *** IR Dump After mlir::iree_compiler::`anonymous-namespace'::FoldTensorExtractOpPass ***
module  {
  func @predict_dispatch_4() {
    %cst = constant 0x7FC00000 : f32
    %cst_0 = constant 0xFF800000 : f32
    %c10 = constant 10 : index
    %c0 = constant 0 : index
    %c1 = constant 1 : index
    %0 = hal.interface.binding.subspan @io::@s0b0_ro_external[%c0] : memref<10xf32>
    %1 = hal.interface.binding.subspan @io::@s0b1_xw_external[%c0] : memref<f32>
    memref.store %cst_0, %1[] : memref<f32>
    br ^bb1(%c0 : index)
  ^bb1(%2: index):  // 2 preds: ^bb0, ^bb2
    %3 = cmpi slt, %2, %c10 : index
    cond_br %3, ^bb2, ^bb3
  ^bb2:  // pred: ^bb1
    %4 = memref.load %0[%2] : memref<10xf32>
    %5 = memref.load %1[] : memref<f32>
    %6 = cmpf ogt, %4, %5 : f32
    %7 = select %6, %4, %5 : f32
    %8 = cmpf uno, %4, %5 : f32
    %9 = select %8, %cst, %7 : f32
    memref.store %9, %1[] : memref<f32>
    %10 = addi %2, %c1 : index
    br ^bb1(%10 : index)
  ^bb3:  // pred: ^bb1
    return
  }
  hal.interface @io attributes {sym_visibility = "private"} {
    hal.interface.binding @s0b0_ro_external, set=0, binding=0, type="StorageBuffer", access="Read"
    hal.interface.binding @s0b1_xw_external, set=0, binding=1, type="StorageBuffer", access="Write|Discard"
  }
}

// *** IR Dump After mlir::iree_compiler::`anonymous-namespace'::ConvertToLLVMPass ***
module  {
  llvm.func internal @predict_dispatch_4(%arg0: !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>, %arg1: !llvm.ptr<array<3 x i32>>) -> i32 {
    %0 = llvm.mlir.constant(0x7FC00000 : f32) : f32
    %1 = llvm.mlir.constant(0xFF800000 : f32) : f32
    %2 = llvm.mlir.constant(10 : index) : i64
    %3 = llvm.mlir.constant(0 : index) : i64
    %4 = llvm.mlir.constant(1 : index) : i64
    %5 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
    %6 = llvm.extractvalue %5[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
    %7 = llvm.mlir.constant(0 : index) : i64
    %8 = llvm.getelementptr %6[%7] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
    %9 = llvm.load %8 : !llvm.ptr<ptr<i8>>
    %10 = llvm.getelementptr %9[%3] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
    %11 = llvm.bitcast %10 : !llvm.ptr<i8> to !llvm.ptr<f32>
    %12 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
    %13 = llvm.insertvalue %11, %12[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
    %14 = llvm.insertvalue %11, %13[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
    %15 = llvm.mlir.constant(0 : index) : i64
    %16 = llvm.insertvalue %15, %14[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
    %17 = llvm.mlir.constant(10 : index) : i64
    %18 = llvm.insertvalue %17, %16[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
    %19 = llvm.mlir.constant(1 : index) : i64
    %20 = llvm.insertvalue %19, %18[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
    %21 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
    %22 = llvm.extractvalue %21[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
    %23 = llvm.mlir.constant(1 : index) : i64
    %24 = llvm.getelementptr %22[%23] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
    %25 = llvm.load %24 : !llvm.ptr<ptr<i8>>
    %26 = llvm.getelementptr %25[%3] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
    %27 = llvm.bitcast %26 : !llvm.ptr<i8> to !llvm.ptr<f32>
    %28 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
    %29 = llvm.insertvalue %27, %28[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
    %30 = llvm.insertvalue %27, %29[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
    %31 = llvm.mlir.constant(0 : index) : i64
    %32 = llvm.insertvalue %31, %30[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
    %33 = llvm.extractvalue %32[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
    llvm.store %1, %33 : !llvm.ptr<f32>
    llvm.br ^bb1(%3 : i64)
  ^bb1(%34: i64):  // 2 preds: ^bb0, ^bb2
    %35 = llvm.icmp "slt" %34, %2 : i64
    llvm.cond_br %35, ^bb2, ^bb3
  ^bb2:  // pred: ^bb1
    %36 = llvm.extractvalue %20[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
    %37 = llvm.getelementptr %36[%34] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %38 = llvm.load %37 : !llvm.ptr<f32>
    %39 = llvm.extractvalue %32[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
    %40 = llvm.load %39 : !llvm.ptr<f32>
    %41 = llvm.fcmp "ogt" %38, %40 : f32
    %42 = llvm.select %41, %38, %40 : i1, f32
    %43 = llvm.fcmp "uno" %38, %40 : f32
    %44 = llvm.select %43, %0, %42 : i1, f32
    %45 = llvm.extractvalue %32[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
    llvm.store %44, %45 : !llvm.ptr<f32>
    %46 = llvm.add %34, %4  : i64
    llvm.br ^bb1(%46 : i64)
  ^bb3:  // pred: ^bb1
    %47 = llvm.mlir.constant(0 : i32) : i32
    llvm.return %47 : i32
  }
}

// *** IR Dump After Canonicalizer ***
module  {
  llvm.func internal @predict_dispatch_4(%arg0: !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>, %arg1: !llvm.ptr<array<3 x i32>>) -> i32 {
    %0 = llvm.mlir.constant(0x7FC00000 : f32) : f32
    %1 = llvm.mlir.constant(0xFF800000 : f32) : f32
    %2 = llvm.mlir.constant(10 : index) : i64
    %3 = llvm.mlir.constant(0 : index) : i64
    %4 = llvm.mlir.constant(1 : index) : i64
    %5 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
    %6 = llvm.extractvalue %5[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
    %7 = llvm.mlir.constant(0 : index) : i64
    %8 = llvm.getelementptr %6[%7] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
    %9 = llvm.load %8 : !llvm.ptr<ptr<i8>>
    %10 = llvm.getelementptr %9[%3] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
    %11 = llvm.bitcast %10 : !llvm.ptr<i8> to !llvm.ptr<f32>
    %12 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
    %13 = llvm.insertvalue %11, %12[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
    %14 = llvm.insertvalue %11, %13[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
    %15 = llvm.mlir.constant(0 : index) : i64
    %16 = llvm.insertvalue %15, %14[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
    %17 = llvm.mlir.constant(10 : index) : i64
    %18 = llvm.insertvalue %17, %16[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
    %19 = llvm.mlir.constant(1 : index) : i64
    %20 = llvm.insertvalue %19, %18[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
    %21 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
    %22 = llvm.extractvalue %21[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
    %23 = llvm.mlir.constant(1 : index) : i64
    %24 = llvm.getelementptr %22[%23] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
    %25 = llvm.load %24 : !llvm.ptr<ptr<i8>>
    %26 = llvm.getelementptr %25[%3] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
    %27 = llvm.bitcast %26 : !llvm.ptr<i8> to !llvm.ptr<f32>
    %28 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
    %29 = llvm.insertvalue %27, %28[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
    %30 = llvm.insertvalue %27, %29[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
    %31 = llvm.mlir.constant(0 : index) : i64
    %32 = llvm.insertvalue %31, %30[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
    %33 = llvm.extractvalue %32[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
    llvm.store %1, %33 : !llvm.ptr<f32>
    llvm.br ^bb1(%3 : i64)
  ^bb1(%34: i64):  // 2 preds: ^bb0, ^bb2
    %35 = llvm.icmp "slt" %34, %2 : i64
    llvm.cond_br %35, ^bb2, ^bb3
  ^bb2:  // pred: ^bb1
    %36 = llvm.extractvalue %20[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
    %37 = llvm.getelementptr %36[%34] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %38 = llvm.load %37 : !llvm.ptr<f32>
    %39 = llvm.extractvalue %32[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
    %40 = llvm.load %39 : !llvm.ptr<f32>
    %41 = llvm.fcmp "ogt" %38, %40 : f32
    %42 = llvm.select %41, %38, %40 : i1, f32
    %43 = llvm.fcmp "uno" %38, %40 : f32
    %44 = llvm.select %43, %0, %42 : i1, f32
    %45 = llvm.extractvalue %32[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
    llvm.store %44, %45 : !llvm.ptr<f32>
    %46 = llvm.add %34, %4  : i64
    llvm.br ^bb1(%46 : i64)
  ^bb3:  // pred: ^bb1
    %47 = llvm.mlir.constant(0 : i32) : i32
    llvm.return %47 : i32
  }
}

// *** IR Dump After CSE ***
module  {
  llvm.func internal @predict_dispatch_4(%arg0: !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>, %arg1: !llvm.ptr<array<3 x i32>>) -> i32 {
    %0 = llvm.mlir.constant(0x7FC00000 : f32) : f32
    %1 = llvm.mlir.constant(0xFF800000 : f32) : f32
    %2 = llvm.mlir.constant(10 : index) : i64
    %3 = llvm.mlir.constant(0 : index) : i64
    %4 = llvm.mlir.constant(1 : index) : i64
    %5 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
    %6 = llvm.extractvalue %5[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
    %7 = llvm.getelementptr %6[%3] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
    %8 = llvm.load %7 : !llvm.ptr<ptr<i8>>
    %9 = llvm.getelementptr %8[%3] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
    %10 = llvm.bitcast %9 : !llvm.ptr<i8> to !llvm.ptr<f32>
    %11 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
    %12 = llvm.insertvalue %10, %11[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
    %13 = llvm.insertvalue %10, %12[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
    %14 = llvm.insertvalue %3, %13[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
    %15 = llvm.insertvalue %2, %14[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
    %16 = llvm.insertvalue %4, %15[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
    %17 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
    %18 = llvm.extractvalue %17[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
    %19 = llvm.getelementptr %18[%4] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
    %20 = llvm.load %19 : !llvm.ptr<ptr<i8>>
    %21 = llvm.getelementptr %20[%3] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
    %22 = llvm.bitcast %21 : !llvm.ptr<i8> to !llvm.ptr<f32>
    %23 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
    %24 = llvm.insertvalue %22, %23[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
    %25 = llvm.insertvalue %22, %24[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
    %26 = llvm.insertvalue %3, %25[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
    %27 = llvm.extractvalue %26[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
    llvm.store %1, %27 : !llvm.ptr<f32>
    llvm.br ^bb1(%3 : i64)
  ^bb1(%28: i64):  // 2 preds: ^bb0, ^bb2
    %29 = llvm.icmp "slt" %28, %2 : i64
    llvm.cond_br %29, ^bb2, ^bb3
  ^bb2:  // pred: ^bb1
    %30 = llvm.extractvalue %16[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
    %31 = llvm.getelementptr %30[%28] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %32 = llvm.load %31 : !llvm.ptr<f32>
    %33 = llvm.load %27 : !llvm.ptr<f32>
    %34 = llvm.fcmp "ogt" %32, %33 : f32
    %35 = llvm.select %34, %32, %33 : i1, f32
    %36 = llvm.fcmp "uno" %32, %33 : f32
    %37 = llvm.select %36, %0, %35 : i1, f32
    llvm.store %37, %27 : !llvm.ptr<f32>
    %38 = llvm.add %28, %4  : i64
    llvm.br ^bb1(%38 : i64)
  ^bb3:  // pred: ^bb1
    %39 = llvm.mlir.constant(0 : i32) : i32
    llvm.return %39 : i32
  }
}

// *** IR Dump After mlir::iree_compiler::`anonymous-namespace'::LowerExecutableTargetPass ***
hal.executable.target @llvm_aot, filter="dylib*" {
  hal.executable.entry_point @predict_dispatch_4 attributes {interface = @io, ordinal = 0 : index} {
  ^bb0(%arg0: index, %arg1: index, %arg2: index):  // no predecessors
    %c1 = constant 1 : index
    hal.return %c1, %c1, %c1 : index, index, index
  }
  module  {
    llvm.func internal @predict_dispatch_4(%arg0: !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>, %arg1: !llvm.ptr<array<3 x i32>>) -> i32 {
      %0 = llvm.mlir.constant(0x7FC00000 : f32) : f32
      %1 = llvm.mlir.constant(0xFF800000 : f32) : f32
      %2 = llvm.mlir.constant(10 : index) : i64
      %3 = llvm.mlir.constant(0 : index) : i64
      %4 = llvm.mlir.constant(1 : index) : i64
      %5 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
      %6 = llvm.extractvalue %5[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
      %7 = llvm.getelementptr %6[%3] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
      %8 = llvm.load %7 : !llvm.ptr<ptr<i8>>
      %9 = llvm.getelementptr %8[%3] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
      %10 = llvm.bitcast %9 : !llvm.ptr<i8> to !llvm.ptr<f32>
      %11 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
      %12 = llvm.insertvalue %10, %11[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
      %13 = llvm.insertvalue %10, %12[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
      %14 = llvm.insertvalue %3, %13[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
      %15 = llvm.insertvalue %2, %14[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
      %16 = llvm.insertvalue %4, %15[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
      %17 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
      %18 = llvm.extractvalue %17[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
      %19 = llvm.getelementptr %18[%4] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
      %20 = llvm.load %19 : !llvm.ptr<ptr<i8>>
      %21 = llvm.getelementptr %20[%3] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
      %22 = llvm.bitcast %21 : !llvm.ptr<i8> to !llvm.ptr<f32>
      %23 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
      %24 = llvm.insertvalue %22, %23[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
      %25 = llvm.insertvalue %22, %24[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
      %26 = llvm.insertvalue %3, %25[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
      %27 = llvm.extractvalue %26[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
      llvm.store %1, %27 : !llvm.ptr<f32>
      llvm.br ^bb1(%3 : i64)
    ^bb1(%28: i64):  // 2 preds: ^bb0, ^bb2
      %29 = llvm.icmp "slt" %28, %2 : i64
      llvm.cond_br %29, ^bb2, ^bb3
    ^bb2:  // pred: ^bb1
      %30 = llvm.extractvalue %16[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
      %31 = llvm.getelementptr %30[%28] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
      %32 = llvm.load %31 : !llvm.ptr<f32>
      %33 = llvm.load %27 : !llvm.ptr<f32>
      %34 = llvm.fcmp "ogt" %32, %33 : f32
      %35 = llvm.select %34, %32, %33 : i1, f32
      %36 = llvm.fcmp "uno" %32, %33 : f32
      %37 = llvm.select %36, %0, %35 : i1, f32
      llvm.store %37, %27 : !llvm.ptr<f32>
      %38 = llvm.add %28, %4  : i64
      llvm.br ^bb1(%38 : i64)
    ^bb3:  // pred: ^bb1
      %39 = llvm.mlir.constant(0 : i32) : i32
      llvm.return %39 : i32
    }
  }
}

// *** IR Dump After mlir::iree_compiler::IREE::HAL::TranslateExecutablesPass ***
hal.executable.target @llvm_aot, filter="dylib*" {
  hal.executable.entry_point @predict_dispatch_4 attributes {interface = @io, ordinal = 0 : index} {
  ^bb0(%arg0: index, %arg1: index, %arg2: index):  // no predecessors
    %c1 = constant 1 : index
    hal.return %c1, %c1, %c1 : index, index, index
  }
  module  {
    llvm.func internal @predict_dispatch_4(%arg0: !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>, %arg1: !llvm.ptr<array<3 x i32>>) -> i32 {
      %0 = llvm.mlir.constant(0x7FC00000 : f32) : f32
      %1 = llvm.mlir.constant(0xFF800000 : f32) : f32
      %2 = llvm.mlir.constant(10 : index) : i64
      %3 = llvm.mlir.constant(0 : index) : i64
      %4 = llvm.mlir.constant(1 : index) : i64
      %5 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
      %6 = llvm.extractvalue %5[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
      %7 = llvm.getelementptr %6[%3] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
      %8 = llvm.load %7 : !llvm.ptr<ptr<i8>>
      %9 = llvm.getelementptr %8[%3] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
      %10 = llvm.bitcast %9 : !llvm.ptr<i8> to !llvm.ptr<f32>
      %11 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
      %12 = llvm.insertvalue %10, %11[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
      %13 = llvm.insertvalue %10, %12[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
      %14 = llvm.insertvalue %3, %13[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
      %15 = llvm.insertvalue %2, %14[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
      %16 = llvm.insertvalue %4, %15[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
      %17 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
      %18 = llvm.extractvalue %17[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
      %19 = llvm.getelementptr %18[%4] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
      %20 = llvm.load %19 : !llvm.ptr<ptr<i8>>
      %21 = llvm.getelementptr %20[%3] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
      %22 = llvm.bitcast %21 : !llvm.ptr<i8> to !llvm.ptr<f32>
      %23 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
      %24 = llvm.insertvalue %22, %23[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
      %25 = llvm.insertvalue %22, %24[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
      %26 = llvm.insertvalue %3, %25[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
      %27 = llvm.extractvalue %26[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
      llvm.store %1, %27 : !llvm.ptr<f32>
      llvm.br ^bb1(%3 : i64)
    ^bb1(%28: i64):  // 2 preds: ^bb0, ^bb2
      %29 = llvm.icmp "slt" %28, %2 : i64
      llvm.cond_br %29, ^bb2, ^bb3
    ^bb2:  // pred: ^bb1
      %30 = llvm.extractvalue %16[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
      %31 = llvm.getelementptr %30[%28] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
      %32 = llvm.load %31 : !llvm.ptr<f32>
      %33 = llvm.load %27 : !llvm.ptr<f32>
      %34 = llvm.fcmp "ogt" %32, %33 : f32
      %35 = llvm.select %34, %32, %33 : i1, f32
      %36 = llvm.fcmp "uno" %32, %33 : f32
      %37 = llvm.select %36, %0, %35 : i1, f32
      llvm.store %37, %27 : !llvm.ptr<f32>
      %38 = llvm.add %28, %4  : i64
      llvm.br ^bb1(%38 : i64)
    ^bb3:  // pred: ^bb1
      %39 = llvm.mlir.constant(0 : i32) : i32
      llvm.return %39 : i32
    }
  }
}

// *** IR Dump After mlir::iree_compiler::IREE::HAL::PropagateConstantWorkgroupInfoPass ***
hal.executable.target @llvm_aot, filter="dylib*" {
  hal.executable.entry_point @predict_dispatch_5 attributes {interface = @io, ordinal = 0 : index}
  module  {
    func @predict_dispatch_5() {
      %c0 = constant 0 : index
      %cst = constant opaque<"_", "0xDEADBEEF"> : tensor<1x10xf32>
      %c1 = constant 1 : index
      %c10 = constant 10 : index
      %0 = hal.interface.binding.subspan @io::@s0b0_ro_external[%c0] : !flow.dispatch.tensor<readonly:1x10xf32>
      %1 = hal.interface.binding.subspan @io::@s0b1_ro_external[%c0] : !flow.dispatch.tensor<readonly:f32>
      %2 = hal.interface.binding.subspan @io::@s0b2_xw_external[%c0] : !flow.dispatch.tensor<writeonly:10xf32>
      %3 = flow.dispatch.tensor.load %1, offsets = [], sizes = [], strides = [] : !flow.dispatch.tensor<readonly:f32> -> tensor<f32>
      %workgroup_size_x = hal.interface.workgroup.size[0] : index
      %workgroup_size_y = hal.interface.workgroup.size[1] : index
      %workgroup_id_x = hal.interface.workgroup.id[0] : index
      %workgroup_count_x = hal.interface.workgroup.count[0] : index
      %workgroup_id_y = hal.interface.workgroup.id[1] : index
      %workgroup_count_y = hal.interface.workgroup.count[1] : index
      %4 = affine.apply affine_map<()[s0, s1] -> (s0 * s1)>()[%workgroup_id_y, %workgroup_size_y]
      %5 = affine.apply affine_map<()[s0, s1] -> (s0 * s1)>()[%workgroup_count_y, %workgroup_size_y]
      scf.for %arg0 = %4 to %c1 step %5 {
        %6 = affine.apply affine_map<()[s0, s1] -> (s0 * s1)>()[%workgroup_id_x, %workgroup_size_x]
        %7 = affine.apply affine_map<()[s0, s1] -> (s0 * s1)>()[%workgroup_count_x, %workgroup_size_x]
        scf.for %arg1 = %6 to %c10 step %7 {
          %8 = affine.min affine_map<(d0)[s0] -> (s0, -d0 + 1)>(%arg0)[%workgroup_size_y]
          %9 = affine.min affine_map<(d0)[s0] -> (s0, -d0 + 10)>(%arg1)[%workgroup_size_x]
          %10 = flow.dispatch.tensor.load %0, offsets = [%arg0, %arg1], sizes = [%8, %9], strides = [1, 1] : !flow.dispatch.tensor<readonly:1x10xf32> -> tensor<?x?xf32>
          %11 = affine.min affine_map<(d0)[s0] -> (s0, -d0 + 1)>(%arg0)[%workgroup_size_y]
          %12 = affine.min affine_map<(d0)[s0] -> (s0, -d0 + 10)>(%arg1)[%workgroup_size_x]
          %13 = subtensor %cst[%arg0, %arg1] [%11, %12] [1, 1] : tensor<1x10xf32> to tensor<?x?xf32>
          %14 = affine.min affine_map<(d0)[s0] -> (s0, -d0 + 10)>(%arg1)[%workgroup_size_x]
          %15 = linalg.init_tensor [%14] : tensor<?xf32>
          %16 = linalg.generic {indexing_maps = [affine_map<(d0, d1) -> (d0, d1)>, affine_map<(d0, d1) -> (d0, d1)>, affine_map<(d0, d1) -> ()>, affine_map<(d0, d1) -> (d1)>], iterator_types = ["parallel", "parallel"]} ins(%10, %13, %3 : tensor<?x?xf32>, tensor<?x?xf32>, tensor<f32>) outs(%15 : tensor<?xf32>) attrs =  {__internal_linalg_transform__ = "workgroup"} {
          ^bb0(%arg2: f32, %arg3: f32, %arg4: f32, %arg5: f32):  // no predecessors
            %17 = addf %arg2, %arg3 : f32
            %18 = subf %17, %arg4 : f32
            %19 = math.exp %18 : f32
            linalg.yield %19 : f32
          } -> tensor<?xf32>
          flow.dispatch.tensor.store %16, %2, offsets = [%arg1], sizes = [%14], strides = [1] : tensor<?xf32> -> !flow.dispatch.tensor<writeonly:10xf32>
        }
      }
      return
    }
    hal.interface @io attributes {sym_visibility = "private"} {
      hal.interface.binding @s0b0_ro_external, set=0, binding=0, type="StorageBuffer", access="Read"
      hal.interface.binding @s0b1_ro_external, set=0, binding=1, type="StorageBuffer", access="Read"
      hal.interface.binding @s0b2_xw_external, set=0, binding=2, type="StorageBuffer", access="Write|Discard"
    }
  }
}

// *** IR Dump After mlir::iree_compiler::`anonymous-namespace'::SetNumWorkgroupsPass ***
hal.executable.target @llvm_aot, filter="dylib*" {
  hal.executable.entry_point @predict_dispatch_5 attributes {interface = @io, ordinal = 0 : index} {
  ^bb0(%arg0: index, %arg1: index, %arg2: index):  // no predecessors
    %c1 = constant 1 : index
    %0 = affine.apply affine_map<()[s0] -> (s0 ceildiv 128)>()[%arg0]
    %1 = affine.apply affine_map<()[s0] -> (s0 ceildiv 128)>()[%arg1]
    hal.return %0, %1, %c1 : index, index, index
  }
  module  {
    func @predict_dispatch_5() {
      %c0 = constant 0 : index
      %cst = constant opaque<"_", "0xDEADBEEF"> : tensor<1x10xf32>
      %c1 = constant 1 : index
      %c10 = constant 10 : index
      %c128 = constant 128 : index
      %0 = hal.interface.binding.subspan @io::@s0b0_ro_external[%c0] : !flow.dispatch.tensor<readonly:1x10xf32>
      %1 = hal.interface.binding.subspan @io::@s0b1_ro_external[%c0] : !flow.dispatch.tensor<readonly:f32>
      %2 = hal.interface.binding.subspan @io::@s0b2_xw_external[%c0] : !flow.dispatch.tensor<writeonly:10xf32>
      %3 = flow.dispatch.tensor.load %1, offsets = [], sizes = [], strides = [] : !flow.dispatch.tensor<readonly:f32> -> tensor<f32>
      %workgroup_id_x = hal.interface.workgroup.id[0] : index
      %workgroup_count_x = hal.interface.workgroup.count[0] : index
      %workgroup_id_y = hal.interface.workgroup.id[1] : index
      %workgroup_count_y = hal.interface.workgroup.count[1] : index
      %4 = affine.apply affine_map<()[s0, s1] -> (s0 * s1)>()[%workgroup_id_y, %c128]
      %5 = affine.apply affine_map<()[s0, s1] -> (s0 * s1)>()[%workgroup_count_y, %c128]
      scf.for %arg0 = %4 to %c1 step %5 {
        %6 = affine.apply affine_map<()[s0, s1] -> (s0 * s1)>()[%workgroup_id_x, %c128]
        %7 = affine.apply affine_map<()[s0, s1] -> (s0 * s1)>()[%workgroup_count_x, %c128]
        scf.for %arg1 = %6 to %c10 step %7 {
          %8 = affine.min affine_map<(d0) -> (128, -d0 + 1)>(%arg0)
          %9 = affine.min affine_map<(d0) -> (128, -d0 + 10)>(%arg1)
          %10 = flow.dispatch.tensor.load %0, offsets = [%arg0, %arg1], sizes = [%8, %9], strides = [1, 1] : !flow.dispatch.tensor<readonly:1x10xf32> -> tensor<?x?xf32>
          %11 = affine.min affine_map<(d0) -> (128, -d0 + 1)>(%arg0)
          %12 = affine.min affine_map<(d0) -> (128, -d0 + 10)>(%arg1)
          %13 = subtensor %cst[%arg0, %arg1] [%11, %12] [1, 1] : tensor<1x10xf32> to tensor<?x?xf32>
          %14 = affine.min affine_map<(d0) -> (128, -d0 + 10)>(%arg1)
          %15 = linalg.init_tensor [%14] : tensor<?xf32>
          %16 = linalg.generic {indexing_maps = [affine_map<(d0, d1) -> (d0, d1)>, affine_map<(d0, d1) -> (d0, d1)>, affine_map<(d0, d1) -> ()>, affine_map<(d0, d1) -> (d1)>], iterator_types = ["parallel", "parallel"]} ins(%10, %13, %3 : tensor<?x?xf32>, tensor<?x?xf32>, tensor<f32>) outs(%15 : tensor<?xf32>) attrs =  {__internal_linalg_transform__ = "workgroup", lowering.config = {tileSizes = [[128, 128]]}} {
          ^bb0(%arg2: f32, %arg3: f32, %arg4: f32, %arg5: f32):  // no predecessors
            %17 = addf %arg2, %arg3 : f32
            %18 = subf %17, %arg4 : f32
            %19 = math.exp %18 : f32
            linalg.yield %19 : f32
          } -> tensor<?xf32>
          flow.dispatch.tensor.store %16, %2, offsets = [%arg1], sizes = [%14], strides = [1] : tensor<?xf32> -> !flow.dispatch.tensor<writeonly:10xf32>
        }
      }
      return
    }
    hal.interface @io attributes {sym_visibility = "private"} {
      hal.interface.binding @s0b0_ro_external, set=0, binding=0, type="StorageBuffer", access="Read"
      hal.interface.binding @s0b1_ro_external, set=0, binding=1, type="StorageBuffer", access="Read"
      hal.interface.binding @s0b2_xw_external, set=0, binding=2, type="StorageBuffer", access="Write|Discard"
    }
  }
}

// *** IR Dump After Canonicalizer ***
module  {
  func @predict_dispatch_5() {
    %c0 = constant 0 : index
    %cst = constant opaque<"_", "0xDEADBEEF"> : tensor<1x10xf32>
    %c1 = constant 1 : index
    %c10 = constant 10 : index
    %0 = hal.interface.binding.subspan @io::@s0b0_ro_external[%c0] : !flow.dispatch.tensor<readonly:1x10xf32>
    %1 = hal.interface.binding.subspan @io::@s0b1_ro_external[%c0] : !flow.dispatch.tensor<readonly:f32>
    %2 = hal.interface.binding.subspan @io::@s0b2_xw_external[%c0] : !flow.dispatch.tensor<writeonly:10xf32>
    %3 = flow.dispatch.tensor.load %1, offsets = [], sizes = [], strides = [] : !flow.dispatch.tensor<readonly:f32> -> tensor<f32>
    %workgroup_id_x = hal.interface.workgroup.id[0] : index
    %workgroup_count_x = hal.interface.workgroup.count[0] : index
    %workgroup_id_y = hal.interface.workgroup.id[1] : index
    %workgroup_count_y = hal.interface.workgroup.count[1] : index
    %4 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_y]
    %5 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_y]
    scf.for %arg0 = %4 to %c1 step %5 {
      %6 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
      %7 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
      scf.for %arg1 = %6 to %c10 step %7 {
        %8 = affine.min affine_map<(d0) -> (128, -d0 + 1)>(%arg0)
        %9 = affine.min affine_map<(d0) -> (128, -d0 + 10)>(%arg1)
        %10 = flow.dispatch.tensor.load %0, offsets = [%arg0, %arg1], sizes = [%8, %9], strides = [1, 1] : !flow.dispatch.tensor<readonly:1x10xf32> -> tensor<?x?xf32>
        %11 = affine.min affine_map<(d0) -> (128, -d0 + 1)>(%arg0)
        %12 = affine.min affine_map<(d0) -> (128, -d0 + 10)>(%arg1)
        %13 = subtensor %cst[%arg0, %arg1] [%11, %12] [1, 1] : tensor<1x10xf32> to tensor<?x?xf32>
        %14 = affine.min affine_map<(d0) -> (128, -d0 + 10)>(%arg1)
        %15 = linalg.init_tensor [%14] : tensor<?xf32>
        %16 = linalg.generic {indexing_maps = [affine_map<(d0, d1) -> (d0, d1)>, affine_map<(d0, d1) -> (d0, d1)>, affine_map<(d0, d1) -> ()>, affine_map<(d0, d1) -> (d1)>], iterator_types = ["parallel", "parallel"]} ins(%10, %13, %3 : tensor<?x?xf32>, tensor<?x?xf32>, tensor<f32>) outs(%15 : tensor<?xf32>) attrs =  {__internal_linalg_transform__ = "workgroup", lowering.config = {tileSizes = [[128, 128]]}} {
        ^bb0(%arg2: f32, %arg3: f32, %arg4: f32, %arg5: f32):  // no predecessors
          %17 = addf %arg2, %arg3 : f32
          %18 = subf %17, %arg4 : f32
          %19 = math.exp %18 : f32
          linalg.yield %19 : f32
        } -> tensor<?xf32>
        flow.dispatch.tensor.store %16, %2, offsets = [%arg1], sizes = [%14], strides = [1] : tensor<?xf32> -> !flow.dispatch.tensor<writeonly:10xf32>
      }
    }
    return
  }
  hal.interface @io attributes {sym_visibility = "private"} {
    hal.interface.binding @s0b0_ro_external, set=0, binding=0, type="StorageBuffer", access="Read"
    hal.interface.binding @s0b1_ro_external, set=0, binding=1, type="StorageBuffer", access="Read"
    hal.interface.binding @s0b2_xw_external, set=0, binding=2, type="StorageBuffer", access="Write|Discard"
  }
}

// *** IR Dump After mlir::iree_compiler::`anonymous-namespace'::LinalgBufferizePass ***
func @predict_dispatch_5() {
  %c0 = constant 0 : index
  %cst = constant opaque<"_", "0xDEADBEEF"> : tensor<1x10xf32>
  %0 = memref.buffer_cast %cst : memref<1x10xf32>
  %c1 = constant 1 : index
  %c10 = constant 10 : index
  %1 = hal.interface.binding.subspan @io::@s0b0_ro_external[%c0] : memref<1x10xf32>
  %2 = hal.interface.binding.subspan @io::@s0b0_ro_external[%c0] : !flow.dispatch.tensor<readonly:1x10xf32>
  %3 = hal.interface.binding.subspan @io::@s0b1_ro_external[%c0] : memref<f32>
  %4 = hal.interface.binding.subspan @io::@s0b1_ro_external[%c0] : !flow.dispatch.tensor<readonly:f32>
  %5 = hal.interface.binding.subspan @io::@s0b2_xw_external[%c0] : memref<10xf32>
  %6 = hal.interface.binding.subspan @io::@s0b2_xw_external[%c0] : !flow.dispatch.tensor<writeonly:10xf32>
  %7 = flow.dispatch.tensor.load %4, offsets = [], sizes = [], strides = [] : !flow.dispatch.tensor<readonly:f32> -> tensor<f32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %8 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_y]
  %9 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_y]
  scf.for %arg0 = %8 to %c1 step %9 {
    %10 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
    %11 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
    scf.for %arg1 = %10 to %c10 step %11 {
      %12 = affine.min affine_map<(d0) -> (128, -d0 + 1)>(%arg0)
      %13 = affine.min affine_map<(d0) -> (128, -d0 + 10)>(%arg1)
      %14 = memref.subview %1[%arg0, %arg1] [%12, %13] [1, 1] : memref<1x10xf32> to memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
      %15 = flow.dispatch.tensor.load %2, offsets = [%arg0, %arg1], sizes = [%12, %13], strides = [1, 1] : !flow.dispatch.tensor<readonly:1x10xf32> -> tensor<?x?xf32>
      %16 = affine.min affine_map<(d0) -> (128, -d0 + 1)>(%arg0)
      %17 = affine.min affine_map<(d0) -> (128, -d0 + 10)>(%arg1)
      %18 = memref.subview %0[%arg0, %arg1] [%16, %17] [1, 1] : memref<1x10xf32> to memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
      %19 = subtensor %cst[%arg0, %arg1] [%16, %17] [1, 1] : tensor<1x10xf32> to tensor<?x?xf32>
      %20 = affine.min affine_map<(d0) -> (128, -d0 + 10)>(%arg1)
      %21 = linalg.init_tensor [%20] : tensor<?xf32>
      %22 = memref.subview %5[%arg1] [%20] [1] : memref<10xf32> to memref<?xf32, affine_map<(d0)[s0] -> (d0 + s0)>>
      linalg.generic {indexing_maps = [affine_map<(d0, d1) -> (d0, d1)>, affine_map<(d0, d1) -> (d0, d1)>, affine_map<(d0, d1) -> ()>, affine_map<(d0, d1) -> (d1)>], iterator_types = ["parallel", "parallel"]} ins(%14, %18, %3 : memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>, memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>, memref<f32>) outs(%22 : memref<?xf32, affine_map<(d0)[s0] -> (d0 + s0)>>) attrs =  {__internal_linalg_transform__ = "workgroup", lowering.config = {tileSizes = [[128, 128]]}} {
      ^bb0(%arg2: f32, %arg3: f32, %arg4: f32, %arg5: f32):  // no predecessors
        %24 = addf %arg2, %arg3 : f32
        %25 = subf %24, %arg4 : f32
        %26 = math.exp %25 : f32
        linalg.yield %26 : f32
      }
      %23 = linalg.generic {indexing_maps = [affine_map<(d0, d1) -> (d0, d1)>, affine_map<(d0, d1) -> (d0, d1)>, affine_map<(d0, d1) -> ()>, affine_map<(d0, d1) -> (d1)>], iterator_types = ["parallel", "parallel"]} ins(%15, %19, %7 : tensor<?x?xf32>, tensor<?x?xf32>, tensor<f32>) outs(%21 : tensor<?xf32>) attrs =  {__internal_linalg_transform__ = "workgroup", lowering.config = {tileSizes = [[128, 128]]}} {
      ^bb0(%arg2: f32, %arg3: f32, %arg4: f32, %arg5: f32):  // no predecessors
        %24 = addf %arg2, %arg3 : f32
        %25 = subf %24, %arg4 : f32
        %26 = math.exp %25 : f32
        linalg.yield %26 : f32
      } -> tensor<?xf32>
    }
  }
  return
}

// *** IR Dump After Canonicalizer ***
func @predict_dispatch_5() {
  %c0 = constant 0 : index
  %cst = constant opaque<"_", "0xDEADBEEF"> : tensor<1x10xf32>
  %c1 = constant 1 : index
  %c10 = constant 10 : index
  %0 = memref.buffer_cast %cst : memref<1x10xf32>
  %1 = hal.interface.binding.subspan @io::@s0b0_ro_external[%c0] : memref<1x10xf32>
  %2 = hal.interface.binding.subspan @io::@s0b0_ro_external[%c0] : !flow.dispatch.tensor<readonly:1x10xf32>
  %3 = hal.interface.binding.subspan @io::@s0b1_ro_external[%c0] : memref<f32>
  %4 = hal.interface.binding.subspan @io::@s0b1_ro_external[%c0] : !flow.dispatch.tensor<readonly:f32>
  %5 = hal.interface.binding.subspan @io::@s0b2_xw_external[%c0] : memref<10xf32>
  %6 = hal.interface.binding.subspan @io::@s0b2_xw_external[%c0] : !flow.dispatch.tensor<writeonly:10xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %7 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_y]
  %8 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_y]
  scf.for %arg0 = %7 to %c1 step %8 {
    %9 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
    %10 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
    scf.for %arg1 = %9 to %c10 step %10 {
      %11 = affine.min affine_map<(d0) -> (128, -d0 + 1)>(%arg0)
      %12 = affine.min affine_map<(d0) -> (128, -d0 + 10)>(%arg1)
      %13 = memref.subview %1[%arg0, %arg1] [%11, %12] [1, 1] : memref<1x10xf32> to memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
      %14 = affine.min affine_map<(d0) -> (128, -d0 + 1)>(%arg0)
      %15 = affine.min affine_map<(d0) -> (128, -d0 + 10)>(%arg1)
      %16 = memref.subview %0[%arg0, %arg1] [%14, %15] [1, 1] : memref<1x10xf32> to memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
      %17 = affine.min affine_map<(d0) -> (128, -d0 + 10)>(%arg1)
      %18 = memref.subview %5[%arg1] [%17] [1] : memref<10xf32> to memref<?xf32, affine_map<(d0)[s0] -> (d0 + s0)>>
      linalg.generic {indexing_maps = [affine_map<(d0, d1) -> (d0, d1)>, affine_map<(d0, d1) -> (d0, d1)>, affine_map<(d0, d1) -> ()>, affine_map<(d0, d1) -> (d1)>], iterator_types = ["parallel", "parallel"]} ins(%13, %16, %3 : memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>, memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>, memref<f32>) outs(%18 : memref<?xf32, affine_map<(d0)[s0] -> (d0 + s0)>>) attrs =  {__internal_linalg_transform__ = "workgroup", lowering.config = {tileSizes = [[128, 128]]}} {
      ^bb0(%arg2: f32, %arg3: f32, %arg4: f32, %arg5: f32):  // no predecessors
        %19 = addf %arg2, %arg3 : f32
        %20 = subf %19, %arg4 : f32
        %21 = math.exp %20 : f32
        linalg.yield %21 : f32
      }
    }
  }
  return
}

// *** IR Dump After CSE ***
func @predict_dispatch_5() {
  %c0 = constant 0 : index
  %cst = constant opaque<"_", "0xDEADBEEF"> : tensor<1x10xf32>
  %c1 = constant 1 : index
  %c10 = constant 10 : index
  %0 = memref.buffer_cast %cst : memref<1x10xf32>
  %1 = hal.interface.binding.subspan @io::@s0b0_ro_external[%c0] : memref<1x10xf32>
  %2 = hal.interface.binding.subspan @io::@s0b0_ro_external[%c0] : !flow.dispatch.tensor<readonly:1x10xf32>
  %3 = hal.interface.binding.subspan @io::@s0b1_ro_external[%c0] : memref<f32>
  %4 = hal.interface.binding.subspan @io::@s0b1_ro_external[%c0] : !flow.dispatch.tensor<readonly:f32>
  %5 = hal.interface.binding.subspan @io::@s0b2_xw_external[%c0] : memref<10xf32>
  %6 = hal.interface.binding.subspan @io::@s0b2_xw_external[%c0] : !flow.dispatch.tensor<writeonly:10xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %7 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_y]
  %8 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_y]
  scf.for %arg0 = %7 to %c1 step %8 {
    %9 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
    %10 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
    scf.for %arg1 = %9 to %c10 step %10 {
      %11 = affine.min affine_map<(d0) -> (128, -d0 + 1)>(%arg0)
      %12 = affine.min affine_map<(d0) -> (128, -d0 + 10)>(%arg1)
      %13 = memref.subview %1[%arg0, %arg1] [%11, %12] [1, 1] : memref<1x10xf32> to memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
      %14 = memref.subview %0[%arg0, %arg1] [%11, %12] [1, 1] : memref<1x10xf32> to memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
      %15 = memref.subview %5[%arg1] [%12] [1] : memref<10xf32> to memref<?xf32, affine_map<(d0)[s0] -> (d0 + s0)>>
      linalg.generic {indexing_maps = [affine_map<(d0, d1) -> (d0, d1)>, affine_map<(d0, d1) -> (d0, d1)>, affine_map<(d0, d1) -> ()>, affine_map<(d0, d1) -> (d1)>], iterator_types = ["parallel", "parallel"]} ins(%13, %14, %3 : memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>, memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>, memref<f32>) outs(%15 : memref<?xf32, affine_map<(d0)[s0] -> (d0 + s0)>>) attrs =  {__internal_linalg_transform__ = "workgroup", lowering.config = {tileSizes = [[128, 128]]}} {
      ^bb0(%arg2: f32, %arg3: f32, %arg4: f32, %arg5: f32):  // no predecessors
        %16 = addf %arg2, %arg3 : f32
        %17 = subf %16, %arg4 : f32
        %18 = math.exp %17 : f32
        linalg.yield %18 : f32
      }
    }
  }
  return
}

// *** IR Dump After mlir::iree_compiler::`anonymous-namespace'::BufferAllocViewCleanUpPass ***
func @predict_dispatch_5() {
  %c0 = constant 0 : index
  %cst = constant opaque<"_", "0xDEADBEEF"> : tensor<1x10xf32>
  %c1 = constant 1 : index
  %c10 = constant 10 : index
  %0 = memref.buffer_cast %cst : memref<1x10xf32>
  %1 = hal.interface.binding.subspan @io::@s0b0_ro_external[%c0] : memref<1x10xf32>
  %2 = hal.interface.binding.subspan @io::@s0b1_ro_external[%c0] : memref<f32>
  %3 = hal.interface.binding.subspan @io::@s0b2_xw_external[%c0] : memref<10xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %4 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_y]
  %5 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_y]
  scf.for %arg0 = %4 to %c1 step %5 {
    %6 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
    %7 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
    scf.for %arg1 = %6 to %c10 step %7 {
      %8 = affine.min affine_map<(d0) -> (128, -d0 + 1)>(%arg0)
      %9 = affine.min affine_map<(d0) -> (128, -d0 + 10)>(%arg1)
      %10 = memref.subview %1[%arg0, %arg1] [%8, %9] [1, 1] : memref<1x10xf32> to memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
      %11 = memref.subview %0[%arg0, %arg1] [%8, %9] [1, 1] : memref<1x10xf32> to memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
      %12 = memref.subview %3[%arg1] [%9] [1] : memref<10xf32> to memref<?xf32, affine_map<(d0)[s0] -> (d0 + s0)>>
      linalg.generic {indexing_maps = [affine_map<(d0, d1) -> (d0, d1)>, affine_map<(d0, d1) -> (d0, d1)>, affine_map<(d0, d1) -> ()>, affine_map<(d0, d1) -> (d1)>], iterator_types = ["parallel", "parallel"]} ins(%10, %11, %2 : memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>, memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>, memref<f32>) outs(%12 : memref<?xf32, affine_map<(d0)[s0] -> (d0 + s0)>>) attrs =  {__internal_linalg_transform__ = "workgroup", lowering.config = {tileSizes = [[128, 128]]}} {
      ^bb0(%arg2: f32, %arg3: f32, %arg4: f32, %arg5: f32):  // no predecessors
        %13 = addf %arg2, %arg3 : f32
        %14 = subf %13, %arg4 : f32
        %15 = math.exp %14 : f32
        linalg.yield %15 : f32
      }
    }
  }
  return
}

// *** IR Dump After Canonicalizer ***
func @predict_dispatch_5() {
  %c0 = constant 0 : index
  %cst = constant opaque<"_", "0xDEADBEEF"> : tensor<1x10xf32>
  %c1 = constant 1 : index
  %c10 = constant 10 : index
  %0 = memref.buffer_cast %cst : memref<1x10xf32>
  %1 = hal.interface.binding.subspan @io::@s0b0_ro_external[%c0] : memref<1x10xf32>
  %2 = hal.interface.binding.subspan @io::@s0b1_ro_external[%c0] : memref<f32>
  %3 = hal.interface.binding.subspan @io::@s0b2_xw_external[%c0] : memref<10xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %4 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_y]
  %5 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_y]
  scf.for %arg0 = %4 to %c1 step %5 {
    %6 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
    %7 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
    scf.for %arg1 = %6 to %c10 step %7 {
      %8 = affine.min affine_map<(d0) -> (128, -d0 + 1)>(%arg0)
      %9 = affine.min affine_map<(d0) -> (128, -d0 + 10)>(%arg1)
      %10 = memref.subview %1[%arg0, %arg1] [%8, %9] [1, 1] : memref<1x10xf32> to memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
      %11 = memref.subview %0[%arg0, %arg1] [%8, %9] [1, 1] : memref<1x10xf32> to memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
      %12 = memref.subview %3[%arg1] [%9] [1] : memref<10xf32> to memref<?xf32, affine_map<(d0)[s0] -> (d0 + s0)>>
      linalg.generic {indexing_maps = [affine_map<(d0, d1) -> (d0, d1)>, affine_map<(d0, d1) -> (d0, d1)>, affine_map<(d0, d1) -> ()>, affine_map<(d0, d1) -> (d1)>], iterator_types = ["parallel", "parallel"]} ins(%10, %11, %2 : memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>, memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>, memref<f32>) outs(%12 : memref<?xf32, affine_map<(d0)[s0] -> (d0 + s0)>>) attrs =  {__internal_linalg_transform__ = "workgroup", lowering.config = {tileSizes = [[128, 128]]}} {
      ^bb0(%arg2: f32, %arg3: f32, %arg4: f32, %arg5: f32):  // no predecessors
        %13 = addf %arg2, %arg3 : f32
        %14 = subf %13, %arg4 : f32
        %15 = math.exp %14 : f32
        linalg.yield %15 : f32
      }
    }
  }
  return
}

// *** IR Dump After mlir::iree_compiler::`anonymous-namespace'::TileAndVectorizeWorkgroups ***
func @predict_dispatch_5() {
  %c0 = constant 0 : index
  %cst = constant opaque<"_", "0xDEADBEEF"> : tensor<1x10xf32>
  %c1 = constant 1 : index
  %c10 = constant 10 : index
  %0 = memref.buffer_cast %cst : memref<1x10xf32>
  %1 = hal.interface.binding.subspan @io::@s0b0_ro_external[%c0] : memref<1x10xf32>
  %2 = hal.interface.binding.subspan @io::@s0b1_ro_external[%c0] : memref<f32>
  %3 = hal.interface.binding.subspan @io::@s0b2_xw_external[%c0] : memref<10xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %4 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_y]
  %5 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_y]
  scf.for %arg0 = %4 to %c1 step %5 {
    %6 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
    %7 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
    scf.for %arg1 = %6 to %c10 step %7 {
      %8 = affine.min affine_map<(d0) -> (128, -d0 + 1)>(%arg0)
      %9 = affine.min affine_map<(d0) -> (128, -d0 + 10)>(%arg1)
      %10 = memref.subview %1[%arg0, %arg1] [%8, %9] [1, 1] : memref<1x10xf32> to memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
      %11 = memref.subview %0[%arg0, %arg1] [%8, %9] [1, 1] : memref<1x10xf32> to memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
      %12 = memref.subview %3[%arg1] [%9] [1] : memref<10xf32> to memref<?xf32, affine_map<(d0)[s0] -> (d0 + s0)>>
      linalg.generic {indexing_maps = [affine_map<(d0, d1) -> (d0, d1)>, affine_map<(d0, d1) -> (d0, d1)>, affine_map<(d0, d1) -> ()>, affine_map<(d0, d1) -> (d1)>], iterator_types = ["parallel", "parallel"]} ins(%10, %11, %2 : memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>, memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>, memref<f32>) outs(%12 : memref<?xf32, affine_map<(d0)[s0] -> (d0 + s0)>>) attrs =  {__internal_linalg_transform__ = "workgroup", lowering.config = {tileSizes = [[128, 128]]}} {
      ^bb0(%arg2: f32, %arg3: f32, %arg4: f32, %arg5: f32):  // no predecessors
        %13 = addf %arg2, %arg3 : f32
        %14 = subf %13, %arg4 : f32
        %15 = math.exp %14 : f32
        linalg.yield %15 : f32
      }
    }
  }
  return
}

// *** IR Dump After Canonicalizer ***
func @predict_dispatch_5() {
  %c0 = constant 0 : index
  %cst = constant opaque<"_", "0xDEADBEEF"> : tensor<1x10xf32>
  %c1 = constant 1 : index
  %c10 = constant 10 : index
  %0 = memref.buffer_cast %cst : memref<1x10xf32>
  %1 = hal.interface.binding.subspan @io::@s0b0_ro_external[%c0] : memref<1x10xf32>
  %2 = hal.interface.binding.subspan @io::@s0b1_ro_external[%c0] : memref<f32>
  %3 = hal.interface.binding.subspan @io::@s0b2_xw_external[%c0] : memref<10xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %4 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_y]
  %5 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_y]
  scf.for %arg0 = %4 to %c1 step %5 {
    %6 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
    %7 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
    scf.for %arg1 = %6 to %c10 step %7 {
      %8 = affine.min affine_map<(d0) -> (128, -d0 + 1)>(%arg0)
      %9 = affine.min affine_map<(d0) -> (128, -d0 + 10)>(%arg1)
      %10 = memref.subview %1[%arg0, %arg1] [%8, %9] [1, 1] : memref<1x10xf32> to memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
      %11 = memref.subview %0[%arg0, %arg1] [%8, %9] [1, 1] : memref<1x10xf32> to memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
      %12 = memref.subview %3[%arg1] [%9] [1] : memref<10xf32> to memref<?xf32, affine_map<(d0)[s0] -> (d0 + s0)>>
      linalg.generic {indexing_maps = [affine_map<(d0, d1) -> (d0, d1)>, affine_map<(d0, d1) -> (d0, d1)>, affine_map<(d0, d1) -> ()>, affine_map<(d0, d1) -> (d1)>], iterator_types = ["parallel", "parallel"]} ins(%10, %11, %2 : memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>, memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>, memref<f32>) outs(%12 : memref<?xf32, affine_map<(d0)[s0] -> (d0 + s0)>>) attrs =  {__internal_linalg_transform__ = "workgroup", lowering.config = {tileSizes = [[128, 128]]}} {
      ^bb0(%arg2: f32, %arg3: f32, %arg4: f32, %arg5: f32):  // no predecessors
        %13 = addf %arg2, %arg3 : f32
        %14 = subf %13, %arg4 : f32
        %15 = math.exp %14 : f32
        linalg.yield %15 : f32
      }
    }
  }
  return
}

// *** IR Dump After mlir::iree_compiler::`anonymous-namespace'::ForOpCanonicalizationPass ***
func @predict_dispatch_5() {
  %c0 = constant 0 : index
  %cst = constant opaque<"_", "0xDEADBEEF"> : tensor<1x10xf32>
  %c1 = constant 1 : index
  %c10 = constant 10 : index
  %0 = memref.buffer_cast %cst : memref<1x10xf32>
  %1 = hal.interface.binding.subspan @io::@s0b0_ro_external[%c0] : memref<1x10xf32>
  %2 = hal.interface.binding.subspan @io::@s0b1_ro_external[%c0] : memref<f32>
  %3 = hal.interface.binding.subspan @io::@s0b2_xw_external[%c0] : memref<10xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %4 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_y]
  %5 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_y]
  scf.for %arg0 = %4 to %c1 step %5 {
    %6 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
    %7 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
    scf.for %arg1 = %6 to %c10 step %7 {
      %8 = affine.min affine_map<(d0) -> (128, -d0 + 1)>(%arg0)
      %9 = affine.min affine_map<(d0) -> (128, -d0 + 10)>(%arg1)
      %10 = memref.subview %1[%arg0, %arg1] [%8, %9] [1, 1] : memref<1x10xf32> to memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
      %11 = memref.subview %0[%arg0, %arg1] [%8, %9] [1, 1] : memref<1x10xf32> to memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
      %12 = memref.subview %3[%arg1] [%9] [1] : memref<10xf32> to memref<?xf32, affine_map<(d0)[s0] -> (d0 + s0)>>
      linalg.generic {indexing_maps = [affine_map<(d0, d1) -> (d0, d1)>, affine_map<(d0, d1) -> (d0, d1)>, affine_map<(d0, d1) -> ()>, affine_map<(d0, d1) -> (d1)>], iterator_types = ["parallel", "parallel"]} ins(%10, %11, %2 : memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>, memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>, memref<f32>) outs(%12 : memref<?xf32, affine_map<(d0)[s0] -> (d0 + s0)>>) attrs =  {__internal_linalg_transform__ = "workgroup", lowering.config = {tileSizes = [[128, 128]]}} {
      ^bb0(%arg2: f32, %arg3: f32, %arg4: f32, %arg5: f32):  // no predecessors
        %13 = addf %arg2, %arg3 : f32
        %14 = subf %13, %arg4 : f32
        %15 = math.exp %14 : f32
        linalg.yield %15 : f32
      }
    }
  }
  return
}

// *** IR Dump After mlir::iree_compiler::`anonymous-namespace'::PlanConvLoopOrderPass ***
func @predict_dispatch_5() {
  %c0 = constant 0 : index
  %cst = constant opaque<"_", "0xDEADBEEF"> : tensor<1x10xf32>
  %c1 = constant 1 : index
  %c10 = constant 10 : index
  %0 = memref.buffer_cast %cst : memref<1x10xf32>
  %1 = hal.interface.binding.subspan @io::@s0b0_ro_external[%c0] : memref<1x10xf32>
  %2 = hal.interface.binding.subspan @io::@s0b1_ro_external[%c0] : memref<f32>
  %3 = hal.interface.binding.subspan @io::@s0b2_xw_external[%c0] : memref<10xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %4 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_y]
  %5 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_y]
  scf.for %arg0 = %4 to %c1 step %5 {
    %6 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
    %7 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
    scf.for %arg1 = %6 to %c10 step %7 {
      %8 = affine.min affine_map<(d0) -> (128, -d0 + 1)>(%arg0)
      %9 = affine.min affine_map<(d0) -> (128, -d0 + 10)>(%arg1)
      %10 = memref.subview %1[%arg0, %arg1] [%8, %9] [1, 1] : memref<1x10xf32> to memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
      %11 = memref.subview %0[%arg0, %arg1] [%8, %9] [1, 1] : memref<1x10xf32> to memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
      %12 = memref.subview %3[%arg1] [%9] [1] : memref<10xf32> to memref<?xf32, affine_map<(d0)[s0] -> (d0 + s0)>>
      linalg.generic {indexing_maps = [affine_map<(d0, d1) -> (d0, d1)>, affine_map<(d0, d1) -> (d0, d1)>, affine_map<(d0, d1) -> ()>, affine_map<(d0, d1) -> (d1)>], iterator_types = ["parallel", "parallel"]} ins(%10, %11, %2 : memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>, memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>, memref<f32>) outs(%12 : memref<?xf32, affine_map<(d0)[s0] -> (d0 + s0)>>) attrs =  {__internal_linalg_transform__ = "workgroup", lowering.config = {tileSizes = [[128, 128]]}} {
      ^bb0(%arg2: f32, %arg3: f32, %arg4: f32, %arg5: f32):  // no predecessors
        %13 = addf %arg2, %arg3 : f32
        %14 = subf %13, %arg4 : f32
        %15 = math.exp %14 : f32
        linalg.yield %15 : f32
      }
    }
  }
  return
}

// *** IR Dump After LinalgLowerToLoops ***
func @predict_dispatch_5() {
  %cst = constant opaque<"_", "0xDEADBEEF"> : tensor<1x10xf32>
  %c10 = constant 10 : index
  %c0 = constant 0 : index
  %c1 = constant 1 : index
  %0 = memref.buffer_cast %cst : memref<1x10xf32>
  %1 = hal.interface.binding.subspan @io::@s0b0_ro_external[%c0] : memref<1x10xf32>
  %2 = hal.interface.binding.subspan @io::@s0b1_ro_external[%c0] : memref<f32>
  %3 = hal.interface.binding.subspan @io::@s0b2_xw_external[%c0] : memref<10xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %4 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_y]
  %5 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_y]
  scf.for %arg0 = %4 to %c1 step %5 {
    %6 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
    %7 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
    scf.for %arg1 = %6 to %c10 step %7 {
      %8 = affine.min affine_map<(d0) -> (128, -d0 + 1)>(%arg0)
      %9 = affine.min affine_map<(d0) -> (128, -d0 + 10)>(%arg1)
      %10 = memref.subview %1[%arg0, %arg1] [%8, %9] [1, 1] : memref<1x10xf32> to memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
      %11 = memref.subview %0[%arg0, %arg1] [%8, %9] [1, 1] : memref<1x10xf32> to memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
      %12 = memref.subview %3[%arg1] [%9] [1] : memref<10xf32> to memref<?xf32, affine_map<(d0)[s0] -> (d0 + s0)>>
      scf.for %arg2 = %c0 to %8 step %c1 {
        scf.for %arg3 = %c0 to %9 step %c1 {
          %13 = memref.load %10[%arg2, %arg3] : memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
          %14 = memref.load %11[%arg2, %arg3] : memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
          %15 = memref.load %2[] : memref<f32>
          %16 = addf %13, %14 : f32
          %17 = subf %16, %15 : f32
          %18 = math.exp %17 : f32
          memref.store %18, %12[%arg3] : memref<?xf32, affine_map<(d0)[s0] -> (d0 + s0)>>
        }
      }
    }
  }
  return
}

// *** IR Dump After Canonicalizer ***
func @predict_dispatch_5() {
  %cst = constant opaque<"_", "0xDEADBEEF"> : tensor<1x10xf32>
  %c10 = constant 10 : index
  %c0 = constant 0 : index
  %c1 = constant 1 : index
  %0 = memref.buffer_cast %cst : memref<1x10xf32>
  %1 = hal.interface.binding.subspan @io::@s0b0_ro_external[%c0] : memref<1x10xf32>
  %2 = hal.interface.binding.subspan @io::@s0b1_ro_external[%c0] : memref<f32>
  %3 = hal.interface.binding.subspan @io::@s0b2_xw_external[%c0] : memref<10xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %4 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_y]
  %5 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_y]
  scf.for %arg0 = %4 to %c1 step %5 {
    %6 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
    %7 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
    scf.for %arg1 = %6 to %c10 step %7 {
      %8 = affine.min affine_map<(d0) -> (128, -d0 + 1)>(%arg0)
      %9 = affine.min affine_map<(d0) -> (128, -d0 + 10)>(%arg1)
      %10 = memref.subview %1[%arg0, %arg1] [%8, %9] [1, 1] : memref<1x10xf32> to memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
      %11 = memref.subview %0[%arg0, %arg1] [%8, %9] [1, 1] : memref<1x10xf32> to memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
      %12 = memref.subview %3[%arg1] [%9] [1] : memref<10xf32> to memref<?xf32, affine_map<(d0)[s0] -> (d0 + s0)>>
      scf.for %arg2 = %c0 to %8 step %c1 {
        scf.for %arg3 = %c0 to %9 step %c1 {
          %13 = memref.load %10[%arg2, %arg3] : memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
          %14 = memref.load %11[%arg2, %arg3] : memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
          %15 = memref.load %2[] : memref<f32>
          %16 = addf %13, %14 : f32
          %17 = subf %16, %15 : f32
          %18 = math.exp %17 : f32
          memref.store %18, %12[%arg3] : memref<?xf32, affine_map<(d0)[s0] -> (d0 + s0)>>
        }
      }
    }
  }
  return
}

// *** IR Dump After CSE ***
func @predict_dispatch_5() {
  %cst = constant opaque<"_", "0xDEADBEEF"> : tensor<1x10xf32>
  %c10 = constant 10 : index
  %c0 = constant 0 : index
  %c1 = constant 1 : index
  %0 = memref.buffer_cast %cst : memref<1x10xf32>
  %1 = hal.interface.binding.subspan @io::@s0b0_ro_external[%c0] : memref<1x10xf32>
  %2 = hal.interface.binding.subspan @io::@s0b1_ro_external[%c0] : memref<f32>
  %3 = hal.interface.binding.subspan @io::@s0b2_xw_external[%c0] : memref<10xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %4 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_y]
  %5 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_y]
  scf.for %arg0 = %4 to %c1 step %5 {
    %6 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
    %7 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
    scf.for %arg1 = %6 to %c10 step %7 {
      %8 = affine.min affine_map<(d0) -> (128, -d0 + 1)>(%arg0)
      %9 = affine.min affine_map<(d0) -> (128, -d0 + 10)>(%arg1)
      %10 = memref.subview %1[%arg0, %arg1] [%8, %9] [1, 1] : memref<1x10xf32> to memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
      %11 = memref.subview %0[%arg0, %arg1] [%8, %9] [1, 1] : memref<1x10xf32> to memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
      %12 = memref.subview %3[%arg1] [%9] [1] : memref<10xf32> to memref<?xf32, affine_map<(d0)[s0] -> (d0 + s0)>>
      scf.for %arg2 = %c0 to %8 step %c1 {
        scf.for %arg3 = %c0 to %9 step %c1 {
          %13 = memref.load %10[%arg2, %arg3] : memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
          %14 = memref.load %11[%arg2, %arg3] : memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
          %15 = memref.load %2[] : memref<f32>
          %16 = addf %13, %14 : f32
          %17 = subf %16, %15 : f32
          %18 = math.exp %17 : f32
          memref.store %18, %12[%arg3] : memref<?xf32, affine_map<(d0)[s0] -> (d0 + s0)>>
        }
      }
    }
  }
  return
}

// *** IR Dump After SCFToStandard ***
func @predict_dispatch_5() {
  %cst = constant opaque<"_", "0xDEADBEEF"> : tensor<1x10xf32>
  %c10 = constant 10 : index
  %c0 = constant 0 : index
  %c1 = constant 1 : index
  %0 = memref.buffer_cast %cst : memref<1x10xf32>
  %1 = hal.interface.binding.subspan @io::@s0b0_ro_external[%c0] : memref<1x10xf32>
  %2 = hal.interface.binding.subspan @io::@s0b1_ro_external[%c0] : memref<f32>
  %3 = hal.interface.binding.subspan @io::@s0b2_xw_external[%c0] : memref<10xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %4 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_y]
  %5 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_y]
  br ^bb1(%4 : index)
^bb1(%6: index):  // 2 preds: ^bb0, ^bb11
  %7 = cmpi slt, %6, %c1 : index
  cond_br %7, ^bb2, ^bb12
^bb2:  // pred: ^bb1
  %8 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %9 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
  br ^bb3(%8 : index)
^bb3(%10: index):  // 2 preds: ^bb2, ^bb10
  %11 = cmpi slt, %10, %c10 : index
  cond_br %11, ^bb4, ^bb11
^bb4:  // pred: ^bb3
  %12 = affine.min affine_map<(d0) -> (128, -d0 + 1)>(%6)
  %13 = affine.min affine_map<(d0) -> (128, -d0 + 10)>(%10)
  %14 = memref.subview %1[%6, %10] [%12, %13] [1, 1] : memref<1x10xf32> to memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
  %15 = memref.subview %0[%6, %10] [%12, %13] [1, 1] : memref<1x10xf32> to memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
  %16 = memref.subview %3[%10] [%13] [1] : memref<10xf32> to memref<?xf32, affine_map<(d0)[s0] -> (d0 + s0)>>
  br ^bb5(%c0 : index)
^bb5(%17: index):  // 2 preds: ^bb4, ^bb9
  %18 = cmpi slt, %17, %12 : index
  cond_br %18, ^bb6, ^bb10
^bb6:  // pred: ^bb5
  br ^bb7(%c0 : index)
^bb7(%19: index):  // 2 preds: ^bb6, ^bb8
  %20 = cmpi slt, %19, %13 : index
  cond_br %20, ^bb8, ^bb9
^bb8:  // pred: ^bb7
  %21 = memref.load %14[%17, %19] : memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
  %22 = memref.load %15[%17, %19] : memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
  %23 = memref.load %2[] : memref<f32>
  %24 = addf %21, %22 : f32
  %25 = subf %24, %23 : f32
  %26 = math.exp %25 : f32
  memref.store %26, %16[%19] : memref<?xf32, affine_map<(d0)[s0] -> (d0 + s0)>>
  %27 = addi %19, %c1 : index
  br ^bb7(%27 : index)
^bb9:  // pred: ^bb7
  %28 = addi %17, %c1 : index
  br ^bb5(%28 : index)
^bb10:  // pred: ^bb5
  %29 = addi %10, %9 : index
  br ^bb3(%29 : index)
^bb11:  // pred: ^bb3
  %30 = addi %6, %5 : index
  br ^bb1(%30 : index)
^bb12:  // pred: ^bb1
  return
}

// *** IR Dump After Canonicalizer ***
func @predict_dispatch_5() {
  %cst = constant opaque<"_", "0xDEADBEEF"> : tensor<1x10xf32>
  %c10 = constant 10 : index
  %c0 = constant 0 : index
  %c1 = constant 1 : index
  %0 = memref.buffer_cast %cst : memref<1x10xf32>
  %1 = hal.interface.binding.subspan @io::@s0b0_ro_external[%c0] : memref<1x10xf32>
  %2 = hal.interface.binding.subspan @io::@s0b1_ro_external[%c0] : memref<f32>
  %3 = hal.interface.binding.subspan @io::@s0b2_xw_external[%c0] : memref<10xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %4 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_y]
  %5 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_y]
  br ^bb1(%4 : index)
^bb1(%6: index):  // 2 preds: ^bb0, ^bb10
  %7 = cmpi slt, %6, %c1 : index
  cond_br %7, ^bb2, ^bb11
^bb2:  // pred: ^bb1
  %8 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %9 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
  br ^bb3(%8 : index)
^bb3(%10: index):  // 2 preds: ^bb2, ^bb9
  %11 = cmpi slt, %10, %c10 : index
  cond_br %11, ^bb4, ^bb10
^bb4:  // pred: ^bb3
  %12 = affine.min affine_map<()[s0] -> (128, -s0 + 1)>()[%6]
  %13 = affine.min affine_map<()[s0] -> (128, -s0 + 10)>()[%10]
  %14 = memref.subview %1[%6, %10] [%12, %13] [1, 1] : memref<1x10xf32> to memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
  %15 = memref.subview %0[%6, %10] [%12, %13] [1, 1] : memref<1x10xf32> to memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
  %16 = memref.subview %3[%10] [%13] [1] : memref<10xf32> to memref<?xf32, affine_map<(d0)[s0] -> (d0 + s0)>>
  br ^bb5(%c0 : index)
^bb5(%17: index):  // 2 preds: ^bb4, ^bb8
  %18 = cmpi slt, %17, %12 : index
  cond_br %18, ^bb6(%c0 : index), ^bb9
^bb6(%19: index):  // 2 preds: ^bb5, ^bb7
  %20 = cmpi slt, %19, %13 : index
  cond_br %20, ^bb7, ^bb8
^bb7:  // pred: ^bb6
  %21 = memref.load %14[%17, %19] : memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
  %22 = memref.load %15[%17, %19] : memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
  %23 = memref.load %2[] : memref<f32>
  %24 = addf %21, %22 : f32
  %25 = subf %24, %23 : f32
  %26 = math.exp %25 : f32
  memref.store %26, %16[%19] : memref<?xf32, affine_map<(d0)[s0] -> (d0 + s0)>>
  %27 = addi %19, %c1 : index
  br ^bb6(%27 : index)
^bb8:  // pred: ^bb6
  %28 = addi %17, %c1 : index
  br ^bb5(%28 : index)
^bb9:  // pred: ^bb5
  %29 = addi %10, %9 : index
  br ^bb3(%29 : index)
^bb10:  // pred: ^bb3
  %30 = addi %6, %5 : index
  br ^bb1(%30 : index)
^bb11:  // pred: ^bb1
  return
}

// *** IR Dump After CSE ***
func @predict_dispatch_5() {
  %cst = constant opaque<"_", "0xDEADBEEF"> : tensor<1x10xf32>
  %c10 = constant 10 : index
  %c0 = constant 0 : index
  %c1 = constant 1 : index
  %0 = memref.buffer_cast %cst : memref<1x10xf32>
  %1 = hal.interface.binding.subspan @io::@s0b0_ro_external[%c0] : memref<1x10xf32>
  %2 = hal.interface.binding.subspan @io::@s0b1_ro_external[%c0] : memref<f32>
  %3 = hal.interface.binding.subspan @io::@s0b2_xw_external[%c0] : memref<10xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %4 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_y]
  %5 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_y]
  br ^bb1(%4 : index)
^bb1(%6: index):  // 2 preds: ^bb0, ^bb10
  %7 = cmpi slt, %6, %c1 : index
  cond_br %7, ^bb2, ^bb11
^bb2:  // pred: ^bb1
  %8 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %9 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
  br ^bb3(%8 : index)
^bb3(%10: index):  // 2 preds: ^bb2, ^bb9
  %11 = cmpi slt, %10, %c10 : index
  cond_br %11, ^bb4, ^bb10
^bb4:  // pred: ^bb3
  %12 = affine.min affine_map<()[s0] -> (128, -s0 + 1)>()[%6]
  %13 = affine.min affine_map<()[s0] -> (128, -s0 + 10)>()[%10]
  %14 = memref.subview %1[%6, %10] [%12, %13] [1, 1] : memref<1x10xf32> to memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
  %15 = memref.subview %0[%6, %10] [%12, %13] [1, 1] : memref<1x10xf32> to memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
  %16 = memref.subview %3[%10] [%13] [1] : memref<10xf32> to memref<?xf32, affine_map<(d0)[s0] -> (d0 + s0)>>
  br ^bb5(%c0 : index)
^bb5(%17: index):  // 2 preds: ^bb4, ^bb8
  %18 = cmpi slt, %17, %12 : index
  cond_br %18, ^bb6(%c0 : index), ^bb9
^bb6(%19: index):  // 2 preds: ^bb5, ^bb7
  %20 = cmpi slt, %19, %13 : index
  cond_br %20, ^bb7, ^bb8
^bb7:  // pred: ^bb6
  %21 = memref.load %14[%17, %19] : memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
  %22 = memref.load %15[%17, %19] : memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
  %23 = memref.load %2[] : memref<f32>
  %24 = addf %21, %22 : f32
  %25 = subf %24, %23 : f32
  %26 = math.exp %25 : f32
  memref.store %26, %16[%19] : memref<?xf32, affine_map<(d0)[s0] -> (d0 + s0)>>
  %27 = addi %19, %c1 : index
  br ^bb6(%27 : index)
^bb8:  // pred: ^bb6
  %28 = addi %17, %c1 : index
  br ^bb5(%28 : index)
^bb9:  // pred: ^bb5
  %29 = addi %10, %9 : index
  br ^bb3(%29 : index)
^bb10:  // pred: ^bb3
  %30 = addi %6, %5 : index
  br ^bb1(%30 : index)
^bb11:  // pred: ^bb1
  return
}

// *** IR Dump After TensorConstantBufferize ***
module  {
  memref.global "private" constant @__constant_1x10xf32 : memref<1x10xf32> = opaque<"_", "0xDEADBEEF">
  func @predict_dispatch_5() {
    %0 = memref.get_global @__constant_1x10xf32 : memref<1x10xf32>
    %1 = memref.tensor_load %0 : memref<1x10xf32>
    %c10 = constant 10 : index
    %c0 = constant 0 : index
    %c1 = constant 1 : index
    %2 = memref.buffer_cast %1 : memref<1x10xf32>
    %3 = hal.interface.binding.subspan @io::@s0b0_ro_external[%c0] : memref<1x10xf32>
    %4 = hal.interface.binding.subspan @io::@s0b1_ro_external[%c0] : memref<f32>
    %5 = hal.interface.binding.subspan @io::@s0b2_xw_external[%c0] : memref<10xf32>
    %workgroup_id_x = hal.interface.workgroup.id[0] : index
    %workgroup_count_x = hal.interface.workgroup.count[0] : index
    %workgroup_id_y = hal.interface.workgroup.id[1] : index
    %workgroup_count_y = hal.interface.workgroup.count[1] : index
    %6 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_y]
    %7 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_y]
    br ^bb1(%6 : index)
  ^bb1(%8: index):  // 2 preds: ^bb0, ^bb10
    %9 = cmpi slt, %8, %c1 : index
    cond_br %9, ^bb2, ^bb11
  ^bb2:  // pred: ^bb1
    %10 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
    %11 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
    br ^bb3(%10 : index)
  ^bb3(%12: index):  // 2 preds: ^bb2, ^bb9
    %13 = cmpi slt, %12, %c10 : index
    cond_br %13, ^bb4, ^bb10
  ^bb4:  // pred: ^bb3
    %14 = affine.min affine_map<()[s0] -> (128, -s0 + 1)>()[%8]
    %15 = affine.min affine_map<()[s0] -> (128, -s0 + 10)>()[%12]
    %16 = memref.subview %3[%8, %12] [%14, %15] [1, 1] : memref<1x10xf32> to memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
    %17 = memref.subview %2[%8, %12] [%14, %15] [1, 1] : memref<1x10xf32> to memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
    %18 = memref.subview %5[%12] [%15] [1] : memref<10xf32> to memref<?xf32, affine_map<(d0)[s0] -> (d0 + s0)>>
    br ^bb5(%c0 : index)
  ^bb5(%19: index):  // 2 preds: ^bb4, ^bb8
    %20 = cmpi slt, %19, %14 : index
    cond_br %20, ^bb6(%c0 : index), ^bb9
  ^bb6(%21: index):  // 2 preds: ^bb5, ^bb7
    %22 = cmpi slt, %21, %15 : index
    cond_br %22, ^bb7, ^bb8
  ^bb7:  // pred: ^bb6
    %23 = memref.load %16[%19, %21] : memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
    %24 = memref.load %17[%19, %21] : memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
    %25 = memref.load %4[] : memref<f32>
    %26 = addf %23, %24 : f32
    %27 = subf %26, %25 : f32
    %28 = math.exp %27 : f32
    memref.store %28, %18[%21] : memref<?xf32, affine_map<(d0)[s0] -> (d0 + s0)>>
    %29 = addi %21, %c1 : index
    br ^bb6(%29 : index)
  ^bb8:  // pred: ^bb6
    %30 = addi %19, %c1 : index
    br ^bb5(%30 : index)
  ^bb9:  // pred: ^bb5
    %31 = addi %12, %11 : index
    br ^bb3(%31 : index)
  ^bb10:  // pred: ^bb3
    %32 = addi %8, %7 : index
    br ^bb1(%32 : index)
  ^bb11:  // pred: ^bb1
    return
  }
  hal.interface @io attributes {sym_visibility = "private"} {
    hal.interface.binding @s0b0_ro_external, set=0, binding=0, type="StorageBuffer", access="Read"
    hal.interface.binding @s0b1_ro_external, set=0, binding=1, type="StorageBuffer", access="Read"
    hal.interface.binding @s0b2_xw_external, set=0, binding=2, type="StorageBuffer", access="Write|Discard"
  }
}

// *** IR Dump After mlir::iree_compiler::`anonymous-namespace'::FoldTensorExtractOpPass ***
module  {
  memref.global "private" constant @__constant_1x10xf32 : memref<1x10xf32> = opaque<"_", "0xDEADBEEF">
  func @predict_dispatch_5() {
    %c10 = constant 10 : index
    %c0 = constant 0 : index
    %c1 = constant 1 : index
    %0 = memref.get_global @__constant_1x10xf32 : memref<1x10xf32>
    %1 = hal.interface.binding.subspan @io::@s0b0_ro_external[%c0] : memref<1x10xf32>
    %2 = hal.interface.binding.subspan @io::@s0b1_ro_external[%c0] : memref<f32>
    %3 = hal.interface.binding.subspan @io::@s0b2_xw_external[%c0] : memref<10xf32>
    %workgroup_id_x = hal.interface.workgroup.id[0] : index
    %workgroup_count_x = hal.interface.workgroup.count[0] : index
    %workgroup_id_y = hal.interface.workgroup.id[1] : index
    %workgroup_count_y = hal.interface.workgroup.count[1] : index
    %4 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_y]
    %5 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_y]
    br ^bb1(%4 : index)
  ^bb1(%6: index):  // 2 preds: ^bb0, ^bb10
    %7 = cmpi slt, %6, %c1 : index
    cond_br %7, ^bb2, ^bb11
  ^bb2:  // pred: ^bb1
    %8 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
    %9 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
    br ^bb3(%8 : index)
  ^bb3(%10: index):  // 2 preds: ^bb2, ^bb9
    %11 = cmpi slt, %10, %c10 : index
    cond_br %11, ^bb4, ^bb10
  ^bb4:  // pred: ^bb3
    %12 = affine.min affine_map<()[s0] -> (128, -s0 + 1)>()[%6]
    %13 = affine.min affine_map<()[s0] -> (128, -s0 + 10)>()[%10]
    %14 = memref.subview %1[%6, %10] [%12, %13] [1, 1] : memref<1x10xf32> to memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
    %15 = memref.subview %0[%6, %10] [%12, %13] [1, 1] : memref<1x10xf32> to memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
    %16 = memref.subview %3[%10] [%13] [1] : memref<10xf32> to memref<?xf32, affine_map<(d0)[s0] -> (d0 + s0)>>
    br ^bb5(%c0 : index)
  ^bb5(%17: index):  // 2 preds: ^bb4, ^bb8
    %18 = cmpi slt, %17, %12 : index
    cond_br %18, ^bb6(%c0 : index), ^bb9
  ^bb6(%19: index):  // 2 preds: ^bb5, ^bb7
    %20 = cmpi slt, %19, %13 : index
    cond_br %20, ^bb7, ^bb8
  ^bb7:  // pred: ^bb6
    %21 = memref.load %14[%17, %19] : memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
    %22 = memref.load %15[%17, %19] : memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
    %23 = memref.load %2[] : memref<f32>
    %24 = addf %21, %22 : f32
    %25 = subf %24, %23 : f32
    %26 = math.exp %25 : f32
    memref.store %26, %16[%19] : memref<?xf32, affine_map<(d0)[s0] -> (d0 + s0)>>
    %27 = addi %19, %c1 : index
    br ^bb6(%27 : index)
  ^bb8:  // pred: ^bb6
    %28 = addi %17, %c1 : index
    br ^bb5(%28 : index)
  ^bb9:  // pred: ^bb5
    %29 = addi %10, %9 : index
    br ^bb3(%29 : index)
  ^bb10:  // pred: ^bb3
    %30 = addi %6, %5 : index
    br ^bb1(%30 : index)
  ^bb11:  // pred: ^bb1
    return
  }
  hal.interface @io attributes {sym_visibility = "private"} {
    hal.interface.binding @s0b0_ro_external, set=0, binding=0, type="StorageBuffer", access="Read"
    hal.interface.binding @s0b1_ro_external, set=0, binding=1, type="StorageBuffer", access="Read"
    hal.interface.binding @s0b2_xw_external, set=0, binding=2, type="StorageBuffer", access="Write|Discard"
  }
}

// *** IR Dump After mlir::iree_compiler::`anonymous-namespace'::ConvertToLLVMPass ***
module  {
  llvm.mlir.global private constant @__constant_1x10xf32(opaque<"_", "0xDEADBEEF"> : tensor<1x10xf32>) : !llvm.array<1 x array<10 x f32>>
  llvm.func internal @predict_dispatch_5(%arg0: !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>, %arg1: !llvm.ptr<array<3 x i32>>) -> i32 {
    %0 = llvm.mlir.constant(10 : index) : i64
    %1 = llvm.mlir.constant(0 : index) : i64
    %2 = llvm.mlir.constant(1 : index) : i64
    %3 = llvm.mlir.constant(0.693147182 : f32) : f32
    %4 = llvm.mlir.constant(1.44269502 : f32) : f32
    %5 = llvm.mlir.constant(1.000000e+00 : f32) : f32
    %6 = llvm.mlir.constant(0.499705136 : f32) : f32
    %7 = llvm.mlir.constant(0.168738902 : f32) : f32
    %8 = llvm.mlir.constant(0.0366896503 : f32) : f32
    %9 = llvm.mlir.constant(1.314350e-02 : f32) : f32
    %10 = llvm.mlir.constant(23 : i32) : i32
    %11 = llvm.mlir.constant(0.000000e+00 : f32) : f32
    %12 = llvm.mlir.constant(0x7F800000 : f32) : f32
    %13 = llvm.mlir.constant(0xFF800000 : f32) : f32
    %14 = llvm.mlir.constant(1.17549435E-38 : f32) : f32
    %15 = llvm.mlir.constant(127 : i32) : i32
    %16 = llvm.mlir.constant(-127 : i32) : i32
    %17 = llvm.mlir.constant(1 : index) : i64
    %18 = llvm.mlir.constant(10 : index) : i64
    %19 = llvm.mlir.constant(1 : index) : i64
    %20 = llvm.mlir.constant(10 : index) : i64
    %21 = llvm.mlir.null : !llvm.ptr<f32>
    %22 = llvm.getelementptr %21[%20] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %23 = llvm.ptrtoint %22 : !llvm.ptr<f32> to i64
    %24 = llvm.mlir.addressof @__constant_1x10xf32 : !llvm.ptr<array<1 x array<10 x f32>>>
    %25 = llvm.mlir.constant(0 : index) : i64
    %26 = llvm.getelementptr %24[%25, %25, %25] : (!llvm.ptr<array<1 x array<10 x f32>>>, i64, i64, i64) -> !llvm.ptr<f32>
    %27 = llvm.mlir.constant(3735928559 : index) : i64
    %28 = llvm.inttoptr %27 : i64 to !llvm.ptr<f32>
    %29 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %30 = llvm.insertvalue %28, %29[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %31 = llvm.insertvalue %26, %30[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %32 = llvm.mlir.constant(0 : index) : i64
    %33 = llvm.insertvalue %32, %31[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %34 = llvm.insertvalue %17, %33[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %35 = llvm.insertvalue %18, %34[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %36 = llvm.insertvalue %18, %35[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %37 = llvm.insertvalue %19, %36[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %38 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
    %39 = llvm.extractvalue %38[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
    %40 = llvm.mlir.constant(0 : index) : i64
    %41 = llvm.getelementptr %39[%40] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
    %42 = llvm.load %41 : !llvm.ptr<ptr<i8>>
    %43 = llvm.getelementptr %42[%1] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
    %44 = llvm.bitcast %43 : !llvm.ptr<i8> to !llvm.ptr<f32>
    %45 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %46 = llvm.insertvalue %44, %45[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %47 = llvm.insertvalue %44, %46[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %48 = llvm.mlir.constant(0 : index) : i64
    %49 = llvm.insertvalue %48, %47[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %50 = llvm.mlir.constant(1 : index) : i64
    %51 = llvm.insertvalue %50, %49[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %52 = llvm.mlir.constant(10 : index) : i64
    %53 = llvm.insertvalue %52, %51[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %54 = llvm.mlir.constant(10 : index) : i64
    %55 = llvm.insertvalue %54, %53[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %56 = llvm.mlir.constant(1 : index) : i64
    %57 = llvm.insertvalue %56, %55[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %58 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
    %59 = llvm.extractvalue %58[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
    %60 = llvm.mlir.constant(1 : index) : i64
    %61 = llvm.getelementptr %59[%60] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
    %62 = llvm.load %61 : !llvm.ptr<ptr<i8>>
    %63 = llvm.getelementptr %62[%1] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
    %64 = llvm.bitcast %63 : !llvm.ptr<i8> to !llvm.ptr<f32>
    %65 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
    %66 = llvm.insertvalue %64, %65[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
    %67 = llvm.insertvalue %64, %66[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
    %68 = llvm.mlir.constant(0 : index) : i64
    %69 = llvm.insertvalue %68, %67[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
    %70 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
    %71 = llvm.extractvalue %70[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
    %72 = llvm.mlir.constant(2 : index) : i64
    %73 = llvm.getelementptr %71[%72] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
    %74 = llvm.load %73 : !llvm.ptr<ptr<i8>>
    %75 = llvm.getelementptr %74[%1] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
    %76 = llvm.bitcast %75 : !llvm.ptr<i8> to !llvm.ptr<f32>
    %77 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
    %78 = llvm.insertvalue %76, %77[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
    %79 = llvm.insertvalue %76, %78[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
    %80 = llvm.mlir.constant(0 : index) : i64
    %81 = llvm.insertvalue %80, %79[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
    %82 = llvm.mlir.constant(10 : index) : i64
    %83 = llvm.insertvalue %82, %81[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
    %84 = llvm.mlir.constant(1 : index) : i64
    %85 = llvm.insertvalue %84, %83[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
    %86 = llvm.load %arg1 : !llvm.ptr<array<3 x i32>>
    %87 = llvm.extractvalue %86[0] : !llvm.array<3 x i32>
    %88 = llvm.zext %87 : i32 to i64
    %89 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
    %90 = llvm.extractvalue %89[0] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
    %91 = llvm.extractvalue %90[0] : !llvm.array<3 x i32>
    %92 = llvm.zext %91 : i32 to i64
    %93 = llvm.load %arg1 : !llvm.ptr<array<3 x i32>>
    %94 = llvm.extractvalue %93[1] : !llvm.array<3 x i32>
    %95 = llvm.zext %94 : i32 to i64
    %96 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
    %97 = llvm.extractvalue %96[0] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
    %98 = llvm.extractvalue %97[1] : !llvm.array<3 x i32>
    %99 = llvm.zext %98 : i32 to i64
    %100 = llvm.mlir.constant(128 : index) : i64
    %101 = llvm.mul %95, %100  : i64
    %102 = llvm.mlir.constant(128 : index) : i64
    %103 = llvm.mul %99, %102  : i64
    llvm.br ^bb1(%101 : i64)
  ^bb1(%104: i64):  // 2 preds: ^bb0, ^bb10
    %105 = llvm.icmp "slt" %104, %2 : i64
    llvm.cond_br %105, ^bb2, ^bb11
  ^bb2:  // pred: ^bb1
    %106 = llvm.mlir.constant(128 : index) : i64
    %107 = llvm.mul %88, %106  : i64
    %108 = llvm.mlir.constant(128 : index) : i64
    %109 = llvm.mul %92, %108  : i64
    llvm.br ^bb3(%107 : i64)
  ^bb3(%110: i64):  // 2 preds: ^bb2, ^bb9
    %111 = llvm.icmp "slt" %110, %0 : i64
    llvm.cond_br %111, ^bb4, ^bb10
  ^bb4:  // pred: ^bb3
    %112 = llvm.mlir.constant(128 : index) : i64
    %113 = llvm.mlir.constant(-1 : index) : i64
    %114 = llvm.mul %104, %113  : i64
    %115 = llvm.mlir.constant(1 : index) : i64
    %116 = llvm.add %114, %115  : i64
    %117 = llvm.icmp "slt" %112, %116 : i64
    %118 = llvm.select %117, %112, %116 : i1, i64
    %119 = llvm.mlir.constant(128 : index) : i64
    %120 = llvm.mlir.constant(-1 : index) : i64
    %121 = llvm.mul %110, %120  : i64
    %122 = llvm.mlir.constant(10 : index) : i64
    %123 = llvm.add %121, %122  : i64
    %124 = llvm.icmp "slt" %119, %123 : i64
    %125 = llvm.select %124, %119, %123 : i1, i64
    %126 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %127 = llvm.extractvalue %57[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %128 = llvm.bitcast %127 : !llvm.ptr<f32> to !llvm.ptr<f32>
    %129 = llvm.insertvalue %128, %126[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %130 = llvm.extractvalue %57[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %131 = llvm.bitcast %130 : !llvm.ptr<f32> to !llvm.ptr<f32>
    %132 = llvm.insertvalue %131, %129[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %133 = llvm.extractvalue %57[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %134 = llvm.extractvalue %57[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %135 = llvm.extractvalue %57[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %136 = llvm.mul %104, %133  : i64
    %137 = llvm.add %135, %136  : i64
    %138 = llvm.mul %110, %134  : i64
    %139 = llvm.add %137, %138  : i64
    %140 = llvm.insertvalue %139, %132[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %141 = llvm.mlir.constant(1 : i64) : i64
    %142 = llvm.insertvalue %125, %140[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %143 = llvm.insertvalue %141, %142[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %144 = llvm.mlir.constant(10 : i64) : i64
    %145 = llvm.insertvalue %118, %143[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %146 = llvm.insertvalue %144, %145[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %147 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %148 = llvm.extractvalue %37[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %149 = llvm.bitcast %148 : !llvm.ptr<f32> to !llvm.ptr<f32>
    %150 = llvm.insertvalue %149, %147[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %151 = llvm.extractvalue %37[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %152 = llvm.bitcast %151 : !llvm.ptr<f32> to !llvm.ptr<f32>
    %153 = llvm.insertvalue %152, %150[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %154 = llvm.extractvalue %37[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %155 = llvm.extractvalue %37[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %156 = llvm.extractvalue %37[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %157 = llvm.mul %104, %154  : i64
    %158 = llvm.add %156, %157  : i64
    %159 = llvm.mul %110, %155  : i64
    %160 = llvm.add %158, %159  : i64
    %161 = llvm.insertvalue %160, %153[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %162 = llvm.mlir.constant(1 : i64) : i64
    %163 = llvm.insertvalue %125, %161[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %164 = llvm.insertvalue %162, %163[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %165 = llvm.mlir.constant(10 : i64) : i64
    %166 = llvm.insertvalue %118, %164[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %167 = llvm.insertvalue %165, %166[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %168 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
    %169 = llvm.extractvalue %85[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
    %170 = llvm.bitcast %169 : !llvm.ptr<f32> to !llvm.ptr<f32>
    %171 = llvm.insertvalue %170, %168[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
    %172 = llvm.extractvalue %85[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
    %173 = llvm.bitcast %172 : !llvm.ptr<f32> to !llvm.ptr<f32>
    %174 = llvm.insertvalue %173, %171[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
    %175 = llvm.extractvalue %85[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
    %176 = llvm.extractvalue %85[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
    %177 = llvm.mul %110, %175  : i64
    %178 = llvm.add %176, %177  : i64
    %179 = llvm.insertvalue %178, %174[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
    %180 = llvm.mlir.constant(1 : i64) : i64
    %181 = llvm.insertvalue %125, %179[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
    %182 = llvm.insertvalue %180, %181[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
    llvm.br ^bb5(%1 : i64)
  ^bb5(%183: i64):  // 2 preds: ^bb4, ^bb8
    %184 = llvm.icmp "slt" %183, %118 : i64
    llvm.cond_br %184, ^bb6(%1 : i64), ^bb9
  ^bb6(%185: i64):  // 2 preds: ^bb5, ^bb7
    %186 = llvm.icmp "slt" %185, %125 : i64
    llvm.cond_br %186, ^bb7, ^bb8
  ^bb7:  // pred: ^bb6
    %187 = llvm.extractvalue %146[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %188 = llvm.extractvalue %146[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %189 = llvm.mlir.constant(10 : index) : i64
    %190 = llvm.mul %183, %189  : i64
    %191 = llvm.add %188, %190  : i64
    %192 = llvm.add %191, %185  : i64
    %193 = llvm.getelementptr %187[%192] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %194 = llvm.load %193 : !llvm.ptr<f32>
    %195 = llvm.extractvalue %167[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %196 = llvm.extractvalue %167[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %197 = llvm.mlir.constant(10 : index) : i64
    %198 = llvm.mul %183, %197  : i64
    %199 = llvm.add %196, %198  : i64
    %200 = llvm.add %199, %185  : i64
    %201 = llvm.getelementptr %195[%200] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %202 = llvm.load %201 : !llvm.ptr<f32>
    %203 = llvm.extractvalue %69[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
    %204 = llvm.load %203 : !llvm.ptr<f32>
    %205 = llvm.fadd %194, %202  : f32
    %206 = llvm.fsub %205, %204  : f32
    %207 = llvm.fmul %206, %4  : f32
    %208 = "llvm.intr.floor"(%207) : (f32) -> f32
    %209 = llvm.fmul %208, %3  : f32
    %210 = llvm.fsub %206, %209  : f32
    %211 = llvm.fmul %210, %210  : f32
    %212 = llvm.fmul %211, %211  : f32
    %213 = "llvm.intr.fma"(%5, %210, %5) : (f32, f32, f32) -> f32
    %214 = "llvm.intr.fma"(%7, %210, %6) : (f32, f32, f32) -> f32
    %215 = "llvm.intr.fma"(%9, %210, %8) : (f32, f32, f32) -> f32
    %216 = "llvm.intr.fma"(%214, %211, %213) : (f32, f32, f32) -> f32
    %217 = "llvm.intr.fma"(%215, %212, %216) : (f32, f32, f32) -> f32
    %218 = llvm.fptosi %208 : f32 to i32
    %219 = llvm.add %218, %15  : i32
    %220 = llvm.shl %219, %10  : i32
    %221 = llvm.bitcast %220 : i32 to f32
    %222 = llvm.fmul %217, %221  : f32
    %223 = llvm.icmp "sle" %218, %15 : i32
    %224 = llvm.icmp "sge" %218, %16 : i32
    %225 = llvm.fcmp "oeq" %206, %13 : f32
    %226 = llvm.fcmp "ogt" %206, %11 : f32
    %227 = llvm.and %223, %224  : i1
    %228 = llvm.select %225, %11, %14 : i1, f32
    %229 = llvm.select %226, %12, %228 : i1, f32
    %230 = llvm.select %227, %222, %229 : i1, f32
    %231 = llvm.extractvalue %182[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
    %232 = llvm.extractvalue %182[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
    %233 = llvm.add %232, %185  : i64
    %234 = llvm.getelementptr %231[%233] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    llvm.store %230, %234 : !llvm.ptr<f32>
    %235 = llvm.add %185, %2  : i64
    llvm.br ^bb6(%235 : i64)
  ^bb8:  // pred: ^bb6
    %236 = llvm.add %183, %2  : i64
    llvm.br ^bb5(%236 : i64)
  ^bb9:  // pred: ^bb5
    %237 = llvm.add %110, %109  : i64
    llvm.br ^bb3(%237 : i64)
  ^bb10:  // pred: ^bb3
    %238 = llvm.add %104, %103  : i64
    llvm.br ^bb1(%238 : i64)
  ^bb11:  // pred: ^bb1
    %239 = llvm.mlir.constant(0 : i32) : i32
    llvm.return %239 : i32
  }
}

// *** IR Dump After Canonicalizer ***
module  {
  llvm.mlir.global private constant @__constant_1x10xf32(opaque<"_", "0xDEADBEEF"> : tensor<1x10xf32>) : !llvm.array<1 x array<10 x f32>>
  llvm.func internal @predict_dispatch_5(%arg0: !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>, %arg1: !llvm.ptr<array<3 x i32>>) -> i32 {
    %0 = llvm.mlir.constant(10 : index) : i64
    %1 = llvm.mlir.constant(0 : index) : i64
    %2 = llvm.mlir.constant(1 : index) : i64
    %3 = llvm.mlir.constant(0.693147182 : f32) : f32
    %4 = llvm.mlir.constant(1.44269502 : f32) : f32
    %5 = llvm.mlir.constant(1.000000e+00 : f32) : f32
    %6 = llvm.mlir.constant(0.499705136 : f32) : f32
    %7 = llvm.mlir.constant(0.168738902 : f32) : f32
    %8 = llvm.mlir.constant(0.0366896503 : f32) : f32
    %9 = llvm.mlir.constant(1.314350e-02 : f32) : f32
    %10 = llvm.mlir.constant(23 : i32) : i32
    %11 = llvm.mlir.constant(0.000000e+00 : f32) : f32
    %12 = llvm.mlir.constant(0x7F800000 : f32) : f32
    %13 = llvm.mlir.constant(0xFF800000 : f32) : f32
    %14 = llvm.mlir.constant(1.17549435E-38 : f32) : f32
    %15 = llvm.mlir.constant(127 : i32) : i32
    %16 = llvm.mlir.constant(-127 : i32) : i32
    %17 = llvm.mlir.constant(1 : index) : i64
    %18 = llvm.mlir.constant(10 : index) : i64
    %19 = llvm.mlir.constant(1 : index) : i64
    %20 = llvm.mlir.addressof @__constant_1x10xf32 : !llvm.ptr<array<1 x array<10 x f32>>>
    %21 = llvm.mlir.constant(0 : index) : i64
    %22 = llvm.getelementptr %20[%21, %21, %21] : (!llvm.ptr<array<1 x array<10 x f32>>>, i64, i64, i64) -> !llvm.ptr<f32>
    %23 = llvm.mlir.constant(3735928559 : index) : i64
    %24 = llvm.inttoptr %23 : i64 to !llvm.ptr<f32>
    %25 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %26 = llvm.insertvalue %24, %25[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %27 = llvm.insertvalue %22, %26[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %28 = llvm.mlir.constant(0 : index) : i64
    %29 = llvm.insertvalue %28, %27[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %30 = llvm.insertvalue %17, %29[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %31 = llvm.insertvalue %18, %30[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %32 = llvm.insertvalue %18, %31[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %33 = llvm.insertvalue %19, %32[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %34 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
    %35 = llvm.extractvalue %34[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
    %36 = llvm.mlir.constant(0 : index) : i64
    %37 = llvm.getelementptr %35[%36] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
    %38 = llvm.load %37 : !llvm.ptr<ptr<i8>>
    %39 = llvm.getelementptr %38[%1] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
    %40 = llvm.bitcast %39 : !llvm.ptr<i8> to !llvm.ptr<f32>
    %41 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %42 = llvm.insertvalue %40, %41[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %43 = llvm.insertvalue %40, %42[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %44 = llvm.mlir.constant(0 : index) : i64
    %45 = llvm.insertvalue %44, %43[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %46 = llvm.mlir.constant(1 : index) : i64
    %47 = llvm.insertvalue %46, %45[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %48 = llvm.mlir.constant(10 : index) : i64
    %49 = llvm.insertvalue %48, %47[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %50 = llvm.mlir.constant(10 : index) : i64
    %51 = llvm.insertvalue %50, %49[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %52 = llvm.mlir.constant(1 : index) : i64
    %53 = llvm.insertvalue %52, %51[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %54 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
    %55 = llvm.extractvalue %54[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
    %56 = llvm.mlir.constant(1 : index) : i64
    %57 = llvm.getelementptr %55[%56] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
    %58 = llvm.load %57 : !llvm.ptr<ptr<i8>>
    %59 = llvm.getelementptr %58[%1] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
    %60 = llvm.bitcast %59 : !llvm.ptr<i8> to !llvm.ptr<f32>
    %61 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
    %62 = llvm.insertvalue %60, %61[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
    %63 = llvm.insertvalue %60, %62[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
    %64 = llvm.mlir.constant(0 : index) : i64
    %65 = llvm.insertvalue %64, %63[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
    %66 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
    %67 = llvm.extractvalue %66[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
    %68 = llvm.mlir.constant(2 : index) : i64
    %69 = llvm.getelementptr %67[%68] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
    %70 = llvm.load %69 : !llvm.ptr<ptr<i8>>
    %71 = llvm.getelementptr %70[%1] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
    %72 = llvm.bitcast %71 : !llvm.ptr<i8> to !llvm.ptr<f32>
    %73 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
    %74 = llvm.insertvalue %72, %73[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
    %75 = llvm.insertvalue %72, %74[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
    %76 = llvm.mlir.constant(0 : index) : i64
    %77 = llvm.insertvalue %76, %75[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
    %78 = llvm.mlir.constant(10 : index) : i64
    %79 = llvm.insertvalue %78, %77[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
    %80 = llvm.mlir.constant(1 : index) : i64
    %81 = llvm.insertvalue %80, %79[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
    %82 = llvm.load %arg1 : !llvm.ptr<array<3 x i32>>
    %83 = llvm.extractvalue %82[0] : !llvm.array<3 x i32>
    %84 = llvm.zext %83 : i32 to i64
    %85 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
    %86 = llvm.extractvalue %85[0] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
    %87 = llvm.extractvalue %86[0] : !llvm.array<3 x i32>
    %88 = llvm.zext %87 : i32 to i64
    %89 = llvm.load %arg1 : !llvm.ptr<array<3 x i32>>
    %90 = llvm.extractvalue %89[1] : !llvm.array<3 x i32>
    %91 = llvm.zext %90 : i32 to i64
    %92 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
    %93 = llvm.extractvalue %92[0] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
    %94 = llvm.extractvalue %93[1] : !llvm.array<3 x i32>
    %95 = llvm.zext %94 : i32 to i64
    %96 = llvm.mlir.constant(128 : index) : i64
    %97 = llvm.mul %91, %96  : i64
    %98 = llvm.mlir.constant(128 : index) : i64
    %99 = llvm.mul %95, %98  : i64
    llvm.br ^bb1(%97 : i64)
  ^bb1(%100: i64):  // 2 preds: ^bb0, ^bb10
    %101 = llvm.icmp "slt" %100, %2 : i64
    llvm.cond_br %101, ^bb2, ^bb11
  ^bb2:  // pred: ^bb1
    %102 = llvm.mlir.constant(128 : index) : i64
    %103 = llvm.mul %84, %102  : i64
    %104 = llvm.mlir.constant(128 : index) : i64
    %105 = llvm.mul %88, %104  : i64
    llvm.br ^bb3(%103 : i64)
  ^bb3(%106: i64):  // 2 preds: ^bb2, ^bb9
    %107 = llvm.icmp "slt" %106, %0 : i64
    llvm.cond_br %107, ^bb4, ^bb10
  ^bb4:  // pred: ^bb3
    %108 = llvm.mlir.constant(128 : index) : i64
    %109 = llvm.mlir.constant(-1 : index) : i64
    %110 = llvm.mul %100, %109  : i64
    %111 = llvm.mlir.constant(1 : index) : i64
    %112 = llvm.add %110, %111  : i64
    %113 = llvm.icmp "slt" %108, %112 : i64
    %114 = llvm.select %113, %108, %112 : i1, i64
    %115 = llvm.mlir.constant(128 : index) : i64
    %116 = llvm.mlir.constant(-1 : index) : i64
    %117 = llvm.mul %106, %116  : i64
    %118 = llvm.mlir.constant(10 : index) : i64
    %119 = llvm.add %117, %118  : i64
    %120 = llvm.icmp "slt" %115, %119 : i64
    %121 = llvm.select %120, %115, %119 : i1, i64
    %122 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %123 = llvm.extractvalue %53[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %124 = llvm.bitcast %123 : !llvm.ptr<f32> to !llvm.ptr<f32>
    %125 = llvm.insertvalue %124, %122[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %126 = llvm.extractvalue %53[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %127 = llvm.bitcast %126 : !llvm.ptr<f32> to !llvm.ptr<f32>
    %128 = llvm.insertvalue %127, %125[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %129 = llvm.extractvalue %53[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %130 = llvm.extractvalue %53[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %131 = llvm.extractvalue %53[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %132 = llvm.mul %100, %129  : i64
    %133 = llvm.add %131, %132  : i64
    %134 = llvm.mul %106, %130  : i64
    %135 = llvm.add %133, %134  : i64
    %136 = llvm.insertvalue %135, %128[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %137 = llvm.mlir.constant(1 : i64) : i64
    %138 = llvm.insertvalue %121, %136[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %139 = llvm.insertvalue %137, %138[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %140 = llvm.mlir.constant(10 : i64) : i64
    %141 = llvm.insertvalue %114, %139[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %142 = llvm.insertvalue %140, %141[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %143 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %144 = llvm.extractvalue %33[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %145 = llvm.bitcast %144 : !llvm.ptr<f32> to !llvm.ptr<f32>
    %146 = llvm.insertvalue %145, %143[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %147 = llvm.extractvalue %33[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %148 = llvm.bitcast %147 : !llvm.ptr<f32> to !llvm.ptr<f32>
    %149 = llvm.insertvalue %148, %146[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %150 = llvm.extractvalue %33[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %151 = llvm.extractvalue %33[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %152 = llvm.extractvalue %33[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %153 = llvm.mul %100, %150  : i64
    %154 = llvm.add %152, %153  : i64
    %155 = llvm.mul %106, %151  : i64
    %156 = llvm.add %154, %155  : i64
    %157 = llvm.insertvalue %156, %149[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %158 = llvm.mlir.constant(1 : i64) : i64
    %159 = llvm.insertvalue %121, %157[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %160 = llvm.insertvalue %158, %159[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %161 = llvm.mlir.constant(10 : i64) : i64
    %162 = llvm.insertvalue %114, %160[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %163 = llvm.insertvalue %161, %162[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %164 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
    %165 = llvm.extractvalue %81[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
    %166 = llvm.bitcast %165 : !llvm.ptr<f32> to !llvm.ptr<f32>
    %167 = llvm.insertvalue %166, %164[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
    %168 = llvm.extractvalue %81[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
    %169 = llvm.bitcast %168 : !llvm.ptr<f32> to !llvm.ptr<f32>
    %170 = llvm.insertvalue %169, %167[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
    %171 = llvm.extractvalue %81[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
    %172 = llvm.extractvalue %81[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
    %173 = llvm.mul %106, %171  : i64
    %174 = llvm.add %172, %173  : i64
    %175 = llvm.insertvalue %174, %170[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
    %176 = llvm.mlir.constant(1 : i64) : i64
    %177 = llvm.insertvalue %121, %175[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
    %178 = llvm.insertvalue %176, %177[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
    llvm.br ^bb5(%1 : i64)
  ^bb5(%179: i64):  // 2 preds: ^bb4, ^bb8
    %180 = llvm.icmp "slt" %179, %114 : i64
    llvm.cond_br %180, ^bb6(%1 : i64), ^bb9
  ^bb6(%181: i64):  // 2 preds: ^bb5, ^bb7
    %182 = llvm.icmp "slt" %181, %121 : i64
    llvm.cond_br %182, ^bb7, ^bb8
  ^bb7:  // pred: ^bb6
    %183 = llvm.extractvalue %142[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %184 = llvm.extractvalue %142[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %185 = llvm.mlir.constant(10 : index) : i64
    %186 = llvm.mul %179, %185  : i64
    %187 = llvm.add %184, %186  : i64
    %188 = llvm.add %187, %181  : i64
    %189 = llvm.getelementptr %183[%188] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %190 = llvm.load %189 : !llvm.ptr<f32>
    %191 = llvm.extractvalue %163[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %192 = llvm.extractvalue %163[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %193 = llvm.mlir.constant(10 : index) : i64
    %194 = llvm.mul %179, %193  : i64
    %195 = llvm.add %192, %194  : i64
    %196 = llvm.add %195, %181  : i64
    %197 = llvm.getelementptr %191[%196] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %198 = llvm.load %197 : !llvm.ptr<f32>
    %199 = llvm.extractvalue %65[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
    %200 = llvm.load %199 : !llvm.ptr<f32>
    %201 = llvm.fadd %190, %198  : f32
    %202 = llvm.fsub %201, %200  : f32
    %203 = llvm.fmul %202, %4  : f32
    %204 = "llvm.intr.floor"(%203) : (f32) -> f32
    %205 = llvm.fmul %204, %3  : f32
    %206 = llvm.fsub %202, %205  : f32
    %207 = llvm.fmul %206, %206  : f32
    %208 = llvm.fmul %207, %207  : f32
    %209 = "llvm.intr.fma"(%5, %206, %5) : (f32, f32, f32) -> f32
    %210 = "llvm.intr.fma"(%7, %206, %6) : (f32, f32, f32) -> f32
    %211 = "llvm.intr.fma"(%9, %206, %8) : (f32, f32, f32) -> f32
    %212 = "llvm.intr.fma"(%210, %207, %209) : (f32, f32, f32) -> f32
    %213 = "llvm.intr.fma"(%211, %208, %212) : (f32, f32, f32) -> f32
    %214 = llvm.fptosi %204 : f32 to i32
    %215 = llvm.add %214, %15  : i32
    %216 = llvm.shl %215, %10  : i32
    %217 = llvm.bitcast %216 : i32 to f32
    %218 = llvm.fmul %213, %217  : f32
    %219 = llvm.icmp "sle" %214, %15 : i32
    %220 = llvm.icmp "sge" %214, %16 : i32
    %221 = llvm.fcmp "oeq" %202, %13 : f32
    %222 = llvm.fcmp "ogt" %202, %11 : f32
    %223 = llvm.and %219, %220  : i1
    %224 = llvm.select %221, %11, %14 : i1, f32
    %225 = llvm.select %222, %12, %224 : i1, f32
    %226 = llvm.select %223, %218, %225 : i1, f32
    %227 = llvm.extractvalue %178[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
    %228 = llvm.extractvalue %178[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
    %229 = llvm.add %228, %181  : i64
    %230 = llvm.getelementptr %227[%229] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    llvm.store %226, %230 : !llvm.ptr<f32>
    %231 = llvm.add %181, %2  : i64
    llvm.br ^bb6(%231 : i64)
  ^bb8:  // pred: ^bb6
    %232 = llvm.add %179, %2  : i64
    llvm.br ^bb5(%232 : i64)
  ^bb9:  // pred: ^bb5
    %233 = llvm.add %106, %105  : i64
    llvm.br ^bb3(%233 : i64)
  ^bb10:  // pred: ^bb3
    %234 = llvm.add %100, %99  : i64
    llvm.br ^bb1(%234 : i64)
  ^bb11:  // pred: ^bb1
    %235 = llvm.mlir.constant(0 : i32) : i32
    llvm.return %235 : i32
  }
}

// *** IR Dump After CSE ***
module  {
  llvm.mlir.global private constant @__constant_1x10xf32(opaque<"_", "0xDEADBEEF"> : tensor<1x10xf32>) : !llvm.array<1 x array<10 x f32>>
  llvm.func internal @predict_dispatch_5(%arg0: !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>, %arg1: !llvm.ptr<array<3 x i32>>) -> i32 {
    %0 = llvm.mlir.constant(10 : index) : i64
    %1 = llvm.mlir.constant(0 : index) : i64
    %2 = llvm.mlir.constant(1 : index) : i64
    %3 = llvm.mlir.constant(0.693147182 : f32) : f32
    %4 = llvm.mlir.constant(1.44269502 : f32) : f32
    %5 = llvm.mlir.constant(1.000000e+00 : f32) : f32
    %6 = llvm.mlir.constant(0.499705136 : f32) : f32
    %7 = llvm.mlir.constant(0.168738902 : f32) : f32
    %8 = llvm.mlir.constant(0.0366896503 : f32) : f32
    %9 = llvm.mlir.constant(1.314350e-02 : f32) : f32
    %10 = llvm.mlir.constant(23 : i32) : i32
    %11 = llvm.mlir.constant(0.000000e+00 : f32) : f32
    %12 = llvm.mlir.constant(0x7F800000 : f32) : f32
    %13 = llvm.mlir.constant(0xFF800000 : f32) : f32
    %14 = llvm.mlir.constant(1.17549435E-38 : f32) : f32
    %15 = llvm.mlir.constant(127 : i32) : i32
    %16 = llvm.mlir.constant(-127 : i32) : i32
    %17 = llvm.mlir.addressof @__constant_1x10xf32 : !llvm.ptr<array<1 x array<10 x f32>>>
    %18 = llvm.getelementptr %17[%1, %1, %1] : (!llvm.ptr<array<1 x array<10 x f32>>>, i64, i64, i64) -> !llvm.ptr<f32>
    %19 = llvm.mlir.constant(3735928559 : index) : i64
    %20 = llvm.inttoptr %19 : i64 to !llvm.ptr<f32>
    %21 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %22 = llvm.insertvalue %20, %21[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %23 = llvm.insertvalue %18, %22[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %24 = llvm.insertvalue %1, %23[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %25 = llvm.insertvalue %2, %24[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %26 = llvm.insertvalue %0, %25[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %27 = llvm.insertvalue %0, %26[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %28 = llvm.insertvalue %2, %27[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %29 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
    %30 = llvm.extractvalue %29[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
    %31 = llvm.getelementptr %30[%1] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
    %32 = llvm.load %31 : !llvm.ptr<ptr<i8>>
    %33 = llvm.getelementptr %32[%1] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
    %34 = llvm.bitcast %33 : !llvm.ptr<i8> to !llvm.ptr<f32>
    %35 = llvm.insertvalue %34, %21[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %36 = llvm.insertvalue %34, %35[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %37 = llvm.insertvalue %1, %36[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %38 = llvm.insertvalue %2, %37[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %39 = llvm.insertvalue %0, %38[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %40 = llvm.insertvalue %0, %39[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %41 = llvm.insertvalue %2, %40[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %42 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
    %43 = llvm.extractvalue %42[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
    %44 = llvm.getelementptr %43[%2] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
    %45 = llvm.load %44 : !llvm.ptr<ptr<i8>>
    %46 = llvm.getelementptr %45[%1] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
    %47 = llvm.bitcast %46 : !llvm.ptr<i8> to !llvm.ptr<f32>
    %48 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
    %49 = llvm.insertvalue %47, %48[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
    %50 = llvm.insertvalue %47, %49[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
    %51 = llvm.insertvalue %1, %50[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
    %52 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
    %53 = llvm.extractvalue %52[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
    %54 = llvm.mlir.constant(2 : index) : i64
    %55 = llvm.getelementptr %53[%54] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
    %56 = llvm.load %55 : !llvm.ptr<ptr<i8>>
    %57 = llvm.getelementptr %56[%1] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
    %58 = llvm.bitcast %57 : !llvm.ptr<i8> to !llvm.ptr<f32>
    %59 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
    %60 = llvm.insertvalue %58, %59[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
    %61 = llvm.insertvalue %58, %60[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
    %62 = llvm.insertvalue %1, %61[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
    %63 = llvm.insertvalue %0, %62[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
    %64 = llvm.insertvalue %2, %63[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
    %65 = llvm.load %arg1 : !llvm.ptr<array<3 x i32>>
    %66 = llvm.extractvalue %65[0] : !llvm.array<3 x i32>
    %67 = llvm.zext %66 : i32 to i64
    %68 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
    %69 = llvm.extractvalue %68[0] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
    %70 = llvm.extractvalue %69[0] : !llvm.array<3 x i32>
    %71 = llvm.zext %70 : i32 to i64
    %72 = llvm.load %arg1 : !llvm.ptr<array<3 x i32>>
    %73 = llvm.extractvalue %72[1] : !llvm.array<3 x i32>
    %74 = llvm.zext %73 : i32 to i64
    %75 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
    %76 = llvm.extractvalue %75[0] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
    %77 = llvm.extractvalue %76[1] : !llvm.array<3 x i32>
    %78 = llvm.zext %77 : i32 to i64
    %79 = llvm.mlir.constant(128 : index) : i64
    %80 = llvm.mul %74, %79  : i64
    %81 = llvm.mul %78, %79  : i64
    llvm.br ^bb1(%80 : i64)
  ^bb1(%82: i64):  // 2 preds: ^bb0, ^bb10
    %83 = llvm.icmp "slt" %82, %2 : i64
    llvm.cond_br %83, ^bb2, ^bb11
  ^bb2:  // pred: ^bb1
    %84 = llvm.mul %67, %79  : i64
    %85 = llvm.mul %71, %79  : i64
    llvm.br ^bb3(%84 : i64)
  ^bb3(%86: i64):  // 2 preds: ^bb2, ^bb9
    %87 = llvm.icmp "slt" %86, %0 : i64
    llvm.cond_br %87, ^bb4, ^bb10
  ^bb4:  // pred: ^bb3
    %88 = llvm.mlir.constant(-1 : index) : i64
    %89 = llvm.mul %82, %88  : i64
    %90 = llvm.add %89, %2  : i64
    %91 = llvm.icmp "slt" %79, %90 : i64
    %92 = llvm.select %91, %79, %90 : i1, i64
    %93 = llvm.mul %86, %88  : i64
    %94 = llvm.add %93, %0  : i64
    %95 = llvm.icmp "slt" %79, %94 : i64
    %96 = llvm.select %95, %79, %94 : i1, i64
    %97 = llvm.extractvalue %41[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %98 = llvm.bitcast %97 : !llvm.ptr<f32> to !llvm.ptr<f32>
    %99 = llvm.insertvalue %98, %21[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %100 = llvm.extractvalue %41[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %101 = llvm.bitcast %100 : !llvm.ptr<f32> to !llvm.ptr<f32>
    %102 = llvm.insertvalue %101, %99[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %103 = llvm.extractvalue %41[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %104 = llvm.extractvalue %41[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %105 = llvm.extractvalue %41[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %106 = llvm.mul %82, %103  : i64
    %107 = llvm.add %105, %106  : i64
    %108 = llvm.mul %86, %104  : i64
    %109 = llvm.add %107, %108  : i64
    %110 = llvm.insertvalue %109, %102[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %111 = llvm.mlir.constant(1 : i64) : i64
    %112 = llvm.insertvalue %96, %110[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %113 = llvm.insertvalue %111, %112[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %114 = llvm.mlir.constant(10 : i64) : i64
    %115 = llvm.insertvalue %92, %113[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %116 = llvm.insertvalue %114, %115[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %117 = llvm.extractvalue %28[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %118 = llvm.bitcast %117 : !llvm.ptr<f32> to !llvm.ptr<f32>
    %119 = llvm.insertvalue %118, %21[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %120 = llvm.extractvalue %28[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %121 = llvm.bitcast %120 : !llvm.ptr<f32> to !llvm.ptr<f32>
    %122 = llvm.insertvalue %121, %119[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %123 = llvm.extractvalue %28[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %124 = llvm.extractvalue %28[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %125 = llvm.extractvalue %28[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %126 = llvm.mul %82, %123  : i64
    %127 = llvm.add %125, %126  : i64
    %128 = llvm.mul %86, %124  : i64
    %129 = llvm.add %127, %128  : i64
    %130 = llvm.insertvalue %129, %122[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %131 = llvm.insertvalue %96, %130[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %132 = llvm.insertvalue %111, %131[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %133 = llvm.insertvalue %92, %132[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %134 = llvm.insertvalue %114, %133[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %135 = llvm.extractvalue %64[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
    %136 = llvm.bitcast %135 : !llvm.ptr<f32> to !llvm.ptr<f32>
    %137 = llvm.insertvalue %136, %59[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
    %138 = llvm.extractvalue %64[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
    %139 = llvm.bitcast %138 : !llvm.ptr<f32> to !llvm.ptr<f32>
    %140 = llvm.insertvalue %139, %137[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
    %141 = llvm.extractvalue %64[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
    %142 = llvm.extractvalue %64[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
    %143 = llvm.mul %86, %141  : i64
    %144 = llvm.add %142, %143  : i64
    %145 = llvm.insertvalue %144, %140[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
    %146 = llvm.insertvalue %96, %145[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
    %147 = llvm.insertvalue %111, %146[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
    llvm.br ^bb5(%1 : i64)
  ^bb5(%148: i64):  // 2 preds: ^bb4, ^bb8
    %149 = llvm.icmp "slt" %148, %92 : i64
    llvm.cond_br %149, ^bb6(%1 : i64), ^bb9
  ^bb6(%150: i64):  // 2 preds: ^bb5, ^bb7
    %151 = llvm.icmp "slt" %150, %96 : i64
    llvm.cond_br %151, ^bb7, ^bb8
  ^bb7:  // pred: ^bb6
    %152 = llvm.extractvalue %116[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %153 = llvm.extractvalue %116[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %154 = llvm.mul %148, %0  : i64
    %155 = llvm.add %153, %154  : i64
    %156 = llvm.add %155, %150  : i64
    %157 = llvm.getelementptr %152[%156] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %158 = llvm.load %157 : !llvm.ptr<f32>
    %159 = llvm.extractvalue %134[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %160 = llvm.extractvalue %134[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %161 = llvm.add %160, %154  : i64
    %162 = llvm.add %161, %150  : i64
    %163 = llvm.getelementptr %159[%162] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %164 = llvm.load %163 : !llvm.ptr<f32>
    %165 = llvm.extractvalue %51[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
    %166 = llvm.load %165 : !llvm.ptr<f32>
    %167 = llvm.fadd %158, %164  : f32
    %168 = llvm.fsub %167, %166  : f32
    %169 = llvm.fmul %168, %4  : f32
    %170 = "llvm.intr.floor"(%169) : (f32) -> f32
    %171 = llvm.fmul %170, %3  : f32
    %172 = llvm.fsub %168, %171  : f32
    %173 = llvm.fmul %172, %172  : f32
    %174 = llvm.fmul %173, %173  : f32
    %175 = "llvm.intr.fma"(%5, %172, %5) : (f32, f32, f32) -> f32
    %176 = "llvm.intr.fma"(%7, %172, %6) : (f32, f32, f32) -> f32
    %177 = "llvm.intr.fma"(%9, %172, %8) : (f32, f32, f32) -> f32
    %178 = "llvm.intr.fma"(%176, %173, %175) : (f32, f32, f32) -> f32
    %179 = "llvm.intr.fma"(%177, %174, %178) : (f32, f32, f32) -> f32
    %180 = llvm.fptosi %170 : f32 to i32
    %181 = llvm.add %180, %15  : i32
    %182 = llvm.shl %181, %10  : i32
    %183 = llvm.bitcast %182 : i32 to f32
    %184 = llvm.fmul %179, %183  : f32
    %185 = llvm.icmp "sle" %180, %15 : i32
    %186 = llvm.icmp "sge" %180, %16 : i32
    %187 = llvm.fcmp "oeq" %168, %13 : f32
    %188 = llvm.fcmp "ogt" %168, %11 : f32
    %189 = llvm.and %185, %186  : i1
    %190 = llvm.select %187, %11, %14 : i1, f32
    %191 = llvm.select %188, %12, %190 : i1, f32
    %192 = llvm.select %189, %184, %191 : i1, f32
    %193 = llvm.extractvalue %147[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
    %194 = llvm.extractvalue %147[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
    %195 = llvm.add %194, %150  : i64
    %196 = llvm.getelementptr %193[%195] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    llvm.store %192, %196 : !llvm.ptr<f32>
    %197 = llvm.add %150, %2  : i64
    llvm.br ^bb6(%197 : i64)
  ^bb8:  // pred: ^bb6
    %198 = llvm.add %148, %2  : i64
    llvm.br ^bb5(%198 : i64)
  ^bb9:  // pred: ^bb5
    %199 = llvm.add %86, %85  : i64
    llvm.br ^bb3(%199 : i64)
  ^bb10:  // pred: ^bb3
    %200 = llvm.add %82, %81  : i64
    llvm.br ^bb1(%200 : i64)
  ^bb11:  // pred: ^bb1
    %201 = llvm.mlir.constant(0 : i32) : i32
    llvm.return %201 : i32
  }
}

// *** IR Dump After mlir::iree_compiler::`anonymous-namespace'::LowerExecutableTargetPass ***
hal.executable.target @llvm_aot, filter="dylib*" {
  hal.executable.entry_point @predict_dispatch_5 attributes {interface = @io, ordinal = 0 : index} {
  ^bb0(%arg0: index, %arg1: index, %arg2: index):  // no predecessors
    %c1 = constant 1 : index
    %0 = affine.apply affine_map<()[s0] -> (s0 ceildiv 128)>()[%arg0]
    %1 = affine.apply affine_map<()[s0] -> (s0 ceildiv 128)>()[%arg1]
    hal.return %0, %1, %c1 : index, index, index
  }
  module  {
    llvm.mlir.global private constant @__constant_1x10xf32(opaque<"_", "0xDEADBEEF"> : tensor<1x10xf32>) : !llvm.array<1 x array<10 x f32>>
    llvm.func internal @predict_dispatch_5(%arg0: !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>, %arg1: !llvm.ptr<array<3 x i32>>) -> i32 {
      %0 = llvm.mlir.constant(10 : index) : i64
      %1 = llvm.mlir.constant(0 : index) : i64
      %2 = llvm.mlir.constant(1 : index) : i64
      %3 = llvm.mlir.constant(0.693147182 : f32) : f32
      %4 = llvm.mlir.constant(1.44269502 : f32) : f32
      %5 = llvm.mlir.constant(1.000000e+00 : f32) : f32
      %6 = llvm.mlir.constant(0.499705136 : f32) : f32
      %7 = llvm.mlir.constant(0.168738902 : f32) : f32
      %8 = llvm.mlir.constant(0.0366896503 : f32) : f32
      %9 = llvm.mlir.constant(1.314350e-02 : f32) : f32
      %10 = llvm.mlir.constant(23 : i32) : i32
      %11 = llvm.mlir.constant(0.000000e+00 : f32) : f32
      %12 = llvm.mlir.constant(0x7F800000 : f32) : f32
      %13 = llvm.mlir.constant(0xFF800000 : f32) : f32
      %14 = llvm.mlir.constant(1.17549435E-38 : f32) : f32
      %15 = llvm.mlir.constant(127 : i32) : i32
      %16 = llvm.mlir.constant(-127 : i32) : i32
      %17 = llvm.mlir.addressof @__constant_1x10xf32 : !llvm.ptr<array<1 x array<10 x f32>>>
      %18 = llvm.getelementptr %17[%1, %1, %1] : (!llvm.ptr<array<1 x array<10 x f32>>>, i64, i64, i64) -> !llvm.ptr<f32>
      %19 = llvm.mlir.constant(3735928559 : index) : i64
      %20 = llvm.inttoptr %19 : i64 to !llvm.ptr<f32>
      %21 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %22 = llvm.insertvalue %20, %21[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %23 = llvm.insertvalue %18, %22[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %24 = llvm.insertvalue %1, %23[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %25 = llvm.insertvalue %2, %24[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %26 = llvm.insertvalue %0, %25[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %27 = llvm.insertvalue %0, %26[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %28 = llvm.insertvalue %2, %27[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %29 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
      %30 = llvm.extractvalue %29[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
      %31 = llvm.getelementptr %30[%1] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
      %32 = llvm.load %31 : !llvm.ptr<ptr<i8>>
      %33 = llvm.getelementptr %32[%1] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
      %34 = llvm.bitcast %33 : !llvm.ptr<i8> to !llvm.ptr<f32>
      %35 = llvm.insertvalue %34, %21[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %36 = llvm.insertvalue %34, %35[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %37 = llvm.insertvalue %1, %36[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %38 = llvm.insertvalue %2, %37[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %39 = llvm.insertvalue %0, %38[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %40 = llvm.insertvalue %0, %39[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %41 = llvm.insertvalue %2, %40[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %42 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
      %43 = llvm.extractvalue %42[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
      %44 = llvm.getelementptr %43[%2] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
      %45 = llvm.load %44 : !llvm.ptr<ptr<i8>>
      %46 = llvm.getelementptr %45[%1] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
      %47 = llvm.bitcast %46 : !llvm.ptr<i8> to !llvm.ptr<f32>
      %48 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
      %49 = llvm.insertvalue %47, %48[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
      %50 = llvm.insertvalue %47, %49[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
      %51 = llvm.insertvalue %1, %50[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
      %52 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
      %53 = llvm.extractvalue %52[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
      %54 = llvm.mlir.constant(2 : index) : i64
      %55 = llvm.getelementptr %53[%54] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
      %56 = llvm.load %55 : !llvm.ptr<ptr<i8>>
      %57 = llvm.getelementptr %56[%1] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
      %58 = llvm.bitcast %57 : !llvm.ptr<i8> to !llvm.ptr<f32>
      %59 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
      %60 = llvm.insertvalue %58, %59[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
      %61 = llvm.insertvalue %58, %60[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
      %62 = llvm.insertvalue %1, %61[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
      %63 = llvm.insertvalue %0, %62[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
      %64 = llvm.insertvalue %2, %63[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
      %65 = llvm.load %arg1 : !llvm.ptr<array<3 x i32>>
      %66 = llvm.extractvalue %65[0] : !llvm.array<3 x i32>
      %67 = llvm.zext %66 : i32 to i64
      %68 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
      %69 = llvm.extractvalue %68[0] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
      %70 = llvm.extractvalue %69[0] : !llvm.array<3 x i32>
      %71 = llvm.zext %70 : i32 to i64
      %72 = llvm.load %arg1 : !llvm.ptr<array<3 x i32>>
      %73 = llvm.extractvalue %72[1] : !llvm.array<3 x i32>
      %74 = llvm.zext %73 : i32 to i64
      %75 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
      %76 = llvm.extractvalue %75[0] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
      %77 = llvm.extractvalue %76[1] : !llvm.array<3 x i32>
      %78 = llvm.zext %77 : i32 to i64
      %79 = llvm.mlir.constant(128 : index) : i64
      %80 = llvm.mul %74, %79  : i64
      %81 = llvm.mul %78, %79  : i64
      llvm.br ^bb1(%80 : i64)
    ^bb1(%82: i64):  // 2 preds: ^bb0, ^bb10
      %83 = llvm.icmp "slt" %82, %2 : i64
      llvm.cond_br %83, ^bb2, ^bb11
    ^bb2:  // pred: ^bb1
      %84 = llvm.mul %67, %79  : i64
      %85 = llvm.mul %71, %79  : i64
      llvm.br ^bb3(%84 : i64)
    ^bb3(%86: i64):  // 2 preds: ^bb2, ^bb9
      %87 = llvm.icmp "slt" %86, %0 : i64
      llvm.cond_br %87, ^bb4, ^bb10
    ^bb4:  // pred: ^bb3
      %88 = llvm.mlir.constant(-1 : index) : i64
      %89 = llvm.mul %82, %88  : i64
      %90 = llvm.add %89, %2  : i64
      %91 = llvm.icmp "slt" %79, %90 : i64
      %92 = llvm.select %91, %79, %90 : i1, i64
      %93 = llvm.mul %86, %88  : i64
      %94 = llvm.add %93, %0  : i64
      %95 = llvm.icmp "slt" %79, %94 : i64
      %96 = llvm.select %95, %79, %94 : i1, i64
      %97 = llvm.extractvalue %41[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %98 = llvm.bitcast %97 : !llvm.ptr<f32> to !llvm.ptr<f32>
      %99 = llvm.insertvalue %98, %21[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %100 = llvm.extractvalue %41[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %101 = llvm.bitcast %100 : !llvm.ptr<f32> to !llvm.ptr<f32>
      %102 = llvm.insertvalue %101, %99[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %103 = llvm.extractvalue %41[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %104 = llvm.extractvalue %41[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %105 = llvm.extractvalue %41[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %106 = llvm.mul %82, %103  : i64
      %107 = llvm.add %105, %106  : i64
      %108 = llvm.mul %86, %104  : i64
      %109 = llvm.add %107, %108  : i64
      %110 = llvm.insertvalue %109, %102[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %111 = llvm.mlir.constant(1 : i64) : i64
      %112 = llvm.insertvalue %96, %110[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %113 = llvm.insertvalue %111, %112[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %114 = llvm.mlir.constant(10 : i64) : i64
      %115 = llvm.insertvalue %92, %113[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %116 = llvm.insertvalue %114, %115[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %117 = llvm.extractvalue %28[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %118 = llvm.bitcast %117 : !llvm.ptr<f32> to !llvm.ptr<f32>
      %119 = llvm.insertvalue %118, %21[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %120 = llvm.extractvalue %28[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %121 = llvm.bitcast %120 : !llvm.ptr<f32> to !llvm.ptr<f32>
      %122 = llvm.insertvalue %121, %119[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %123 = llvm.extractvalue %28[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %124 = llvm.extractvalue %28[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %125 = llvm.extractvalue %28[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %126 = llvm.mul %82, %123  : i64
      %127 = llvm.add %125, %126  : i64
      %128 = llvm.mul %86, %124  : i64
      %129 = llvm.add %127, %128  : i64
      %130 = llvm.insertvalue %129, %122[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %131 = llvm.insertvalue %96, %130[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %132 = llvm.insertvalue %111, %131[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %133 = llvm.insertvalue %92, %132[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %134 = llvm.insertvalue %114, %133[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %135 = llvm.extractvalue %64[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
      %136 = llvm.bitcast %135 : !llvm.ptr<f32> to !llvm.ptr<f32>
      %137 = llvm.insertvalue %136, %59[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
      %138 = llvm.extractvalue %64[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
      %139 = llvm.bitcast %138 : !llvm.ptr<f32> to !llvm.ptr<f32>
      %140 = llvm.insertvalue %139, %137[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
      %141 = llvm.extractvalue %64[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
      %142 = llvm.extractvalue %64[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
      %143 = llvm.mul %86, %141  : i64
      %144 = llvm.add %142, %143  : i64
      %145 = llvm.insertvalue %144, %140[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
      %146 = llvm.insertvalue %96, %145[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
      %147 = llvm.insertvalue %111, %146[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
      llvm.br ^bb5(%1 : i64)
    ^bb5(%148: i64):  // 2 preds: ^bb4, ^bb8
      %149 = llvm.icmp "slt" %148, %92 : i64
      llvm.cond_br %149, ^bb6(%1 : i64), ^bb9
    ^bb6(%150: i64):  // 2 preds: ^bb5, ^bb7
      %151 = llvm.icmp "slt" %150, %96 : i64
      llvm.cond_br %151, ^bb7, ^bb8
    ^bb7:  // pred: ^bb6
      %152 = llvm.extractvalue %116[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %153 = llvm.extractvalue %116[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %154 = llvm.mul %148, %0  : i64
      %155 = llvm.add %153, %154  : i64
      %156 = llvm.add %155, %150  : i64
      %157 = llvm.getelementptr %152[%156] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
      %158 = llvm.load %157 : !llvm.ptr<f32>
      %159 = llvm.extractvalue %134[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %160 = llvm.extractvalue %134[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %161 = llvm.add %160, %154  : i64
      %162 = llvm.add %161, %150  : i64
      %163 = llvm.getelementptr %159[%162] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
      %164 = llvm.load %163 : !llvm.ptr<f32>
      %165 = llvm.extractvalue %51[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
      %166 = llvm.load %165 : !llvm.ptr<f32>
      %167 = llvm.fadd %158, %164  : f32
      %168 = llvm.fsub %167, %166  : f32
      %169 = llvm.fmul %168, %4  : f32
      %170 = "llvm.intr.floor"(%169) : (f32) -> f32
      %171 = llvm.fmul %170, %3  : f32
      %172 = llvm.fsub %168, %171  : f32
      %173 = llvm.fmul %172, %172  : f32
      %174 = llvm.fmul %173, %173  : f32
      %175 = "llvm.intr.fma"(%5, %172, %5) : (f32, f32, f32) -> f32
      %176 = "llvm.intr.fma"(%7, %172, %6) : (f32, f32, f32) -> f32
      %177 = "llvm.intr.fma"(%9, %172, %8) : (f32, f32, f32) -> f32
      %178 = "llvm.intr.fma"(%176, %173, %175) : (f32, f32, f32) -> f32
      %179 = "llvm.intr.fma"(%177, %174, %178) : (f32, f32, f32) -> f32
      %180 = llvm.fptosi %170 : f32 to i32
      %181 = llvm.add %180, %15  : i32
      %182 = llvm.shl %181, %10  : i32
      %183 = llvm.bitcast %182 : i32 to f32
      %184 = llvm.fmul %179, %183  : f32
      %185 = llvm.icmp "sle" %180, %15 : i32
      %186 = llvm.icmp "sge" %180, %16 : i32
      %187 = llvm.fcmp "oeq" %168, %13 : f32
      %188 = llvm.fcmp "ogt" %168, %11 : f32
      %189 = llvm.and %185, %186  : i1
      %190 = llvm.select %187, %11, %14 : i1, f32
      %191 = llvm.select %188, %12, %190 : i1, f32
      %192 = llvm.select %189, %184, %191 : i1, f32
      %193 = llvm.extractvalue %147[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
      %194 = llvm.extractvalue %147[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
      %195 = llvm.add %194, %150  : i64
      %196 = llvm.getelementptr %193[%195] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
      llvm.store %192, %196 : !llvm.ptr<f32>
      %197 = llvm.add %150, %2  : i64
      llvm.br ^bb6(%197 : i64)
    ^bb8:  // pred: ^bb6
      %198 = llvm.add %148, %2  : i64
      llvm.br ^bb5(%198 : i64)
    ^bb9:  // pred: ^bb5
      %199 = llvm.add %86, %85  : i64
      llvm.br ^bb3(%199 : i64)
    ^bb10:  // pred: ^bb3
      %200 = llvm.add %82, %81  : i64
      llvm.br ^bb1(%200 : i64)
    ^bb11:  // pred: ^bb1
      %201 = llvm.mlir.constant(0 : i32) : i32
      llvm.return %201 : i32
    }
  }
}

// *** IR Dump After mlir::iree_compiler::IREE::HAL::TranslateExecutablesPass ***
hal.executable.target @llvm_aot, filter="dylib*" {
  hal.executable.entry_point @predict_dispatch_5 attributes {interface = @io, ordinal = 0 : index} {
  ^bb0(%arg0: index, %arg1: index, %arg2: index):  // no predecessors
    %c1 = constant 1 : index
    %0 = affine.apply affine_map<()[s0] -> (s0 ceildiv 128)>()[%arg0]
    %1 = affine.apply affine_map<()[s0] -> (s0 ceildiv 128)>()[%arg1]
    hal.return %0, %1, %c1 : index, index, index
  }
  module  {
    llvm.mlir.global private constant @__constant_1x10xf32(opaque<"_", "0xDEADBEEF"> : tensor<1x10xf32>) : !llvm.array<1 x array<10 x f32>>
    llvm.func internal @predict_dispatch_5(%arg0: !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>, %arg1: !llvm.ptr<array<3 x i32>>) -> i32 {
      %0 = llvm.mlir.constant(10 : index) : i64
      %1 = llvm.mlir.constant(0 : index) : i64
      %2 = llvm.mlir.constant(1 : index) : i64
      %3 = llvm.mlir.constant(0.693147182 : f32) : f32
      %4 = llvm.mlir.constant(1.44269502 : f32) : f32
      %5 = llvm.mlir.constant(1.000000e+00 : f32) : f32
      %6 = llvm.mlir.constant(0.499705136 : f32) : f32
      %7 = llvm.mlir.constant(0.168738902 : f32) : f32
      %8 = llvm.mlir.constant(0.0366896503 : f32) : f32
      %9 = llvm.mlir.constant(1.314350e-02 : f32) : f32
      %10 = llvm.mlir.constant(23 : i32) : i32
      %11 = llvm.mlir.constant(0.000000e+00 : f32) : f32
      %12 = llvm.mlir.constant(0x7F800000 : f32) : f32
      %13 = llvm.mlir.constant(0xFF800000 : f32) : f32
      %14 = llvm.mlir.constant(1.17549435E-38 : f32) : f32
      %15 = llvm.mlir.constant(127 : i32) : i32
      %16 = llvm.mlir.constant(-127 : i32) : i32
      %17 = llvm.mlir.addressof @__constant_1x10xf32 : !llvm.ptr<array<1 x array<10 x f32>>>
      %18 = llvm.getelementptr %17[%1, %1, %1] : (!llvm.ptr<array<1 x array<10 x f32>>>, i64, i64, i64) -> !llvm.ptr<f32>
      %19 = llvm.mlir.constant(3735928559 : index) : i64
      %20 = llvm.inttoptr %19 : i64 to !llvm.ptr<f32>
      %21 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %22 = llvm.insertvalue %20, %21[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %23 = llvm.insertvalue %18, %22[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %24 = llvm.insertvalue %1, %23[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %25 = llvm.insertvalue %2, %24[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %26 = llvm.insertvalue %0, %25[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %27 = llvm.insertvalue %0, %26[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %28 = llvm.insertvalue %2, %27[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %29 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
      %30 = llvm.extractvalue %29[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
      %31 = llvm.getelementptr %30[%1] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
      %32 = llvm.load %31 : !llvm.ptr<ptr<i8>>
      %33 = llvm.getelementptr %32[%1] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
      %34 = llvm.bitcast %33 : !llvm.ptr<i8> to !llvm.ptr<f32>
      %35 = llvm.insertvalue %34, %21[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %36 = llvm.insertvalue %34, %35[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %37 = llvm.insertvalue %1, %36[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %38 = llvm.insertvalue %2, %37[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %39 = llvm.insertvalue %0, %38[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %40 = llvm.insertvalue %0, %39[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %41 = llvm.insertvalue %2, %40[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %42 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
      %43 = llvm.extractvalue %42[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
      %44 = llvm.getelementptr %43[%2] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
      %45 = llvm.load %44 : !llvm.ptr<ptr<i8>>
      %46 = llvm.getelementptr %45[%1] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
      %47 = llvm.bitcast %46 : !llvm.ptr<i8> to !llvm.ptr<f32>
      %48 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
      %49 = llvm.insertvalue %47, %48[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
      %50 = llvm.insertvalue %47, %49[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
      %51 = llvm.insertvalue %1, %50[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
      %52 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
      %53 = llvm.extractvalue %52[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
      %54 = llvm.mlir.constant(2 : index) : i64
      %55 = llvm.getelementptr %53[%54] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
      %56 = llvm.load %55 : !llvm.ptr<ptr<i8>>
      %57 = llvm.getelementptr %56[%1] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
      %58 = llvm.bitcast %57 : !llvm.ptr<i8> to !llvm.ptr<f32>
      %59 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
      %60 = llvm.insertvalue %58, %59[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
      %61 = llvm.insertvalue %58, %60[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
      %62 = llvm.insertvalue %1, %61[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
      %63 = llvm.insertvalue %0, %62[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
      %64 = llvm.insertvalue %2, %63[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
      %65 = llvm.load %arg1 : !llvm.ptr<array<3 x i32>>
      %66 = llvm.extractvalue %65[0] : !llvm.array<3 x i32>
      %67 = llvm.zext %66 : i32 to i64
      %68 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
      %69 = llvm.extractvalue %68[0] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
      %70 = llvm.extractvalue %69[0] : !llvm.array<3 x i32>
      %71 = llvm.zext %70 : i32 to i64
      %72 = llvm.load %arg1 : !llvm.ptr<array<3 x i32>>
      %73 = llvm.extractvalue %72[1] : !llvm.array<3 x i32>
      %74 = llvm.zext %73 : i32 to i64
      %75 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
      %76 = llvm.extractvalue %75[0] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
      %77 = llvm.extractvalue %76[1] : !llvm.array<3 x i32>
      %78 = llvm.zext %77 : i32 to i64
      %79 = llvm.mlir.constant(128 : index) : i64
      %80 = llvm.mul %74, %79  : i64
      %81 = llvm.mul %78, %79  : i64
      llvm.br ^bb1(%80 : i64)
    ^bb1(%82: i64):  // 2 preds: ^bb0, ^bb10
      %83 = llvm.icmp "slt" %82, %2 : i64
      llvm.cond_br %83, ^bb2, ^bb11
    ^bb2:  // pred: ^bb1
      %84 = llvm.mul %67, %79  : i64
      %85 = llvm.mul %71, %79  : i64
      llvm.br ^bb3(%84 : i64)
    ^bb3(%86: i64):  // 2 preds: ^bb2, ^bb9
      %87 = llvm.icmp "slt" %86, %0 : i64
      llvm.cond_br %87, ^bb4, ^bb10
    ^bb4:  // pred: ^bb3
      %88 = llvm.mlir.constant(-1 : index) : i64
      %89 = llvm.mul %82, %88  : i64
      %90 = llvm.add %89, %2  : i64
      %91 = llvm.icmp "slt" %79, %90 : i64
      %92 = llvm.select %91, %79, %90 : i1, i64
      %93 = llvm.mul %86, %88  : i64
      %94 = llvm.add %93, %0  : i64
      %95 = llvm.icmp "slt" %79, %94 : i64
      %96 = llvm.select %95, %79, %94 : i1, i64
      %97 = llvm.extractvalue %41[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %98 = llvm.bitcast %97 : !llvm.ptr<f32> to !llvm.ptr<f32>
      %99 = llvm.insertvalue %98, %21[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %100 = llvm.extractvalue %41[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %101 = llvm.bitcast %100 : !llvm.ptr<f32> to !llvm.ptr<f32>
      %102 = llvm.insertvalue %101, %99[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %103 = llvm.extractvalue %41[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %104 = llvm.extractvalue %41[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %105 = llvm.extractvalue %41[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %106 = llvm.mul %82, %103  : i64
      %107 = llvm.add %105, %106  : i64
      %108 = llvm.mul %86, %104  : i64
      %109 = llvm.add %107, %108  : i64
      %110 = llvm.insertvalue %109, %102[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %111 = llvm.mlir.constant(1 : i64) : i64
      %112 = llvm.insertvalue %96, %110[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %113 = llvm.insertvalue %111, %112[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %114 = llvm.mlir.constant(10 : i64) : i64
      %115 = llvm.insertvalue %92, %113[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %116 = llvm.insertvalue %114, %115[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %117 = llvm.extractvalue %28[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %118 = llvm.bitcast %117 : !llvm.ptr<f32> to !llvm.ptr<f32>
      %119 = llvm.insertvalue %118, %21[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %120 = llvm.extractvalue %28[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %121 = llvm.bitcast %120 : !llvm.ptr<f32> to !llvm.ptr<f32>
      %122 = llvm.insertvalue %121, %119[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %123 = llvm.extractvalue %28[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %124 = llvm.extractvalue %28[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %125 = llvm.extractvalue %28[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %126 = llvm.mul %82, %123  : i64
      %127 = llvm.add %125, %126  : i64
      %128 = llvm.mul %86, %124  : i64
      %129 = llvm.add %127, %128  : i64
      %130 = llvm.insertvalue %129, %122[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %131 = llvm.insertvalue %96, %130[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %132 = llvm.insertvalue %111, %131[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %133 = llvm.insertvalue %92, %132[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %134 = llvm.insertvalue %114, %133[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %135 = llvm.extractvalue %64[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
      %136 = llvm.bitcast %135 : !llvm.ptr<f32> to !llvm.ptr<f32>
      %137 = llvm.insertvalue %136, %59[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
      %138 = llvm.extractvalue %64[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
      %139 = llvm.bitcast %138 : !llvm.ptr<f32> to !llvm.ptr<f32>
      %140 = llvm.insertvalue %139, %137[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
      %141 = llvm.extractvalue %64[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
      %142 = llvm.extractvalue %64[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
      %143 = llvm.mul %86, %141  : i64
      %144 = llvm.add %142, %143  : i64
      %145 = llvm.insertvalue %144, %140[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
      %146 = llvm.insertvalue %96, %145[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
      %147 = llvm.insertvalue %111, %146[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
      llvm.br ^bb5(%1 : i64)
    ^bb5(%148: i64):  // 2 preds: ^bb4, ^bb8
      %149 = llvm.icmp "slt" %148, %92 : i64
      llvm.cond_br %149, ^bb6(%1 : i64), ^bb9
    ^bb6(%150: i64):  // 2 preds: ^bb5, ^bb7
      %151 = llvm.icmp "slt" %150, %96 : i64
      llvm.cond_br %151, ^bb7, ^bb8
    ^bb7:  // pred: ^bb6
      %152 = llvm.extractvalue %116[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %153 = llvm.extractvalue %116[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %154 = llvm.mul %148, %0  : i64
      %155 = llvm.add %153, %154  : i64
      %156 = llvm.add %155, %150  : i64
      %157 = llvm.getelementptr %152[%156] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
      %158 = llvm.load %157 : !llvm.ptr<f32>
      %159 = llvm.extractvalue %134[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %160 = llvm.extractvalue %134[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %161 = llvm.add %160, %154  : i64
      %162 = llvm.add %161, %150  : i64
      %163 = llvm.getelementptr %159[%162] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
      %164 = llvm.load %163 : !llvm.ptr<f32>
      %165 = llvm.extractvalue %51[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
      %166 = llvm.load %165 : !llvm.ptr<f32>
      %167 = llvm.fadd %158, %164  : f32
      %168 = llvm.fsub %167, %166  : f32
      %169 = llvm.fmul %168, %4  : f32
      %170 = "llvm.intr.floor"(%169) : (f32) -> f32
      %171 = llvm.fmul %170, %3  : f32
      %172 = llvm.fsub %168, %171  : f32
      %173 = llvm.fmul %172, %172  : f32
      %174 = llvm.fmul %173, %173  : f32
      %175 = "llvm.intr.fma"(%5, %172, %5) : (f32, f32, f32) -> f32
      %176 = "llvm.intr.fma"(%7, %172, %6) : (f32, f32, f32) -> f32
      %177 = "llvm.intr.fma"(%9, %172, %8) : (f32, f32, f32) -> f32
      %178 = "llvm.intr.fma"(%176, %173, %175) : (f32, f32, f32) -> f32
      %179 = "llvm.intr.fma"(%177, %174, %178) : (f32, f32, f32) -> f32
      %180 = llvm.fptosi %170 : f32 to i32
      %181 = llvm.add %180, %15  : i32
      %182 = llvm.shl %181, %10  : i32
      %183 = llvm.bitcast %182 : i32 to f32
      %184 = llvm.fmul %179, %183  : f32
      %185 = llvm.icmp "sle" %180, %15 : i32
      %186 = llvm.icmp "sge" %180, %16 : i32
      %187 = llvm.fcmp "oeq" %168, %13 : f32
      %188 = llvm.fcmp "ogt" %168, %11 : f32
      %189 = llvm.and %185, %186  : i1
      %190 = llvm.select %187, %11, %14 : i1, f32
      %191 = llvm.select %188, %12, %190 : i1, f32
      %192 = llvm.select %189, %184, %191 : i1, f32
      %193 = llvm.extractvalue %147[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
      %194 = llvm.extractvalue %147[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
      %195 = llvm.add %194, %150  : i64
      %196 = llvm.getelementptr %193[%195] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
      llvm.store %192, %196 : !llvm.ptr<f32>
      %197 = llvm.add %150, %2  : i64
      llvm.br ^bb6(%197 : i64)
    ^bb8:  // pred: ^bb6
      %198 = llvm.add %148, %2  : i64
      llvm.br ^bb5(%198 : i64)
    ^bb9:  // pred: ^bb5
      %199 = llvm.add %86, %85  : i64
      llvm.br ^bb3(%199 : i64)
    ^bb10:  // pred: ^bb3
      %200 = llvm.add %82, %81  : i64
      llvm.br ^bb1(%200 : i64)
    ^bb11:  // pred: ^bb1
      %201 = llvm.mlir.constant(0 : i32) : i32
      llvm.return %201 : i32
    }
  }
}

// *** IR Dump After mlir::iree_compiler::IREE::HAL::PropagateConstantWorkgroupInfoPass ***
hal.executable.target @llvm_aot, filter="dylib*" {
  hal.executable.entry_point @predict_dispatch_6 attributes {interface = @io, ordinal = 0 : index}
  module  {
    func @predict_dispatch_6() {
      %c0 = constant 0 : index
      %cst = constant 0.000000e+00 : f32
      %0 = hal.interface.binding.subspan @io::@s0b0_ro_external[%c0] : !flow.dispatch.tensor<readonly:10xf32>
      %1 = hal.interface.binding.subspan @io::@s0b1_xw_external[%c0] : !flow.dispatch.tensor<writeonly:f32>
      %2 = flow.dispatch.tensor.load %0, offsets = [], sizes = [], strides = [] : !flow.dispatch.tensor<readonly:10xf32> -> tensor<10xf32>
      %3 = linalg.init_tensor [] : tensor<f32>
      %4 = linalg.fill(%3, %cst) : tensor<f32>, f32 -> tensor<f32> 
      %5 = linalg.generic {indexing_maps = [affine_map<(d0) -> (d0)>, affine_map<(d0) -> ()>], iterator_types = ["reduction"]} ins(%2 : tensor<10xf32>) outs(%4 : tensor<f32>) {
      ^bb0(%arg0: f32, %arg1: f32):  // no predecessors
        %6 = addf %arg0, %arg1 : f32
        linalg.yield %6 : f32
      } -> tensor<f32>
      flow.dispatch.tensor.store %5, %1, offsets = [], sizes = [], strides = [] : tensor<f32> -> !flow.dispatch.tensor<writeonly:f32>
      return
    }
    hal.interface @io attributes {sym_visibility = "private"} {
      hal.interface.binding @s0b0_ro_external, set=0, binding=0, type="StorageBuffer", access="Read"
      hal.interface.binding @s0b1_xw_external, set=0, binding=1, type="StorageBuffer", access="Write|Discard"
    }
  }
}

// *** IR Dump After mlir::iree_compiler::`anonymous-namespace'::SetNumWorkgroupsPass ***
hal.executable.target @llvm_aot, filter="dylib*" {
  hal.executable.entry_point @predict_dispatch_6 attributes {interface = @io, ordinal = 0 : index} {
  ^bb0(%arg0: index, %arg1: index, %arg2: index):  // no predecessors
    %c1 = constant 1 : index
    hal.return %c1, %c1, %c1 : index, index, index
  }
  module  {
    func @predict_dispatch_6() {
      %c0 = constant 0 : index
      %cst = constant 0.000000e+00 : f32
      %0 = hal.interface.binding.subspan @io::@s0b0_ro_external[%c0] : !flow.dispatch.tensor<readonly:10xf32>
      %1 = hal.interface.binding.subspan @io::@s0b1_xw_external[%c0] : !flow.dispatch.tensor<writeonly:f32>
      %2 = flow.dispatch.tensor.load %0, offsets = [], sizes = [], strides = [] : !flow.dispatch.tensor<readonly:10xf32> -> tensor<10xf32>
      %3 = linalg.init_tensor [] : tensor<f32>
      %4 = linalg.fill(%3, %cst) : tensor<f32>, f32 -> tensor<f32> 
      %5 = linalg.generic {indexing_maps = [affine_map<(d0) -> (d0)>, affine_map<(d0) -> ()>], iterator_types = ["reduction"]} ins(%2 : tensor<10xf32>) outs(%4 : tensor<f32>) {
      ^bb0(%arg0: f32, %arg1: f32):  // no predecessors
        %6 = addf %arg0, %arg1 : f32
        linalg.yield %6 : f32
      } -> tensor<f32>
      flow.dispatch.tensor.store %5, %1, offsets = [], sizes = [], strides = [] : tensor<f32> -> !flow.dispatch.tensor<writeonly:f32>
      return
    }
    hal.interface @io attributes {sym_visibility = "private"} {
      hal.interface.binding @s0b0_ro_external, set=0, binding=0, type="StorageBuffer", access="Read"
      hal.interface.binding @s0b1_xw_external, set=0, binding=1, type="StorageBuffer", access="Write|Discard"
    }
  }
}

// *** IR Dump After Canonicalizer ***
module  {
  func @predict_dispatch_6() {
    %c0 = constant 0 : index
    %cst = constant 0.000000e+00 : f32
    %0 = hal.interface.binding.subspan @io::@s0b0_ro_external[%c0] : !flow.dispatch.tensor<readonly:10xf32>
    %1 = hal.interface.binding.subspan @io::@s0b1_xw_external[%c0] : !flow.dispatch.tensor<writeonly:f32>
    %2 = flow.dispatch.tensor.load %0, offsets = [], sizes = [], strides = [] : !flow.dispatch.tensor<readonly:10xf32> -> tensor<10xf32>
    %3 = linalg.init_tensor [] : tensor<f32>
    %4 = linalg.fill(%3, %cst) : tensor<f32>, f32 -> tensor<f32> 
    %5 = linalg.generic {indexing_maps = [affine_map<(d0) -> (d0)>, affine_map<(d0) -> ()>], iterator_types = ["reduction"]} ins(%2 : tensor<10xf32>) outs(%4 : tensor<f32>) {
    ^bb0(%arg0: f32, %arg1: f32):  // no predecessors
      %6 = addf %arg0, %arg1 : f32
      linalg.yield %6 : f32
    } -> tensor<f32>
    flow.dispatch.tensor.store %5, %1, offsets = [], sizes = [], strides = [] : tensor<f32> -> !flow.dispatch.tensor<writeonly:f32>
    return
  }
  hal.interface @io attributes {sym_visibility = "private"} {
    hal.interface.binding @s0b0_ro_external, set=0, binding=0, type="StorageBuffer", access="Read"
    hal.interface.binding @s0b1_xw_external, set=0, binding=1, type="StorageBuffer", access="Write|Discard"
  }
}

// *** IR Dump After mlir::iree_compiler::`anonymous-namespace'::LinalgBufferizePass ***
func @predict_dispatch_6() {
  %c0 = constant 0 : index
  %cst = constant 0.000000e+00 : f32
  %0 = hal.interface.binding.subspan @io::@s0b0_ro_external[%c0] : memref<10xf32>
  %1 = hal.interface.binding.subspan @io::@s0b0_ro_external[%c0] : !flow.dispatch.tensor<readonly:10xf32>
  %2 = hal.interface.binding.subspan @io::@s0b1_xw_external[%c0] : memref<f32>
  %3 = hal.interface.binding.subspan @io::@s0b1_xw_external[%c0] : !flow.dispatch.tensor<writeonly:f32>
  %4 = flow.dispatch.tensor.load %1, offsets = [], sizes = [], strides = [] : !flow.dispatch.tensor<readonly:10xf32> -> tensor<10xf32>
  %5 = linalg.init_tensor [] : tensor<f32>
  linalg.fill(%2, %cst) : memref<f32>, f32 
  %6 = linalg.fill(%5, %cst) : tensor<f32>, f32 -> tensor<f32> 
  linalg.generic {indexing_maps = [affine_map<(d0) -> (d0)>, affine_map<(d0) -> ()>], iterator_types = ["reduction"]} ins(%0 : memref<10xf32>) outs(%2 : memref<f32>) {
  ^bb0(%arg0: f32, %arg1: f32):  // no predecessors
    %8 = addf %arg0, %arg1 : f32
    linalg.yield %8 : f32
  }
  %7 = linalg.generic {indexing_maps = [affine_map<(d0) -> (d0)>, affine_map<(d0) -> ()>], iterator_types = ["reduction"]} ins(%4 : tensor<10xf32>) outs(%6 : tensor<f32>) {
  ^bb0(%arg0: f32, %arg1: f32):  // no predecessors
    %8 = addf %arg0, %arg1 : f32
    linalg.yield %8 : f32
  } -> tensor<f32>
  return
}

// *** IR Dump After Canonicalizer ***
func @predict_dispatch_6() {
  %c0 = constant 0 : index
  %cst = constant 0.000000e+00 : f32
  %0 = hal.interface.binding.subspan @io::@s0b0_ro_external[%c0] : memref<10xf32>
  %1 = hal.interface.binding.subspan @io::@s0b0_ro_external[%c0] : !flow.dispatch.tensor<readonly:10xf32>
  %2 = hal.interface.binding.subspan @io::@s0b1_xw_external[%c0] : memref<f32>
  %3 = hal.interface.binding.subspan @io::@s0b1_xw_external[%c0] : !flow.dispatch.tensor<writeonly:f32>
  linalg.fill(%2, %cst) : memref<f32>, f32 
  linalg.generic {indexing_maps = [affine_map<(d0) -> (d0)>, affine_map<(d0) -> ()>], iterator_types = ["reduction"]} ins(%0 : memref<10xf32>) outs(%2 : memref<f32>) {
  ^bb0(%arg0: f32, %arg1: f32):  // no predecessors
    %4 = addf %arg0, %arg1 : f32
    linalg.yield %4 : f32
  }
  return
}

// *** IR Dump After CSE ***
func @predict_dispatch_6() {
  %c0 = constant 0 : index
  %cst = constant 0.000000e+00 : f32
  %0 = hal.interface.binding.subspan @io::@s0b0_ro_external[%c0] : memref<10xf32>
  %1 = hal.interface.binding.subspan @io::@s0b0_ro_external[%c0] : !flow.dispatch.tensor<readonly:10xf32>
  %2 = hal.interface.binding.subspan @io::@s0b1_xw_external[%c0] : memref<f32>
  %3 = hal.interface.binding.subspan @io::@s0b1_xw_external[%c0] : !flow.dispatch.tensor<writeonly:f32>
  linalg.fill(%2, %cst) : memref<f32>, f32 
  linalg.generic {indexing_maps = [affine_map<(d0) -> (d0)>, affine_map<(d0) -> ()>], iterator_types = ["reduction"]} ins(%0 : memref<10xf32>) outs(%2 : memref<f32>) {
  ^bb0(%arg0: f32, %arg1: f32):  // no predecessors
    %4 = addf %arg0, %arg1 : f32
    linalg.yield %4 : f32
  }
  return
}

// *** IR Dump After mlir::iree_compiler::`anonymous-namespace'::BufferAllocViewCleanUpPass ***
func @predict_dispatch_6() {
  %c0 = constant 0 : index
  %cst = constant 0.000000e+00 : f32
  %0 = hal.interface.binding.subspan @io::@s0b0_ro_external[%c0] : memref<10xf32>
  %1 = hal.interface.binding.subspan @io::@s0b1_xw_external[%c0] : memref<f32>
  linalg.fill(%1, %cst) : memref<f32>, f32 
  linalg.generic {indexing_maps = [affine_map<(d0) -> (d0)>, affine_map<(d0) -> ()>], iterator_types = ["reduction"]} ins(%0 : memref<10xf32>) outs(%1 : memref<f32>) {
  ^bb0(%arg0: f32, %arg1: f32):  // no predecessors
    %2 = addf %arg0, %arg1 : f32
    linalg.yield %2 : f32
  }
  return
}

// *** IR Dump After mlir::iree_compiler::`anonymous-namespace'::PlanConvLoopOrderPass ***
func @predict_dispatch_6() {
  %c0 = constant 0 : index
  %cst = constant 0.000000e+00 : f32
  %0 = hal.interface.binding.subspan @io::@s0b0_ro_external[%c0] : memref<10xf32>
  %1 = hal.interface.binding.subspan @io::@s0b1_xw_external[%c0] : memref<f32>
  linalg.fill(%1, %cst) : memref<f32>, f32 
  linalg.generic {indexing_maps = [affine_map<(d0) -> (d0)>, affine_map<(d0) -> ()>], iterator_types = ["reduction"]} ins(%0 : memref<10xf32>) outs(%1 : memref<f32>) {
  ^bb0(%arg0: f32, %arg1: f32):  // no predecessors
    %2 = addf %arg0, %arg1 : f32
    linalg.yield %2 : f32
  }
  return
}

// *** IR Dump After LinalgLowerToLoops ***
func @predict_dispatch_6() {
  %cst = constant 0.000000e+00 : f32
  %c10 = constant 10 : index
  %c0 = constant 0 : index
  %c1 = constant 1 : index
  %0 = hal.interface.binding.subspan @io::@s0b0_ro_external[%c0] : memref<10xf32>
  %1 = hal.interface.binding.subspan @io::@s0b1_xw_external[%c0] : memref<f32>
  memref.store %cst, %1[] : memref<f32>
  scf.for %arg0 = %c0 to %c10 step %c1 {
    %2 = memref.load %0[%arg0] : memref<10xf32>
    %3 = memref.load %1[] : memref<f32>
    %4 = addf %2, %3 : f32
    memref.store %4, %1[] : memref<f32>
  }
  return
}

// *** IR Dump After Canonicalizer ***
func @predict_dispatch_6() {
  %cst = constant 0.000000e+00 : f32
  %c10 = constant 10 : index
  %c0 = constant 0 : index
  %c1 = constant 1 : index
  %0 = hal.interface.binding.subspan @io::@s0b0_ro_external[%c0] : memref<10xf32>
  %1 = hal.interface.binding.subspan @io::@s0b1_xw_external[%c0] : memref<f32>
  memref.store %cst, %1[] : memref<f32>
  scf.for %arg0 = %c0 to %c10 step %c1 {
    %2 = memref.load %0[%arg0] : memref<10xf32>
    %3 = memref.load %1[] : memref<f32>
    %4 = addf %2, %3 : f32
    memref.store %4, %1[] : memref<f32>
  }
  return
}

// *** IR Dump After CSE ***
func @predict_dispatch_6() {
  %cst = constant 0.000000e+00 : f32
  %c10 = constant 10 : index
  %c0 = constant 0 : index
  %c1 = constant 1 : index
  %0 = hal.interface.binding.subspan @io::@s0b0_ro_external[%c0] : memref<10xf32>
  %1 = hal.interface.binding.subspan @io::@s0b1_xw_external[%c0] : memref<f32>
  memref.store %cst, %1[] : memref<f32>
  scf.for %arg0 = %c0 to %c10 step %c1 {
    %2 = memref.load %0[%arg0] : memref<10xf32>
    %3 = memref.load %1[] : memref<f32>
    %4 = addf %2, %3 : f32
    memref.store %4, %1[] : memref<f32>
  }
  return
}

// *** IR Dump After SCFToStandard ***
func @predict_dispatch_6() {
  %cst = constant 0.000000e+00 : f32
  %c10 = constant 10 : index
  %c0 = constant 0 : index
  %c1 = constant 1 : index
  %0 = hal.interface.binding.subspan @io::@s0b0_ro_external[%c0] : memref<10xf32>
  %1 = hal.interface.binding.subspan @io::@s0b1_xw_external[%c0] : memref<f32>
  memref.store %cst, %1[] : memref<f32>
  br ^bb1(%c0 : index)
^bb1(%2: index):  // 2 preds: ^bb0, ^bb2
  %3 = cmpi slt, %2, %c10 : index
  cond_br %3, ^bb2, ^bb3
^bb2:  // pred: ^bb1
  %4 = memref.load %0[%2] : memref<10xf32>
  %5 = memref.load %1[] : memref<f32>
  %6 = addf %4, %5 : f32
  memref.store %6, %1[] : memref<f32>
  %7 = addi %2, %c1 : index
  br ^bb1(%7 : index)
^bb3:  // pred: ^bb1
  return
}

// *** IR Dump After Canonicalizer ***
func @predict_dispatch_6() {
  %cst = constant 0.000000e+00 : f32
  %c10 = constant 10 : index
  %c0 = constant 0 : index
  %c1 = constant 1 : index
  %0 = hal.interface.binding.subspan @io::@s0b0_ro_external[%c0] : memref<10xf32>
  %1 = hal.interface.binding.subspan @io::@s0b1_xw_external[%c0] : memref<f32>
  memref.store %cst, %1[] : memref<f32>
  br ^bb1(%c0 : index)
^bb1(%2: index):  // 2 preds: ^bb0, ^bb2
  %3 = cmpi slt, %2, %c10 : index
  cond_br %3, ^bb2, ^bb3
^bb2:  // pred: ^bb1
  %4 = memref.load %0[%2] : memref<10xf32>
  %5 = memref.load %1[] : memref<f32>
  %6 = addf %4, %5 : f32
  memref.store %6, %1[] : memref<f32>
  %7 = addi %2, %c1 : index
  br ^bb1(%7 : index)
^bb3:  // pred: ^bb1
  return
}

// *** IR Dump After CSE ***
func @predict_dispatch_6() {
  %cst = constant 0.000000e+00 : f32
  %c10 = constant 10 : index
  %c0 = constant 0 : index
  %c1 = constant 1 : index
  %0 = hal.interface.binding.subspan @io::@s0b0_ro_external[%c0] : memref<10xf32>
  %1 = hal.interface.binding.subspan @io::@s0b1_xw_external[%c0] : memref<f32>
  memref.store %cst, %1[] : memref<f32>
  br ^bb1(%c0 : index)
^bb1(%2: index):  // 2 preds: ^bb0, ^bb2
  %3 = cmpi slt, %2, %c10 : index
  cond_br %3, ^bb2, ^bb3
^bb2:  // pred: ^bb1
  %4 = memref.load %0[%2] : memref<10xf32>
  %5 = memref.load %1[] : memref<f32>
  %6 = addf %4, %5 : f32
  memref.store %6, %1[] : memref<f32>
  %7 = addi %2, %c1 : index
  br ^bb1(%7 : index)
^bb3:  // pred: ^bb1
  return
}

// *** IR Dump After TensorConstantBufferize ***
module  {
  func @predict_dispatch_6() {
    %cst = constant 0.000000e+00 : f32
    %c10 = constant 10 : index
    %c0 = constant 0 : index
    %c1 = constant 1 : index
    %0 = hal.interface.binding.subspan @io::@s0b0_ro_external[%c0] : memref<10xf32>
    %1 = hal.interface.binding.subspan @io::@s0b1_xw_external[%c0] : memref<f32>
    memref.store %cst, %1[] : memref<f32>
    br ^bb1(%c0 : index)
  ^bb1(%2: index):  // 2 preds: ^bb0, ^bb2
    %3 = cmpi slt, %2, %c10 : index
    cond_br %3, ^bb2, ^bb3
  ^bb2:  // pred: ^bb1
    %4 = memref.load %0[%2] : memref<10xf32>
    %5 = memref.load %1[] : memref<f32>
    %6 = addf %4, %5 : f32
    memref.store %6, %1[] : memref<f32>
    %7 = addi %2, %c1 : index
    br ^bb1(%7 : index)
  ^bb3:  // pred: ^bb1
    return
  }
  hal.interface @io attributes {sym_visibility = "private"} {
    hal.interface.binding @s0b0_ro_external, set=0, binding=0, type="StorageBuffer", access="Read"
    hal.interface.binding @s0b1_xw_external, set=0, binding=1, type="StorageBuffer", access="Write|Discard"
  }
}

// *** IR Dump After mlir::iree_compiler::`anonymous-namespace'::FoldTensorExtractOpPass ***
module  {
  func @predict_dispatch_6() {
    %cst = constant 0.000000e+00 : f32
    %c10 = constant 10 : index
    %c0 = constant 0 : index
    %c1 = constant 1 : index
    %0 = hal.interface.binding.subspan @io::@s0b0_ro_external[%c0] : memref<10xf32>
    %1 = hal.interface.binding.subspan @io::@s0b1_xw_external[%c0] : memref<f32>
    memref.store %cst, %1[] : memref<f32>
    br ^bb1(%c0 : index)
  ^bb1(%2: index):  // 2 preds: ^bb0, ^bb2
    %3 = cmpi slt, %2, %c10 : index
    cond_br %3, ^bb2, ^bb3
  ^bb2:  // pred: ^bb1
    %4 = memref.load %0[%2] : memref<10xf32>
    %5 = memref.load %1[] : memref<f32>
    %6 = addf %4, %5 : f32
    memref.store %6, %1[] : memref<f32>
    %7 = addi %2, %c1 : index
    br ^bb1(%7 : index)
  ^bb3:  // pred: ^bb1
    return
  }
  hal.interface @io attributes {sym_visibility = "private"} {
    hal.interface.binding @s0b0_ro_external, set=0, binding=0, type="StorageBuffer", access="Read"
    hal.interface.binding @s0b1_xw_external, set=0, binding=1, type="StorageBuffer", access="Write|Discard"
  }
}

// *** IR Dump After mlir::iree_compiler::`anonymous-namespace'::ConvertToLLVMPass ***
module  {
  llvm.func internal @predict_dispatch_6(%arg0: !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>, %arg1: !llvm.ptr<array<3 x i32>>) -> i32 {
    %0 = llvm.mlir.constant(0.000000e+00 : f32) : f32
    %1 = llvm.mlir.constant(10 : index) : i64
    %2 = llvm.mlir.constant(0 : index) : i64
    %3 = llvm.mlir.constant(1 : index) : i64
    %4 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
    %5 = llvm.extractvalue %4[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
    %6 = llvm.mlir.constant(0 : index) : i64
    %7 = llvm.getelementptr %5[%6] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
    %8 = llvm.load %7 : !llvm.ptr<ptr<i8>>
    %9 = llvm.getelementptr %8[%2] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
    %10 = llvm.bitcast %9 : !llvm.ptr<i8> to !llvm.ptr<f32>
    %11 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
    %12 = llvm.insertvalue %10, %11[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
    %13 = llvm.insertvalue %10, %12[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
    %14 = llvm.mlir.constant(0 : index) : i64
    %15 = llvm.insertvalue %14, %13[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
    %16 = llvm.mlir.constant(10 : index) : i64
    %17 = llvm.insertvalue %16, %15[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
    %18 = llvm.mlir.constant(1 : index) : i64
    %19 = llvm.insertvalue %18, %17[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
    %20 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
    %21 = llvm.extractvalue %20[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
    %22 = llvm.mlir.constant(1 : index) : i64
    %23 = llvm.getelementptr %21[%22] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
    %24 = llvm.load %23 : !llvm.ptr<ptr<i8>>
    %25 = llvm.getelementptr %24[%2] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
    %26 = llvm.bitcast %25 : !llvm.ptr<i8> to !llvm.ptr<f32>
    %27 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
    %28 = llvm.insertvalue %26, %27[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
    %29 = llvm.insertvalue %26, %28[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
    %30 = llvm.mlir.constant(0 : index) : i64
    %31 = llvm.insertvalue %30, %29[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
    %32 = llvm.extractvalue %31[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
    llvm.store %0, %32 : !llvm.ptr<f32>
    llvm.br ^bb1(%2 : i64)
  ^bb1(%33: i64):  // 2 preds: ^bb0, ^bb2
    %34 = llvm.icmp "slt" %33, %1 : i64
    llvm.cond_br %34, ^bb2, ^bb3
  ^bb2:  // pred: ^bb1
    %35 = llvm.extractvalue %19[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
    %36 = llvm.getelementptr %35[%33] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %37 = llvm.load %36 : !llvm.ptr<f32>
    %38 = llvm.extractvalue %31[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
    %39 = llvm.load %38 : !llvm.ptr<f32>
    %40 = llvm.fadd %37, %39  : f32
    %41 = llvm.extractvalue %31[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
    llvm.store %40, %41 : !llvm.ptr<f32>
    %42 = llvm.add %33, %3  : i64
    llvm.br ^bb1(%42 : i64)
  ^bb3:  // pred: ^bb1
    %43 = llvm.mlir.constant(0 : i32) : i32
    llvm.return %43 : i32
  }
}

// *** IR Dump After Canonicalizer ***
module  {
  llvm.func internal @predict_dispatch_6(%arg0: !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>, %arg1: !llvm.ptr<array<3 x i32>>) -> i32 {
    %0 = llvm.mlir.constant(0.000000e+00 : f32) : f32
    %1 = llvm.mlir.constant(10 : index) : i64
    %2 = llvm.mlir.constant(0 : index) : i64
    %3 = llvm.mlir.constant(1 : index) : i64
    %4 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
    %5 = llvm.extractvalue %4[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
    %6 = llvm.mlir.constant(0 : index) : i64
    %7 = llvm.getelementptr %5[%6] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
    %8 = llvm.load %7 : !llvm.ptr<ptr<i8>>
    %9 = llvm.getelementptr %8[%2] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
    %10 = llvm.bitcast %9 : !llvm.ptr<i8> to !llvm.ptr<f32>
    %11 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
    %12 = llvm.insertvalue %10, %11[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
    %13 = llvm.insertvalue %10, %12[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
    %14 = llvm.mlir.constant(0 : index) : i64
    %15 = llvm.insertvalue %14, %13[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
    %16 = llvm.mlir.constant(10 : index) : i64
    %17 = llvm.insertvalue %16, %15[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
    %18 = llvm.mlir.constant(1 : index) : i64
    %19 = llvm.insertvalue %18, %17[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
    %20 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
    %21 = llvm.extractvalue %20[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
    %22 = llvm.mlir.constant(1 : index) : i64
    %23 = llvm.getelementptr %21[%22] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
    %24 = llvm.load %23 : !llvm.ptr<ptr<i8>>
    %25 = llvm.getelementptr %24[%2] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
    %26 = llvm.bitcast %25 : !llvm.ptr<i8> to !llvm.ptr<f32>
    %27 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
    %28 = llvm.insertvalue %26, %27[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
    %29 = llvm.insertvalue %26, %28[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
    %30 = llvm.mlir.constant(0 : index) : i64
    %31 = llvm.insertvalue %30, %29[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
    %32 = llvm.extractvalue %31[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
    llvm.store %0, %32 : !llvm.ptr<f32>
    llvm.br ^bb1(%2 : i64)
  ^bb1(%33: i64):  // 2 preds: ^bb0, ^bb2
    %34 = llvm.icmp "slt" %33, %1 : i64
    llvm.cond_br %34, ^bb2, ^bb3
  ^bb2:  // pred: ^bb1
    %35 = llvm.extractvalue %19[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
    %36 = llvm.getelementptr %35[%33] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %37 = llvm.load %36 : !llvm.ptr<f32>
    %38 = llvm.extractvalue %31[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
    %39 = llvm.load %38 : !llvm.ptr<f32>
    %40 = llvm.fadd %37, %39  : f32
    %41 = llvm.extractvalue %31[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
    llvm.store %40, %41 : !llvm.ptr<f32>
    %42 = llvm.add %33, %3  : i64
    llvm.br ^bb1(%42 : i64)
  ^bb3:  // pred: ^bb1
    %43 = llvm.mlir.constant(0 : i32) : i32
    llvm.return %43 : i32
  }
}

// *** IR Dump After CSE ***
module  {
  llvm.func internal @predict_dispatch_6(%arg0: !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>, %arg1: !llvm.ptr<array<3 x i32>>) -> i32 {
    %0 = llvm.mlir.constant(0.000000e+00 : f32) : f32
    %1 = llvm.mlir.constant(10 : index) : i64
    %2 = llvm.mlir.constant(0 : index) : i64
    %3 = llvm.mlir.constant(1 : index) : i64
    %4 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
    %5 = llvm.extractvalue %4[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
    %6 = llvm.getelementptr %5[%2] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
    %7 = llvm.load %6 : !llvm.ptr<ptr<i8>>
    %8 = llvm.getelementptr %7[%2] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
    %9 = llvm.bitcast %8 : !llvm.ptr<i8> to !llvm.ptr<f32>
    %10 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
    %11 = llvm.insertvalue %9, %10[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
    %12 = llvm.insertvalue %9, %11[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
    %13 = llvm.insertvalue %2, %12[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
    %14 = llvm.insertvalue %1, %13[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
    %15 = llvm.insertvalue %3, %14[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
    %16 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
    %17 = llvm.extractvalue %16[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
    %18 = llvm.getelementptr %17[%3] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
    %19 = llvm.load %18 : !llvm.ptr<ptr<i8>>
    %20 = llvm.getelementptr %19[%2] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
    %21 = llvm.bitcast %20 : !llvm.ptr<i8> to !llvm.ptr<f32>
    %22 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
    %23 = llvm.insertvalue %21, %22[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
    %24 = llvm.insertvalue %21, %23[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
    %25 = llvm.insertvalue %2, %24[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
    %26 = llvm.extractvalue %25[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
    llvm.store %0, %26 : !llvm.ptr<f32>
    llvm.br ^bb1(%2 : i64)
  ^bb1(%27: i64):  // 2 preds: ^bb0, ^bb2
    %28 = llvm.icmp "slt" %27, %1 : i64
    llvm.cond_br %28, ^bb2, ^bb3
  ^bb2:  // pred: ^bb1
    %29 = llvm.extractvalue %15[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
    %30 = llvm.getelementptr %29[%27] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %31 = llvm.load %30 : !llvm.ptr<f32>
    %32 = llvm.load %26 : !llvm.ptr<f32>
    %33 = llvm.fadd %31, %32  : f32
    llvm.store %33, %26 : !llvm.ptr<f32>
    %34 = llvm.add %27, %3  : i64
    llvm.br ^bb1(%34 : i64)
  ^bb3:  // pred: ^bb1
    %35 = llvm.mlir.constant(0 : i32) : i32
    llvm.return %35 : i32
  }
}

// *** IR Dump After mlir::iree_compiler::`anonymous-namespace'::LowerExecutableTargetPass ***
hal.executable.target @llvm_aot, filter="dylib*" {
  hal.executable.entry_point @predict_dispatch_6 attributes {interface = @io, ordinal = 0 : index} {
  ^bb0(%arg0: index, %arg1: index, %arg2: index):  // no predecessors
    %c1 = constant 1 : index
    hal.return %c1, %c1, %c1 : index, index, index
  }
  module  {
    llvm.func internal @predict_dispatch_6(%arg0: !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>, %arg1: !llvm.ptr<array<3 x i32>>) -> i32 {
      %0 = llvm.mlir.constant(0.000000e+00 : f32) : f32
      %1 = llvm.mlir.constant(10 : index) : i64
      %2 = llvm.mlir.constant(0 : index) : i64
      %3 = llvm.mlir.constant(1 : index) : i64
      %4 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
      %5 = llvm.extractvalue %4[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
      %6 = llvm.getelementptr %5[%2] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
      %7 = llvm.load %6 : !llvm.ptr<ptr<i8>>
      %8 = llvm.getelementptr %7[%2] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
      %9 = llvm.bitcast %8 : !llvm.ptr<i8> to !llvm.ptr<f32>
      %10 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
      %11 = llvm.insertvalue %9, %10[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
      %12 = llvm.insertvalue %9, %11[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
      %13 = llvm.insertvalue %2, %12[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
      %14 = llvm.insertvalue %1, %13[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
      %15 = llvm.insertvalue %3, %14[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
      %16 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
      %17 = llvm.extractvalue %16[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
      %18 = llvm.getelementptr %17[%3] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
      %19 = llvm.load %18 : !llvm.ptr<ptr<i8>>
      %20 = llvm.getelementptr %19[%2] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
      %21 = llvm.bitcast %20 : !llvm.ptr<i8> to !llvm.ptr<f32>
      %22 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
      %23 = llvm.insertvalue %21, %22[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
      %24 = llvm.insertvalue %21, %23[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
      %25 = llvm.insertvalue %2, %24[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
      %26 = llvm.extractvalue %25[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
      llvm.store %0, %26 : !llvm.ptr<f32>
      llvm.br ^bb1(%2 : i64)
    ^bb1(%27: i64):  // 2 preds: ^bb0, ^bb2
      %28 = llvm.icmp "slt" %27, %1 : i64
      llvm.cond_br %28, ^bb2, ^bb3
    ^bb2:  // pred: ^bb1
      %29 = llvm.extractvalue %15[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
      %30 = llvm.getelementptr %29[%27] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
      %31 = llvm.load %30 : !llvm.ptr<f32>
      %32 = llvm.load %26 : !llvm.ptr<f32>
      %33 = llvm.fadd %31, %32  : f32
      llvm.store %33, %26 : !llvm.ptr<f32>
      %34 = llvm.add %27, %3  : i64
      llvm.br ^bb1(%34 : i64)
    ^bb3:  // pred: ^bb1
      %35 = llvm.mlir.constant(0 : i32) : i32
      llvm.return %35 : i32
    }
  }
}

// *** IR Dump After mlir::iree_compiler::IREE::HAL::TranslateExecutablesPass ***
hal.executable.target @llvm_aot, filter="dylib*" {
  hal.executable.entry_point @predict_dispatch_6 attributes {interface = @io, ordinal = 0 : index} {
  ^bb0(%arg0: index, %arg1: index, %arg2: index):  // no predecessors
    %c1 = constant 1 : index
    hal.return %c1, %c1, %c1 : index, index, index
  }
  module  {
    llvm.func internal @predict_dispatch_6(%arg0: !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>, %arg1: !llvm.ptr<array<3 x i32>>) -> i32 {
      %0 = llvm.mlir.constant(0.000000e+00 : f32) : f32
      %1 = llvm.mlir.constant(10 : index) : i64
      %2 = llvm.mlir.constant(0 : index) : i64
      %3 = llvm.mlir.constant(1 : index) : i64
      %4 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
      %5 = llvm.extractvalue %4[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
      %6 = llvm.getelementptr %5[%2] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
      %7 = llvm.load %6 : !llvm.ptr<ptr<i8>>
      %8 = llvm.getelementptr %7[%2] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
      %9 = llvm.bitcast %8 : !llvm.ptr<i8> to !llvm.ptr<f32>
      %10 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
      %11 = llvm.insertvalue %9, %10[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
      %12 = llvm.insertvalue %9, %11[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
      %13 = llvm.insertvalue %2, %12[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
      %14 = llvm.insertvalue %1, %13[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
      %15 = llvm.insertvalue %3, %14[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
      %16 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
      %17 = llvm.extractvalue %16[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
      %18 = llvm.getelementptr %17[%3] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
      %19 = llvm.load %18 : !llvm.ptr<ptr<i8>>
      %20 = llvm.getelementptr %19[%2] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
      %21 = llvm.bitcast %20 : !llvm.ptr<i8> to !llvm.ptr<f32>
      %22 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
      %23 = llvm.insertvalue %21, %22[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
      %24 = llvm.insertvalue %21, %23[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
      %25 = llvm.insertvalue %2, %24[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
      %26 = llvm.extractvalue %25[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
      llvm.store %0, %26 : !llvm.ptr<f32>
      llvm.br ^bb1(%2 : i64)
    ^bb1(%27: i64):  // 2 preds: ^bb0, ^bb2
      %28 = llvm.icmp "slt" %27, %1 : i64
      llvm.cond_br %28, ^bb2, ^bb3
    ^bb2:  // pred: ^bb1
      %29 = llvm.extractvalue %15[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
      %30 = llvm.getelementptr %29[%27] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
      %31 = llvm.load %30 : !llvm.ptr<f32>
      %32 = llvm.load %26 : !llvm.ptr<f32>
      %33 = llvm.fadd %31, %32  : f32
      llvm.store %33, %26 : !llvm.ptr<f32>
      %34 = llvm.add %27, %3  : i64
      llvm.br ^bb1(%34 : i64)
    ^bb3:  // pred: ^bb1
      %35 = llvm.mlir.constant(0 : i32) : i32
      llvm.return %35 : i32
    }
  }
}

// *** IR Dump After mlir::iree_compiler::IREE::HAL::PropagateConstantWorkgroupInfoPass ***
hal.executable.target @llvm_aot, filter="dylib*" {
  hal.executable.entry_point @predict_dispatch_7 attributes {interface = @io, ordinal = 0 : index}
  module  {
    func @predict_dispatch_7() {
      %c0 = constant 0 : index
      %cst = constant opaque<"_", "0xDEADBEEF"> : tensor<1x10xf32>
      %c1 = constant 1 : index
      %c10 = constant 10 : index
      %0 = hal.interface.binding.subspan @io::@s0b0_ro_external[%c0] : !flow.dispatch.tensor<readonly:1x10xf32>
      %1 = hal.interface.binding.subspan @io::@s0b1_ro_external[%c0] : !flow.dispatch.tensor<readonly:f32>
      %2 = hal.interface.binding.subspan @io::@s0b2_ro_external[%c0] : !flow.dispatch.tensor<readonly:f32>
      %3 = hal.interface.binding.subspan @io::@s0b3_xw_external[%c0] : !flow.dispatch.tensor<writeonly:1x10xf32>
      %4 = flow.dispatch.tensor.load %1, offsets = [], sizes = [], strides = [] : !flow.dispatch.tensor<readonly:f32> -> tensor<f32>
      %5 = flow.dispatch.tensor.load %2, offsets = [], sizes = [], strides = [] : !flow.dispatch.tensor<readonly:f32> -> tensor<f32>
      %workgroup_size_x = hal.interface.workgroup.size[0] : index
      %workgroup_size_y = hal.interface.workgroup.size[1] : index
      %workgroup_id_x = hal.interface.workgroup.id[0] : index
      %workgroup_count_x = hal.interface.workgroup.count[0] : index
      %workgroup_id_y = hal.interface.workgroup.id[1] : index
      %workgroup_count_y = hal.interface.workgroup.count[1] : index
      %6 = affine.apply affine_map<()[s0, s1] -> (s0 * s1)>()[%workgroup_id_y, %workgroup_size_y]
      %7 = affine.apply affine_map<()[s0, s1] -> (s0 * s1)>()[%workgroup_count_y, %workgroup_size_y]
      scf.for %arg0 = %6 to %c1 step %7 {
        %8 = affine.apply affine_map<()[s0, s1] -> (s0 * s1)>()[%workgroup_id_x, %workgroup_size_x]
        %9 = affine.apply affine_map<()[s0, s1] -> (s0 * s1)>()[%workgroup_count_x, %workgroup_size_x]
        scf.for %arg1 = %8 to %c10 step %9 {
          %10 = affine.min affine_map<(d0)[s0] -> (s0, -d0 + 1)>(%arg0)[%workgroup_size_y]
          %11 = affine.min affine_map<(d0)[s0] -> (s0, -d0 + 10)>(%arg1)[%workgroup_size_x]
          %12 = flow.dispatch.tensor.load %0, offsets = [%arg0, %arg1], sizes = [%10, %11], strides = [1, 1] : !flow.dispatch.tensor<readonly:1x10xf32> -> tensor<?x?xf32>
          %13 = affine.min affine_map<(d0)[s0] -> (s0, -d0 + 1)>(%arg0)[%workgroup_size_y]
          %14 = affine.min affine_map<(d0)[s0] -> (s0, -d0 + 10)>(%arg1)[%workgroup_size_x]
          %15 = subtensor %cst[%arg0, %arg1] [%13, %14] [1, 1] : tensor<1x10xf32> to tensor<?x?xf32>
          %16 = affine.min affine_map<(d0)[s0] -> (s0, -d0 + 1)>(%arg0)[%workgroup_size_y]
          %17 = affine.min affine_map<(d0)[s0] -> (s0, -d0 + 10)>(%arg1)[%workgroup_size_x]
          %18 = linalg.init_tensor [%16, %17] : tensor<?x?xf32>
          %19 = linalg.generic {indexing_maps = [affine_map<(d0, d1) -> (d0, d1)>, affine_map<(d0, d1) -> (d0, d1)>, affine_map<(d0, d1) -> ()>, affine_map<(d0, d1) -> ()>, affine_map<(d0, d1) -> (d0, d1)>], iterator_types = ["parallel", "parallel"]} ins(%12, %15, %4, %5 : tensor<?x?xf32>, tensor<?x?xf32>, tensor<f32>, tensor<f32>) outs(%18 : tensor<?x?xf32>) attrs =  {__internal_linalg_transform__ = "workgroup"} {
          ^bb0(%arg2: f32, %arg3: f32, %arg4: f32, %arg5: f32, %arg6: f32):  // no predecessors
            %20 = addf %arg2, %arg3 : f32
            %21 = subf %20, %arg4 : f32
            %22 = math.exp %21 : f32
            %23 = divf %22, %arg5 : f32
            linalg.yield %23 : f32
          } -> tensor<?x?xf32>
          flow.dispatch.tensor.store %19, %3, offsets = [%arg0, %arg1], sizes = [%16, %17], strides = [1, 1] : tensor<?x?xf32> -> !flow.dispatch.tensor<writeonly:1x10xf32>
        }
      }
      return
    }
    hal.interface @io attributes {sym_visibility = "private"} {
      hal.interface.binding @s0b0_ro_external, set=0, binding=0, type="StorageBuffer", access="Read"
      hal.interface.binding @s0b1_ro_external, set=0, binding=1, type="StorageBuffer", access="Read"
      hal.interface.binding @s0b2_ro_external, set=0, binding=2, type="StorageBuffer", access="Read"
      hal.interface.binding @s0b3_xw_external, set=0, binding=3, type="StorageBuffer", access="Write|Discard"
    }
  }
}

// *** IR Dump After mlir::iree_compiler::`anonymous-namespace'::SetNumWorkgroupsPass ***
hal.executable.target @llvm_aot, filter="dylib*" {
  hal.executable.entry_point @predict_dispatch_7 attributes {interface = @io, ordinal = 0 : index} {
  ^bb0(%arg0: index, %arg1: index, %arg2: index):  // no predecessors
    %c1 = constant 1 : index
    %0 = affine.apply affine_map<()[s0] -> (s0 ceildiv 128)>()[%arg0]
    %1 = affine.apply affine_map<()[s0] -> (s0 ceildiv 128)>()[%arg1]
    hal.return %0, %1, %c1 : index, index, index
  }
  module  {
    func @predict_dispatch_7() {
      %c0 = constant 0 : index
      %cst = constant opaque<"_", "0xDEADBEEF"> : tensor<1x10xf32>
      %c1 = constant 1 : index
      %c10 = constant 10 : index
      %c128 = constant 128 : index
      %0 = hal.interface.binding.subspan @io::@s0b0_ro_external[%c0] : !flow.dispatch.tensor<readonly:1x10xf32>
      %1 = hal.interface.binding.subspan @io::@s0b1_ro_external[%c0] : !flow.dispatch.tensor<readonly:f32>
      %2 = hal.interface.binding.subspan @io::@s0b2_ro_external[%c0] : !flow.dispatch.tensor<readonly:f32>
      %3 = hal.interface.binding.subspan @io::@s0b3_xw_external[%c0] : !flow.dispatch.tensor<writeonly:1x10xf32>
      %4 = flow.dispatch.tensor.load %1, offsets = [], sizes = [], strides = [] : !flow.dispatch.tensor<readonly:f32> -> tensor<f32>
      %5 = flow.dispatch.tensor.load %2, offsets = [], sizes = [], strides = [] : !flow.dispatch.tensor<readonly:f32> -> tensor<f32>
      %workgroup_id_x = hal.interface.workgroup.id[0] : index
      %workgroup_count_x = hal.interface.workgroup.count[0] : index
      %workgroup_id_y = hal.interface.workgroup.id[1] : index
      %workgroup_count_y = hal.interface.workgroup.count[1] : index
      %6 = affine.apply affine_map<()[s0, s1] -> (s0 * s1)>()[%workgroup_id_y, %c128]
      %7 = affine.apply affine_map<()[s0, s1] -> (s0 * s1)>()[%workgroup_count_y, %c128]
      scf.for %arg0 = %6 to %c1 step %7 {
        %8 = affine.apply affine_map<()[s0, s1] -> (s0 * s1)>()[%workgroup_id_x, %c128]
        %9 = affine.apply affine_map<()[s0, s1] -> (s0 * s1)>()[%workgroup_count_x, %c128]
        scf.for %arg1 = %8 to %c10 step %9 {
          %10 = affine.min affine_map<(d0) -> (128, -d0 + 1)>(%arg0)
          %11 = affine.min affine_map<(d0) -> (128, -d0 + 10)>(%arg1)
          %12 = flow.dispatch.tensor.load %0, offsets = [%arg0, %arg1], sizes = [%10, %11], strides = [1, 1] : !flow.dispatch.tensor<readonly:1x10xf32> -> tensor<?x?xf32>
          %13 = affine.min affine_map<(d0) -> (128, -d0 + 1)>(%arg0)
          %14 = affine.min affine_map<(d0) -> (128, -d0 + 10)>(%arg1)
          %15 = subtensor %cst[%arg0, %arg1] [%13, %14] [1, 1] : tensor<1x10xf32> to tensor<?x?xf32>
          %16 = affine.min affine_map<(d0) -> (128, -d0 + 1)>(%arg0)
          %17 = affine.min affine_map<(d0) -> (128, -d0 + 10)>(%arg1)
          %18 = linalg.init_tensor [%16, %17] : tensor<?x?xf32>
          %19 = linalg.generic {indexing_maps = [affine_map<(d0, d1) -> (d0, d1)>, affine_map<(d0, d1) -> (d0, d1)>, affine_map<(d0, d1) -> ()>, affine_map<(d0, d1) -> ()>, affine_map<(d0, d1) -> (d0, d1)>], iterator_types = ["parallel", "parallel"]} ins(%12, %15, %4, %5 : tensor<?x?xf32>, tensor<?x?xf32>, tensor<f32>, tensor<f32>) outs(%18 : tensor<?x?xf32>) attrs =  {__internal_linalg_transform__ = "workgroup", lowering.config = {tileSizes = [[128, 128]]}} {
          ^bb0(%arg2: f32, %arg3: f32, %arg4: f32, %arg5: f32, %arg6: f32):  // no predecessors
            %20 = addf %arg2, %arg3 : f32
            %21 = subf %20, %arg4 : f32
            %22 = math.exp %21 : f32
            %23 = divf %22, %arg5 : f32
            linalg.yield %23 : f32
          } -> tensor<?x?xf32>
          flow.dispatch.tensor.store %19, %3, offsets = [%arg0, %arg1], sizes = [%16, %17], strides = [1, 1] : tensor<?x?xf32> -> !flow.dispatch.tensor<writeonly:1x10xf32>
        }
      }
      return
    }
    hal.interface @io attributes {sym_visibility = "private"} {
      hal.interface.binding @s0b0_ro_external, set=0, binding=0, type="StorageBuffer", access="Read"
      hal.interface.binding @s0b1_ro_external, set=0, binding=1, type="StorageBuffer", access="Read"
      hal.interface.binding @s0b2_ro_external, set=0, binding=2, type="StorageBuffer", access="Read"
      hal.interface.binding @s0b3_xw_external, set=0, binding=3, type="StorageBuffer", access="Write|Discard"
    }
  }
}

// *** IR Dump After Canonicalizer ***
module  {
  func @predict_dispatch_7() {
    %c0 = constant 0 : index
    %cst = constant opaque<"_", "0xDEADBEEF"> : tensor<1x10xf32>
    %c1 = constant 1 : index
    %c10 = constant 10 : index
    %0 = hal.interface.binding.subspan @io::@s0b0_ro_external[%c0] : !flow.dispatch.tensor<readonly:1x10xf32>
    %1 = hal.interface.binding.subspan @io::@s0b1_ro_external[%c0] : !flow.dispatch.tensor<readonly:f32>
    %2 = hal.interface.binding.subspan @io::@s0b2_ro_external[%c0] : !flow.dispatch.tensor<readonly:f32>
    %3 = hal.interface.binding.subspan @io::@s0b3_xw_external[%c0] : !flow.dispatch.tensor<writeonly:1x10xf32>
    %4 = flow.dispatch.tensor.load %1, offsets = [], sizes = [], strides = [] : !flow.dispatch.tensor<readonly:f32> -> tensor<f32>
    %5 = flow.dispatch.tensor.load %2, offsets = [], sizes = [], strides = [] : !flow.dispatch.tensor<readonly:f32> -> tensor<f32>
    %workgroup_id_x = hal.interface.workgroup.id[0] : index
    %workgroup_count_x = hal.interface.workgroup.count[0] : index
    %workgroup_id_y = hal.interface.workgroup.id[1] : index
    %workgroup_count_y = hal.interface.workgroup.count[1] : index
    %6 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_y]
    %7 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_y]
    scf.for %arg0 = %6 to %c1 step %7 {
      %8 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
      %9 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
      scf.for %arg1 = %8 to %c10 step %9 {
        %10 = affine.min affine_map<(d0) -> (128, -d0 + 1)>(%arg0)
        %11 = affine.min affine_map<(d0) -> (128, -d0 + 10)>(%arg1)
        %12 = flow.dispatch.tensor.load %0, offsets = [%arg0, %arg1], sizes = [%10, %11], strides = [1, 1] : !flow.dispatch.tensor<readonly:1x10xf32> -> tensor<?x?xf32>
        %13 = affine.min affine_map<(d0) -> (128, -d0 + 1)>(%arg0)
        %14 = affine.min affine_map<(d0) -> (128, -d0 + 10)>(%arg1)
        %15 = subtensor %cst[%arg0, %arg1] [%13, %14] [1, 1] : tensor<1x10xf32> to tensor<?x?xf32>
        %16 = affine.min affine_map<(d0) -> (128, -d0 + 1)>(%arg0)
        %17 = affine.min affine_map<(d0) -> (128, -d0 + 10)>(%arg1)
        %18 = linalg.init_tensor [%16, %17] : tensor<?x?xf32>
        %19 = linalg.generic {indexing_maps = [affine_map<(d0, d1) -> (d0, d1)>, affine_map<(d0, d1) -> (d0, d1)>, affine_map<(d0, d1) -> ()>, affine_map<(d0, d1) -> ()>, affine_map<(d0, d1) -> (d0, d1)>], iterator_types = ["parallel", "parallel"]} ins(%12, %15, %4, %5 : tensor<?x?xf32>, tensor<?x?xf32>, tensor<f32>, tensor<f32>) outs(%18 : tensor<?x?xf32>) attrs =  {__internal_linalg_transform__ = "workgroup", lowering.config = {tileSizes = [[128, 128]]}} {
        ^bb0(%arg2: f32, %arg3: f32, %arg4: f32, %arg5: f32, %arg6: f32):  // no predecessors
          %20 = addf %arg2, %arg3 : f32
          %21 = subf %20, %arg4 : f32
          %22 = math.exp %21 : f32
          %23 = divf %22, %arg5 : f32
          linalg.yield %23 : f32
        } -> tensor<?x?xf32>
        flow.dispatch.tensor.store %19, %3, offsets = [%arg0, %arg1], sizes = [%16, %17], strides = [1, 1] : tensor<?x?xf32> -> !flow.dispatch.tensor<writeonly:1x10xf32>
      }
    }
    return
  }
  hal.interface @io attributes {sym_visibility = "private"} {
    hal.interface.binding @s0b0_ro_external, set=0, binding=0, type="StorageBuffer", access="Read"
    hal.interface.binding @s0b1_ro_external, set=0, binding=1, type="StorageBuffer", access="Read"
    hal.interface.binding @s0b2_ro_external, set=0, binding=2, type="StorageBuffer", access="Read"
    hal.interface.binding @s0b3_xw_external, set=0, binding=3, type="StorageBuffer", access="Write|Discard"
  }
}

// *** IR Dump After mlir::iree_compiler::`anonymous-namespace'::LinalgBufferizePass ***
func @predict_dispatch_7() {
  %c0 = constant 0 : index
  %cst = constant opaque<"_", "0xDEADBEEF"> : tensor<1x10xf32>
  %0 = memref.buffer_cast %cst : memref<1x10xf32>
  %c1 = constant 1 : index
  %c10 = constant 10 : index
  %1 = hal.interface.binding.subspan @io::@s0b0_ro_external[%c0] : memref<1x10xf32>
  %2 = hal.interface.binding.subspan @io::@s0b0_ro_external[%c0] : !flow.dispatch.tensor<readonly:1x10xf32>
  %3 = hal.interface.binding.subspan @io::@s0b1_ro_external[%c0] : memref<f32>
  %4 = hal.interface.binding.subspan @io::@s0b1_ro_external[%c0] : !flow.dispatch.tensor<readonly:f32>
  %5 = hal.interface.binding.subspan @io::@s0b2_ro_external[%c0] : memref<f32>
  %6 = hal.interface.binding.subspan @io::@s0b2_ro_external[%c0] : !flow.dispatch.tensor<readonly:f32>
  %7 = hal.interface.binding.subspan @io::@s0b3_xw_external[%c0] : memref<1x10xf32>
  %8 = hal.interface.binding.subspan @io::@s0b3_xw_external[%c0] : !flow.dispatch.tensor<writeonly:1x10xf32>
  %9 = flow.dispatch.tensor.load %4, offsets = [], sizes = [], strides = [] : !flow.dispatch.tensor<readonly:f32> -> tensor<f32>
  %10 = flow.dispatch.tensor.load %6, offsets = [], sizes = [], strides = [] : !flow.dispatch.tensor<readonly:f32> -> tensor<f32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %11 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_y]
  %12 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_y]
  scf.for %arg0 = %11 to %c1 step %12 {
    %13 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
    %14 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
    scf.for %arg1 = %13 to %c10 step %14 {
      %15 = affine.min affine_map<(d0) -> (128, -d0 + 1)>(%arg0)
      %16 = affine.min affine_map<(d0) -> (128, -d0 + 10)>(%arg1)
      %17 = memref.subview %1[%arg0, %arg1] [%15, %16] [1, 1] : memref<1x10xf32> to memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
      %18 = flow.dispatch.tensor.load %2, offsets = [%arg0, %arg1], sizes = [%15, %16], strides = [1, 1] : !flow.dispatch.tensor<readonly:1x10xf32> -> tensor<?x?xf32>
      %19 = affine.min affine_map<(d0) -> (128, -d0 + 1)>(%arg0)
      %20 = affine.min affine_map<(d0) -> (128, -d0 + 10)>(%arg1)
      %21 = memref.subview %0[%arg0, %arg1] [%19, %20] [1, 1] : memref<1x10xf32> to memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
      %22 = subtensor %cst[%arg0, %arg1] [%19, %20] [1, 1] : tensor<1x10xf32> to tensor<?x?xf32>
      %23 = affine.min affine_map<(d0) -> (128, -d0 + 1)>(%arg0)
      %24 = affine.min affine_map<(d0) -> (128, -d0 + 10)>(%arg1)
      %25 = linalg.init_tensor [%23, %24] : tensor<?x?xf32>
      %26 = memref.subview %7[%arg0, %arg1] [%23, %24] [1, 1] : memref<1x10xf32> to memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
      linalg.generic {indexing_maps = [affine_map<(d0, d1) -> (d0, d1)>, affine_map<(d0, d1) -> (d0, d1)>, affine_map<(d0, d1) -> ()>, affine_map<(d0, d1) -> ()>, affine_map<(d0, d1) -> (d0, d1)>], iterator_types = ["parallel", "parallel"]} ins(%17, %21, %3, %5 : memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>, memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>, memref<f32>, memref<f32>) outs(%26 : memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>) attrs =  {__internal_linalg_transform__ = "workgroup", lowering.config = {tileSizes = [[128, 128]]}} {
      ^bb0(%arg2: f32, %arg3: f32, %arg4: f32, %arg5: f32, %arg6: f32):  // no predecessors
        %28 = addf %arg2, %arg3 : f32
        %29 = subf %28, %arg4 : f32
        %30 = math.exp %29 : f32
        %31 = divf %30, %arg5 : f32
        linalg.yield %31 : f32
      }
      %27 = linalg.generic {indexing_maps = [affine_map<(d0, d1) -> (d0, d1)>, affine_map<(d0, d1) -> (d0, d1)>, affine_map<(d0, d1) -> ()>, affine_map<(d0, d1) -> ()>, affine_map<(d0, d1) -> (d0, d1)>], iterator_types = ["parallel", "parallel"]} ins(%18, %22, %9, %10 : tensor<?x?xf32>, tensor<?x?xf32>, tensor<f32>, tensor<f32>) outs(%25 : tensor<?x?xf32>) attrs =  {__internal_linalg_transform__ = "workgroup", lowering.config = {tileSizes = [[128, 128]]}} {
      ^bb0(%arg2: f32, %arg3: f32, %arg4: f32, %arg5: f32, %arg6: f32):  // no predecessors
        %28 = addf %arg2, %arg3 : f32
        %29 = subf %28, %arg4 : f32
        %30 = math.exp %29 : f32
        %31 = divf %30, %arg5 : f32
        linalg.yield %31 : f32
      } -> tensor<?x?xf32>
    }
  }
  return
}

// *** IR Dump After Canonicalizer ***
func @predict_dispatch_7() {
  %c0 = constant 0 : index
  %cst = constant opaque<"_", "0xDEADBEEF"> : tensor<1x10xf32>
  %c1 = constant 1 : index
  %c10 = constant 10 : index
  %0 = memref.buffer_cast %cst : memref<1x10xf32>
  %1 = hal.interface.binding.subspan @io::@s0b0_ro_external[%c0] : memref<1x10xf32>
  %2 = hal.interface.binding.subspan @io::@s0b0_ro_external[%c0] : !flow.dispatch.tensor<readonly:1x10xf32>
  %3 = hal.interface.binding.subspan @io::@s0b1_ro_external[%c0] : memref<f32>
  %4 = hal.interface.binding.subspan @io::@s0b1_ro_external[%c0] : !flow.dispatch.tensor<readonly:f32>
  %5 = hal.interface.binding.subspan @io::@s0b2_ro_external[%c0] : memref<f32>
  %6 = hal.interface.binding.subspan @io::@s0b2_ro_external[%c0] : !flow.dispatch.tensor<readonly:f32>
  %7 = hal.interface.binding.subspan @io::@s0b3_xw_external[%c0] : memref<1x10xf32>
  %8 = hal.interface.binding.subspan @io::@s0b3_xw_external[%c0] : !flow.dispatch.tensor<writeonly:1x10xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %9 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_y]
  %10 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_y]
  scf.for %arg0 = %9 to %c1 step %10 {
    %11 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
    %12 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
    scf.for %arg1 = %11 to %c10 step %12 {
      %13 = affine.min affine_map<(d0) -> (128, -d0 + 1)>(%arg0)
      %14 = affine.min affine_map<(d0) -> (128, -d0 + 10)>(%arg1)
      %15 = memref.subview %1[%arg0, %arg1] [%13, %14] [1, 1] : memref<1x10xf32> to memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
      %16 = affine.min affine_map<(d0) -> (128, -d0 + 1)>(%arg0)
      %17 = affine.min affine_map<(d0) -> (128, -d0 + 10)>(%arg1)
      %18 = memref.subview %0[%arg0, %arg1] [%16, %17] [1, 1] : memref<1x10xf32> to memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
      %19 = affine.min affine_map<(d0) -> (128, -d0 + 1)>(%arg0)
      %20 = affine.min affine_map<(d0) -> (128, -d0 + 10)>(%arg1)
      %21 = memref.subview %7[%arg0, %arg1] [%19, %20] [1, 1] : memref<1x10xf32> to memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
      linalg.generic {indexing_maps = [affine_map<(d0, d1) -> (d0, d1)>, affine_map<(d0, d1) -> (d0, d1)>, affine_map<(d0, d1) -> ()>, affine_map<(d0, d1) -> ()>, affine_map<(d0, d1) -> (d0, d1)>], iterator_types = ["parallel", "parallel"]} ins(%15, %18, %3, %5 : memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>, memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>, memref<f32>, memref<f32>) outs(%21 : memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>) attrs =  {__internal_linalg_transform__ = "workgroup", lowering.config = {tileSizes = [[128, 128]]}} {
      ^bb0(%arg2: f32, %arg3: f32, %arg4: f32, %arg5: f32, %arg6: f32):  // no predecessors
        %22 = addf %arg2, %arg3 : f32
        %23 = subf %22, %arg4 : f32
        %24 = math.exp %23 : f32
        %25 = divf %24, %arg5 : f32
        linalg.yield %25 : f32
      }
    }
  }
  return
}

// *** IR Dump After CSE ***
func @predict_dispatch_7() {
  %c0 = constant 0 : index
  %cst = constant opaque<"_", "0xDEADBEEF"> : tensor<1x10xf32>
  %c1 = constant 1 : index
  %c10 = constant 10 : index
  %0 = memref.buffer_cast %cst : memref<1x10xf32>
  %1 = hal.interface.binding.subspan @io::@s0b0_ro_external[%c0] : memref<1x10xf32>
  %2 = hal.interface.binding.subspan @io::@s0b0_ro_external[%c0] : !flow.dispatch.tensor<readonly:1x10xf32>
  %3 = hal.interface.binding.subspan @io::@s0b1_ro_external[%c0] : memref<f32>
  %4 = hal.interface.binding.subspan @io::@s0b1_ro_external[%c0] : !flow.dispatch.tensor<readonly:f32>
  %5 = hal.interface.binding.subspan @io::@s0b2_ro_external[%c0] : memref<f32>
  %6 = hal.interface.binding.subspan @io::@s0b2_ro_external[%c0] : !flow.dispatch.tensor<readonly:f32>
  %7 = hal.interface.binding.subspan @io::@s0b3_xw_external[%c0] : memref<1x10xf32>
  %8 = hal.interface.binding.subspan @io::@s0b3_xw_external[%c0] : !flow.dispatch.tensor<writeonly:1x10xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %9 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_y]
  %10 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_y]
  scf.for %arg0 = %9 to %c1 step %10 {
    %11 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
    %12 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
    scf.for %arg1 = %11 to %c10 step %12 {
      %13 = affine.min affine_map<(d0) -> (128, -d0 + 1)>(%arg0)
      %14 = affine.min affine_map<(d0) -> (128, -d0 + 10)>(%arg1)
      %15 = memref.subview %1[%arg0, %arg1] [%13, %14] [1, 1] : memref<1x10xf32> to memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
      %16 = memref.subview %0[%arg0, %arg1] [%13, %14] [1, 1] : memref<1x10xf32> to memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
      %17 = memref.subview %7[%arg0, %arg1] [%13, %14] [1, 1] : memref<1x10xf32> to memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
      linalg.generic {indexing_maps = [affine_map<(d0, d1) -> (d0, d1)>, affine_map<(d0, d1) -> (d0, d1)>, affine_map<(d0, d1) -> ()>, affine_map<(d0, d1) -> ()>, affine_map<(d0, d1) -> (d0, d1)>], iterator_types = ["parallel", "parallel"]} ins(%15, %16, %3, %5 : memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>, memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>, memref<f32>, memref<f32>) outs(%17 : memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>) attrs =  {__internal_linalg_transform__ = "workgroup", lowering.config = {tileSizes = [[128, 128]]}} {
      ^bb0(%arg2: f32, %arg3: f32, %arg4: f32, %arg5: f32, %arg6: f32):  // no predecessors
        %18 = addf %arg2, %arg3 : f32
        %19 = subf %18, %arg4 : f32
        %20 = math.exp %19 : f32
        %21 = divf %20, %arg5 : f32
        linalg.yield %21 : f32
      }
    }
  }
  return
}

// *** IR Dump After mlir::iree_compiler::`anonymous-namespace'::BufferAllocViewCleanUpPass ***
func @predict_dispatch_7() {
  %c0 = constant 0 : index
  %cst = constant opaque<"_", "0xDEADBEEF"> : tensor<1x10xf32>
  %c1 = constant 1 : index
  %c10 = constant 10 : index
  %0 = memref.buffer_cast %cst : memref<1x10xf32>
  %1 = hal.interface.binding.subspan @io::@s0b0_ro_external[%c0] : memref<1x10xf32>
  %2 = hal.interface.binding.subspan @io::@s0b1_ro_external[%c0] : memref<f32>
  %3 = hal.interface.binding.subspan @io::@s0b2_ro_external[%c0] : memref<f32>
  %4 = hal.interface.binding.subspan @io::@s0b3_xw_external[%c0] : memref<1x10xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %5 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_y]
  %6 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_y]
  scf.for %arg0 = %5 to %c1 step %6 {
    %7 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
    %8 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
    scf.for %arg1 = %7 to %c10 step %8 {
      %9 = affine.min affine_map<(d0) -> (128, -d0 + 1)>(%arg0)
      %10 = affine.min affine_map<(d0) -> (128, -d0 + 10)>(%arg1)
      %11 = memref.subview %1[%arg0, %arg1] [%9, %10] [1, 1] : memref<1x10xf32> to memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
      %12 = memref.subview %0[%arg0, %arg1] [%9, %10] [1, 1] : memref<1x10xf32> to memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
      %13 = memref.subview %4[%arg0, %arg1] [%9, %10] [1, 1] : memref<1x10xf32> to memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
      linalg.generic {indexing_maps = [affine_map<(d0, d1) -> (d0, d1)>, affine_map<(d0, d1) -> (d0, d1)>, affine_map<(d0, d1) -> ()>, affine_map<(d0, d1) -> ()>, affine_map<(d0, d1) -> (d0, d1)>], iterator_types = ["parallel", "parallel"]} ins(%11, %12, %2, %3 : memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>, memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>, memref<f32>, memref<f32>) outs(%13 : memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>) attrs =  {__internal_linalg_transform__ = "workgroup", lowering.config = {tileSizes = [[128, 128]]}} {
      ^bb0(%arg2: f32, %arg3: f32, %arg4: f32, %arg5: f32, %arg6: f32):  // no predecessors
        %14 = addf %arg2, %arg3 : f32
        %15 = subf %14, %arg4 : f32
        %16 = math.exp %15 : f32
        %17 = divf %16, %arg5 : f32
        linalg.yield %17 : f32
      }
    }
  }
  return
}

// *** IR Dump After Canonicalizer ***
func @predict_dispatch_7() {
  %c0 = constant 0 : index
  %cst = constant opaque<"_", "0xDEADBEEF"> : tensor<1x10xf32>
  %c1 = constant 1 : index
  %c10 = constant 10 : index
  %0 = memref.buffer_cast %cst : memref<1x10xf32>
  %1 = hal.interface.binding.subspan @io::@s0b0_ro_external[%c0] : memref<1x10xf32>
  %2 = hal.interface.binding.subspan @io::@s0b1_ro_external[%c0] : memref<f32>
  %3 = hal.interface.binding.subspan @io::@s0b2_ro_external[%c0] : memref<f32>
  %4 = hal.interface.binding.subspan @io::@s0b3_xw_external[%c0] : memref<1x10xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %5 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_y]
  %6 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_y]
  scf.for %arg0 = %5 to %c1 step %6 {
    %7 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
    %8 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
    scf.for %arg1 = %7 to %c10 step %8 {
      %9 = affine.min affine_map<(d0) -> (128, -d0 + 1)>(%arg0)
      %10 = affine.min affine_map<(d0) -> (128, -d0 + 10)>(%arg1)
      %11 = memref.subview %1[%arg0, %arg1] [%9, %10] [1, 1] : memref<1x10xf32> to memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
      %12 = memref.subview %0[%arg0, %arg1] [%9, %10] [1, 1] : memref<1x10xf32> to memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
      %13 = memref.subview %4[%arg0, %arg1] [%9, %10] [1, 1] : memref<1x10xf32> to memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
      linalg.generic {indexing_maps = [affine_map<(d0, d1) -> (d0, d1)>, affine_map<(d0, d1) -> (d0, d1)>, affine_map<(d0, d1) -> ()>, affine_map<(d0, d1) -> ()>, affine_map<(d0, d1) -> (d0, d1)>], iterator_types = ["parallel", "parallel"]} ins(%11, %12, %2, %3 : memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>, memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>, memref<f32>, memref<f32>) outs(%13 : memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>) attrs =  {__internal_linalg_transform__ = "workgroup", lowering.config = {tileSizes = [[128, 128]]}} {
      ^bb0(%arg2: f32, %arg3: f32, %arg4: f32, %arg5: f32, %arg6: f32):  // no predecessors
        %14 = addf %arg2, %arg3 : f32
        %15 = subf %14, %arg4 : f32
        %16 = math.exp %15 : f32
        %17 = divf %16, %arg5 : f32
        linalg.yield %17 : f32
      }
    }
  }
  return
}

// *** IR Dump After mlir::iree_compiler::`anonymous-namespace'::TileAndVectorizeWorkgroups ***
func @predict_dispatch_7() {
  %c0 = constant 0 : index
  %cst = constant opaque<"_", "0xDEADBEEF"> : tensor<1x10xf32>
  %c1 = constant 1 : index
  %c10 = constant 10 : index
  %0 = memref.buffer_cast %cst : memref<1x10xf32>
  %1 = hal.interface.binding.subspan @io::@s0b0_ro_external[%c0] : memref<1x10xf32>
  %2 = hal.interface.binding.subspan @io::@s0b1_ro_external[%c0] : memref<f32>
  %3 = hal.interface.binding.subspan @io::@s0b2_ro_external[%c0] : memref<f32>
  %4 = hal.interface.binding.subspan @io::@s0b3_xw_external[%c0] : memref<1x10xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %5 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_y]
  %6 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_y]
  scf.for %arg0 = %5 to %c1 step %6 {
    %7 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
    %8 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
    scf.for %arg1 = %7 to %c10 step %8 {
      %9 = affine.min affine_map<(d0) -> (128, -d0 + 1)>(%arg0)
      %10 = affine.min affine_map<(d0) -> (128, -d0 + 10)>(%arg1)
      %11 = memref.subview %1[%arg0, %arg1] [%9, %10] [1, 1] : memref<1x10xf32> to memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
      %12 = memref.subview %0[%arg0, %arg1] [%9, %10] [1, 1] : memref<1x10xf32> to memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
      %13 = memref.subview %4[%arg0, %arg1] [%9, %10] [1, 1] : memref<1x10xf32> to memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
      linalg.generic {indexing_maps = [affine_map<(d0, d1) -> (d0, d1)>, affine_map<(d0, d1) -> (d0, d1)>, affine_map<(d0, d1) -> ()>, affine_map<(d0, d1) -> ()>, affine_map<(d0, d1) -> (d0, d1)>], iterator_types = ["parallel", "parallel"]} ins(%11, %12, %2, %3 : memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>, memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>, memref<f32>, memref<f32>) outs(%13 : memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>) attrs =  {__internal_linalg_transform__ = "workgroup", lowering.config = {tileSizes = [[128, 128]]}} {
      ^bb0(%arg2: f32, %arg3: f32, %arg4: f32, %arg5: f32, %arg6: f32):  // no predecessors
        %14 = addf %arg2, %arg3 : f32
        %15 = subf %14, %arg4 : f32
        %16 = math.exp %15 : f32
        %17 = divf %16, %arg5 : f32
        linalg.yield %17 : f32
      }
    }
  }
  return
}

// *** IR Dump After Canonicalizer ***
func @predict_dispatch_7() {
  %c0 = constant 0 : index
  %cst = constant opaque<"_", "0xDEADBEEF"> : tensor<1x10xf32>
  %c1 = constant 1 : index
  %c10 = constant 10 : index
  %0 = memref.buffer_cast %cst : memref<1x10xf32>
  %1 = hal.interface.binding.subspan @io::@s0b0_ro_external[%c0] : memref<1x10xf32>
  %2 = hal.interface.binding.subspan @io::@s0b1_ro_external[%c0] : memref<f32>
  %3 = hal.interface.binding.subspan @io::@s0b2_ro_external[%c0] : memref<f32>
  %4 = hal.interface.binding.subspan @io::@s0b3_xw_external[%c0] : memref<1x10xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %5 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_y]
  %6 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_y]
  scf.for %arg0 = %5 to %c1 step %6 {
    %7 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
    %8 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
    scf.for %arg1 = %7 to %c10 step %8 {
      %9 = affine.min affine_map<(d0) -> (128, -d0 + 1)>(%arg0)
      %10 = affine.min affine_map<(d0) -> (128, -d0 + 10)>(%arg1)
      %11 = memref.subview %1[%arg0, %arg1] [%9, %10] [1, 1] : memref<1x10xf32> to memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
      %12 = memref.subview %0[%arg0, %arg1] [%9, %10] [1, 1] : memref<1x10xf32> to memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
      %13 = memref.subview %4[%arg0, %arg1] [%9, %10] [1, 1] : memref<1x10xf32> to memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
      linalg.generic {indexing_maps = [affine_map<(d0, d1) -> (d0, d1)>, affine_map<(d0, d1) -> (d0, d1)>, affine_map<(d0, d1) -> ()>, affine_map<(d0, d1) -> ()>, affine_map<(d0, d1) -> (d0, d1)>], iterator_types = ["parallel", "parallel"]} ins(%11, %12, %2, %3 : memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>, memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>, memref<f32>, memref<f32>) outs(%13 : memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>) attrs =  {__internal_linalg_transform__ = "workgroup", lowering.config = {tileSizes = [[128, 128]]}} {
      ^bb0(%arg2: f32, %arg3: f32, %arg4: f32, %arg5: f32, %arg6: f32):  // no predecessors
        %14 = addf %arg2, %arg3 : f32
        %15 = subf %14, %arg4 : f32
        %16 = math.exp %15 : f32
        %17 = divf %16, %arg5 : f32
        linalg.yield %17 : f32
      }
    }
  }
  return
}

// *** IR Dump After mlir::iree_compiler::`anonymous-namespace'::ForOpCanonicalizationPass ***
func @predict_dispatch_7() {
  %c0 = constant 0 : index
  %cst = constant opaque<"_", "0xDEADBEEF"> : tensor<1x10xf32>
  %c1 = constant 1 : index
  %c10 = constant 10 : index
  %0 = memref.buffer_cast %cst : memref<1x10xf32>
  %1 = hal.interface.binding.subspan @io::@s0b0_ro_external[%c0] : memref<1x10xf32>
  %2 = hal.interface.binding.subspan @io::@s0b1_ro_external[%c0] : memref<f32>
  %3 = hal.interface.binding.subspan @io::@s0b2_ro_external[%c0] : memref<f32>
  %4 = hal.interface.binding.subspan @io::@s0b3_xw_external[%c0] : memref<1x10xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %5 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_y]
  %6 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_y]
  scf.for %arg0 = %5 to %c1 step %6 {
    %7 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
    %8 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
    scf.for %arg1 = %7 to %c10 step %8 {
      %9 = affine.min affine_map<(d0) -> (128, -d0 + 1)>(%arg0)
      %10 = affine.min affine_map<(d0) -> (128, -d0 + 10)>(%arg1)
      %11 = memref.subview %1[%arg0, %arg1] [%9, %10] [1, 1] : memref<1x10xf32> to memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
      %12 = memref.subview %0[%arg0, %arg1] [%9, %10] [1, 1] : memref<1x10xf32> to memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
      %13 = memref.subview %4[%arg0, %arg1] [%9, %10] [1, 1] : memref<1x10xf32> to memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
      linalg.generic {indexing_maps = [affine_map<(d0, d1) -> (d0, d1)>, affine_map<(d0, d1) -> (d0, d1)>, affine_map<(d0, d1) -> ()>, affine_map<(d0, d1) -> ()>, affine_map<(d0, d1) -> (d0, d1)>], iterator_types = ["parallel", "parallel"]} ins(%11, %12, %2, %3 : memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>, memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>, memref<f32>, memref<f32>) outs(%13 : memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>) attrs =  {__internal_linalg_transform__ = "workgroup", lowering.config = {tileSizes = [[128, 128]]}} {
      ^bb0(%arg2: f32, %arg3: f32, %arg4: f32, %arg5: f32, %arg6: f32):  // no predecessors
        %14 = addf %arg2, %arg3 : f32
        %15 = subf %14, %arg4 : f32
        %16 = math.exp %15 : f32
        %17 = divf %16, %arg5 : f32
        linalg.yield %17 : f32
      }
    }
  }
  return
}

// *** IR Dump After mlir::iree_compiler::`anonymous-namespace'::PlanConvLoopOrderPass ***
func @predict_dispatch_7() {
  %c0 = constant 0 : index
  %cst = constant opaque<"_", "0xDEADBEEF"> : tensor<1x10xf32>
  %c1 = constant 1 : index
  %c10 = constant 10 : index
  %0 = memref.buffer_cast %cst : memref<1x10xf32>
  %1 = hal.interface.binding.subspan @io::@s0b0_ro_external[%c0] : memref<1x10xf32>
  %2 = hal.interface.binding.subspan @io::@s0b1_ro_external[%c0] : memref<f32>
  %3 = hal.interface.binding.subspan @io::@s0b2_ro_external[%c0] : memref<f32>
  %4 = hal.interface.binding.subspan @io::@s0b3_xw_external[%c0] : memref<1x10xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %5 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_y]
  %6 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_y]
  scf.for %arg0 = %5 to %c1 step %6 {
    %7 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
    %8 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
    scf.for %arg1 = %7 to %c10 step %8 {
      %9 = affine.min affine_map<(d0) -> (128, -d0 + 1)>(%arg0)
      %10 = affine.min affine_map<(d0) -> (128, -d0 + 10)>(%arg1)
      %11 = memref.subview %1[%arg0, %arg1] [%9, %10] [1, 1] : memref<1x10xf32> to memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
      %12 = memref.subview %0[%arg0, %arg1] [%9, %10] [1, 1] : memref<1x10xf32> to memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
      %13 = memref.subview %4[%arg0, %arg1] [%9, %10] [1, 1] : memref<1x10xf32> to memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
      linalg.generic {indexing_maps = [affine_map<(d0, d1) -> (d0, d1)>, affine_map<(d0, d1) -> (d0, d1)>, affine_map<(d0, d1) -> ()>, affine_map<(d0, d1) -> ()>, affine_map<(d0, d1) -> (d0, d1)>], iterator_types = ["parallel", "parallel"]} ins(%11, %12, %2, %3 : memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>, memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>, memref<f32>, memref<f32>) outs(%13 : memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>) attrs =  {__internal_linalg_transform__ = "workgroup", lowering.config = {tileSizes = [[128, 128]]}} {
      ^bb0(%arg2: f32, %arg3: f32, %arg4: f32, %arg5: f32, %arg6: f32):  // no predecessors
        %14 = addf %arg2, %arg3 : f32
        %15 = subf %14, %arg4 : f32
        %16 = math.exp %15 : f32
        %17 = divf %16, %arg5 : f32
        linalg.yield %17 : f32
      }
    }
  }
  return
}

// *** IR Dump After LinalgLowerToLoops ***
func @predict_dispatch_7() {
  %cst = constant opaque<"_", "0xDEADBEEF"> : tensor<1x10xf32>
  %c10 = constant 10 : index
  %c0 = constant 0 : index
  %c1 = constant 1 : index
  %0 = memref.buffer_cast %cst : memref<1x10xf32>
  %1 = hal.interface.binding.subspan @io::@s0b0_ro_external[%c0] : memref<1x10xf32>
  %2 = hal.interface.binding.subspan @io::@s0b1_ro_external[%c0] : memref<f32>
  %3 = hal.interface.binding.subspan @io::@s0b2_ro_external[%c0] : memref<f32>
  %4 = hal.interface.binding.subspan @io::@s0b3_xw_external[%c0] : memref<1x10xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %5 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_y]
  %6 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_y]
  scf.for %arg0 = %5 to %c1 step %6 {
    %7 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
    %8 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
    scf.for %arg1 = %7 to %c10 step %8 {
      %9 = affine.min affine_map<(d0) -> (128, -d0 + 1)>(%arg0)
      %10 = affine.min affine_map<(d0) -> (128, -d0 + 10)>(%arg1)
      %11 = memref.subview %1[%arg0, %arg1] [%9, %10] [1, 1] : memref<1x10xf32> to memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
      %12 = memref.subview %0[%arg0, %arg1] [%9, %10] [1, 1] : memref<1x10xf32> to memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
      %13 = memref.subview %4[%arg0, %arg1] [%9, %10] [1, 1] : memref<1x10xf32> to memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
      scf.for %arg2 = %c0 to %9 step %c1 {
        scf.for %arg3 = %c0 to %10 step %c1 {
          %14 = memref.load %11[%arg2, %arg3] : memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
          %15 = memref.load %12[%arg2, %arg3] : memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
          %16 = memref.load %2[] : memref<f32>
          %17 = memref.load %3[] : memref<f32>
          %18 = addf %14, %15 : f32
          %19 = subf %18, %16 : f32
          %20 = math.exp %19 : f32
          %21 = divf %20, %17 : f32
          memref.store %21, %13[%arg2, %arg3] : memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
        }
      }
    }
  }
  return
}

// *** IR Dump After Canonicalizer ***
func @predict_dispatch_7() {
  %cst = constant opaque<"_", "0xDEADBEEF"> : tensor<1x10xf32>
  %c10 = constant 10 : index
  %c0 = constant 0 : index
  %c1 = constant 1 : index
  %0 = memref.buffer_cast %cst : memref<1x10xf32>
  %1 = hal.interface.binding.subspan @io::@s0b0_ro_external[%c0] : memref<1x10xf32>
  %2 = hal.interface.binding.subspan @io::@s0b1_ro_external[%c0] : memref<f32>
  %3 = hal.interface.binding.subspan @io::@s0b2_ro_external[%c0] : memref<f32>
  %4 = hal.interface.binding.subspan @io::@s0b3_xw_external[%c0] : memref<1x10xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %5 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_y]
  %6 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_y]
  scf.for %arg0 = %5 to %c1 step %6 {
    %7 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
    %8 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
    scf.for %arg1 = %7 to %c10 step %8 {
      %9 = affine.min affine_map<(d0) -> (128, -d0 + 1)>(%arg0)
      %10 = affine.min affine_map<(d0) -> (128, -d0 + 10)>(%arg1)
      %11 = memref.subview %1[%arg0, %arg1] [%9, %10] [1, 1] : memref<1x10xf32> to memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
      %12 = memref.subview %0[%arg0, %arg1] [%9, %10] [1, 1] : memref<1x10xf32> to memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
      %13 = memref.subview %4[%arg0, %arg1] [%9, %10] [1, 1] : memref<1x10xf32> to memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
      scf.for %arg2 = %c0 to %9 step %c1 {
        scf.for %arg3 = %c0 to %10 step %c1 {
          %14 = memref.load %11[%arg2, %arg3] : memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
          %15 = memref.load %12[%arg2, %arg3] : memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
          %16 = memref.load %2[] : memref<f32>
          %17 = memref.load %3[] : memref<f32>
          %18 = addf %14, %15 : f32
          %19 = subf %18, %16 : f32
          %20 = math.exp %19 : f32
          %21 = divf %20, %17 : f32
          memref.store %21, %13[%arg2, %arg3] : memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
        }
      }
    }
  }
  return
}

// *** IR Dump After CSE ***
func @predict_dispatch_7() {
  %cst = constant opaque<"_", "0xDEADBEEF"> : tensor<1x10xf32>
  %c10 = constant 10 : index
  %c0 = constant 0 : index
  %c1 = constant 1 : index
  %0 = memref.buffer_cast %cst : memref<1x10xf32>
  %1 = hal.interface.binding.subspan @io::@s0b0_ro_external[%c0] : memref<1x10xf32>
  %2 = hal.interface.binding.subspan @io::@s0b1_ro_external[%c0] : memref<f32>
  %3 = hal.interface.binding.subspan @io::@s0b2_ro_external[%c0] : memref<f32>
  %4 = hal.interface.binding.subspan @io::@s0b3_xw_external[%c0] : memref<1x10xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %5 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_y]
  %6 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_y]
  scf.for %arg0 = %5 to %c1 step %6 {
    %7 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
    %8 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
    scf.for %arg1 = %7 to %c10 step %8 {
      %9 = affine.min affine_map<(d0) -> (128, -d0 + 1)>(%arg0)
      %10 = affine.min affine_map<(d0) -> (128, -d0 + 10)>(%arg1)
      %11 = memref.subview %1[%arg0, %arg1] [%9, %10] [1, 1] : memref<1x10xf32> to memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
      %12 = memref.subview %0[%arg0, %arg1] [%9, %10] [1, 1] : memref<1x10xf32> to memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
      %13 = memref.subview %4[%arg0, %arg1] [%9, %10] [1, 1] : memref<1x10xf32> to memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
      scf.for %arg2 = %c0 to %9 step %c1 {
        scf.for %arg3 = %c0 to %10 step %c1 {
          %14 = memref.load %11[%arg2, %arg3] : memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
          %15 = memref.load %12[%arg2, %arg3] : memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
          %16 = memref.load %2[] : memref<f32>
          %17 = memref.load %3[] : memref<f32>
          %18 = addf %14, %15 : f32
          %19 = subf %18, %16 : f32
          %20 = math.exp %19 : f32
          %21 = divf %20, %17 : f32
          memref.store %21, %13[%arg2, %arg3] : memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
        }
      }
    }
  }
  return
}

// *** IR Dump After SCFToStandard ***
func @predict_dispatch_7() {
  %cst = constant opaque<"_", "0xDEADBEEF"> : tensor<1x10xf32>
  %c10 = constant 10 : index
  %c0 = constant 0 : index
  %c1 = constant 1 : index
  %0 = memref.buffer_cast %cst : memref<1x10xf32>
  %1 = hal.interface.binding.subspan @io::@s0b0_ro_external[%c0] : memref<1x10xf32>
  %2 = hal.interface.binding.subspan @io::@s0b1_ro_external[%c0] : memref<f32>
  %3 = hal.interface.binding.subspan @io::@s0b2_ro_external[%c0] : memref<f32>
  %4 = hal.interface.binding.subspan @io::@s0b3_xw_external[%c0] : memref<1x10xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %5 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_y]
  %6 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_y]
  br ^bb1(%5 : index)
^bb1(%7: index):  // 2 preds: ^bb0, ^bb11
  %8 = cmpi slt, %7, %c1 : index
  cond_br %8, ^bb2, ^bb12
^bb2:  // pred: ^bb1
  %9 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %10 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
  br ^bb3(%9 : index)
^bb3(%11: index):  // 2 preds: ^bb2, ^bb10
  %12 = cmpi slt, %11, %c10 : index
  cond_br %12, ^bb4, ^bb11
^bb4:  // pred: ^bb3
  %13 = affine.min affine_map<(d0) -> (128, -d0 + 1)>(%7)
  %14 = affine.min affine_map<(d0) -> (128, -d0 + 10)>(%11)
  %15 = memref.subview %1[%7, %11] [%13, %14] [1, 1] : memref<1x10xf32> to memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
  %16 = memref.subview %0[%7, %11] [%13, %14] [1, 1] : memref<1x10xf32> to memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
  %17 = memref.subview %4[%7, %11] [%13, %14] [1, 1] : memref<1x10xf32> to memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
  br ^bb5(%c0 : index)
^bb5(%18: index):  // 2 preds: ^bb4, ^bb9
  %19 = cmpi slt, %18, %13 : index
  cond_br %19, ^bb6, ^bb10
^bb6:  // pred: ^bb5
  br ^bb7(%c0 : index)
^bb7(%20: index):  // 2 preds: ^bb6, ^bb8
  %21 = cmpi slt, %20, %14 : index
  cond_br %21, ^bb8, ^bb9
^bb8:  // pred: ^bb7
  %22 = memref.load %15[%18, %20] : memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
  %23 = memref.load %16[%18, %20] : memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
  %24 = memref.load %2[] : memref<f32>
  %25 = memref.load %3[] : memref<f32>
  %26 = addf %22, %23 : f32
  %27 = subf %26, %24 : f32
  %28 = math.exp %27 : f32
  %29 = divf %28, %25 : f32
  memref.store %29, %17[%18, %20] : memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
  %30 = addi %20, %c1 : index
  br ^bb7(%30 : index)
^bb9:  // pred: ^bb7
  %31 = addi %18, %c1 : index
  br ^bb5(%31 : index)
^bb10:  // pred: ^bb5
  %32 = addi %11, %10 : index
  br ^bb3(%32 : index)
^bb11:  // pred: ^bb3
  %33 = addi %7, %6 : index
  br ^bb1(%33 : index)
^bb12:  // pred: ^bb1
  return
}

// *** IR Dump After Canonicalizer ***
func @predict_dispatch_7() {
  %cst = constant opaque<"_", "0xDEADBEEF"> : tensor<1x10xf32>
  %c10 = constant 10 : index
  %c0 = constant 0 : index
  %c1 = constant 1 : index
  %0 = memref.buffer_cast %cst : memref<1x10xf32>
  %1 = hal.interface.binding.subspan @io::@s0b0_ro_external[%c0] : memref<1x10xf32>
  %2 = hal.interface.binding.subspan @io::@s0b1_ro_external[%c0] : memref<f32>
  %3 = hal.interface.binding.subspan @io::@s0b2_ro_external[%c0] : memref<f32>
  %4 = hal.interface.binding.subspan @io::@s0b3_xw_external[%c0] : memref<1x10xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %5 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_y]
  %6 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_y]
  br ^bb1(%5 : index)
^bb1(%7: index):  // 2 preds: ^bb0, ^bb10
  %8 = cmpi slt, %7, %c1 : index
  cond_br %8, ^bb2, ^bb11
^bb2:  // pred: ^bb1
  %9 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %10 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
  br ^bb3(%9 : index)
^bb3(%11: index):  // 2 preds: ^bb2, ^bb9
  %12 = cmpi slt, %11, %c10 : index
  cond_br %12, ^bb4, ^bb10
^bb4:  // pred: ^bb3
  %13 = affine.min affine_map<()[s0] -> (128, -s0 + 1)>()[%7]
  %14 = affine.min affine_map<()[s0] -> (128, -s0 + 10)>()[%11]
  %15 = memref.subview %1[%7, %11] [%13, %14] [1, 1] : memref<1x10xf32> to memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
  %16 = memref.subview %0[%7, %11] [%13, %14] [1, 1] : memref<1x10xf32> to memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
  %17 = memref.subview %4[%7, %11] [%13, %14] [1, 1] : memref<1x10xf32> to memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
  br ^bb5(%c0 : index)
^bb5(%18: index):  // 2 preds: ^bb4, ^bb8
  %19 = cmpi slt, %18, %13 : index
  cond_br %19, ^bb6(%c0 : index), ^bb9
^bb6(%20: index):  // 2 preds: ^bb5, ^bb7
  %21 = cmpi slt, %20, %14 : index
  cond_br %21, ^bb7, ^bb8
^bb7:  // pred: ^bb6
  %22 = memref.load %15[%18, %20] : memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
  %23 = memref.load %16[%18, %20] : memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
  %24 = memref.load %2[] : memref<f32>
  %25 = memref.load %3[] : memref<f32>
  %26 = addf %22, %23 : f32
  %27 = subf %26, %24 : f32
  %28 = math.exp %27 : f32
  %29 = divf %28, %25 : f32
  memref.store %29, %17[%18, %20] : memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
  %30 = addi %20, %c1 : index
  br ^bb6(%30 : index)
^bb8:  // pred: ^bb6
  %31 = addi %18, %c1 : index
  br ^bb5(%31 : index)
^bb9:  // pred: ^bb5
  %32 = addi %11, %10 : index
  br ^bb3(%32 : index)
^bb10:  // pred: ^bb3
  %33 = addi %7, %6 : index
  br ^bb1(%33 : index)
^bb11:  // pred: ^bb1
  return
}

// *** IR Dump After CSE ***
func @predict_dispatch_7() {
  %cst = constant opaque<"_", "0xDEADBEEF"> : tensor<1x10xf32>
  %c10 = constant 10 : index
  %c0 = constant 0 : index
  %c1 = constant 1 : index
  %0 = memref.buffer_cast %cst : memref<1x10xf32>
  %1 = hal.interface.binding.subspan @io::@s0b0_ro_external[%c0] : memref<1x10xf32>
  %2 = hal.interface.binding.subspan @io::@s0b1_ro_external[%c0] : memref<f32>
  %3 = hal.interface.binding.subspan @io::@s0b2_ro_external[%c0] : memref<f32>
  %4 = hal.interface.binding.subspan @io::@s0b3_xw_external[%c0] : memref<1x10xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %5 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_y]
  %6 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_y]
  br ^bb1(%5 : index)
^bb1(%7: index):  // 2 preds: ^bb0, ^bb10
  %8 = cmpi slt, %7, %c1 : index
  cond_br %8, ^bb2, ^bb11
^bb2:  // pred: ^bb1
  %9 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %10 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
  br ^bb3(%9 : index)
^bb3(%11: index):  // 2 preds: ^bb2, ^bb9
  %12 = cmpi slt, %11, %c10 : index
  cond_br %12, ^bb4, ^bb10
^bb4:  // pred: ^bb3
  %13 = affine.min affine_map<()[s0] -> (128, -s0 + 1)>()[%7]
  %14 = affine.min affine_map<()[s0] -> (128, -s0 + 10)>()[%11]
  %15 = memref.subview %1[%7, %11] [%13, %14] [1, 1] : memref<1x10xf32> to memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
  %16 = memref.subview %0[%7, %11] [%13, %14] [1, 1] : memref<1x10xf32> to memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
  %17 = memref.subview %4[%7, %11] [%13, %14] [1, 1] : memref<1x10xf32> to memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
  br ^bb5(%c0 : index)
^bb5(%18: index):  // 2 preds: ^bb4, ^bb8
  %19 = cmpi slt, %18, %13 : index
  cond_br %19, ^bb6(%c0 : index), ^bb9
^bb6(%20: index):  // 2 preds: ^bb5, ^bb7
  %21 = cmpi slt, %20, %14 : index
  cond_br %21, ^bb7, ^bb8
^bb7:  // pred: ^bb6
  %22 = memref.load %15[%18, %20] : memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
  %23 = memref.load %16[%18, %20] : memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
  %24 = memref.load %2[] : memref<f32>
  %25 = memref.load %3[] : memref<f32>
  %26 = addf %22, %23 : f32
  %27 = subf %26, %24 : f32
  %28 = math.exp %27 : f32
  %29 = divf %28, %25 : f32
  memref.store %29, %17[%18, %20] : memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
  %30 = addi %20, %c1 : index
  br ^bb6(%30 : index)
^bb8:  // pred: ^bb6
  %31 = addi %18, %c1 : index
  br ^bb5(%31 : index)
^bb9:  // pred: ^bb5
  %32 = addi %11, %10 : index
  br ^bb3(%32 : index)
^bb10:  // pred: ^bb3
  %33 = addi %7, %6 : index
  br ^bb1(%33 : index)
^bb11:  // pred: ^bb1
  return
}

// *** IR Dump After TensorConstantBufferize ***
module  {
  memref.global "private" constant @__constant_1x10xf32 : memref<1x10xf32> = opaque<"_", "0xDEADBEEF">
  func @predict_dispatch_7() {
    %0 = memref.get_global @__constant_1x10xf32 : memref<1x10xf32>
    %1 = memref.tensor_load %0 : memref<1x10xf32>
    %c10 = constant 10 : index
    %c0 = constant 0 : index
    %c1 = constant 1 : index
    %2 = memref.buffer_cast %1 : memref<1x10xf32>
    %3 = hal.interface.binding.subspan @io::@s0b0_ro_external[%c0] : memref<1x10xf32>
    %4 = hal.interface.binding.subspan @io::@s0b1_ro_external[%c0] : memref<f32>
    %5 = hal.interface.binding.subspan @io::@s0b2_ro_external[%c0] : memref<f32>
    %6 = hal.interface.binding.subspan @io::@s0b3_xw_external[%c0] : memref<1x10xf32>
    %workgroup_id_x = hal.interface.workgroup.id[0] : index
    %workgroup_count_x = hal.interface.workgroup.count[0] : index
    %workgroup_id_y = hal.interface.workgroup.id[1] : index
    %workgroup_count_y = hal.interface.workgroup.count[1] : index
    %7 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_y]
    %8 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_y]
    br ^bb1(%7 : index)
  ^bb1(%9: index):  // 2 preds: ^bb0, ^bb10
    %10 = cmpi slt, %9, %c1 : index
    cond_br %10, ^bb2, ^bb11
  ^bb2:  // pred: ^bb1
    %11 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
    %12 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
    br ^bb3(%11 : index)
  ^bb3(%13: index):  // 2 preds: ^bb2, ^bb9
    %14 = cmpi slt, %13, %c10 : index
    cond_br %14, ^bb4, ^bb10
  ^bb4:  // pred: ^bb3
    %15 = affine.min affine_map<()[s0] -> (128, -s0 + 1)>()[%9]
    %16 = affine.min affine_map<()[s0] -> (128, -s0 + 10)>()[%13]
    %17 = memref.subview %3[%9, %13] [%15, %16] [1, 1] : memref<1x10xf32> to memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
    %18 = memref.subview %2[%9, %13] [%15, %16] [1, 1] : memref<1x10xf32> to memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
    %19 = memref.subview %6[%9, %13] [%15, %16] [1, 1] : memref<1x10xf32> to memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
    br ^bb5(%c0 : index)
  ^bb5(%20: index):  // 2 preds: ^bb4, ^bb8
    %21 = cmpi slt, %20, %15 : index
    cond_br %21, ^bb6(%c0 : index), ^bb9
  ^bb6(%22: index):  // 2 preds: ^bb5, ^bb7
    %23 = cmpi slt, %22, %16 : index
    cond_br %23, ^bb7, ^bb8
  ^bb7:  // pred: ^bb6
    %24 = memref.load %17[%20, %22] : memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
    %25 = memref.load %18[%20, %22] : memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
    %26 = memref.load %4[] : memref<f32>
    %27 = memref.load %5[] : memref<f32>
    %28 = addf %24, %25 : f32
    %29 = subf %28, %26 : f32
    %30 = math.exp %29 : f32
    %31 = divf %30, %27 : f32
    memref.store %31, %19[%20, %22] : memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
    %32 = addi %22, %c1 : index
    br ^bb6(%32 : index)
  ^bb8:  // pred: ^bb6
    %33 = addi %20, %c1 : index
    br ^bb5(%33 : index)
  ^bb9:  // pred: ^bb5
    %34 = addi %13, %12 : index
    br ^bb3(%34 : index)
  ^bb10:  // pred: ^bb3
    %35 = addi %9, %8 : index
    br ^bb1(%35 : index)
  ^bb11:  // pred: ^bb1
    return
  }
  hal.interface @io attributes {sym_visibility = "private"} {
    hal.interface.binding @s0b0_ro_external, set=0, binding=0, type="StorageBuffer", access="Read"
    hal.interface.binding @s0b1_ro_external, set=0, binding=1, type="StorageBuffer", access="Read"
    hal.interface.binding @s0b2_ro_external, set=0, binding=2, type="StorageBuffer", access="Read"
    hal.interface.binding @s0b3_xw_external, set=0, binding=3, type="StorageBuffer", access="Write|Discard"
  }
}

// *** IR Dump After mlir::iree_compiler::`anonymous-namespace'::FoldTensorExtractOpPass ***
module  {
  memref.global "private" constant @__constant_1x10xf32 : memref<1x10xf32> = opaque<"_", "0xDEADBEEF">
  func @predict_dispatch_7() {
    %c10 = constant 10 : index
    %c0 = constant 0 : index
    %c1 = constant 1 : index
    %0 = memref.get_global @__constant_1x10xf32 : memref<1x10xf32>
    %1 = hal.interface.binding.subspan @io::@s0b0_ro_external[%c0] : memref<1x10xf32>
    %2 = hal.interface.binding.subspan @io::@s0b1_ro_external[%c0] : memref<f32>
    %3 = hal.interface.binding.subspan @io::@s0b2_ro_external[%c0] : memref<f32>
    %4 = hal.interface.binding.subspan @io::@s0b3_xw_external[%c0] : memref<1x10xf32>
    %workgroup_id_x = hal.interface.workgroup.id[0] : index
    %workgroup_count_x = hal.interface.workgroup.count[0] : index
    %workgroup_id_y = hal.interface.workgroup.id[1] : index
    %workgroup_count_y = hal.interface.workgroup.count[1] : index
    %5 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_y]
    %6 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_y]
    br ^bb1(%5 : index)
  ^bb1(%7: index):  // 2 preds: ^bb0, ^bb10
    %8 = cmpi slt, %7, %c1 : index
    cond_br %8, ^bb2, ^bb11
  ^bb2:  // pred: ^bb1
    %9 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
    %10 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
    br ^bb3(%9 : index)
  ^bb3(%11: index):  // 2 preds: ^bb2, ^bb9
    %12 = cmpi slt, %11, %c10 : index
    cond_br %12, ^bb4, ^bb10
  ^bb4:  // pred: ^bb3
    %13 = affine.min affine_map<()[s0] -> (128, -s0 + 1)>()[%7]
    %14 = affine.min affine_map<()[s0] -> (128, -s0 + 10)>()[%11]
    %15 = memref.subview %1[%7, %11] [%13, %14] [1, 1] : memref<1x10xf32> to memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
    %16 = memref.subview %0[%7, %11] [%13, %14] [1, 1] : memref<1x10xf32> to memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
    %17 = memref.subview %4[%7, %11] [%13, %14] [1, 1] : memref<1x10xf32> to memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
    br ^bb5(%c0 : index)
  ^bb5(%18: index):  // 2 preds: ^bb4, ^bb8
    %19 = cmpi slt, %18, %13 : index
    cond_br %19, ^bb6(%c0 : index), ^bb9
  ^bb6(%20: index):  // 2 preds: ^bb5, ^bb7
    %21 = cmpi slt, %20, %14 : index
    cond_br %21, ^bb7, ^bb8
  ^bb7:  // pred: ^bb6
    %22 = memref.load %15[%18, %20] : memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
    %23 = memref.load %16[%18, %20] : memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
    %24 = memref.load %2[] : memref<f32>
    %25 = memref.load %3[] : memref<f32>
    %26 = addf %22, %23 : f32
    %27 = subf %26, %24 : f32
    %28 = math.exp %27 : f32
    %29 = divf %28, %25 : f32
    memref.store %29, %17[%18, %20] : memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 10 + s0 + d1)>>
    %30 = addi %20, %c1 : index
    br ^bb6(%30 : index)
  ^bb8:  // pred: ^bb6
    %31 = addi %18, %c1 : index
    br ^bb5(%31 : index)
  ^bb9:  // pred: ^bb5
    %32 = addi %11, %10 : index
    br ^bb3(%32 : index)
  ^bb10:  // pred: ^bb3
    %33 = addi %7, %6 : index
    br ^bb1(%33 : index)
  ^bb11:  // pred: ^bb1
    return
  }
  hal.interface @io attributes {sym_visibility = "private"} {
    hal.interface.binding @s0b0_ro_external, set=0, binding=0, type="StorageBuffer", access="Read"
    hal.interface.binding @s0b1_ro_external, set=0, binding=1, type="StorageBuffer", access="Read"
    hal.interface.binding @s0b2_ro_external, set=0, binding=2, type="StorageBuffer", access="Read"
    hal.interface.binding @s0b3_xw_external, set=0, binding=3, type="StorageBuffer", access="Write|Discard"
  }
}

// *** IR Dump After mlir::iree_compiler::`anonymous-namespace'::ConvertToLLVMPass ***
module  {
  llvm.mlir.global private constant @__constant_1x10xf32(opaque<"_", "0xDEADBEEF"> : tensor<1x10xf32>) : !llvm.array<1 x array<10 x f32>>
  llvm.func internal @predict_dispatch_7(%arg0: !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>, %arg1: !llvm.ptr<array<3 x i32>>) -> i32 {
    %0 = llvm.mlir.constant(10 : index) : i64
    %1 = llvm.mlir.constant(0 : index) : i64
    %2 = llvm.mlir.constant(1 : index) : i64
    %3 = llvm.mlir.constant(0.693147182 : f32) : f32
    %4 = llvm.mlir.constant(1.44269502 : f32) : f32
    %5 = llvm.mlir.constant(1.000000e+00 : f32) : f32
    %6 = llvm.mlir.constant(0.499705136 : f32) : f32
    %7 = llvm.mlir.constant(0.168738902 : f32) : f32
    %8 = llvm.mlir.constant(0.0366896503 : f32) : f32
    %9 = llvm.mlir.constant(1.314350e-02 : f32) : f32
    %10 = llvm.mlir.constant(23 : i32) : i32
    %11 = llvm.mlir.constant(0.000000e+00 : f32) : f32
    %12 = llvm.mlir.constant(0x7F800000 : f32) : f32
    %13 = llvm.mlir.constant(0xFF800000 : f32) : f32
    %14 = llvm.mlir.constant(1.17549435E-38 : f32) : f32
    %15 = llvm.mlir.constant(127 : i32) : i32
    %16 = llvm.mlir.constant(-127 : i32) : i32
    %17 = llvm.mlir.constant(1 : index) : i64
    %18 = llvm.mlir.constant(10 : index) : i64
    %19 = llvm.mlir.constant(1 : index) : i64
    %20 = llvm.mlir.constant(10 : index) : i64
    %21 = llvm.mlir.null : !llvm.ptr<f32>
    %22 = llvm.getelementptr %21[%20] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %23 = llvm.ptrtoint %22 : !llvm.ptr<f32> to i64
    %24 = llvm.mlir.addressof @__constant_1x10xf32 : !llvm.ptr<array<1 x array<10 x f32>>>
    %25 = llvm.mlir.constant(0 : index) : i64
    %26 = llvm.getelementptr %24[%25, %25, %25] : (!llvm.ptr<array<1 x array<10 x f32>>>, i64, i64, i64) -> !llvm.ptr<f32>
    %27 = llvm.mlir.constant(3735928559 : index) : i64
    %28 = llvm.inttoptr %27 : i64 to !llvm.ptr<f32>
    %29 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %30 = llvm.insertvalue %28, %29[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %31 = llvm.insertvalue %26, %30[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %32 = llvm.mlir.constant(0 : index) : i64
    %33 = llvm.insertvalue %32, %31[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %34 = llvm.insertvalue %17, %33[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %35 = llvm.insertvalue %18, %34[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %36 = llvm.insertvalue %18, %35[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %37 = llvm.insertvalue %19, %36[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %38 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
    %39 = llvm.extractvalue %38[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
    %40 = llvm.mlir.constant(0 : index) : i64
    %41 = llvm.getelementptr %39[%40] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
    %42 = llvm.load %41 : !llvm.ptr<ptr<i8>>
    %43 = llvm.getelementptr %42[%1] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
    %44 = llvm.bitcast %43 : !llvm.ptr<i8> to !llvm.ptr<f32>
    %45 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %46 = llvm.insertvalue %44, %45[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %47 = llvm.insertvalue %44, %46[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %48 = llvm.mlir.constant(0 : index) : i64
    %49 = llvm.insertvalue %48, %47[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %50 = llvm.mlir.constant(1 : index) : i64
    %51 = llvm.insertvalue %50, %49[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %52 = llvm.mlir.constant(10 : index) : i64
    %53 = llvm.insertvalue %52, %51[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %54 = llvm.mlir.constant(10 : index) : i64
    %55 = llvm.insertvalue %54, %53[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %56 = llvm.mlir.constant(1 : index) : i64
    %57 = llvm.insertvalue %56, %55[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %58 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
    %59 = llvm.extractvalue %58[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
    %60 = llvm.mlir.constant(1 : index) : i64
    %61 = llvm.getelementptr %59[%60] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
    %62 = llvm.load %61 : !llvm.ptr<ptr<i8>>
    %63 = llvm.getelementptr %62[%1] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
    %64 = llvm.bitcast %63 : !llvm.ptr<i8> to !llvm.ptr<f32>
    %65 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
    %66 = llvm.insertvalue %64, %65[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
    %67 = llvm.insertvalue %64, %66[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
    %68 = llvm.mlir.constant(0 : index) : i64
    %69 = llvm.insertvalue %68, %67[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
    %70 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
    %71 = llvm.extractvalue %70[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
    %72 = llvm.mlir.constant(2 : index) : i64
    %73 = llvm.getelementptr %71[%72] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
    %74 = llvm.load %73 : !llvm.ptr<ptr<i8>>
    %75 = llvm.getelementptr %74[%1] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
    %76 = llvm.bitcast %75 : !llvm.ptr<i8> to !llvm.ptr<f32>
    %77 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
    %78 = llvm.insertvalue %76, %77[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
    %79 = llvm.insertvalue %76, %78[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
    %80 = llvm.mlir.constant(0 : index) : i64
    %81 = llvm.insertvalue %80, %79[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
    %82 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
    %83 = llvm.extractvalue %82[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
    %84 = llvm.mlir.constant(3 : index) : i64
    %85 = llvm.getelementptr %83[%84] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
    %86 = llvm.load %85 : !llvm.ptr<ptr<i8>>
    %87 = llvm.getelementptr %86[%1] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
    %88 = llvm.bitcast %87 : !llvm.ptr<i8> to !llvm.ptr<f32>
    %89 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %90 = llvm.insertvalue %88, %89[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %91 = llvm.insertvalue %88, %90[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %92 = llvm.mlir.constant(0 : index) : i64
    %93 = llvm.insertvalue %92, %91[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %94 = llvm.mlir.constant(1 : index) : i64
    %95 = llvm.insertvalue %94, %93[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %96 = llvm.mlir.constant(10 : index) : i64
    %97 = llvm.insertvalue %96, %95[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %98 = llvm.mlir.constant(10 : index) : i64
    %99 = llvm.insertvalue %98, %97[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %100 = llvm.mlir.constant(1 : index) : i64
    %101 = llvm.insertvalue %100, %99[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %102 = llvm.load %arg1 : !llvm.ptr<array<3 x i32>>
    %103 = llvm.extractvalue %102[0] : !llvm.array<3 x i32>
    %104 = llvm.zext %103 : i32 to i64
    %105 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
    %106 = llvm.extractvalue %105[0] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
    %107 = llvm.extractvalue %106[0] : !llvm.array<3 x i32>
    %108 = llvm.zext %107 : i32 to i64
    %109 = llvm.load %arg1 : !llvm.ptr<array<3 x i32>>
    %110 = llvm.extractvalue %109[1] : !llvm.array<3 x i32>
    %111 = llvm.zext %110 : i32 to i64
    %112 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
    %113 = llvm.extractvalue %112[0] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
    %114 = llvm.extractvalue %113[1] : !llvm.array<3 x i32>
    %115 = llvm.zext %114 : i32 to i64
    %116 = llvm.mlir.constant(128 : index) : i64
    %117 = llvm.mul %111, %116  : i64
    %118 = llvm.mlir.constant(128 : index) : i64
    %119 = llvm.mul %115, %118  : i64
    llvm.br ^bb1(%117 : i64)
  ^bb1(%120: i64):  // 2 preds: ^bb0, ^bb10
    %121 = llvm.icmp "slt" %120, %2 : i64
    llvm.cond_br %121, ^bb2, ^bb11
  ^bb2:  // pred: ^bb1
    %122 = llvm.mlir.constant(128 : index) : i64
    %123 = llvm.mul %104, %122  : i64
    %124 = llvm.mlir.constant(128 : index) : i64
    %125 = llvm.mul %108, %124  : i64
    llvm.br ^bb3(%123 : i64)
  ^bb3(%126: i64):  // 2 preds: ^bb2, ^bb9
    %127 = llvm.icmp "slt" %126, %0 : i64
    llvm.cond_br %127, ^bb4, ^bb10
  ^bb4:  // pred: ^bb3
    %128 = llvm.mlir.constant(128 : index) : i64
    %129 = llvm.mlir.constant(-1 : index) : i64
    %130 = llvm.mul %120, %129  : i64
    %131 = llvm.mlir.constant(1 : index) : i64
    %132 = llvm.add %130, %131  : i64
    %133 = llvm.icmp "slt" %128, %132 : i64
    %134 = llvm.select %133, %128, %132 : i1, i64
    %135 = llvm.mlir.constant(128 : index) : i64
    %136 = llvm.mlir.constant(-1 : index) : i64
    %137 = llvm.mul %126, %136  : i64
    %138 = llvm.mlir.constant(10 : index) : i64
    %139 = llvm.add %137, %138  : i64
    %140 = llvm.icmp "slt" %135, %139 : i64
    %141 = llvm.select %140, %135, %139 : i1, i64
    %142 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %143 = llvm.extractvalue %57[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %144 = llvm.bitcast %143 : !llvm.ptr<f32> to !llvm.ptr<f32>
    %145 = llvm.insertvalue %144, %142[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %146 = llvm.extractvalue %57[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %147 = llvm.bitcast %146 : !llvm.ptr<f32> to !llvm.ptr<f32>
    %148 = llvm.insertvalue %147, %145[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %149 = llvm.extractvalue %57[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %150 = llvm.extractvalue %57[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %151 = llvm.extractvalue %57[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %152 = llvm.mul %120, %149  : i64
    %153 = llvm.add %151, %152  : i64
    %154 = llvm.mul %126, %150  : i64
    %155 = llvm.add %153, %154  : i64
    %156 = llvm.insertvalue %155, %148[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %157 = llvm.mlir.constant(1 : i64) : i64
    %158 = llvm.insertvalue %141, %156[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %159 = llvm.insertvalue %157, %158[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %160 = llvm.mlir.constant(10 : i64) : i64
    %161 = llvm.insertvalue %134, %159[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %162 = llvm.insertvalue %160, %161[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %163 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %164 = llvm.extractvalue %37[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %165 = llvm.bitcast %164 : !llvm.ptr<f32> to !llvm.ptr<f32>
    %166 = llvm.insertvalue %165, %163[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %167 = llvm.extractvalue %37[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %168 = llvm.bitcast %167 : !llvm.ptr<f32> to !llvm.ptr<f32>
    %169 = llvm.insertvalue %168, %166[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %170 = llvm.extractvalue %37[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %171 = llvm.extractvalue %37[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %172 = llvm.extractvalue %37[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %173 = llvm.mul %120, %170  : i64
    %174 = llvm.add %172, %173  : i64
    %175 = llvm.mul %126, %171  : i64
    %176 = llvm.add %174, %175  : i64
    %177 = llvm.insertvalue %176, %169[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %178 = llvm.mlir.constant(1 : i64) : i64
    %179 = llvm.insertvalue %141, %177[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %180 = llvm.insertvalue %178, %179[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %181 = llvm.mlir.constant(10 : i64) : i64
    %182 = llvm.insertvalue %134, %180[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %183 = llvm.insertvalue %181, %182[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %184 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %185 = llvm.extractvalue %101[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %186 = llvm.bitcast %185 : !llvm.ptr<f32> to !llvm.ptr<f32>
    %187 = llvm.insertvalue %186, %184[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %188 = llvm.extractvalue %101[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %189 = llvm.bitcast %188 : !llvm.ptr<f32> to !llvm.ptr<f32>
    %190 = llvm.insertvalue %189, %187[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %191 = llvm.extractvalue %101[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %192 = llvm.extractvalue %101[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %193 = llvm.extractvalue %101[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %194 = llvm.mul %120, %191  : i64
    %195 = llvm.add %193, %194  : i64
    %196 = llvm.mul %126, %192  : i64
    %197 = llvm.add %195, %196  : i64
    %198 = llvm.insertvalue %197, %190[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %199 = llvm.mlir.constant(1 : i64) : i64
    %200 = llvm.insertvalue %141, %198[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %201 = llvm.insertvalue %199, %200[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %202 = llvm.mlir.constant(10 : i64) : i64
    %203 = llvm.insertvalue %134, %201[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %204 = llvm.insertvalue %202, %203[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    llvm.br ^bb5(%1 : i64)
  ^bb5(%205: i64):  // 2 preds: ^bb4, ^bb8
    %206 = llvm.icmp "slt" %205, %134 : i64
    llvm.cond_br %206, ^bb6(%1 : i64), ^bb9
  ^bb6(%207: i64):  // 2 preds: ^bb5, ^bb7
    %208 = llvm.icmp "slt" %207, %141 : i64
    llvm.cond_br %208, ^bb7, ^bb8
  ^bb7:  // pred: ^bb6
    %209 = llvm.extractvalue %162[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %210 = llvm.extractvalue %162[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %211 = llvm.mlir.constant(10 : index) : i64
    %212 = llvm.mul %205, %211  : i64
    %213 = llvm.add %210, %212  : i64
    %214 = llvm.add %213, %207  : i64
    %215 = llvm.getelementptr %209[%214] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %216 = llvm.load %215 : !llvm.ptr<f32>
    %217 = llvm.extractvalue %183[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %218 = llvm.extractvalue %183[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %219 = llvm.mlir.constant(10 : index) : i64
    %220 = llvm.mul %205, %219  : i64
    %221 = llvm.add %218, %220  : i64
    %222 = llvm.add %221, %207  : i64
    %223 = llvm.getelementptr %217[%222] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %224 = llvm.load %223 : !llvm.ptr<f32>
    %225 = llvm.extractvalue %69[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
    %226 = llvm.load %225 : !llvm.ptr<f32>
    %227 = llvm.extractvalue %81[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
    %228 = llvm.load %227 : !llvm.ptr<f32>
    %229 = llvm.fadd %216, %224  : f32
    %230 = llvm.fsub %229, %226  : f32
    %231 = llvm.fmul %230, %4  : f32
    %232 = "llvm.intr.floor"(%231) : (f32) -> f32
    %233 = llvm.fmul %232, %3  : f32
    %234 = llvm.fsub %230, %233  : f32
    %235 = llvm.fmul %234, %234  : f32
    %236 = llvm.fmul %235, %235  : f32
    %237 = "llvm.intr.fma"(%5, %234, %5) : (f32, f32, f32) -> f32
    %238 = "llvm.intr.fma"(%7, %234, %6) : (f32, f32, f32) -> f32
    %239 = "llvm.intr.fma"(%9, %234, %8) : (f32, f32, f32) -> f32
    %240 = "llvm.intr.fma"(%238, %235, %237) : (f32, f32, f32) -> f32
    %241 = "llvm.intr.fma"(%239, %236, %240) : (f32, f32, f32) -> f32
    %242 = llvm.fptosi %232 : f32 to i32
    %243 = llvm.add %242, %15  : i32
    %244 = llvm.shl %243, %10  : i32
    %245 = llvm.bitcast %244 : i32 to f32
    %246 = llvm.fmul %241, %245  : f32
    %247 = llvm.icmp "sle" %242, %15 : i32
    %248 = llvm.icmp "sge" %242, %16 : i32
    %249 = llvm.fcmp "oeq" %230, %13 : f32
    %250 = llvm.fcmp "ogt" %230, %11 : f32
    %251 = llvm.and %247, %248  : i1
    %252 = llvm.select %249, %11, %14 : i1, f32
    %253 = llvm.select %250, %12, %252 : i1, f32
    %254 = llvm.select %251, %246, %253 : i1, f32
    %255 = llvm.fdiv %254, %228  : f32
    %256 = llvm.extractvalue %204[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %257 = llvm.extractvalue %204[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %258 = llvm.mlir.constant(10 : index) : i64
    %259 = llvm.mul %205, %258  : i64
    %260 = llvm.add %257, %259  : i64
    %261 = llvm.add %260, %207  : i64
    %262 = llvm.getelementptr %256[%261] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    llvm.store %255, %262 : !llvm.ptr<f32>
    %263 = llvm.add %207, %2  : i64
    llvm.br ^bb6(%263 : i64)
  ^bb8:  // pred: ^bb6
    %264 = llvm.add %205, %2  : i64
    llvm.br ^bb5(%264 : i64)
  ^bb9:  // pred: ^bb5
    %265 = llvm.add %126, %125  : i64
    llvm.br ^bb3(%265 : i64)
  ^bb10:  // pred: ^bb3
    %266 = llvm.add %120, %119  : i64
    llvm.br ^bb1(%266 : i64)
  ^bb11:  // pred: ^bb1
    %267 = llvm.mlir.constant(0 : i32) : i32
    llvm.return %267 : i32
  }
}

// *** IR Dump After Canonicalizer ***
module  {
  llvm.mlir.global private constant @__constant_1x10xf32(opaque<"_", "0xDEADBEEF"> : tensor<1x10xf32>) : !llvm.array<1 x array<10 x f32>>
  llvm.func internal @predict_dispatch_7(%arg0: !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>, %arg1: !llvm.ptr<array<3 x i32>>) -> i32 {
    %0 = llvm.mlir.constant(10 : index) : i64
    %1 = llvm.mlir.constant(0 : index) : i64
    %2 = llvm.mlir.constant(1 : index) : i64
    %3 = llvm.mlir.constant(0.693147182 : f32) : f32
    %4 = llvm.mlir.constant(1.44269502 : f32) : f32
    %5 = llvm.mlir.constant(1.000000e+00 : f32) : f32
    %6 = llvm.mlir.constant(0.499705136 : f32) : f32
    %7 = llvm.mlir.constant(0.168738902 : f32) : f32
    %8 = llvm.mlir.constant(0.0366896503 : f32) : f32
    %9 = llvm.mlir.constant(1.314350e-02 : f32) : f32
    %10 = llvm.mlir.constant(23 : i32) : i32
    %11 = llvm.mlir.constant(0.000000e+00 : f32) : f32
    %12 = llvm.mlir.constant(0x7F800000 : f32) : f32
    %13 = llvm.mlir.constant(0xFF800000 : f32) : f32
    %14 = llvm.mlir.constant(1.17549435E-38 : f32) : f32
    %15 = llvm.mlir.constant(127 : i32) : i32
    %16 = llvm.mlir.constant(-127 : i32) : i32
    %17 = llvm.mlir.constant(1 : index) : i64
    %18 = llvm.mlir.constant(10 : index) : i64
    %19 = llvm.mlir.constant(1 : index) : i64
    %20 = llvm.mlir.addressof @__constant_1x10xf32 : !llvm.ptr<array<1 x array<10 x f32>>>
    %21 = llvm.mlir.constant(0 : index) : i64
    %22 = llvm.getelementptr %20[%21, %21, %21] : (!llvm.ptr<array<1 x array<10 x f32>>>, i64, i64, i64) -> !llvm.ptr<f32>
    %23 = llvm.mlir.constant(3735928559 : index) : i64
    %24 = llvm.inttoptr %23 : i64 to !llvm.ptr<f32>
    %25 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %26 = llvm.insertvalue %24, %25[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %27 = llvm.insertvalue %22, %26[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %28 = llvm.mlir.constant(0 : index) : i64
    %29 = llvm.insertvalue %28, %27[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %30 = llvm.insertvalue %17, %29[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %31 = llvm.insertvalue %18, %30[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %32 = llvm.insertvalue %18, %31[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %33 = llvm.insertvalue %19, %32[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %34 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
    %35 = llvm.extractvalue %34[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
    %36 = llvm.mlir.constant(0 : index) : i64
    %37 = llvm.getelementptr %35[%36] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
    %38 = llvm.load %37 : !llvm.ptr<ptr<i8>>
    %39 = llvm.getelementptr %38[%1] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
    %40 = llvm.bitcast %39 : !llvm.ptr<i8> to !llvm.ptr<f32>
    %41 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %42 = llvm.insertvalue %40, %41[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %43 = llvm.insertvalue %40, %42[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %44 = llvm.mlir.constant(0 : index) : i64
    %45 = llvm.insertvalue %44, %43[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %46 = llvm.mlir.constant(1 : index) : i64
    %47 = llvm.insertvalue %46, %45[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %48 = llvm.mlir.constant(10 : index) : i64
    %49 = llvm.insertvalue %48, %47[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %50 = llvm.mlir.constant(10 : index) : i64
    %51 = llvm.insertvalue %50, %49[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %52 = llvm.mlir.constant(1 : index) : i64
    %53 = llvm.insertvalue %52, %51[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %54 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
    %55 = llvm.extractvalue %54[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
    %56 = llvm.mlir.constant(1 : index) : i64
    %57 = llvm.getelementptr %55[%56] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
    %58 = llvm.load %57 : !llvm.ptr<ptr<i8>>
    %59 = llvm.getelementptr %58[%1] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
    %60 = llvm.bitcast %59 : !llvm.ptr<i8> to !llvm.ptr<f32>
    %61 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
    %62 = llvm.insertvalue %60, %61[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
    %63 = llvm.insertvalue %60, %62[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
    %64 = llvm.mlir.constant(0 : index) : i64
    %65 = llvm.insertvalue %64, %63[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
    %66 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
    %67 = llvm.extractvalue %66[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
    %68 = llvm.mlir.constant(2 : index) : i64
    %69 = llvm.getelementptr %67[%68] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
    %70 = llvm.load %69 : !llvm.ptr<ptr<i8>>
    %71 = llvm.getelementptr %70[%1] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
    %72 = llvm.bitcast %71 : !llvm.ptr<i8> to !llvm.ptr<f32>
    %73 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
    %74 = llvm.insertvalue %72, %73[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
    %75 = llvm.insertvalue %72, %74[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
    %76 = llvm.mlir.constant(0 : index) : i64
    %77 = llvm.insertvalue %76, %75[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
    %78 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
    %79 = llvm.extractvalue %78[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
    %80 = llvm.mlir.constant(3 : index) : i64
    %81 = llvm.getelementptr %79[%80] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
    %82 = llvm.load %81 : !llvm.ptr<ptr<i8>>
    %83 = llvm.getelementptr %82[%1] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
    %84 = llvm.bitcast %83 : !llvm.ptr<i8> to !llvm.ptr<f32>
    %85 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %86 = llvm.insertvalue %84, %85[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %87 = llvm.insertvalue %84, %86[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %88 = llvm.mlir.constant(0 : index) : i64
    %89 = llvm.insertvalue %88, %87[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %90 = llvm.mlir.constant(1 : index) : i64
    %91 = llvm.insertvalue %90, %89[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %92 = llvm.mlir.constant(10 : index) : i64
    %93 = llvm.insertvalue %92, %91[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %94 = llvm.mlir.constant(10 : index) : i64
    %95 = llvm.insertvalue %94, %93[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %96 = llvm.mlir.constant(1 : index) : i64
    %97 = llvm.insertvalue %96, %95[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %98 = llvm.load %arg1 : !llvm.ptr<array<3 x i32>>
    %99 = llvm.extractvalue %98[0] : !llvm.array<3 x i32>
    %100 = llvm.zext %99 : i32 to i64
    %101 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
    %102 = llvm.extractvalue %101[0] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
    %103 = llvm.extractvalue %102[0] : !llvm.array<3 x i32>
    %104 = llvm.zext %103 : i32 to i64
    %105 = llvm.load %arg1 : !llvm.ptr<array<3 x i32>>
    %106 = llvm.extractvalue %105[1] : !llvm.array<3 x i32>
    %107 = llvm.zext %106 : i32 to i64
    %108 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
    %109 = llvm.extractvalue %108[0] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
    %110 = llvm.extractvalue %109[1] : !llvm.array<3 x i32>
    %111 = llvm.zext %110 : i32 to i64
    %112 = llvm.mlir.constant(128 : index) : i64
    %113 = llvm.mul %107, %112  : i64
    %114 = llvm.mlir.constant(128 : index) : i64
    %115 = llvm.mul %111, %114  : i64
    llvm.br ^bb1(%113 : i64)
  ^bb1(%116: i64):  // 2 preds: ^bb0, ^bb10
    %117 = llvm.icmp "slt" %116, %2 : i64
    llvm.cond_br %117, ^bb2, ^bb11
  ^bb2:  // pred: ^bb1
    %118 = llvm.mlir.constant(128 : index) : i64
    %119 = llvm.mul %100, %118  : i64
    %120 = llvm.mlir.constant(128 : index) : i64
    %121 = llvm.mul %104, %120  : i64
    llvm.br ^bb3(%119 : i64)
  ^bb3(%122: i64):  // 2 preds: ^bb2, ^bb9
    %123 = llvm.icmp "slt" %122, %0 : i64
    llvm.cond_br %123, ^bb4, ^bb10
  ^bb4:  // pred: ^bb3
    %124 = llvm.mlir.constant(128 : index) : i64
    %125 = llvm.mlir.constant(-1 : index) : i64
    %126 = llvm.mul %116, %125  : i64
    %127 = llvm.mlir.constant(1 : index) : i64
    %128 = llvm.add %126, %127  : i64
    %129 = llvm.icmp "slt" %124, %128 : i64
    %130 = llvm.select %129, %124, %128 : i1, i64
    %131 = llvm.mlir.constant(128 : index) : i64
    %132 = llvm.mlir.constant(-1 : index) : i64
    %133 = llvm.mul %122, %132  : i64
    %134 = llvm.mlir.constant(10 : index) : i64
    %135 = llvm.add %133, %134  : i64
    %136 = llvm.icmp "slt" %131, %135 : i64
    %137 = llvm.select %136, %131, %135 : i1, i64
    %138 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %139 = llvm.extractvalue %53[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %140 = llvm.bitcast %139 : !llvm.ptr<f32> to !llvm.ptr<f32>
    %141 = llvm.insertvalue %140, %138[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %142 = llvm.extractvalue %53[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %143 = llvm.bitcast %142 : !llvm.ptr<f32> to !llvm.ptr<f32>
    %144 = llvm.insertvalue %143, %141[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %145 = llvm.extractvalue %53[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %146 = llvm.extractvalue %53[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %147 = llvm.extractvalue %53[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %148 = llvm.mul %116, %145  : i64
    %149 = llvm.add %147, %148  : i64
    %150 = llvm.mul %122, %146  : i64
    %151 = llvm.add %149, %150  : i64
    %152 = llvm.insertvalue %151, %144[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %153 = llvm.mlir.constant(1 : i64) : i64
    %154 = llvm.insertvalue %137, %152[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %155 = llvm.insertvalue %153, %154[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %156 = llvm.mlir.constant(10 : i64) : i64
    %157 = llvm.insertvalue %130, %155[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %158 = llvm.insertvalue %156, %157[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %159 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %160 = llvm.extractvalue %33[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %161 = llvm.bitcast %160 : !llvm.ptr<f32> to !llvm.ptr<f32>
    %162 = llvm.insertvalue %161, %159[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %163 = llvm.extractvalue %33[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %164 = llvm.bitcast %163 : !llvm.ptr<f32> to !llvm.ptr<f32>
    %165 = llvm.insertvalue %164, %162[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %166 = llvm.extractvalue %33[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %167 = llvm.extractvalue %33[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %168 = llvm.extractvalue %33[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %169 = llvm.mul %116, %166  : i64
    %170 = llvm.add %168, %169  : i64
    %171 = llvm.mul %122, %167  : i64
    %172 = llvm.add %170, %171  : i64
    %173 = llvm.insertvalue %172, %165[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %174 = llvm.mlir.constant(1 : i64) : i64
    %175 = llvm.insertvalue %137, %173[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %176 = llvm.insertvalue %174, %175[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %177 = llvm.mlir.constant(10 : i64) : i64
    %178 = llvm.insertvalue %130, %176[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %179 = llvm.insertvalue %177, %178[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %180 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %181 = llvm.extractvalue %97[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %182 = llvm.bitcast %181 : !llvm.ptr<f32> to !llvm.ptr<f32>
    %183 = llvm.insertvalue %182, %180[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %184 = llvm.extractvalue %97[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %185 = llvm.bitcast %184 : !llvm.ptr<f32> to !llvm.ptr<f32>
    %186 = llvm.insertvalue %185, %183[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %187 = llvm.extractvalue %97[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %188 = llvm.extractvalue %97[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %189 = llvm.extractvalue %97[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %190 = llvm.mul %116, %187  : i64
    %191 = llvm.add %189, %190  : i64
    %192 = llvm.mul %122, %188  : i64
    %193 = llvm.add %191, %192  : i64
    %194 = llvm.insertvalue %193, %186[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %195 = llvm.mlir.constant(1 : i64) : i64
    %196 = llvm.insertvalue %137, %194[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %197 = llvm.insertvalue %195, %196[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %198 = llvm.mlir.constant(10 : i64) : i64
    %199 = llvm.insertvalue %130, %197[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %200 = llvm.insertvalue %198, %199[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    llvm.br ^bb5(%1 : i64)
  ^bb5(%201: i64):  // 2 preds: ^bb4, ^bb8
    %202 = llvm.icmp "slt" %201, %130 : i64
    llvm.cond_br %202, ^bb6(%1 : i64), ^bb9
  ^bb6(%203: i64):  // 2 preds: ^bb5, ^bb7
    %204 = llvm.icmp "slt" %203, %137 : i64
    llvm.cond_br %204, ^bb7, ^bb8
  ^bb7:  // pred: ^bb6
    %205 = llvm.extractvalue %158[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %206 = llvm.extractvalue %158[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %207 = llvm.mlir.constant(10 : index) : i64
    %208 = llvm.mul %201, %207  : i64
    %209 = llvm.add %206, %208  : i64
    %210 = llvm.add %209, %203  : i64
    %211 = llvm.getelementptr %205[%210] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %212 = llvm.load %211 : !llvm.ptr<f32>
    %213 = llvm.extractvalue %179[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %214 = llvm.extractvalue %179[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %215 = llvm.mlir.constant(10 : index) : i64
    %216 = llvm.mul %201, %215  : i64
    %217 = llvm.add %214, %216  : i64
    %218 = llvm.add %217, %203  : i64
    %219 = llvm.getelementptr %213[%218] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %220 = llvm.load %219 : !llvm.ptr<f32>
    %221 = llvm.extractvalue %65[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
    %222 = llvm.load %221 : !llvm.ptr<f32>
    %223 = llvm.extractvalue %77[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
    %224 = llvm.load %223 : !llvm.ptr<f32>
    %225 = llvm.fadd %212, %220  : f32
    %226 = llvm.fsub %225, %222  : f32
    %227 = llvm.fmul %226, %4  : f32
    %228 = "llvm.intr.floor"(%227) : (f32) -> f32
    %229 = llvm.fmul %228, %3  : f32
    %230 = llvm.fsub %226, %229  : f32
    %231 = llvm.fmul %230, %230  : f32
    %232 = llvm.fmul %231, %231  : f32
    %233 = "llvm.intr.fma"(%5, %230, %5) : (f32, f32, f32) -> f32
    %234 = "llvm.intr.fma"(%7, %230, %6) : (f32, f32, f32) -> f32
    %235 = "llvm.intr.fma"(%9, %230, %8) : (f32, f32, f32) -> f32
    %236 = "llvm.intr.fma"(%234, %231, %233) : (f32, f32, f32) -> f32
    %237 = "llvm.intr.fma"(%235, %232, %236) : (f32, f32, f32) -> f32
    %238 = llvm.fptosi %228 : f32 to i32
    %239 = llvm.add %238, %15  : i32
    %240 = llvm.shl %239, %10  : i32
    %241 = llvm.bitcast %240 : i32 to f32
    %242 = llvm.fmul %237, %241  : f32
    %243 = llvm.icmp "sle" %238, %15 : i32
    %244 = llvm.icmp "sge" %238, %16 : i32
    %245 = llvm.fcmp "oeq" %226, %13 : f32
    %246 = llvm.fcmp "ogt" %226, %11 : f32
    %247 = llvm.and %243, %244  : i1
    %248 = llvm.select %245, %11, %14 : i1, f32
    %249 = llvm.select %246, %12, %248 : i1, f32
    %250 = llvm.select %247, %242, %249 : i1, f32
    %251 = llvm.fdiv %250, %224  : f32
    %252 = llvm.extractvalue %200[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %253 = llvm.extractvalue %200[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %254 = llvm.mlir.constant(10 : index) : i64
    %255 = llvm.mul %201, %254  : i64
    %256 = llvm.add %253, %255  : i64
    %257 = llvm.add %256, %203  : i64
    %258 = llvm.getelementptr %252[%257] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    llvm.store %251, %258 : !llvm.ptr<f32>
    %259 = llvm.add %203, %2  : i64
    llvm.br ^bb6(%259 : i64)
  ^bb8:  // pred: ^bb6
    %260 = llvm.add %201, %2  : i64
    llvm.br ^bb5(%260 : i64)
  ^bb9:  // pred: ^bb5
    %261 = llvm.add %122, %121  : i64
    llvm.br ^bb3(%261 : i64)
  ^bb10:  // pred: ^bb3
    %262 = llvm.add %116, %115  : i64
    llvm.br ^bb1(%262 : i64)
  ^bb11:  // pred: ^bb1
    %263 = llvm.mlir.constant(0 : i32) : i32
    llvm.return %263 : i32
  }
}

// *** IR Dump After CSE ***
module  {
  llvm.mlir.global private constant @__constant_1x10xf32(opaque<"_", "0xDEADBEEF"> : tensor<1x10xf32>) : !llvm.array<1 x array<10 x f32>>
  llvm.func internal @predict_dispatch_7(%arg0: !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>, %arg1: !llvm.ptr<array<3 x i32>>) -> i32 {
    %0 = llvm.mlir.constant(10 : index) : i64
    %1 = llvm.mlir.constant(0 : index) : i64
    %2 = llvm.mlir.constant(1 : index) : i64
    %3 = llvm.mlir.constant(0.693147182 : f32) : f32
    %4 = llvm.mlir.constant(1.44269502 : f32) : f32
    %5 = llvm.mlir.constant(1.000000e+00 : f32) : f32
    %6 = llvm.mlir.constant(0.499705136 : f32) : f32
    %7 = llvm.mlir.constant(0.168738902 : f32) : f32
    %8 = llvm.mlir.constant(0.0366896503 : f32) : f32
    %9 = llvm.mlir.constant(1.314350e-02 : f32) : f32
    %10 = llvm.mlir.constant(23 : i32) : i32
    %11 = llvm.mlir.constant(0.000000e+00 : f32) : f32
    %12 = llvm.mlir.constant(0x7F800000 : f32) : f32
    %13 = llvm.mlir.constant(0xFF800000 : f32) : f32
    %14 = llvm.mlir.constant(1.17549435E-38 : f32) : f32
    %15 = llvm.mlir.constant(127 : i32) : i32
    %16 = llvm.mlir.constant(-127 : i32) : i32
    %17 = llvm.mlir.addressof @__constant_1x10xf32 : !llvm.ptr<array<1 x array<10 x f32>>>
    %18 = llvm.getelementptr %17[%1, %1, %1] : (!llvm.ptr<array<1 x array<10 x f32>>>, i64, i64, i64) -> !llvm.ptr<f32>
    %19 = llvm.mlir.constant(3735928559 : index) : i64
    %20 = llvm.inttoptr %19 : i64 to !llvm.ptr<f32>
    %21 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %22 = llvm.insertvalue %20, %21[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %23 = llvm.insertvalue %18, %22[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %24 = llvm.insertvalue %1, %23[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %25 = llvm.insertvalue %2, %24[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %26 = llvm.insertvalue %0, %25[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %27 = llvm.insertvalue %0, %26[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %28 = llvm.insertvalue %2, %27[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %29 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
    %30 = llvm.extractvalue %29[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
    %31 = llvm.getelementptr %30[%1] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
    %32 = llvm.load %31 : !llvm.ptr<ptr<i8>>
    %33 = llvm.getelementptr %32[%1] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
    %34 = llvm.bitcast %33 : !llvm.ptr<i8> to !llvm.ptr<f32>
    %35 = llvm.insertvalue %34, %21[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %36 = llvm.insertvalue %34, %35[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %37 = llvm.insertvalue %1, %36[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %38 = llvm.insertvalue %2, %37[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %39 = llvm.insertvalue %0, %38[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %40 = llvm.insertvalue %0, %39[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %41 = llvm.insertvalue %2, %40[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %42 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
    %43 = llvm.extractvalue %42[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
    %44 = llvm.getelementptr %43[%2] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
    %45 = llvm.load %44 : !llvm.ptr<ptr<i8>>
    %46 = llvm.getelementptr %45[%1] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
    %47 = llvm.bitcast %46 : !llvm.ptr<i8> to !llvm.ptr<f32>
    %48 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
    %49 = llvm.insertvalue %47, %48[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
    %50 = llvm.insertvalue %47, %49[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
    %51 = llvm.insertvalue %1, %50[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
    %52 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
    %53 = llvm.extractvalue %52[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
    %54 = llvm.mlir.constant(2 : index) : i64
    %55 = llvm.getelementptr %53[%54] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
    %56 = llvm.load %55 : !llvm.ptr<ptr<i8>>
    %57 = llvm.getelementptr %56[%1] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
    %58 = llvm.bitcast %57 : !llvm.ptr<i8> to !llvm.ptr<f32>
    %59 = llvm.insertvalue %58, %48[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
    %60 = llvm.insertvalue %58, %59[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
    %61 = llvm.insertvalue %1, %60[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
    %62 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
    %63 = llvm.extractvalue %62[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
    %64 = llvm.mlir.constant(3 : index) : i64
    %65 = llvm.getelementptr %63[%64] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
    %66 = llvm.load %65 : !llvm.ptr<ptr<i8>>
    %67 = llvm.getelementptr %66[%1] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
    %68 = llvm.bitcast %67 : !llvm.ptr<i8> to !llvm.ptr<f32>
    %69 = llvm.insertvalue %68, %21[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %70 = llvm.insertvalue %68, %69[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %71 = llvm.insertvalue %1, %70[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %72 = llvm.insertvalue %2, %71[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %73 = llvm.insertvalue %0, %72[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %74 = llvm.insertvalue %0, %73[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %75 = llvm.insertvalue %2, %74[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %76 = llvm.load %arg1 : !llvm.ptr<array<3 x i32>>
    %77 = llvm.extractvalue %76[0] : !llvm.array<3 x i32>
    %78 = llvm.zext %77 : i32 to i64
    %79 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
    %80 = llvm.extractvalue %79[0] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
    %81 = llvm.extractvalue %80[0] : !llvm.array<3 x i32>
    %82 = llvm.zext %81 : i32 to i64
    %83 = llvm.load %arg1 : !llvm.ptr<array<3 x i32>>
    %84 = llvm.extractvalue %83[1] : !llvm.array<3 x i32>
    %85 = llvm.zext %84 : i32 to i64
    %86 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
    %87 = llvm.extractvalue %86[0] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
    %88 = llvm.extractvalue %87[1] : !llvm.array<3 x i32>
    %89 = llvm.zext %88 : i32 to i64
    %90 = llvm.mlir.constant(128 : index) : i64
    %91 = llvm.mul %85, %90  : i64
    %92 = llvm.mul %89, %90  : i64
    llvm.br ^bb1(%91 : i64)
  ^bb1(%93: i64):  // 2 preds: ^bb0, ^bb10
    %94 = llvm.icmp "slt" %93, %2 : i64
    llvm.cond_br %94, ^bb2, ^bb11
  ^bb2:  // pred: ^bb1
    %95 = llvm.mul %78, %90  : i64
    %96 = llvm.mul %82, %90  : i64
    llvm.br ^bb3(%95 : i64)
  ^bb3(%97: i64):  // 2 preds: ^bb2, ^bb9
    %98 = llvm.icmp "slt" %97, %0 : i64
    llvm.cond_br %98, ^bb4, ^bb10
  ^bb4:  // pred: ^bb3
    %99 = llvm.mlir.constant(-1 : index) : i64
    %100 = llvm.mul %93, %99  : i64
    %101 = llvm.add %100, %2  : i64
    %102 = llvm.icmp "slt" %90, %101 : i64
    %103 = llvm.select %102, %90, %101 : i1, i64
    %104 = llvm.mul %97, %99  : i64
    %105 = llvm.add %104, %0  : i64
    %106 = llvm.icmp "slt" %90, %105 : i64
    %107 = llvm.select %106, %90, %105 : i1, i64
    %108 = llvm.extractvalue %41[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %109 = llvm.bitcast %108 : !llvm.ptr<f32> to !llvm.ptr<f32>
    %110 = llvm.insertvalue %109, %21[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %111 = llvm.extractvalue %41[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %112 = llvm.bitcast %111 : !llvm.ptr<f32> to !llvm.ptr<f32>
    %113 = llvm.insertvalue %112, %110[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %114 = llvm.extractvalue %41[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %115 = llvm.extractvalue %41[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %116 = llvm.extractvalue %41[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %117 = llvm.mul %93, %114  : i64
    %118 = llvm.add %116, %117  : i64
    %119 = llvm.mul %97, %115  : i64
    %120 = llvm.add %118, %119  : i64
    %121 = llvm.insertvalue %120, %113[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %122 = llvm.mlir.constant(1 : i64) : i64
    %123 = llvm.insertvalue %107, %121[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %124 = llvm.insertvalue %122, %123[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %125 = llvm.mlir.constant(10 : i64) : i64
    %126 = llvm.insertvalue %103, %124[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %127 = llvm.insertvalue %125, %126[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %128 = llvm.extractvalue %28[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %129 = llvm.bitcast %128 : !llvm.ptr<f32> to !llvm.ptr<f32>
    %130 = llvm.insertvalue %129, %21[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %131 = llvm.extractvalue %28[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %132 = llvm.bitcast %131 : !llvm.ptr<f32> to !llvm.ptr<f32>
    %133 = llvm.insertvalue %132, %130[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %134 = llvm.extractvalue %28[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %135 = llvm.extractvalue %28[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %136 = llvm.extractvalue %28[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %137 = llvm.mul %93, %134  : i64
    %138 = llvm.add %136, %137  : i64
    %139 = llvm.mul %97, %135  : i64
    %140 = llvm.add %138, %139  : i64
    %141 = llvm.insertvalue %140, %133[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %142 = llvm.insertvalue %107, %141[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %143 = llvm.insertvalue %122, %142[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %144 = llvm.insertvalue %103, %143[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %145 = llvm.insertvalue %125, %144[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %146 = llvm.extractvalue %75[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %147 = llvm.bitcast %146 : !llvm.ptr<f32> to !llvm.ptr<f32>
    %148 = llvm.insertvalue %147, %21[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %149 = llvm.extractvalue %75[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %150 = llvm.bitcast %149 : !llvm.ptr<f32> to !llvm.ptr<f32>
    %151 = llvm.insertvalue %150, %148[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %152 = llvm.extractvalue %75[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %153 = llvm.extractvalue %75[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %154 = llvm.extractvalue %75[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %155 = llvm.mul %93, %152  : i64
    %156 = llvm.add %154, %155  : i64
    %157 = llvm.mul %97, %153  : i64
    %158 = llvm.add %156, %157  : i64
    %159 = llvm.insertvalue %158, %151[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %160 = llvm.insertvalue %107, %159[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %161 = llvm.insertvalue %122, %160[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %162 = llvm.insertvalue %103, %161[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %163 = llvm.insertvalue %125, %162[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    llvm.br ^bb5(%1 : i64)
  ^bb5(%164: i64):  // 2 preds: ^bb4, ^bb8
    %165 = llvm.icmp "slt" %164, %103 : i64
    llvm.cond_br %165, ^bb6(%1 : i64), ^bb9
  ^bb6(%166: i64):  // 2 preds: ^bb5, ^bb7
    %167 = llvm.icmp "slt" %166, %107 : i64
    llvm.cond_br %167, ^bb7, ^bb8
  ^bb7:  // pred: ^bb6
    %168 = llvm.extractvalue %127[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %169 = llvm.extractvalue %127[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %170 = llvm.mul %164, %0  : i64
    %171 = llvm.add %169, %170  : i64
    %172 = llvm.add %171, %166  : i64
    %173 = llvm.getelementptr %168[%172] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %174 = llvm.load %173 : !llvm.ptr<f32>
    %175 = llvm.extractvalue %145[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %176 = llvm.extractvalue %145[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %177 = llvm.add %176, %170  : i64
    %178 = llvm.add %177, %166  : i64
    %179 = llvm.getelementptr %175[%178] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %180 = llvm.load %179 : !llvm.ptr<f32>
    %181 = llvm.extractvalue %51[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
    %182 = llvm.load %181 : !llvm.ptr<f32>
    %183 = llvm.extractvalue %61[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
    %184 = llvm.load %183 : !llvm.ptr<f32>
    %185 = llvm.fadd %174, %180  : f32
    %186 = llvm.fsub %185, %182  : f32
    %187 = llvm.fmul %186, %4  : f32
    %188 = "llvm.intr.floor"(%187) : (f32) -> f32
    %189 = llvm.fmul %188, %3  : f32
    %190 = llvm.fsub %186, %189  : f32
    %191 = llvm.fmul %190, %190  : f32
    %192 = llvm.fmul %191, %191  : f32
    %193 = "llvm.intr.fma"(%5, %190, %5) : (f32, f32, f32) -> f32
    %194 = "llvm.intr.fma"(%7, %190, %6) : (f32, f32, f32) -> f32
    %195 = "llvm.intr.fma"(%9, %190, %8) : (f32, f32, f32) -> f32
    %196 = "llvm.intr.fma"(%194, %191, %193) : (f32, f32, f32) -> f32
    %197 = "llvm.intr.fma"(%195, %192, %196) : (f32, f32, f32) -> f32
    %198 = llvm.fptosi %188 : f32 to i32
    %199 = llvm.add %198, %15  : i32
    %200 = llvm.shl %199, %10  : i32
    %201 = llvm.bitcast %200 : i32 to f32
    %202 = llvm.fmul %197, %201  : f32
    %203 = llvm.icmp "sle" %198, %15 : i32
    %204 = llvm.icmp "sge" %198, %16 : i32
    %205 = llvm.fcmp "oeq" %186, %13 : f32
    %206 = llvm.fcmp "ogt" %186, %11 : f32
    %207 = llvm.and %203, %204  : i1
    %208 = llvm.select %205, %11, %14 : i1, f32
    %209 = llvm.select %206, %12, %208 : i1, f32
    %210 = llvm.select %207, %202, %209 : i1, f32
    %211 = llvm.fdiv %210, %184  : f32
    %212 = llvm.extractvalue %163[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %213 = llvm.extractvalue %163[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
    %214 = llvm.add %213, %170  : i64
    %215 = llvm.add %214, %166  : i64
    %216 = llvm.getelementptr %212[%215] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    llvm.store %211, %216 : !llvm.ptr<f32>
    %217 = llvm.add %166, %2  : i64
    llvm.br ^bb6(%217 : i64)
  ^bb8:  // pred: ^bb6
    %218 = llvm.add %164, %2  : i64
    llvm.br ^bb5(%218 : i64)
  ^bb9:  // pred: ^bb5
    %219 = llvm.add %97, %96  : i64
    llvm.br ^bb3(%219 : i64)
  ^bb10:  // pred: ^bb3
    %220 = llvm.add %93, %92  : i64
    llvm.br ^bb1(%220 : i64)
  ^bb11:  // pred: ^bb1
    %221 = llvm.mlir.constant(0 : i32) : i32
    llvm.return %221 : i32
  }
}

// *** IR Dump After mlir::iree_compiler::`anonymous-namespace'::LowerExecutableTargetPass ***
hal.executable.target @llvm_aot, filter="dylib*" {
  hal.executable.entry_point @predict_dispatch_7 attributes {interface = @io, ordinal = 0 : index} {
  ^bb0(%arg0: index, %arg1: index, %arg2: index):  // no predecessors
    %c1 = constant 1 : index
    %0 = affine.apply affine_map<()[s0] -> (s0 ceildiv 128)>()[%arg0]
    %1 = affine.apply affine_map<()[s0] -> (s0 ceildiv 128)>()[%arg1]
    hal.return %0, %1, %c1 : index, index, index
  }
  module  {
    llvm.mlir.global private constant @__constant_1x10xf32(opaque<"_", "0xDEADBEEF"> : tensor<1x10xf32>) : !llvm.array<1 x array<10 x f32>>
    llvm.func internal @predict_dispatch_7(%arg0: !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>, %arg1: !llvm.ptr<array<3 x i32>>) -> i32 {
      %0 = llvm.mlir.constant(10 : index) : i64
      %1 = llvm.mlir.constant(0 : index) : i64
      %2 = llvm.mlir.constant(1 : index) : i64
      %3 = llvm.mlir.constant(0.693147182 : f32) : f32
      %4 = llvm.mlir.constant(1.44269502 : f32) : f32
      %5 = llvm.mlir.constant(1.000000e+00 : f32) : f32
      %6 = llvm.mlir.constant(0.499705136 : f32) : f32
      %7 = llvm.mlir.constant(0.168738902 : f32) : f32
      %8 = llvm.mlir.constant(0.0366896503 : f32) : f32
      %9 = llvm.mlir.constant(1.314350e-02 : f32) : f32
      %10 = llvm.mlir.constant(23 : i32) : i32
      %11 = llvm.mlir.constant(0.000000e+00 : f32) : f32
      %12 = llvm.mlir.constant(0x7F800000 : f32) : f32
      %13 = llvm.mlir.constant(0xFF800000 : f32) : f32
      %14 = llvm.mlir.constant(1.17549435E-38 : f32) : f32
      %15 = llvm.mlir.constant(127 : i32) : i32
      %16 = llvm.mlir.constant(-127 : i32) : i32
      %17 = llvm.mlir.addressof @__constant_1x10xf32 : !llvm.ptr<array<1 x array<10 x f32>>>
      %18 = llvm.getelementptr %17[%1, %1, %1] : (!llvm.ptr<array<1 x array<10 x f32>>>, i64, i64, i64) -> !llvm.ptr<f32>
      %19 = llvm.mlir.constant(3735928559 : index) : i64
      %20 = llvm.inttoptr %19 : i64 to !llvm.ptr<f32>
      %21 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %22 = llvm.insertvalue %20, %21[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %23 = llvm.insertvalue %18, %22[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %24 = llvm.insertvalue %1, %23[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %25 = llvm.insertvalue %2, %24[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %26 = llvm.insertvalue %0, %25[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %27 = llvm.insertvalue %0, %26[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %28 = llvm.insertvalue %2, %27[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %29 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
      %30 = llvm.extractvalue %29[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
      %31 = llvm.getelementptr %30[%1] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
      %32 = llvm.load %31 : !llvm.ptr<ptr<i8>>
      %33 = llvm.getelementptr %32[%1] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
      %34 = llvm.bitcast %33 : !llvm.ptr<i8> to !llvm.ptr<f32>
      %35 = llvm.insertvalue %34, %21[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %36 = llvm.insertvalue %34, %35[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %37 = llvm.insertvalue %1, %36[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %38 = llvm.insertvalue %2, %37[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %39 = llvm.insertvalue %0, %38[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %40 = llvm.insertvalue %0, %39[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %41 = llvm.insertvalue %2, %40[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %42 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
      %43 = llvm.extractvalue %42[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
      %44 = llvm.getelementptr %43[%2] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
      %45 = llvm.load %44 : !llvm.ptr<ptr<i8>>
      %46 = llvm.getelementptr %45[%1] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
      %47 = llvm.bitcast %46 : !llvm.ptr<i8> to !llvm.ptr<f32>
      %48 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
      %49 = llvm.insertvalue %47, %48[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
      %50 = llvm.insertvalue %47, %49[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
      %51 = llvm.insertvalue %1, %50[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
      %52 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
      %53 = llvm.extractvalue %52[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
      %54 = llvm.mlir.constant(2 : index) : i64
      %55 = llvm.getelementptr %53[%54] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
      %56 = llvm.load %55 : !llvm.ptr<ptr<i8>>
      %57 = llvm.getelementptr %56[%1] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
      %58 = llvm.bitcast %57 : !llvm.ptr<i8> to !llvm.ptr<f32>
      %59 = llvm.insertvalue %58, %48[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
      %60 = llvm.insertvalue %58, %59[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
      %61 = llvm.insertvalue %1, %60[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
      %62 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
      %63 = llvm.extractvalue %62[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
      %64 = llvm.mlir.constant(3 : index) : i64
      %65 = llvm.getelementptr %63[%64] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
      %66 = llvm.load %65 : !llvm.ptr<ptr<i8>>
      %67 = llvm.getelementptr %66[%1] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
      %68 = llvm.bitcast %67 : !llvm.ptr<i8> to !llvm.ptr<f32>
      %69 = llvm.insertvalue %68, %21[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %70 = llvm.insertvalue %68, %69[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %71 = llvm.insertvalue %1, %70[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %72 = llvm.insertvalue %2, %71[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %73 = llvm.insertvalue %0, %72[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %74 = llvm.insertvalue %0, %73[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %75 = llvm.insertvalue %2, %74[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %76 = llvm.load %arg1 : !llvm.ptr<array<3 x i32>>
      %77 = llvm.extractvalue %76[0] : !llvm.array<3 x i32>
      %78 = llvm.zext %77 : i32 to i64
      %79 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
      %80 = llvm.extractvalue %79[0] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
      %81 = llvm.extractvalue %80[0] : !llvm.array<3 x i32>
      %82 = llvm.zext %81 : i32 to i64
      %83 = llvm.load %arg1 : !llvm.ptr<array<3 x i32>>
      %84 = llvm.extractvalue %83[1] : !llvm.array<3 x i32>
      %85 = llvm.zext %84 : i32 to i64
      %86 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
      %87 = llvm.extractvalue %86[0] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
      %88 = llvm.extractvalue %87[1] : !llvm.array<3 x i32>
      %89 = llvm.zext %88 : i32 to i64
      %90 = llvm.mlir.constant(128 : index) : i64
      %91 = llvm.mul %85, %90  : i64
      %92 = llvm.mul %89, %90  : i64
      llvm.br ^bb1(%91 : i64)
    ^bb1(%93: i64):  // 2 preds: ^bb0, ^bb10
      %94 = llvm.icmp "slt" %93, %2 : i64
      llvm.cond_br %94, ^bb2, ^bb11
    ^bb2:  // pred: ^bb1
      %95 = llvm.mul %78, %90  : i64
      %96 = llvm.mul %82, %90  : i64
      llvm.br ^bb3(%95 : i64)
    ^bb3(%97: i64):  // 2 preds: ^bb2, ^bb9
      %98 = llvm.icmp "slt" %97, %0 : i64
      llvm.cond_br %98, ^bb4, ^bb10
    ^bb4:  // pred: ^bb3
      %99 = llvm.mlir.constant(-1 : index) : i64
      %100 = llvm.mul %93, %99  : i64
      %101 = llvm.add %100, %2  : i64
      %102 = llvm.icmp "slt" %90, %101 : i64
      %103 = llvm.select %102, %90, %101 : i1, i64
      %104 = llvm.mul %97, %99  : i64
      %105 = llvm.add %104, %0  : i64
      %106 = llvm.icmp "slt" %90, %105 : i64
      %107 = llvm.select %106, %90, %105 : i1, i64
      %108 = llvm.extractvalue %41[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %109 = llvm.bitcast %108 : !llvm.ptr<f32> to !llvm.ptr<f32>
      %110 = llvm.insertvalue %109, %21[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %111 = llvm.extractvalue %41[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %112 = llvm.bitcast %111 : !llvm.ptr<f32> to !llvm.ptr<f32>
      %113 = llvm.insertvalue %112, %110[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %114 = llvm.extractvalue %41[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %115 = llvm.extractvalue %41[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %116 = llvm.extractvalue %41[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %117 = llvm.mul %93, %114  : i64
      %118 = llvm.add %116, %117  : i64
      %119 = llvm.mul %97, %115  : i64
      %120 = llvm.add %118, %119  : i64
      %121 = llvm.insertvalue %120, %113[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %122 = llvm.mlir.constant(1 : i64) : i64
      %123 = llvm.insertvalue %107, %121[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %124 = llvm.insertvalue %122, %123[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %125 = llvm.mlir.constant(10 : i64) : i64
      %126 = llvm.insertvalue %103, %124[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %127 = llvm.insertvalue %125, %126[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %128 = llvm.extractvalue %28[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %129 = llvm.bitcast %128 : !llvm.ptr<f32> to !llvm.ptr<f32>
      %130 = llvm.insertvalue %129, %21[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %131 = llvm.extractvalue %28[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %132 = llvm.bitcast %131 : !llvm.ptr<f32> to !llvm.ptr<f32>
      %133 = llvm.insertvalue %132, %130[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %134 = llvm.extractvalue %28[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %135 = llvm.extractvalue %28[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %136 = llvm.extractvalue %28[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %137 = llvm.mul %93, %134  : i64
      %138 = llvm.add %136, %137  : i64
      %139 = llvm.mul %97, %135  : i64
      %140 = llvm.add %138, %139  : i64
      %141 = llvm.insertvalue %140, %133[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %142 = llvm.insertvalue %107, %141[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %143 = llvm.insertvalue %122, %142[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %144 = llvm.insertvalue %103, %143[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %145 = llvm.insertvalue %125, %144[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %146 = llvm.extractvalue %75[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %147 = llvm.bitcast %146 : !llvm.ptr<f32> to !llvm.ptr<f32>
      %148 = llvm.insertvalue %147, %21[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %149 = llvm.extractvalue %75[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %150 = llvm.bitcast %149 : !llvm.ptr<f32> to !llvm.ptr<f32>
      %151 = llvm.insertvalue %150, %148[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %152 = llvm.extractvalue %75[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %153 = llvm.extractvalue %75[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %154 = llvm.extractvalue %75[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %155 = llvm.mul %93, %152  : i64
      %156 = llvm.add %154, %155  : i64
      %157 = llvm.mul %97, %153  : i64
      %158 = llvm.add %156, %157  : i64
      %159 = llvm.insertvalue %158, %151[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %160 = llvm.insertvalue %107, %159[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %161 = llvm.insertvalue %122, %160[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %162 = llvm.insertvalue %103, %161[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %163 = llvm.insertvalue %125, %162[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      llvm.br ^bb5(%1 : i64)
    ^bb5(%164: i64):  // 2 preds: ^bb4, ^bb8
      %165 = llvm.icmp "slt" %164, %103 : i64
      llvm.cond_br %165, ^bb6(%1 : i64), ^bb9
    ^bb6(%166: i64):  // 2 preds: ^bb5, ^bb7
      %167 = llvm.icmp "slt" %166, %107 : i64
      llvm.cond_br %167, ^bb7, ^bb8
    ^bb7:  // pred: ^bb6
      %168 = llvm.extractvalue %127[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %169 = llvm.extractvalue %127[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %170 = llvm.mul %164, %0  : i64
      %171 = llvm.add %169, %170  : i64
      %172 = llvm.add %171, %166  : i64
      %173 = llvm.getelementptr %168[%172] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
      %174 = llvm.load %173 : !llvm.ptr<f32>
      %175 = llvm.extractvalue %145[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %176 = llvm.extractvalue %145[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %177 = llvm.add %176, %170  : i64
      %178 = llvm.add %177, %166  : i64
      %179 = llvm.getelementptr %175[%178] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
      %180 = llvm.load %179 : !llvm.ptr<f32>
      %181 = llvm.extractvalue %51[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
      %182 = llvm.load %181 : !llvm.ptr<f32>
      %183 = llvm.extractvalue %61[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
      %184 = llvm.load %183 : !llvm.ptr<f32>
      %185 = llvm.fadd %174, %180  : f32
      %186 = llvm.fsub %185, %182  : f32
      %187 = llvm.fmul %186, %4  : f32
      %188 = "llvm.intr.floor"(%187) : (f32) -> f32
      %189 = llvm.fmul %188, %3  : f32
      %190 = llvm.fsub %186, %189  : f32
      %191 = llvm.fmul %190, %190  : f32
      %192 = llvm.fmul %191, %191  : f32
      %193 = "llvm.intr.fma"(%5, %190, %5) : (f32, f32, f32) -> f32
      %194 = "llvm.intr.fma"(%7, %190, %6) : (f32, f32, f32) -> f32
      %195 = "llvm.intr.fma"(%9, %190, %8) : (f32, f32, f32) -> f32
      %196 = "llvm.intr.fma"(%194, %191, %193) : (f32, f32, f32) -> f32
      %197 = "llvm.intr.fma"(%195, %192, %196) : (f32, f32, f32) -> f32
      %198 = llvm.fptosi %188 : f32 to i32
      %199 = llvm.add %198, %15  : i32
      %200 = llvm.shl %199, %10  : i32
      %201 = llvm.bitcast %200 : i32 to f32
      %202 = llvm.fmul %197, %201  : f32
      %203 = llvm.icmp "sle" %198, %15 : i32
      %204 = llvm.icmp "sge" %198, %16 : i32
      %205 = llvm.fcmp "oeq" %186, %13 : f32
      %206 = llvm.fcmp "ogt" %186, %11 : f32
      %207 = llvm.and %203, %204  : i1
      %208 = llvm.select %205, %11, %14 : i1, f32
      %209 = llvm.select %206, %12, %208 : i1, f32
      %210 = llvm.select %207, %202, %209 : i1, f32
      %211 = llvm.fdiv %210, %184  : f32
      %212 = llvm.extractvalue %163[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %213 = llvm.extractvalue %163[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %214 = llvm.add %213, %170  : i64
      %215 = llvm.add %214, %166  : i64
      %216 = llvm.getelementptr %212[%215] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
      llvm.store %211, %216 : !llvm.ptr<f32>
      %217 = llvm.add %166, %2  : i64
      llvm.br ^bb6(%217 : i64)
    ^bb8:  // pred: ^bb6
      %218 = llvm.add %164, %2  : i64
      llvm.br ^bb5(%218 : i64)
    ^bb9:  // pred: ^bb5
      %219 = llvm.add %97, %96  : i64
      llvm.br ^bb3(%219 : i64)
    ^bb10:  // pred: ^bb3
      %220 = llvm.add %93, %92  : i64
      llvm.br ^bb1(%220 : i64)
    ^bb11:  // pred: ^bb1
      %221 = llvm.mlir.constant(0 : i32) : i32
      llvm.return %221 : i32
    }
  }
}

// *** IR Dump After mlir::iree_compiler::IREE::HAL::TranslateExecutablesPass ***
hal.executable.target @llvm_aot, filter="dylib*" {
  hal.executable.entry_point @predict_dispatch_7 attributes {interface = @io, ordinal = 0 : index} {
  ^bb0(%arg0: index, %arg1: index, %arg2: index):  // no predecessors
    %c1 = constant 1 : index
    %0 = affine.apply affine_map<()[s0] -> (s0 ceildiv 128)>()[%arg0]
    %1 = affine.apply affine_map<()[s0] -> (s0 ceildiv 128)>()[%arg1]
    hal.return %0, %1, %c1 : index, index, index
  }
  module  {
    llvm.mlir.global private constant @__constant_1x10xf32(opaque<"_", "0xDEADBEEF"> : tensor<1x10xf32>) : !llvm.array<1 x array<10 x f32>>
    llvm.func internal @predict_dispatch_7(%arg0: !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>, %arg1: !llvm.ptr<array<3 x i32>>) -> i32 {
      %0 = llvm.mlir.constant(10 : index) : i64
      %1 = llvm.mlir.constant(0 : index) : i64
      %2 = llvm.mlir.constant(1 : index) : i64
      %3 = llvm.mlir.constant(0.693147182 : f32) : f32
      %4 = llvm.mlir.constant(1.44269502 : f32) : f32
      %5 = llvm.mlir.constant(1.000000e+00 : f32) : f32
      %6 = llvm.mlir.constant(0.499705136 : f32) : f32
      %7 = llvm.mlir.constant(0.168738902 : f32) : f32
      %8 = llvm.mlir.constant(0.0366896503 : f32) : f32
      %9 = llvm.mlir.constant(1.314350e-02 : f32) : f32
      %10 = llvm.mlir.constant(23 : i32) : i32
      %11 = llvm.mlir.constant(0.000000e+00 : f32) : f32
      %12 = llvm.mlir.constant(0x7F800000 : f32) : f32
      %13 = llvm.mlir.constant(0xFF800000 : f32) : f32
      %14 = llvm.mlir.constant(1.17549435E-38 : f32) : f32
      %15 = llvm.mlir.constant(127 : i32) : i32
      %16 = llvm.mlir.constant(-127 : i32) : i32
      %17 = llvm.mlir.addressof @__constant_1x10xf32 : !llvm.ptr<array<1 x array<10 x f32>>>
      %18 = llvm.getelementptr %17[%1, %1, %1] : (!llvm.ptr<array<1 x array<10 x f32>>>, i64, i64, i64) -> !llvm.ptr<f32>
      %19 = llvm.mlir.constant(3735928559 : index) : i64
      %20 = llvm.inttoptr %19 : i64 to !llvm.ptr<f32>
      %21 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %22 = llvm.insertvalue %20, %21[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %23 = llvm.insertvalue %18, %22[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %24 = llvm.insertvalue %1, %23[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %25 = llvm.insertvalue %2, %24[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %26 = llvm.insertvalue %0, %25[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %27 = llvm.insertvalue %0, %26[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %28 = llvm.insertvalue %2, %27[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %29 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
      %30 = llvm.extractvalue %29[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
      %31 = llvm.getelementptr %30[%1] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
      %32 = llvm.load %31 : !llvm.ptr<ptr<i8>>
      %33 = llvm.getelementptr %32[%1] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
      %34 = llvm.bitcast %33 : !llvm.ptr<i8> to !llvm.ptr<f32>
      %35 = llvm.insertvalue %34, %21[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %36 = llvm.insertvalue %34, %35[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %37 = llvm.insertvalue %1, %36[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %38 = llvm.insertvalue %2, %37[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %39 = llvm.insertvalue %0, %38[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %40 = llvm.insertvalue %0, %39[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %41 = llvm.insertvalue %2, %40[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %42 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
      %43 = llvm.extractvalue %42[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
      %44 = llvm.getelementptr %43[%2] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
      %45 = llvm.load %44 : !llvm.ptr<ptr<i8>>
      %46 = llvm.getelementptr %45[%1] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
      %47 = llvm.bitcast %46 : !llvm.ptr<i8> to !llvm.ptr<f32>
      %48 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
      %49 = llvm.insertvalue %47, %48[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
      %50 = llvm.insertvalue %47, %49[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
      %51 = llvm.insertvalue %1, %50[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
      %52 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
      %53 = llvm.extractvalue %52[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
      %54 = llvm.mlir.constant(2 : index) : i64
      %55 = llvm.getelementptr %53[%54] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
      %56 = llvm.load %55 : !llvm.ptr<ptr<i8>>
      %57 = llvm.getelementptr %56[%1] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
      %58 = llvm.bitcast %57 : !llvm.ptr<i8> to !llvm.ptr<f32>
      %59 = llvm.insertvalue %58, %48[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
      %60 = llvm.insertvalue %58, %59[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
      %61 = llvm.insertvalue %1, %60[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
      %62 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
      %63 = llvm.extractvalue %62[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
      %64 = llvm.mlir.constant(3 : index) : i64
      %65 = llvm.getelementptr %63[%64] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
      %66 = llvm.load %65 : !llvm.ptr<ptr<i8>>
      %67 = llvm.getelementptr %66[%1] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
      %68 = llvm.bitcast %67 : !llvm.ptr<i8> to !llvm.ptr<f32>
      %69 = llvm.insertvalue %68, %21[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %70 = llvm.insertvalue %68, %69[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %71 = llvm.insertvalue %1, %70[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %72 = llvm.insertvalue %2, %71[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %73 = llvm.insertvalue %0, %72[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %74 = llvm.insertvalue %0, %73[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %75 = llvm.insertvalue %2, %74[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %76 = llvm.load %arg1 : !llvm.ptr<array<3 x i32>>
      %77 = llvm.extractvalue %76[0] : !llvm.array<3 x i32>
      %78 = llvm.zext %77 : i32 to i64
      %79 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
      %80 = llvm.extractvalue %79[0] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
      %81 = llvm.extractvalue %80[0] : !llvm.array<3 x i32>
      %82 = llvm.zext %81 : i32 to i64
      %83 = llvm.load %arg1 : !llvm.ptr<array<3 x i32>>
      %84 = llvm.extractvalue %83[1] : !llvm.array<3 x i32>
      %85 = llvm.zext %84 : i32 to i64
      %86 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
      %87 = llvm.extractvalue %86[0] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
      %88 = llvm.extractvalue %87[1] : !llvm.array<3 x i32>
      %89 = llvm.zext %88 : i32 to i64
      %90 = llvm.mlir.constant(128 : index) : i64
      %91 = llvm.mul %85, %90  : i64
      %92 = llvm.mul %89, %90  : i64
      llvm.br ^bb1(%91 : i64)
    ^bb1(%93: i64):  // 2 preds: ^bb0, ^bb10
      %94 = llvm.icmp "slt" %93, %2 : i64
      llvm.cond_br %94, ^bb2, ^bb11
    ^bb2:  // pred: ^bb1
      %95 = llvm.mul %78, %90  : i64
      %96 = llvm.mul %82, %90  : i64
      llvm.br ^bb3(%95 : i64)
    ^bb3(%97: i64):  // 2 preds: ^bb2, ^bb9
      %98 = llvm.icmp "slt" %97, %0 : i64
      llvm.cond_br %98, ^bb4, ^bb10
    ^bb4:  // pred: ^bb3
      %99 = llvm.mlir.constant(-1 : index) : i64
      %100 = llvm.mul %93, %99  : i64
      %101 = llvm.add %100, %2  : i64
      %102 = llvm.icmp "slt" %90, %101 : i64
      %103 = llvm.select %102, %90, %101 : i1, i64
      %104 = llvm.mul %97, %99  : i64
      %105 = llvm.add %104, %0  : i64
      %106 = llvm.icmp "slt" %90, %105 : i64
      %107 = llvm.select %106, %90, %105 : i1, i64
      %108 = llvm.extractvalue %41[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %109 = llvm.bitcast %108 : !llvm.ptr<f32> to !llvm.ptr<f32>
      %110 = llvm.insertvalue %109, %21[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %111 = llvm.extractvalue %41[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %112 = llvm.bitcast %111 : !llvm.ptr<f32> to !llvm.ptr<f32>
      %113 = llvm.insertvalue %112, %110[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %114 = llvm.extractvalue %41[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %115 = llvm.extractvalue %41[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %116 = llvm.extractvalue %41[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %117 = llvm.mul %93, %114  : i64
      %118 = llvm.add %116, %117  : i64
      %119 = llvm.mul %97, %115  : i64
      %120 = llvm.add %118, %119  : i64
      %121 = llvm.insertvalue %120, %113[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %122 = llvm.mlir.constant(1 : i64) : i64
      %123 = llvm.insertvalue %107, %121[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %124 = llvm.insertvalue %122, %123[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %125 = llvm.mlir.constant(10 : i64) : i64
      %126 = llvm.insertvalue %103, %124[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %127 = llvm.insertvalue %125, %126[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %128 = llvm.extractvalue %28[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %129 = llvm.bitcast %128 : !llvm.ptr<f32> to !llvm.ptr<f32>
      %130 = llvm.insertvalue %129, %21[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %131 = llvm.extractvalue %28[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %132 = llvm.bitcast %131 : !llvm.ptr<f32> to !llvm.ptr<f32>
      %133 = llvm.insertvalue %132, %130[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %134 = llvm.extractvalue %28[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %135 = llvm.extractvalue %28[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %136 = llvm.extractvalue %28[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %137 = llvm.mul %93, %134  : i64
      %138 = llvm.add %136, %137  : i64
      %139 = llvm.mul %97, %135  : i64
      %140 = llvm.add %138, %139  : i64
      %141 = llvm.insertvalue %140, %133[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %142 = llvm.insertvalue %107, %141[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %143 = llvm.insertvalue %122, %142[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %144 = llvm.insertvalue %103, %143[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %145 = llvm.insertvalue %125, %144[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %146 = llvm.extractvalue %75[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %147 = llvm.bitcast %146 : !llvm.ptr<f32> to !llvm.ptr<f32>
      %148 = llvm.insertvalue %147, %21[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %149 = llvm.extractvalue %75[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %150 = llvm.bitcast %149 : !llvm.ptr<f32> to !llvm.ptr<f32>
      %151 = llvm.insertvalue %150, %148[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %152 = llvm.extractvalue %75[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %153 = llvm.extractvalue %75[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %154 = llvm.extractvalue %75[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %155 = llvm.mul %93, %152  : i64
      %156 = llvm.add %154, %155  : i64
      %157 = llvm.mul %97, %153  : i64
      %158 = llvm.add %156, %157  : i64
      %159 = llvm.insertvalue %158, %151[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %160 = llvm.insertvalue %107, %159[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %161 = llvm.insertvalue %122, %160[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %162 = llvm.insertvalue %103, %161[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %163 = llvm.insertvalue %125, %162[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      llvm.br ^bb5(%1 : i64)
    ^bb5(%164: i64):  // 2 preds: ^bb4, ^bb8
      %165 = llvm.icmp "slt" %164, %103 : i64
      llvm.cond_br %165, ^bb6(%1 : i64), ^bb9
    ^bb6(%166: i64):  // 2 preds: ^bb5, ^bb7
      %167 = llvm.icmp "slt" %166, %107 : i64
      llvm.cond_br %167, ^bb7, ^bb8
    ^bb7:  // pred: ^bb6
      %168 = llvm.extractvalue %127[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %169 = llvm.extractvalue %127[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %170 = llvm.mul %164, %0  : i64
      %171 = llvm.add %169, %170  : i64
      %172 = llvm.add %171, %166  : i64
      %173 = llvm.getelementptr %168[%172] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
      %174 = llvm.load %173 : !llvm.ptr<f32>
      %175 = llvm.extractvalue %145[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %176 = llvm.extractvalue %145[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %177 = llvm.add %176, %170  : i64
      %178 = llvm.add %177, %166  : i64
      %179 = llvm.getelementptr %175[%178] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
      %180 = llvm.load %179 : !llvm.ptr<f32>
      %181 = llvm.extractvalue %51[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
      %182 = llvm.load %181 : !llvm.ptr<f32>
      %183 = llvm.extractvalue %61[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
      %184 = llvm.load %183 : !llvm.ptr<f32>
      %185 = llvm.fadd %174, %180  : f32
      %186 = llvm.fsub %185, %182  : f32
      %187 = llvm.fmul %186, %4  : f32
      %188 = "llvm.intr.floor"(%187) : (f32) -> f32
      %189 = llvm.fmul %188, %3  : f32
      %190 = llvm.fsub %186, %189  : f32
      %191 = llvm.fmul %190, %190  : f32
      %192 = llvm.fmul %191, %191  : f32
      %193 = "llvm.intr.fma"(%5, %190, %5) : (f32, f32, f32) -> f32
      %194 = "llvm.intr.fma"(%7, %190, %6) : (f32, f32, f32) -> f32
      %195 = "llvm.intr.fma"(%9, %190, %8) : (f32, f32, f32) -> f32
      %196 = "llvm.intr.fma"(%194, %191, %193) : (f32, f32, f32) -> f32
      %197 = "llvm.intr.fma"(%195, %192, %196) : (f32, f32, f32) -> f32
      %198 = llvm.fptosi %188 : f32 to i32
      %199 = llvm.add %198, %15  : i32
      %200 = llvm.shl %199, %10  : i32
      %201 = llvm.bitcast %200 : i32 to f32
      %202 = llvm.fmul %197, %201  : f32
      %203 = llvm.icmp "sle" %198, %15 : i32
      %204 = llvm.icmp "sge" %198, %16 : i32
      %205 = llvm.fcmp "oeq" %186, %13 : f32
      %206 = llvm.fcmp "ogt" %186, %11 : f32
      %207 = llvm.and %203, %204  : i1
      %208 = llvm.select %205, %11, %14 : i1, f32
      %209 = llvm.select %206, %12, %208 : i1, f32
      %210 = llvm.select %207, %202, %209 : i1, f32
      %211 = llvm.fdiv %210, %184  : f32
      %212 = llvm.extractvalue %163[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %213 = llvm.extractvalue %163[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
      %214 = llvm.add %213, %170  : i64
      %215 = llvm.add %214, %166  : i64
      %216 = llvm.getelementptr %212[%215] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
      llvm.store %211, %216 : !llvm.ptr<f32>
      %217 = llvm.add %166, %2  : i64
      llvm.br ^bb6(%217 : i64)
    ^bb8:  // pred: ^bb6
      %218 = llvm.add %164, %2  : i64
      llvm.br ^bb5(%218 : i64)
    ^bb9:  // pred: ^bb5
      %219 = llvm.add %97, %96  : i64
      llvm.br ^bb3(%219 : i64)
    ^bb10:  // pred: ^bb3
      %220 = llvm.add %93, %92  : i64
      llvm.br ^bb1(%220 : i64)
    ^bb11:  // pred: ^bb1
      %221 = llvm.mlir.constant(0 : i32) : i32
      llvm.return %221 : i32
    }
  }
}

// *** IR Dump After mlir::iree_compiler::IREE::HAL::`anonymous-namespace'::ConvertToHALPass ***
#map0 = affine_map<()[s0] -> (s0 ceildiv 64)>
#map1 = affine_map<()[s0] -> (s0 ceildiv 4)>
#map2 = affine_map<()[s0] -> (s0 ceildiv 128)>
module  {
  hal.constant_pool @_const_pool attributes {buffer_constraints = #hal.buffer_constraints<max_allocation_size = 1073741824, min_buffer_offset_alignment = 16, max_buffer_range = 1073741824, min_buffer_range_alignment = 16>, sym_visibility = "private"} {
    hal.constant_storage @_storage = opaque<"_", "0xDEADBEEF"> : vector<407040xi8> attributes {sym_visibility = "nested"}
  }
  hal.variable @_const_pool_storage_buffer init(@_const_pool_storage_buffer_initializer) : !hal.buffer attributes {sym_visibility = "private"}
  func private @_const_pool_storage_buffer_initializer() -> !hal.buffer {
    %c0 = constant 0 : index
    %c407040 = constant 407040 : index
    %device = hal.ex.shared_device : !hal.device
    %allocator = hal.device.allocator<%device : !hal.device> : !hal.allocator
    %storage = hal.constant_storage.lookup @_const_pool::@_storage : !iree.byte_buffer
    %mapped = hal.allocator.map<%allocator : !hal.allocator> source(%storage : !iree.byte_buffer)[%c0, %c407040] type("HostVisible|DeviceVisible|DeviceLocal") usage("Constant|Transfer|Mapping|Dispatch") : !hal.buffer
    return %mapped : !hal.buffer
  }
  hal.executable @predict_dispatch_0 attributes {sym_visibility = "private"} {
    hal.interface @io {
      hal.interface.binding @s0b0_ro_constant, set=0, binding=0, type="StorageBuffer", access="Read"
      hal.interface.binding @s0b1_ro_external, set=0, binding=1, type="StorageBuffer", access="Read"
      hal.interface.binding @s0b2_xw_external, set=0, binding=2, type="StorageBuffer", access="Write|Discard"
    }
    hal.executable.target @llvm_aot, filter="dylib*" {
      hal.executable.entry_point @predict_dispatch_0 attributes {interface = @io, ordinal = 0 : index} {
      ^bb0(%arg0: index, %arg1: index, %arg2: index):  // no predecessors
        %c1 = constant 1 : index
        %0 = affine.apply #map0()[%arg0]
        %1 = affine.apply #map1()[%arg1]
        hal.return %0, %1, %c1 : index, index, index
      }
      module  {
        llvm.func internal @predict_dispatch_0(%arg0: !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>, %arg1: !llvm.ptr<array<3 x i32>>) -> i32 {
          %0 = llvm.mlir.constant(0.000000e+00 : f32) : f32
          %1 = llvm.mlir.constant(128 : index) : i64
          %2 = llvm.mlir.constant(784 : index) : i64
          %3 = llvm.mlir.constant(28 : index) : i64
          %4 = llvm.mlir.constant(32 : index) : i64
          %5 = llvm.mlir.constant(64 : index) : i64
          %6 = llvm.mlir.constant(4 : index) : i64
          %7 = llvm.mlir.constant(0 : index) : i64
          %8 = llvm.mlir.constant(1 : index) : i64
          %9 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %10 = llvm.extractvalue %9[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %11 = llvm.getelementptr %10[%8] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
          %12 = llvm.load %11 : !llvm.ptr<ptr<i8>>
          %13 = llvm.getelementptr %12[%7] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
          %14 = llvm.bitcast %13 : !llvm.ptr<i8> to !llvm.ptr<f32>
          %15 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %16 = llvm.insertvalue %14, %15[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %17 = llvm.insertvalue %14, %16[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %18 = llvm.insertvalue %7, %17[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %19 = llvm.insertvalue %8, %18[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %20 = llvm.insertvalue %2, %19[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %21 = llvm.insertvalue %2, %20[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %22 = llvm.insertvalue %8, %21[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %23 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %24 = llvm.extractvalue %23[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %25 = llvm.getelementptr %24[%7] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
          %26 = llvm.load %25 : !llvm.ptr<ptr<i8>>
          %27 = llvm.getelementptr %26[%7] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
          %28 = llvm.bitcast %27 : !llvm.ptr<i8> to !llvm.ptr<f32>
          %29 = llvm.insertvalue %28, %15[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %30 = llvm.insertvalue %28, %29[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %31 = llvm.insertvalue %7, %30[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %32 = llvm.insertvalue %2, %31[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %33 = llvm.insertvalue %1, %32[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %34 = llvm.insertvalue %1, %33[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %35 = llvm.insertvalue %8, %34[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %36 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %37 = llvm.extractvalue %36[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %38 = llvm.mlir.constant(2 : index) : i64
          %39 = llvm.getelementptr %37[%38] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
          %40 = llvm.load %39 : !llvm.ptr<ptr<i8>>
          %41 = llvm.getelementptr %40[%7] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
          %42 = llvm.bitcast %41 : !llvm.ptr<i8> to !llvm.ptr<f32>
          %43 = llvm.insertvalue %42, %15[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %44 = llvm.insertvalue %42, %43[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %45 = llvm.insertvalue %7, %44[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %46 = llvm.insertvalue %8, %45[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %47 = llvm.insertvalue %1, %46[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %48 = llvm.insertvalue %1, %47[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %49 = llvm.insertvalue %8, %48[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %50 = llvm.load %arg1 : !llvm.ptr<array<3 x i32>>
          %51 = llvm.extractvalue %50[0] : !llvm.array<3 x i32>
          %52 = llvm.zext %51 : i32 to i64
          %53 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %54 = llvm.extractvalue %53[0] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %55 = llvm.extractvalue %54[0] : !llvm.array<3 x i32>
          %56 = llvm.zext %55 : i32 to i64
          %57 = llvm.load %arg1 : !llvm.ptr<array<3 x i32>>
          %58 = llvm.extractvalue %57[1] : !llvm.array<3 x i32>
          %59 = llvm.zext %58 : i32 to i64
          %60 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %61 = llvm.extractvalue %60[0] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %62 = llvm.extractvalue %61[1] : !llvm.array<3 x i32>
          %63 = llvm.zext %62 : i32 to i64
          %64 = llvm.mul %59, %6  : i64
          %65 = llvm.mul %63, %6  : i64
          llvm.br ^bb1(%64 : i64)
        ^bb1(%66: i64):  // 2 preds: ^bb0, ^bb30
          %67 = llvm.icmp "slt" %66, %8 : i64
          llvm.cond_br %67, ^bb2, ^bb31
        ^bb2:  // pred: ^bb1
          %68 = llvm.mul %52, %5  : i64
          %69 = llvm.mul %56, %5  : i64
          llvm.br ^bb3(%68 : i64)
        ^bb3(%70: i64):  // 2 preds: ^bb2, ^bb29
          %71 = llvm.icmp "slt" %70, %1 : i64
          llvm.cond_br %71, ^bb4, ^bb30
        ^bb4:  // pred: ^bb3
          %72 = llvm.mlir.constant(-1 : index) : i64
          %73 = llvm.mul %66, %72  : i64
          %74 = llvm.add %73, %8  : i64
          %75 = llvm.icmp "slt" %6, %74 : i64
          %76 = llvm.select %75, %6, %74 : i1, i64
          %77 = llvm.extractvalue %22[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %78 = llvm.bitcast %77 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %79 = llvm.insertvalue %78, %15[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %80 = llvm.extractvalue %22[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %81 = llvm.bitcast %80 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %82 = llvm.insertvalue %81, %79[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %83 = llvm.extractvalue %22[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %84 = llvm.extractvalue %22[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %85 = llvm.extractvalue %22[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %86 = llvm.mul %66, %83  : i64
          %87 = llvm.add %85, %86  : i64
          %88 = llvm.mlir.constant(0 : i64) : i64
          %89 = llvm.mul %88, %84  : i64
          %90 = llvm.add %87, %89  : i64
          %91 = llvm.insertvalue %90, %82[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %92 = llvm.mlir.constant(784 : i64) : i64
          %93 = llvm.mlir.constant(1 : i64) : i64
          %94 = llvm.insertvalue %92, %91[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %95 = llvm.insertvalue %93, %94[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %96 = llvm.insertvalue %76, %95[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %97 = llvm.insertvalue %92, %96[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %98 = llvm.extractvalue %35[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %99 = llvm.bitcast %98 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %100 = llvm.insertvalue %99, %15[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %101 = llvm.extractvalue %35[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %102 = llvm.bitcast %101 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %103 = llvm.insertvalue %102, %100[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %104 = llvm.extractvalue %35[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %105 = llvm.extractvalue %35[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %106 = llvm.extractvalue %35[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %107 = llvm.mul %88, %104  : i64
          %108 = llvm.add %106, %107  : i64
          %109 = llvm.mul %70, %105  : i64
          %110 = llvm.add %108, %109  : i64
          %111 = llvm.insertvalue %110, %103[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %112 = llvm.mlir.constant(64 : i64) : i64
          %113 = llvm.insertvalue %112, %111[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %114 = llvm.insertvalue %93, %113[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %115 = llvm.mlir.constant(128 : i64) : i64
          %116 = llvm.insertvalue %92, %114[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %117 = llvm.insertvalue %115, %116[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %118 = llvm.extractvalue %49[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %119 = llvm.bitcast %118 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %120 = llvm.insertvalue %119, %15[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %121 = llvm.extractvalue %49[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %122 = llvm.bitcast %121 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %123 = llvm.insertvalue %122, %120[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %124 = llvm.extractvalue %49[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %125 = llvm.extractvalue %49[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %126 = llvm.extractvalue %49[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %127 = llvm.mul %66, %124  : i64
          %128 = llvm.add %126, %127  : i64
          %129 = llvm.mul %70, %125  : i64
          %130 = llvm.add %128, %129  : i64
          %131 = llvm.insertvalue %130, %123[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %132 = llvm.insertvalue %112, %131[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %133 = llvm.insertvalue %93, %132[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %134 = llvm.insertvalue %76, %133[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %135 = llvm.insertvalue %115, %134[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          llvm.br ^bb5(%7 : i64)
        ^bb5(%136: i64):  // 2 preds: ^bb4, ^bb8
          %137 = llvm.icmp "slt" %136, %76 : i64
          llvm.cond_br %137, ^bb6(%7 : i64), ^bb9(%7 : i64)
        ^bb6(%138: i64):  // 2 preds: ^bb5, ^bb7
          %139 = llvm.icmp "slt" %138, %5 : i64
          llvm.cond_br %139, ^bb7, ^bb8
        ^bb7:  // pred: ^bb6
          %140 = llvm.extractvalue %135[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %141 = llvm.extractvalue %135[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %142 = llvm.mul %136, %1  : i64
          %143 = llvm.add %141, %142  : i64
          %144 = llvm.add %143, %138  : i64
          %145 = llvm.getelementptr %140[%144] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
          llvm.store %0, %145 : !llvm.ptr<f32>
          %146 = llvm.add %138, %8  : i64
          llvm.br ^bb6(%146 : i64)
        ^bb8:  // pred: ^bb6
          %147 = llvm.add %136, %8  : i64
          llvm.br ^bb5(%147 : i64)
        ^bb9(%148: i64):  // 2 preds: ^bb5, ^bb28
          %149 = llvm.icmp "slt" %148, %76 : i64
          llvm.cond_br %149, ^bb10(%7 : i64), ^bb29
        ^bb10(%150: i64):  // 2 preds: ^bb9, ^bb27
          %151 = llvm.icmp "slt" %150, %5 : i64
          llvm.cond_br %151, ^bb11(%7 : i64), ^bb28
        ^bb11(%152: i64):  // 2 preds: ^bb10, ^bb26
          %153 = llvm.icmp "slt" %152, %2 : i64
          llvm.cond_br %153, ^bb12, ^bb27
        ^bb12:  // pred: ^bb11
          %154 = llvm.mul %148, %72  : i64
          %155 = llvm.add %76, %154  : i64
          %156 = llvm.icmp "slt" %6, %155 : i64
          %157 = llvm.select %156, %6, %155 : i1, i64
          %158 = llvm.extractvalue %97[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %159 = llvm.bitcast %158 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %160 = llvm.insertvalue %159, %15[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %161 = llvm.extractvalue %97[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %162 = llvm.bitcast %161 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %163 = llvm.insertvalue %162, %160[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %164 = llvm.extractvalue %97[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %165 = llvm.extractvalue %97[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %166 = llvm.extractvalue %97[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %167 = llvm.mul %148, %164  : i64
          %168 = llvm.add %166, %167  : i64
          %169 = llvm.mul %152, %165  : i64
          %170 = llvm.add %168, %169  : i64
          %171 = llvm.insertvalue %170, %163[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %172 = llvm.mlir.constant(28 : i64) : i64
          %173 = llvm.insertvalue %172, %171[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %174 = llvm.insertvalue %93, %173[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %175 = llvm.insertvalue %157, %174[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %176 = llvm.insertvalue %92, %175[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %177 = llvm.extractvalue %117[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %178 = llvm.bitcast %177 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %179 = llvm.insertvalue %178, %15[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %180 = llvm.extractvalue %117[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %181 = llvm.bitcast %180 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %182 = llvm.insertvalue %181, %179[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %183 = llvm.extractvalue %117[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %184 = llvm.extractvalue %117[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %185 = llvm.extractvalue %117[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %186 = llvm.mul %152, %183  : i64
          %187 = llvm.add %185, %186  : i64
          %188 = llvm.mul %150, %184  : i64
          %189 = llvm.add %187, %188  : i64
          %190 = llvm.insertvalue %189, %182[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %191 = llvm.mlir.constant(32 : i64) : i64
          %192 = llvm.insertvalue %191, %190[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %193 = llvm.insertvalue %93, %192[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %194 = llvm.insertvalue %172, %193[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %195 = llvm.insertvalue %115, %194[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %196 = llvm.extractvalue %135[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %197 = llvm.bitcast %196 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %198 = llvm.insertvalue %197, %15[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %199 = llvm.extractvalue %135[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %200 = llvm.bitcast %199 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %201 = llvm.insertvalue %200, %198[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %202 = llvm.extractvalue %135[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %203 = llvm.extractvalue %135[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %204 = llvm.extractvalue %135[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %205 = llvm.mul %148, %202  : i64
          %206 = llvm.add %204, %205  : i64
          %207 = llvm.mul %150, %203  : i64
          %208 = llvm.add %206, %207  : i64
          %209 = llvm.insertvalue %208, %201[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %210 = llvm.insertvalue %191, %209[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %211 = llvm.insertvalue %93, %210[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %212 = llvm.insertvalue %157, %211[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %213 = llvm.insertvalue %115, %212[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          llvm.br ^bb13(%7 : i64)
        ^bb13(%214: i64):  // 2 preds: ^bb12, ^bb25
          %215 = llvm.icmp "slt" %214, %157 : i64
          llvm.cond_br %215, ^bb14(%7 : i64), ^bb26
        ^bb14(%216: i64):  // 2 preds: ^bb13, ^bb24
          %217 = llvm.icmp "slt" %216, %4 : i64
          llvm.cond_br %217, ^bb15(%7 : i64), ^bb25
        ^bb15(%218: i64):  // 2 preds: ^bb14, ^bb23
          %219 = llvm.icmp "slt" %218, %3 : i64
          llvm.cond_br %219, ^bb16, ^bb24
        ^bb16:  // pred: ^bb15
          %220 = llvm.mul %214, %72  : i64
          %221 = llvm.add %157, %220  : i64
          %222 = llvm.icmp "slt" %6, %221 : i64
          %223 = llvm.select %222, %6, %221 : i1, i64
          %224 = llvm.extractvalue %176[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %225 = llvm.bitcast %224 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %226 = llvm.insertvalue %225, %15[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %227 = llvm.extractvalue %176[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %228 = llvm.bitcast %227 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %229 = llvm.insertvalue %228, %226[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %230 = llvm.extractvalue %176[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %231 = llvm.extractvalue %176[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %232 = llvm.extractvalue %176[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %233 = llvm.mul %214, %230  : i64
          %234 = llvm.add %232, %233  : i64
          %235 = llvm.mul %218, %231  : i64
          %236 = llvm.add %234, %235  : i64
          %237 = llvm.insertvalue %236, %229[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %238 = llvm.mlir.constant(4 : i64) : i64
          %239 = llvm.insertvalue %238, %237[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %240 = llvm.insertvalue %93, %239[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %241 = llvm.insertvalue %223, %240[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %242 = llvm.insertvalue %92, %241[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %243 = llvm.extractvalue %195[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %244 = llvm.bitcast %243 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %245 = llvm.insertvalue %244, %15[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %246 = llvm.extractvalue %195[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %247 = llvm.bitcast %246 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %248 = llvm.insertvalue %247, %245[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %249 = llvm.extractvalue %195[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %250 = llvm.extractvalue %195[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %251 = llvm.extractvalue %195[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %252 = llvm.mul %218, %249  : i64
          %253 = llvm.add %251, %252  : i64
          %254 = llvm.mul %216, %250  : i64
          %255 = llvm.add %253, %254  : i64
          %256 = llvm.insertvalue %255, %248[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %257 = llvm.insertvalue %238, %256[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %258 = llvm.insertvalue %93, %257[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %259 = llvm.insertvalue %238, %258[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %260 = llvm.insertvalue %115, %259[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %261 = llvm.extractvalue %213[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %262 = llvm.bitcast %261 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %263 = llvm.insertvalue %262, %15[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %264 = llvm.extractvalue %213[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %265 = llvm.bitcast %264 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %266 = llvm.insertvalue %265, %263[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %267 = llvm.extractvalue %213[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %268 = llvm.extractvalue %213[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %269 = llvm.extractvalue %213[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %270 = llvm.mul %214, %267  : i64
          %271 = llvm.add %269, %270  : i64
          %272 = llvm.mul %216, %268  : i64
          %273 = llvm.add %271, %272  : i64
          %274 = llvm.insertvalue %273, %266[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %275 = llvm.insertvalue %238, %274[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %276 = llvm.insertvalue %93, %275[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %277 = llvm.insertvalue %223, %276[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %278 = llvm.insertvalue %115, %277[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          llvm.br ^bb17(%7 : i64)
        ^bb17(%279: i64):  // 2 preds: ^bb16, ^bb22
          %280 = llvm.icmp "slt" %279, %223 : i64
          llvm.cond_br %280, ^bb18(%7 : i64), ^bb23
        ^bb18(%281: i64):  // 2 preds: ^bb17, ^bb21
          %282 = llvm.icmp "slt" %281, %6 : i64
          llvm.cond_br %282, ^bb19(%7 : i64), ^bb22
        ^bb19(%283: i64):  // 2 preds: ^bb18, ^bb20
          %284 = llvm.icmp "slt" %283, %6 : i64
          llvm.cond_br %284, ^bb20, ^bb21
        ^bb20:  // pred: ^bb19
          %285 = llvm.extractvalue %242[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %286 = llvm.extractvalue %242[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %287 = llvm.mul %279, %2  : i64
          %288 = llvm.add %286, %287  : i64
          %289 = llvm.add %288, %283  : i64
          %290 = llvm.getelementptr %285[%289] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
          %291 = llvm.load %290 : !llvm.ptr<f32>
          %292 = llvm.extractvalue %260[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %293 = llvm.extractvalue %260[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %294 = llvm.mul %283, %1  : i64
          %295 = llvm.add %293, %294  : i64
          %296 = llvm.add %295, %281  : i64
          %297 = llvm.getelementptr %292[%296] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
          %298 = llvm.load %297 : !llvm.ptr<f32>
          %299 = llvm.extractvalue %278[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %300 = llvm.extractvalue %278[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %301 = llvm.mul %279, %1  : i64
          %302 = llvm.add %300, %301  : i64
          %303 = llvm.add %302, %281  : i64
          %304 = llvm.getelementptr %299[%303] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
          %305 = llvm.load %304 : !llvm.ptr<f32>
          %306 = llvm.fmul %291, %298  : f32
          %307 = llvm.fadd %305, %306  : f32
          llvm.store %307, %304 : !llvm.ptr<f32>
          %308 = llvm.add %283, %8  : i64
          llvm.br ^bb19(%308 : i64)
        ^bb21:  // pred: ^bb19
          %309 = llvm.add %281, %8  : i64
          llvm.br ^bb18(%309 : i64)
        ^bb22:  // pred: ^bb18
          %310 = llvm.add %279, %8  : i64
          llvm.br ^bb17(%310 : i64)
        ^bb23:  // pred: ^bb17
          %311 = llvm.add %218, %6  : i64
          llvm.br ^bb15(%311 : i64)
        ^bb24:  // pred: ^bb15
          %312 = llvm.add %216, %6  : i64
          llvm.br ^bb14(%312 : i64)
        ^bb25:  // pred: ^bb14
          %313 = llvm.add %214, %6  : i64
          llvm.br ^bb13(%313 : i64)
        ^bb26:  // pred: ^bb13
          %314 = llvm.add %152, %3  : i64
          llvm.br ^bb11(%314 : i64)
        ^bb27:  // pred: ^bb11
          %315 = llvm.add %150, %4  : i64
          llvm.br ^bb10(%315 : i64)
        ^bb28:  // pred: ^bb10
          %316 = llvm.add %148, %6  : i64
          llvm.br ^bb9(%316 : i64)
        ^bb29:  // pred: ^bb9
          %317 = llvm.add %70, %69  : i64
          llvm.br ^bb3(%317 : i64)
        ^bb30:  // pred: ^bb3
          %318 = llvm.add %66, %65  : i64
          llvm.br ^bb1(%318 : i64)
        ^bb31:  // pred: ^bb1
          %319 = llvm.mlir.constant(0 : i32) : i32
          llvm.return %319 : i32
        }
      }
    }
  }
  hal.executable @predict_dispatch_1 attributes {sym_visibility = "private"} {
    hal.interface @io {
      hal.interface.binding @s0b0_ro_constant, set=0, binding=0, type="StorageBuffer", access="Read"
      hal.interface.binding @s0b1_ro_external, set=0, binding=1, type="StorageBuffer", access="Read"
      hal.interface.binding @s0b2_xw_external, set=0, binding=2, type="StorageBuffer", access="Write|Discard"
    }
    hal.executable.target @llvm_aot, filter="dylib*" {
      hal.executable.entry_point @predict_dispatch_1 attributes {interface = @io, ordinal = 0 : index} {
      ^bb0(%arg0: index, %arg1: index, %arg2: index):  // no predecessors
        %c1 = constant 1 : index
        %0 = affine.apply #map2()[%arg0]
        %1 = affine.apply #map2()[%arg1]
        hal.return %0, %1, %c1 : index, index, index
      }
      module  {
        llvm.func internal @predict_dispatch_1(%arg0: !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>, %arg1: !llvm.ptr<array<3 x i32>>) -> i32 {
          %0 = llvm.mlir.constant(0x7FC00000 : f32) : f32
          %1 = llvm.mlir.constant(0.000000e+00 : f32) : f32
          %2 = llvm.mlir.constant(128 : index) : i64
          %3 = llvm.mlir.constant(0 : index) : i64
          %4 = llvm.mlir.constant(1 : index) : i64
          %5 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %6 = llvm.extractvalue %5[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %7 = llvm.getelementptr %6[%4] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
          %8 = llvm.load %7 : !llvm.ptr<ptr<i8>>
          %9 = llvm.getelementptr %8[%3] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
          %10 = llvm.bitcast %9 : !llvm.ptr<i8> to !llvm.ptr<f32>
          %11 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %12 = llvm.insertvalue %10, %11[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %13 = llvm.insertvalue %10, %12[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %14 = llvm.insertvalue %3, %13[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %15 = llvm.insertvalue %4, %14[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %16 = llvm.insertvalue %2, %15[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %17 = llvm.insertvalue %2, %16[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %18 = llvm.insertvalue %4, %17[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %19 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %20 = llvm.extractvalue %19[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %21 = llvm.getelementptr %20[%3] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
          %22 = llvm.load %21 : !llvm.ptr<ptr<i8>>
          %23 = llvm.getelementptr %22[%3] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
          %24 = llvm.bitcast %23 : !llvm.ptr<i8> to !llvm.ptr<f32>
          %25 = llvm.insertvalue %24, %11[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %26 = llvm.insertvalue %24, %25[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %27 = llvm.insertvalue %3, %26[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %28 = llvm.insertvalue %4, %27[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %29 = llvm.insertvalue %2, %28[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %30 = llvm.insertvalue %2, %29[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %31 = llvm.insertvalue %4, %30[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %32 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %33 = llvm.extractvalue %32[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %34 = llvm.mlir.constant(2 : index) : i64
          %35 = llvm.getelementptr %33[%34] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
          %36 = llvm.load %35 : !llvm.ptr<ptr<i8>>
          %37 = llvm.getelementptr %36[%3] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
          %38 = llvm.bitcast %37 : !llvm.ptr<i8> to !llvm.ptr<f32>
          %39 = llvm.insertvalue %38, %11[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %40 = llvm.insertvalue %38, %39[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %41 = llvm.insertvalue %3, %40[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %42 = llvm.insertvalue %4, %41[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %43 = llvm.insertvalue %2, %42[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %44 = llvm.insertvalue %2, %43[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %45 = llvm.insertvalue %4, %44[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %46 = llvm.load %arg1 : !llvm.ptr<array<3 x i32>>
          %47 = llvm.extractvalue %46[0] : !llvm.array<3 x i32>
          %48 = llvm.zext %47 : i32 to i64
          %49 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %50 = llvm.extractvalue %49[0] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %51 = llvm.extractvalue %50[0] : !llvm.array<3 x i32>
          %52 = llvm.zext %51 : i32 to i64
          %53 = llvm.load %arg1 : !llvm.ptr<array<3 x i32>>
          %54 = llvm.extractvalue %53[1] : !llvm.array<3 x i32>
          %55 = llvm.zext %54 : i32 to i64
          %56 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %57 = llvm.extractvalue %56[0] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %58 = llvm.extractvalue %57[1] : !llvm.array<3 x i32>
          %59 = llvm.zext %58 : i32 to i64
          %60 = llvm.mul %55, %2  : i64
          %61 = llvm.mul %59, %2  : i64
          llvm.br ^bb1(%60 : i64)
        ^bb1(%62: i64):  // 2 preds: ^bb0, ^bb10
          %63 = llvm.icmp "slt" %62, %4 : i64
          llvm.cond_br %63, ^bb2, ^bb11
        ^bb2:  // pred: ^bb1
          %64 = llvm.mul %48, %2  : i64
          %65 = llvm.mul %52, %2  : i64
          llvm.br ^bb3(%64 : i64)
        ^bb3(%66: i64):  // 2 preds: ^bb2, ^bb9
          %67 = llvm.icmp "slt" %66, %2 : i64
          llvm.cond_br %67, ^bb4, ^bb10
        ^bb4:  // pred: ^bb3
          %68 = llvm.mlir.constant(-1 : index) : i64
          %69 = llvm.mul %62, %68  : i64
          %70 = llvm.add %69, %4  : i64
          %71 = llvm.icmp "slt" %2, %70 : i64
          %72 = llvm.select %71, %2, %70 : i1, i64
          %73 = llvm.extractvalue %18[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %74 = llvm.bitcast %73 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %75 = llvm.insertvalue %74, %11[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %76 = llvm.extractvalue %18[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %77 = llvm.bitcast %76 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %78 = llvm.insertvalue %77, %75[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %79 = llvm.extractvalue %18[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %80 = llvm.extractvalue %18[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %81 = llvm.extractvalue %18[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %82 = llvm.mul %62, %79  : i64
          %83 = llvm.add %81, %82  : i64
          %84 = llvm.mul %66, %80  : i64
          %85 = llvm.add %83, %84  : i64
          %86 = llvm.insertvalue %85, %78[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %87 = llvm.mlir.constant(128 : i64) : i64
          %88 = llvm.mlir.constant(1 : i64) : i64
          %89 = llvm.insertvalue %87, %86[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %90 = llvm.insertvalue %88, %89[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %91 = llvm.insertvalue %72, %90[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %92 = llvm.insertvalue %87, %91[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %93 = llvm.extractvalue %31[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %94 = llvm.bitcast %93 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %95 = llvm.insertvalue %94, %11[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %96 = llvm.extractvalue %31[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %97 = llvm.bitcast %96 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %98 = llvm.insertvalue %97, %95[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %99 = llvm.extractvalue %31[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %100 = llvm.extractvalue %31[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %101 = llvm.extractvalue %31[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %102 = llvm.mul %62, %99  : i64
          %103 = llvm.add %101, %102  : i64
          %104 = llvm.mul %66, %100  : i64
          %105 = llvm.add %103, %104  : i64
          %106 = llvm.insertvalue %105, %98[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %107 = llvm.insertvalue %87, %106[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %108 = llvm.insertvalue %88, %107[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %109 = llvm.insertvalue %72, %108[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %110 = llvm.insertvalue %87, %109[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %111 = llvm.extractvalue %45[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %112 = llvm.bitcast %111 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %113 = llvm.insertvalue %112, %11[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %114 = llvm.extractvalue %45[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %115 = llvm.bitcast %114 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %116 = llvm.insertvalue %115, %113[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %117 = llvm.extractvalue %45[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %118 = llvm.extractvalue %45[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %119 = llvm.extractvalue %45[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %120 = llvm.mul %62, %117  : i64
          %121 = llvm.add %119, %120  : i64
          %122 = llvm.mul %66, %118  : i64
          %123 = llvm.add %121, %122  : i64
          %124 = llvm.insertvalue %123, %116[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %125 = llvm.insertvalue %87, %124[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %126 = llvm.insertvalue %88, %125[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %127 = llvm.insertvalue %72, %126[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %128 = llvm.insertvalue %87, %127[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          llvm.br ^bb5(%3 : i64)
        ^bb5(%129: i64):  // 2 preds: ^bb4, ^bb8
          %130 = llvm.icmp "slt" %129, %72 : i64
          llvm.cond_br %130, ^bb6(%3 : i64), ^bb9
        ^bb6(%131: i64):  // 2 preds: ^bb5, ^bb7
          %132 = llvm.icmp "slt" %131, %2 : i64
          llvm.cond_br %132, ^bb7, ^bb8
        ^bb7:  // pred: ^bb6
          %133 = llvm.extractvalue %92[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %134 = llvm.extractvalue %92[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %135 = llvm.mul %129, %2  : i64
          %136 = llvm.add %134, %135  : i64
          %137 = llvm.add %136, %131  : i64
          %138 = llvm.getelementptr %133[%137] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
          %139 = llvm.load %138 : !llvm.ptr<f32>
          %140 = llvm.extractvalue %110[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %141 = llvm.extractvalue %110[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %142 = llvm.add %141, %135  : i64
          %143 = llvm.add %142, %131  : i64
          %144 = llvm.getelementptr %140[%143] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
          %145 = llvm.load %144 : !llvm.ptr<f32>
          %146 = llvm.fadd %139, %145  : f32
          %147 = llvm.fcmp "ogt" %146, %1 : f32
          %148 = llvm.select %147, %146, %1 : i1, f32
          %149 = llvm.fcmp "uno" %146, %1 : f32
          %150 = llvm.select %149, %0, %148 : i1, f32
          %151 = llvm.extractvalue %128[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %152 = llvm.extractvalue %128[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %153 = llvm.add %152, %135  : i64
          %154 = llvm.add %153, %131  : i64
          %155 = llvm.getelementptr %151[%154] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
          llvm.store %150, %155 : !llvm.ptr<f32>
          %156 = llvm.add %131, %4  : i64
          llvm.br ^bb6(%156 : i64)
        ^bb8:  // pred: ^bb6
          %157 = llvm.add %129, %4  : i64
          llvm.br ^bb5(%157 : i64)
        ^bb9:  // pred: ^bb5
          %158 = llvm.add %66, %65  : i64
          llvm.br ^bb3(%158 : i64)
        ^bb10:  // pred: ^bb3
          %159 = llvm.add %62, %61  : i64
          llvm.br ^bb1(%159 : i64)
        ^bb11:  // pred: ^bb1
          %160 = llvm.mlir.constant(0 : i32) : i32
          llvm.return %160 : i32
        }
      }
    }
  }
  hal.executable @predict_dispatch_2 attributes {sym_visibility = "private"} {
    hal.interface @io {
      hal.interface.binding @s0b0_ro_constant, set=0, binding=0, type="StorageBuffer", access="Read"
      hal.interface.binding @s0b1_ro_external, set=0, binding=1, type="StorageBuffer", access="Read"
      hal.interface.binding @s0b2_xw_external, set=0, binding=2, type="StorageBuffer", access="Write|Discard"
    }
    hal.executable.target @llvm_aot, filter="dylib*" {
      hal.executable.entry_point @predict_dispatch_2 attributes {interface = @io, ordinal = 0 : index} {
      ^bb0(%arg0: index, %arg1: index, %arg2: index):  // no predecessors
        %c1 = constant 1 : index
        %0 = affine.apply #map0()[%arg0]
        %1 = affine.apply #map1()[%arg1]
        hal.return %0, %1, %c1 : index, index, index
      }
      module  {
        llvm.func internal @predict_dispatch_2(%arg0: !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>, %arg1: !llvm.ptr<array<3 x i32>>) -> i32 {
          %0 = llvm.mlir.constant(0.000000e+00 : f32) : f32
          %1 = llvm.mlir.constant(10 : index) : i64
          %2 = llvm.mlir.constant(128 : index) : i64
          %3 = llvm.mlir.constant(32 : index) : i64
          %4 = llvm.mlir.constant(4 : index) : i64
          %5 = llvm.mlir.constant(0 : index) : i64
          %6 = llvm.mlir.constant(1 : index) : i64
          %7 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %8 = llvm.extractvalue %7[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %9 = llvm.getelementptr %8[%6] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
          %10 = llvm.load %9 : !llvm.ptr<ptr<i8>>
          %11 = llvm.getelementptr %10[%5] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
          %12 = llvm.bitcast %11 : !llvm.ptr<i8> to !llvm.ptr<f32>
          %13 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %14 = llvm.insertvalue %12, %13[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %15 = llvm.insertvalue %12, %14[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %16 = llvm.insertvalue %5, %15[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %17 = llvm.insertvalue %6, %16[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %18 = llvm.insertvalue %2, %17[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %19 = llvm.insertvalue %2, %18[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %20 = llvm.insertvalue %6, %19[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %21 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %22 = llvm.extractvalue %21[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %23 = llvm.getelementptr %22[%5] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
          %24 = llvm.load %23 : !llvm.ptr<ptr<i8>>
          %25 = llvm.getelementptr %24[%5] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
          %26 = llvm.bitcast %25 : !llvm.ptr<i8> to !llvm.ptr<f32>
          %27 = llvm.insertvalue %26, %13[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %28 = llvm.insertvalue %26, %27[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %29 = llvm.insertvalue %5, %28[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %30 = llvm.insertvalue %2, %29[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %31 = llvm.insertvalue %1, %30[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %32 = llvm.insertvalue %1, %31[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %33 = llvm.insertvalue %6, %32[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %34 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %35 = llvm.extractvalue %34[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %36 = llvm.mlir.constant(2 : index) : i64
          %37 = llvm.getelementptr %35[%36] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
          %38 = llvm.load %37 : !llvm.ptr<ptr<i8>>
          %39 = llvm.getelementptr %38[%5] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
          %40 = llvm.bitcast %39 : !llvm.ptr<i8> to !llvm.ptr<f32>
          %41 = llvm.insertvalue %40, %13[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %42 = llvm.insertvalue %40, %41[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %43 = llvm.insertvalue %5, %42[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %44 = llvm.insertvalue %6, %43[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %45 = llvm.insertvalue %1, %44[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %46 = llvm.insertvalue %1, %45[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %47 = llvm.insertvalue %6, %46[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %48 = llvm.load %arg1 : !llvm.ptr<array<3 x i32>>
          %49 = llvm.extractvalue %48[0] : !llvm.array<3 x i32>
          %50 = llvm.zext %49 : i32 to i64
          %51 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %52 = llvm.extractvalue %51[0] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %53 = llvm.extractvalue %52[0] : !llvm.array<3 x i32>
          %54 = llvm.zext %53 : i32 to i64
          %55 = llvm.load %arg1 : !llvm.ptr<array<3 x i32>>
          %56 = llvm.extractvalue %55[1] : !llvm.array<3 x i32>
          %57 = llvm.zext %56 : i32 to i64
          %58 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %59 = llvm.extractvalue %58[0] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %60 = llvm.extractvalue %59[1] : !llvm.array<3 x i32>
          %61 = llvm.zext %60 : i32 to i64
          %62 = llvm.mul %57, %4  : i64
          %63 = llvm.mul %61, %4  : i64
          llvm.br ^bb1(%62 : i64)
        ^bb1(%64: i64):  // 2 preds: ^bb0, ^bb30
          %65 = llvm.icmp "slt" %64, %6 : i64
          llvm.cond_br %65, ^bb2, ^bb31
        ^bb2:  // pred: ^bb1
          %66 = llvm.mlir.constant(64 : index) : i64
          %67 = llvm.mul %50, %66  : i64
          %68 = llvm.mul %54, %66  : i64
          llvm.br ^bb3(%67 : i64)
        ^bb3(%69: i64):  // 2 preds: ^bb2, ^bb29
          %70 = llvm.icmp "slt" %69, %1 : i64
          llvm.cond_br %70, ^bb4, ^bb30
        ^bb4:  // pred: ^bb3
          %71 = llvm.mlir.constant(-1 : index) : i64
          %72 = llvm.mul %64, %71  : i64
          %73 = llvm.add %72, %6  : i64
          %74 = llvm.icmp "slt" %4, %73 : i64
          %75 = llvm.select %74, %4, %73 : i1, i64
          %76 = llvm.extractvalue %20[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %77 = llvm.bitcast %76 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %78 = llvm.insertvalue %77, %13[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %79 = llvm.extractvalue %20[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %80 = llvm.bitcast %79 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %81 = llvm.insertvalue %80, %78[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %82 = llvm.extractvalue %20[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %83 = llvm.extractvalue %20[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %84 = llvm.extractvalue %20[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %85 = llvm.mul %64, %82  : i64
          %86 = llvm.add %84, %85  : i64
          %87 = llvm.mlir.constant(0 : i64) : i64
          %88 = llvm.mul %87, %83  : i64
          %89 = llvm.add %86, %88  : i64
          %90 = llvm.insertvalue %89, %81[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %91 = llvm.mlir.constant(128 : i64) : i64
          %92 = llvm.mlir.constant(1 : i64) : i64
          %93 = llvm.insertvalue %91, %90[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %94 = llvm.insertvalue %92, %93[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %95 = llvm.insertvalue %75, %94[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %96 = llvm.insertvalue %91, %95[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %97 = llvm.mul %69, %71  : i64
          %98 = llvm.add %97, %1  : i64
          %99 = llvm.icmp "slt" %66, %98 : i64
          %100 = llvm.select %99, %66, %98 : i1, i64
          %101 = llvm.extractvalue %33[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %102 = llvm.bitcast %101 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %103 = llvm.insertvalue %102, %13[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %104 = llvm.extractvalue %33[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %105 = llvm.bitcast %104 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %106 = llvm.insertvalue %105, %103[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %107 = llvm.extractvalue %33[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %108 = llvm.extractvalue %33[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %109 = llvm.extractvalue %33[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %110 = llvm.mul %87, %107  : i64
          %111 = llvm.add %109, %110  : i64
          %112 = llvm.mul %69, %108  : i64
          %113 = llvm.add %111, %112  : i64
          %114 = llvm.insertvalue %113, %106[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %115 = llvm.insertvalue %100, %114[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %116 = llvm.insertvalue %92, %115[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %117 = llvm.mlir.constant(10 : i64) : i64
          %118 = llvm.insertvalue %91, %116[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %119 = llvm.insertvalue %117, %118[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %120 = llvm.extractvalue %47[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %121 = llvm.bitcast %120 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %122 = llvm.insertvalue %121, %13[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %123 = llvm.extractvalue %47[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %124 = llvm.bitcast %123 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %125 = llvm.insertvalue %124, %122[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %126 = llvm.extractvalue %47[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %127 = llvm.extractvalue %47[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %128 = llvm.extractvalue %47[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %129 = llvm.mul %64, %126  : i64
          %130 = llvm.add %128, %129  : i64
          %131 = llvm.mul %69, %127  : i64
          %132 = llvm.add %130, %131  : i64
          %133 = llvm.insertvalue %132, %125[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %134 = llvm.insertvalue %100, %133[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %135 = llvm.insertvalue %92, %134[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %136 = llvm.insertvalue %75, %135[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %137 = llvm.insertvalue %117, %136[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          llvm.br ^bb5(%5 : i64)
        ^bb5(%138: i64):  // 2 preds: ^bb4, ^bb8
          %139 = llvm.icmp "slt" %138, %75 : i64
          llvm.cond_br %139, ^bb6(%5 : i64), ^bb9(%5 : i64)
        ^bb6(%140: i64):  // 2 preds: ^bb5, ^bb7
          %141 = llvm.icmp "slt" %140, %100 : i64
          llvm.cond_br %141, ^bb7, ^bb8
        ^bb7:  // pred: ^bb6
          %142 = llvm.extractvalue %137[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %143 = llvm.extractvalue %137[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %144 = llvm.mul %138, %1  : i64
          %145 = llvm.add %143, %144  : i64
          %146 = llvm.add %145, %140  : i64
          %147 = llvm.getelementptr %142[%146] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
          llvm.store %0, %147 : !llvm.ptr<f32>
          %148 = llvm.add %140, %6  : i64
          llvm.br ^bb6(%148 : i64)
        ^bb8:  // pred: ^bb6
          %149 = llvm.add %138, %6  : i64
          llvm.br ^bb5(%149 : i64)
        ^bb9(%150: i64):  // 2 preds: ^bb5, ^bb28
          %151 = llvm.icmp "slt" %150, %75 : i64
          llvm.cond_br %151, ^bb10(%5 : i64), ^bb29
        ^bb10(%152: i64):  // 2 preds: ^bb9, ^bb27
          %153 = llvm.icmp "slt" %152, %100 : i64
          llvm.cond_br %153, ^bb11(%5 : i64), ^bb28
        ^bb11(%154: i64):  // 2 preds: ^bb10, ^bb26
          %155 = llvm.icmp "slt" %154, %2 : i64
          llvm.cond_br %155, ^bb12, ^bb27
        ^bb12:  // pred: ^bb11
          %156 = llvm.mul %150, %71  : i64
          %157 = llvm.add %75, %156  : i64
          %158 = llvm.icmp "slt" %4, %157 : i64
          %159 = llvm.select %158, %4, %157 : i1, i64
          %160 = llvm.extractvalue %96[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %161 = llvm.bitcast %160 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %162 = llvm.insertvalue %161, %13[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %163 = llvm.extractvalue %96[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %164 = llvm.bitcast %163 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %165 = llvm.insertvalue %164, %162[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %166 = llvm.extractvalue %96[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %167 = llvm.extractvalue %96[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %168 = llvm.extractvalue %96[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %169 = llvm.mul %150, %166  : i64
          %170 = llvm.add %168, %169  : i64
          %171 = llvm.mul %154, %167  : i64
          %172 = llvm.add %170, %171  : i64
          %173 = llvm.insertvalue %172, %165[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %174 = llvm.mlir.constant(32 : i64) : i64
          %175 = llvm.insertvalue %174, %173[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %176 = llvm.insertvalue %92, %175[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %177 = llvm.insertvalue %159, %176[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %178 = llvm.insertvalue %91, %177[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %179 = llvm.mul %152, %71  : i64
          %180 = llvm.add %100, %179  : i64
          %181 = llvm.icmp "slt" %3, %180 : i64
          %182 = llvm.select %181, %3, %180 : i1, i64
          %183 = llvm.extractvalue %119[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %184 = llvm.bitcast %183 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %185 = llvm.insertvalue %184, %13[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %186 = llvm.extractvalue %119[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %187 = llvm.bitcast %186 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %188 = llvm.insertvalue %187, %185[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %189 = llvm.extractvalue %119[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %190 = llvm.extractvalue %119[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %191 = llvm.extractvalue %119[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %192 = llvm.mul %154, %189  : i64
          %193 = llvm.add %191, %192  : i64
          %194 = llvm.mul %152, %190  : i64
          %195 = llvm.add %193, %194  : i64
          %196 = llvm.insertvalue %195, %188[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %197 = llvm.insertvalue %182, %196[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %198 = llvm.insertvalue %92, %197[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %199 = llvm.insertvalue %174, %198[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %200 = llvm.insertvalue %117, %199[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %201 = llvm.extractvalue %137[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %202 = llvm.bitcast %201 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %203 = llvm.insertvalue %202, %13[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %204 = llvm.extractvalue %137[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %205 = llvm.bitcast %204 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %206 = llvm.insertvalue %205, %203[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %207 = llvm.extractvalue %137[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %208 = llvm.extractvalue %137[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %209 = llvm.extractvalue %137[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %210 = llvm.mul %150, %207  : i64
          %211 = llvm.add %209, %210  : i64
          %212 = llvm.mul %152, %208  : i64
          %213 = llvm.add %211, %212  : i64
          %214 = llvm.insertvalue %213, %206[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %215 = llvm.insertvalue %182, %214[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %216 = llvm.insertvalue %92, %215[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %217 = llvm.insertvalue %159, %216[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %218 = llvm.insertvalue %117, %217[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          llvm.br ^bb13(%5 : i64)
        ^bb13(%219: i64):  // 2 preds: ^bb12, ^bb25
          %220 = llvm.icmp "slt" %219, %159 : i64
          llvm.cond_br %220, ^bb14(%5 : i64), ^bb26
        ^bb14(%221: i64):  // 2 preds: ^bb13, ^bb24
          %222 = llvm.icmp "slt" %221, %182 : i64
          llvm.cond_br %222, ^bb15(%5 : i64), ^bb25
        ^bb15(%223: i64):  // 2 preds: ^bb14, ^bb23
          %224 = llvm.icmp "slt" %223, %3 : i64
          llvm.cond_br %224, ^bb16, ^bb24
        ^bb16:  // pred: ^bb15
          %225 = llvm.mul %219, %71  : i64
          %226 = llvm.add %159, %225  : i64
          %227 = llvm.icmp "slt" %4, %226 : i64
          %228 = llvm.select %227, %4, %226 : i1, i64
          %229 = llvm.extractvalue %178[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %230 = llvm.bitcast %229 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %231 = llvm.insertvalue %230, %13[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %232 = llvm.extractvalue %178[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %233 = llvm.bitcast %232 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %234 = llvm.insertvalue %233, %231[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %235 = llvm.extractvalue %178[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %236 = llvm.extractvalue %178[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %237 = llvm.extractvalue %178[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %238 = llvm.mul %219, %235  : i64
          %239 = llvm.add %237, %238  : i64
          %240 = llvm.mul %223, %236  : i64
          %241 = llvm.add %239, %240  : i64
          %242 = llvm.insertvalue %241, %234[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %243 = llvm.mlir.constant(4 : i64) : i64
          %244 = llvm.insertvalue %243, %242[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %245 = llvm.insertvalue %92, %244[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %246 = llvm.insertvalue %228, %245[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %247 = llvm.insertvalue %91, %246[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %248 = llvm.mul %221, %71  : i64
          %249 = llvm.add %182, %248  : i64
          %250 = llvm.icmp "slt" %4, %249 : i64
          %251 = llvm.select %250, %4, %249 : i1, i64
          %252 = llvm.extractvalue %200[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %253 = llvm.bitcast %252 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %254 = llvm.insertvalue %253, %13[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %255 = llvm.extractvalue %200[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %256 = llvm.bitcast %255 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %257 = llvm.insertvalue %256, %254[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %258 = llvm.extractvalue %200[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %259 = llvm.extractvalue %200[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %260 = llvm.extractvalue %200[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %261 = llvm.mul %223, %258  : i64
          %262 = llvm.add %260, %261  : i64
          %263 = llvm.mul %221, %259  : i64
          %264 = llvm.add %262, %263  : i64
          %265 = llvm.insertvalue %264, %257[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %266 = llvm.insertvalue %251, %265[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %267 = llvm.insertvalue %92, %266[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %268 = llvm.insertvalue %243, %267[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %269 = llvm.insertvalue %117, %268[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %270 = llvm.extractvalue %218[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %271 = llvm.bitcast %270 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %272 = llvm.insertvalue %271, %13[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %273 = llvm.extractvalue %218[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %274 = llvm.bitcast %273 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %275 = llvm.insertvalue %274, %272[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %276 = llvm.extractvalue %218[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %277 = llvm.extractvalue %218[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %278 = llvm.extractvalue %218[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %279 = llvm.mul %219, %276  : i64
          %280 = llvm.add %278, %279  : i64
          %281 = llvm.mul %221, %277  : i64
          %282 = llvm.add %280, %281  : i64
          %283 = llvm.insertvalue %282, %275[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %284 = llvm.insertvalue %251, %283[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %285 = llvm.insertvalue %92, %284[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %286 = llvm.insertvalue %228, %285[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %287 = llvm.insertvalue %117, %286[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          llvm.br ^bb17(%5 : i64)
        ^bb17(%288: i64):  // 2 preds: ^bb16, ^bb22
          %289 = llvm.icmp "slt" %288, %228 : i64
          llvm.cond_br %289, ^bb18(%5 : i64), ^bb23
        ^bb18(%290: i64):  // 2 preds: ^bb17, ^bb21
          %291 = llvm.icmp "slt" %290, %251 : i64
          llvm.cond_br %291, ^bb19(%5 : i64), ^bb22
        ^bb19(%292: i64):  // 2 preds: ^bb18, ^bb20
          %293 = llvm.icmp "slt" %292, %4 : i64
          llvm.cond_br %293, ^bb20, ^bb21
        ^bb20:  // pred: ^bb19
          %294 = llvm.extractvalue %247[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %295 = llvm.extractvalue %247[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %296 = llvm.mul %288, %2  : i64
          %297 = llvm.add %295, %296  : i64
          %298 = llvm.add %297, %292  : i64
          %299 = llvm.getelementptr %294[%298] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
          %300 = llvm.load %299 : !llvm.ptr<f32>
          %301 = llvm.extractvalue %269[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %302 = llvm.extractvalue %269[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %303 = llvm.mul %292, %1  : i64
          %304 = llvm.add %302, %303  : i64
          %305 = llvm.add %304, %290  : i64
          %306 = llvm.getelementptr %301[%305] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
          %307 = llvm.load %306 : !llvm.ptr<f32>
          %308 = llvm.extractvalue %287[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %309 = llvm.extractvalue %287[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %310 = llvm.mul %288, %1  : i64
          %311 = llvm.add %309, %310  : i64
          %312 = llvm.add %311, %290  : i64
          %313 = llvm.getelementptr %308[%312] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
          %314 = llvm.load %313 : !llvm.ptr<f32>
          %315 = llvm.fmul %300, %307  : f32
          %316 = llvm.fadd %314, %315  : f32
          llvm.store %316, %313 : !llvm.ptr<f32>
          %317 = llvm.add %292, %6  : i64
          llvm.br ^bb19(%317 : i64)
        ^bb21:  // pred: ^bb19
          %318 = llvm.add %290, %6  : i64
          llvm.br ^bb18(%318 : i64)
        ^bb22:  // pred: ^bb18
          %319 = llvm.add %288, %6  : i64
          llvm.br ^bb17(%319 : i64)
        ^bb23:  // pred: ^bb17
          %320 = llvm.add %223, %4  : i64
          llvm.br ^bb15(%320 : i64)
        ^bb24:  // pred: ^bb15
          %321 = llvm.add %221, %4  : i64
          llvm.br ^bb14(%321 : i64)
        ^bb25:  // pred: ^bb14
          %322 = llvm.add %219, %4  : i64
          llvm.br ^bb13(%322 : i64)
        ^bb26:  // pred: ^bb13
          %323 = llvm.add %154, %3  : i64
          llvm.br ^bb11(%323 : i64)
        ^bb27:  // pred: ^bb11
          %324 = llvm.add %152, %3  : i64
          llvm.br ^bb10(%324 : i64)
        ^bb28:  // pred: ^bb10
          %325 = llvm.add %150, %4  : i64
          llvm.br ^bb9(%325 : i64)
        ^bb29:  // pred: ^bb9
          %326 = llvm.add %69, %68  : i64
          llvm.br ^bb3(%326 : i64)
        ^bb30:  // pred: ^bb3
          %327 = llvm.add %64, %63  : i64
          llvm.br ^bb1(%327 : i64)
        ^bb31:  // pred: ^bb1
          %328 = llvm.mlir.constant(0 : i32) : i32
          llvm.return %328 : i32
        }
      }
    }
  }
  hal.executable @predict_dispatch_3 attributes {sym_visibility = "private"} {
    hal.interface @io {
      hal.interface.binding @s0b0_ro_external, set=0, binding=0, type="StorageBuffer", access="Read"
      hal.interface.binding @s0b1_xw_external, set=0, binding=1, type="StorageBuffer", access="Write|Discard"
    }
    hal.executable.target @llvm_aot, filter="dylib*" {
      hal.executable.entry_point @predict_dispatch_3 attributes {interface = @io, ordinal = 0 : index} {
      ^bb0(%arg0: index, %arg1: index, %arg2: index):  // no predecessors
        %c1 = constant 1 : index
        %0 = affine.apply #map2()[%arg0]
        %1 = affine.apply #map2()[%arg1]
        hal.return %0, %1, %c1 : index, index, index
      }
      module  {
        llvm.mlir.global private constant @__constant_1x10xf32(opaque<"_", "0xDEADBEEF"> : tensor<1x10xf32>) : !llvm.array<1 x array<10 x f32>>
        llvm.func internal @predict_dispatch_3(%arg0: !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>, %arg1: !llvm.ptr<array<3 x i32>>) -> i32 {
          %0 = llvm.mlir.constant(10 : index) : i64
          %1 = llvm.mlir.constant(0 : index) : i64
          %2 = llvm.mlir.constant(1 : index) : i64
          %3 = llvm.mlir.addressof @__constant_1x10xf32 : !llvm.ptr<array<1 x array<10 x f32>>>
          %4 = llvm.getelementptr %3[%1, %1, %1] : (!llvm.ptr<array<1 x array<10 x f32>>>, i64, i64, i64) -> !llvm.ptr<f32>
          %5 = llvm.mlir.constant(3735928559 : index) : i64
          %6 = llvm.inttoptr %5 : i64 to !llvm.ptr<f32>
          %7 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %8 = llvm.insertvalue %6, %7[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %9 = llvm.insertvalue %4, %8[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %10 = llvm.insertvalue %1, %9[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %11 = llvm.insertvalue %2, %10[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %12 = llvm.insertvalue %0, %11[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %13 = llvm.insertvalue %0, %12[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %14 = llvm.insertvalue %2, %13[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %15 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %16 = llvm.extractvalue %15[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %17 = llvm.getelementptr %16[%1] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
          %18 = llvm.load %17 : !llvm.ptr<ptr<i8>>
          %19 = llvm.getelementptr %18[%1] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
          %20 = llvm.bitcast %19 : !llvm.ptr<i8> to !llvm.ptr<f32>
          %21 = llvm.insertvalue %20, %7[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %22 = llvm.insertvalue %20, %21[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %23 = llvm.insertvalue %1, %22[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %24 = llvm.insertvalue %2, %23[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %25 = llvm.insertvalue %0, %24[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %26 = llvm.insertvalue %0, %25[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %27 = llvm.insertvalue %2, %26[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %28 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %29 = llvm.extractvalue %28[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %30 = llvm.getelementptr %29[%2] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
          %31 = llvm.load %30 : !llvm.ptr<ptr<i8>>
          %32 = llvm.getelementptr %31[%1] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
          %33 = llvm.bitcast %32 : !llvm.ptr<i8> to !llvm.ptr<f32>
          %34 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %35 = llvm.insertvalue %33, %34[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %36 = llvm.insertvalue %33, %35[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %37 = llvm.insertvalue %1, %36[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %38 = llvm.insertvalue %0, %37[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %39 = llvm.insertvalue %2, %38[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %40 = llvm.load %arg1 : !llvm.ptr<array<3 x i32>>
          %41 = llvm.extractvalue %40[0] : !llvm.array<3 x i32>
          %42 = llvm.zext %41 : i32 to i64
          %43 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %44 = llvm.extractvalue %43[0] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %45 = llvm.extractvalue %44[0] : !llvm.array<3 x i32>
          %46 = llvm.zext %45 : i32 to i64
          %47 = llvm.load %arg1 : !llvm.ptr<array<3 x i32>>
          %48 = llvm.extractvalue %47[1] : !llvm.array<3 x i32>
          %49 = llvm.zext %48 : i32 to i64
          %50 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %51 = llvm.extractvalue %50[0] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %52 = llvm.extractvalue %51[1] : !llvm.array<3 x i32>
          %53 = llvm.zext %52 : i32 to i64
          %54 = llvm.mlir.constant(128 : index) : i64
          %55 = llvm.mul %49, %54  : i64
          %56 = llvm.mul %53, %54  : i64
          llvm.br ^bb1(%55 : i64)
        ^bb1(%57: i64):  // 2 preds: ^bb0, ^bb10
          %58 = llvm.icmp "slt" %57, %2 : i64
          llvm.cond_br %58, ^bb2, ^bb11
        ^bb2:  // pred: ^bb1
          %59 = llvm.mul %42, %54  : i64
          %60 = llvm.mul %46, %54  : i64
          llvm.br ^bb3(%59 : i64)
        ^bb3(%61: i64):  // 2 preds: ^bb2, ^bb9
          %62 = llvm.icmp "slt" %61, %0 : i64
          llvm.cond_br %62, ^bb4, ^bb10
        ^bb4:  // pred: ^bb3
          %63 = llvm.mlir.constant(-1 : index) : i64
          %64 = llvm.mul %57, %63  : i64
          %65 = llvm.add %64, %2  : i64
          %66 = llvm.icmp "slt" %54, %65 : i64
          %67 = llvm.select %66, %54, %65 : i1, i64
          %68 = llvm.mul %61, %63  : i64
          %69 = llvm.add %68, %0  : i64
          %70 = llvm.icmp "slt" %54, %69 : i64
          %71 = llvm.select %70, %54, %69 : i1, i64
          %72 = llvm.extractvalue %27[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %73 = llvm.bitcast %72 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %74 = llvm.insertvalue %73, %7[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %75 = llvm.extractvalue %27[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %76 = llvm.bitcast %75 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %77 = llvm.insertvalue %76, %74[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %78 = llvm.extractvalue %27[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %79 = llvm.extractvalue %27[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %80 = llvm.extractvalue %27[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %81 = llvm.mul %57, %78  : i64
          %82 = llvm.add %80, %81  : i64
          %83 = llvm.mul %61, %79  : i64
          %84 = llvm.add %82, %83  : i64
          %85 = llvm.insertvalue %84, %77[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %86 = llvm.mlir.constant(1 : i64) : i64
          %87 = llvm.insertvalue %71, %85[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %88 = llvm.insertvalue %86, %87[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %89 = llvm.mlir.constant(10 : i64) : i64
          %90 = llvm.insertvalue %67, %88[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %91 = llvm.insertvalue %89, %90[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %92 = llvm.extractvalue %14[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %93 = llvm.bitcast %92 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %94 = llvm.insertvalue %93, %7[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %95 = llvm.extractvalue %14[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %96 = llvm.bitcast %95 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %97 = llvm.insertvalue %96, %94[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %98 = llvm.extractvalue %14[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %99 = llvm.extractvalue %14[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %100 = llvm.extractvalue %14[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %101 = llvm.mul %57, %98  : i64
          %102 = llvm.add %100, %101  : i64
          %103 = llvm.mul %61, %99  : i64
          %104 = llvm.add %102, %103  : i64
          %105 = llvm.insertvalue %104, %97[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %106 = llvm.insertvalue %71, %105[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %107 = llvm.insertvalue %86, %106[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %108 = llvm.insertvalue %67, %107[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %109 = llvm.insertvalue %89, %108[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %110 = llvm.extractvalue %39[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %111 = llvm.bitcast %110 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %112 = llvm.insertvalue %111, %34[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %113 = llvm.extractvalue %39[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %114 = llvm.bitcast %113 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %115 = llvm.insertvalue %114, %112[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %116 = llvm.extractvalue %39[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %117 = llvm.extractvalue %39[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %118 = llvm.mul %61, %116  : i64
          %119 = llvm.add %117, %118  : i64
          %120 = llvm.insertvalue %119, %115[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %121 = llvm.insertvalue %71, %120[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %122 = llvm.insertvalue %86, %121[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          llvm.br ^bb5(%1 : i64)
        ^bb5(%123: i64):  // 2 preds: ^bb4, ^bb8
          %124 = llvm.icmp "slt" %123, %67 : i64
          llvm.cond_br %124, ^bb6(%1 : i64), ^bb9
        ^bb6(%125: i64):  // 2 preds: ^bb5, ^bb7
          %126 = llvm.icmp "slt" %125, %71 : i64
          llvm.cond_br %126, ^bb7, ^bb8
        ^bb7:  // pred: ^bb6
          %127 = llvm.extractvalue %91[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %128 = llvm.extractvalue %91[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %129 = llvm.mul %123, %0  : i64
          %130 = llvm.add %128, %129  : i64
          %131 = llvm.add %130, %125  : i64
          %132 = llvm.getelementptr %127[%131] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
          %133 = llvm.load %132 : !llvm.ptr<f32>
          %134 = llvm.extractvalue %109[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %135 = llvm.extractvalue %109[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %136 = llvm.add %135, %129  : i64
          %137 = llvm.add %136, %125  : i64
          %138 = llvm.getelementptr %134[%137] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
          %139 = llvm.load %138 : !llvm.ptr<f32>
          %140 = llvm.fadd %133, %139  : f32
          %141 = llvm.extractvalue %122[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %142 = llvm.extractvalue %122[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %143 = llvm.add %142, %125  : i64
          %144 = llvm.getelementptr %141[%143] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
          llvm.store %140, %144 : !llvm.ptr<f32>
          %145 = llvm.add %125, %2  : i64
          llvm.br ^bb6(%145 : i64)
        ^bb8:  // pred: ^bb6
          %146 = llvm.add %123, %2  : i64
          llvm.br ^bb5(%146 : i64)
        ^bb9:  // pred: ^bb5
          %147 = llvm.add %61, %60  : i64
          llvm.br ^bb3(%147 : i64)
        ^bb10:  // pred: ^bb3
          %148 = llvm.add %57, %56  : i64
          llvm.br ^bb1(%148 : i64)
        ^bb11:  // pred: ^bb1
          %149 = llvm.mlir.constant(0 : i32) : i32
          llvm.return %149 : i32
        }
      }
    }
  }
  hal.executable @predict_dispatch_4 attributes {sym_visibility = "private"} {
    hal.interface @io {
      hal.interface.binding @s0b0_ro_external, set=0, binding=0, type="StorageBuffer", access="Read"
      hal.interface.binding @s0b1_xw_external, set=0, binding=1, type="StorageBuffer", access="Write|Discard"
    }
    hal.executable.target @llvm_aot, filter="dylib*" {
      hal.executable.entry_point @predict_dispatch_4 attributes {interface = @io, ordinal = 0 : index} {
      ^bb0(%arg0: index, %arg1: index, %arg2: index):  // no predecessors
        %c1 = constant 1 : index
        hal.return %c1, %c1, %c1 : index, index, index
      }
      module  {
        llvm.func internal @predict_dispatch_4(%arg0: !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>, %arg1: !llvm.ptr<array<3 x i32>>) -> i32 {
          %0 = llvm.mlir.constant(0x7FC00000 : f32) : f32
          %1 = llvm.mlir.constant(0xFF800000 : f32) : f32
          %2 = llvm.mlir.constant(10 : index) : i64
          %3 = llvm.mlir.constant(0 : index) : i64
          %4 = llvm.mlir.constant(1 : index) : i64
          %5 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %6 = llvm.extractvalue %5[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %7 = llvm.getelementptr %6[%3] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
          %8 = llvm.load %7 : !llvm.ptr<ptr<i8>>
          %9 = llvm.getelementptr %8[%3] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
          %10 = llvm.bitcast %9 : !llvm.ptr<i8> to !llvm.ptr<f32>
          %11 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %12 = llvm.insertvalue %10, %11[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %13 = llvm.insertvalue %10, %12[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %14 = llvm.insertvalue %3, %13[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %15 = llvm.insertvalue %2, %14[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %16 = llvm.insertvalue %4, %15[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %17 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %18 = llvm.extractvalue %17[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %19 = llvm.getelementptr %18[%4] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
          %20 = llvm.load %19 : !llvm.ptr<ptr<i8>>
          %21 = llvm.getelementptr %20[%3] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
          %22 = llvm.bitcast %21 : !llvm.ptr<i8> to !llvm.ptr<f32>
          %23 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
          %24 = llvm.insertvalue %22, %23[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
          %25 = llvm.insertvalue %22, %24[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
          %26 = llvm.insertvalue %3, %25[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
          %27 = llvm.extractvalue %26[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
          llvm.store %1, %27 : !llvm.ptr<f32>
          llvm.br ^bb1(%3 : i64)
        ^bb1(%28: i64):  // 2 preds: ^bb0, ^bb2
          %29 = llvm.icmp "slt" %28, %2 : i64
          llvm.cond_br %29, ^bb2, ^bb3
        ^bb2:  // pred: ^bb1
          %30 = llvm.extractvalue %16[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %31 = llvm.getelementptr %30[%28] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
          %32 = llvm.load %31 : !llvm.ptr<f32>
          %33 = llvm.load %27 : !llvm.ptr<f32>
          %34 = llvm.fcmp "ogt" %32, %33 : f32
          %35 = llvm.select %34, %32, %33 : i1, f32
          %36 = llvm.fcmp "uno" %32, %33 : f32
          %37 = llvm.select %36, %0, %35 : i1, f32
          llvm.store %37, %27 : !llvm.ptr<f32>
          %38 = llvm.add %28, %4  : i64
          llvm.br ^bb1(%38 : i64)
        ^bb3:  // pred: ^bb1
          %39 = llvm.mlir.constant(0 : i32) : i32
          llvm.return %39 : i32
        }
      }
    }
  }
  hal.executable @predict_dispatch_5 attributes {sym_visibility = "private"} {
    hal.interface @io {
      hal.interface.binding @s0b0_ro_external, set=0, binding=0, type="StorageBuffer", access="Read"
      hal.interface.binding @s0b1_ro_external, set=0, binding=1, type="StorageBuffer", access="Read"
      hal.interface.binding @s0b2_xw_external, set=0, binding=2, type="StorageBuffer", access="Write|Discard"
    }
    hal.executable.target @llvm_aot, filter="dylib*" {
      hal.executable.entry_point @predict_dispatch_5 attributes {interface = @io, ordinal = 0 : index} {
      ^bb0(%arg0: index, %arg1: index, %arg2: index):  // no predecessors
        %c1 = constant 1 : index
        %0 = affine.apply #map2()[%arg0]
        %1 = affine.apply #map2()[%arg1]
        hal.return %0, %1, %c1 : index, index, index
      }
      module  {
        llvm.mlir.global private constant @__constant_1x10xf32(opaque<"_", "0xDEADBEEF"> : tensor<1x10xf32>) : !llvm.array<1 x array<10 x f32>>
        llvm.func internal @predict_dispatch_5(%arg0: !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>, %arg1: !llvm.ptr<array<3 x i32>>) -> i32 {
          %0 = llvm.mlir.constant(10 : index) : i64
          %1 = llvm.mlir.constant(0 : index) : i64
          %2 = llvm.mlir.constant(1 : index) : i64
          %3 = llvm.mlir.constant(0.693147182 : f32) : f32
          %4 = llvm.mlir.constant(1.44269502 : f32) : f32
          %5 = llvm.mlir.constant(1.000000e+00 : f32) : f32
          %6 = llvm.mlir.constant(0.499705136 : f32) : f32
          %7 = llvm.mlir.constant(0.168738902 : f32) : f32
          %8 = llvm.mlir.constant(0.0366896503 : f32) : f32
          %9 = llvm.mlir.constant(1.314350e-02 : f32) : f32
          %10 = llvm.mlir.constant(23 : i32) : i32
          %11 = llvm.mlir.constant(0.000000e+00 : f32) : f32
          %12 = llvm.mlir.constant(0x7F800000 : f32) : f32
          %13 = llvm.mlir.constant(0xFF800000 : f32) : f32
          %14 = llvm.mlir.constant(1.17549435E-38 : f32) : f32
          %15 = llvm.mlir.constant(127 : i32) : i32
          %16 = llvm.mlir.constant(-127 : i32) : i32
          %17 = llvm.mlir.addressof @__constant_1x10xf32 : !llvm.ptr<array<1 x array<10 x f32>>>
          %18 = llvm.getelementptr %17[%1, %1, %1] : (!llvm.ptr<array<1 x array<10 x f32>>>, i64, i64, i64) -> !llvm.ptr<f32>
          %19 = llvm.mlir.constant(3735928559 : index) : i64
          %20 = llvm.inttoptr %19 : i64 to !llvm.ptr<f32>
          %21 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %22 = llvm.insertvalue %20, %21[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %23 = llvm.insertvalue %18, %22[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %24 = llvm.insertvalue %1, %23[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %25 = llvm.insertvalue %2, %24[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %26 = llvm.insertvalue %0, %25[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %27 = llvm.insertvalue %0, %26[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %28 = llvm.insertvalue %2, %27[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %29 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %30 = llvm.extractvalue %29[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %31 = llvm.getelementptr %30[%1] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
          %32 = llvm.load %31 : !llvm.ptr<ptr<i8>>
          %33 = llvm.getelementptr %32[%1] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
          %34 = llvm.bitcast %33 : !llvm.ptr<i8> to !llvm.ptr<f32>
          %35 = llvm.insertvalue %34, %21[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %36 = llvm.insertvalue %34, %35[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %37 = llvm.insertvalue %1, %36[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %38 = llvm.insertvalue %2, %37[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %39 = llvm.insertvalue %0, %38[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %40 = llvm.insertvalue %0, %39[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %41 = llvm.insertvalue %2, %40[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %42 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %43 = llvm.extractvalue %42[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %44 = llvm.getelementptr %43[%2] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
          %45 = llvm.load %44 : !llvm.ptr<ptr<i8>>
          %46 = llvm.getelementptr %45[%1] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
          %47 = llvm.bitcast %46 : !llvm.ptr<i8> to !llvm.ptr<f32>
          %48 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
          %49 = llvm.insertvalue %47, %48[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
          %50 = llvm.insertvalue %47, %49[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
          %51 = llvm.insertvalue %1, %50[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
          %52 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %53 = llvm.extractvalue %52[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %54 = llvm.mlir.constant(2 : index) : i64
          %55 = llvm.getelementptr %53[%54] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
          %56 = llvm.load %55 : !llvm.ptr<ptr<i8>>
          %57 = llvm.getelementptr %56[%1] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
          %58 = llvm.bitcast %57 : !llvm.ptr<i8> to !llvm.ptr<f32>
          %59 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %60 = llvm.insertvalue %58, %59[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %61 = llvm.insertvalue %58, %60[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %62 = llvm.insertvalue %1, %61[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %63 = llvm.insertvalue %0, %62[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %64 = llvm.insertvalue %2, %63[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %65 = llvm.load %arg1 : !llvm.ptr<array<3 x i32>>
          %66 = llvm.extractvalue %65[0] : !llvm.array<3 x i32>
          %67 = llvm.zext %66 : i32 to i64
          %68 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %69 = llvm.extractvalue %68[0] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %70 = llvm.extractvalue %69[0] : !llvm.array<3 x i32>
          %71 = llvm.zext %70 : i32 to i64
          %72 = llvm.load %arg1 : !llvm.ptr<array<3 x i32>>
          %73 = llvm.extractvalue %72[1] : !llvm.array<3 x i32>
          %74 = llvm.zext %73 : i32 to i64
          %75 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %76 = llvm.extractvalue %75[0] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %77 = llvm.extractvalue %76[1] : !llvm.array<3 x i32>
          %78 = llvm.zext %77 : i32 to i64
          %79 = llvm.mlir.constant(128 : index) : i64
          %80 = llvm.mul %74, %79  : i64
          %81 = llvm.mul %78, %79  : i64
          llvm.br ^bb1(%80 : i64)
        ^bb1(%82: i64):  // 2 preds: ^bb0, ^bb10
          %83 = llvm.icmp "slt" %82, %2 : i64
          llvm.cond_br %83, ^bb2, ^bb11
        ^bb2:  // pred: ^bb1
          %84 = llvm.mul %67, %79  : i64
          %85 = llvm.mul %71, %79  : i64
          llvm.br ^bb3(%84 : i64)
        ^bb3(%86: i64):  // 2 preds: ^bb2, ^bb9
          %87 = llvm.icmp "slt" %86, %0 : i64
          llvm.cond_br %87, ^bb4, ^bb10
        ^bb4:  // pred: ^bb3
          %88 = llvm.mlir.constant(-1 : index) : i64
          %89 = llvm.mul %82, %88  : i64
          %90 = llvm.add %89, %2  : i64
          %91 = llvm.icmp "slt" %79, %90 : i64
          %92 = llvm.select %91, %79, %90 : i1, i64
          %93 = llvm.mul %86, %88  : i64
          %94 = llvm.add %93, %0  : i64
          %95 = llvm.icmp "slt" %79, %94 : i64
          %96 = llvm.select %95, %79, %94 : i1, i64
          %97 = llvm.extractvalue %41[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %98 = llvm.bitcast %97 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %99 = llvm.insertvalue %98, %21[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %100 = llvm.extractvalue %41[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %101 = llvm.bitcast %100 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %102 = llvm.insertvalue %101, %99[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %103 = llvm.extractvalue %41[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %104 = llvm.extractvalue %41[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %105 = llvm.extractvalue %41[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %106 = llvm.mul %82, %103  : i64
          %107 = llvm.add %105, %106  : i64
          %108 = llvm.mul %86, %104  : i64
          %109 = llvm.add %107, %108  : i64
          %110 = llvm.insertvalue %109, %102[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %111 = llvm.mlir.constant(1 : i64) : i64
          %112 = llvm.insertvalue %96, %110[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %113 = llvm.insertvalue %111, %112[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %114 = llvm.mlir.constant(10 : i64) : i64
          %115 = llvm.insertvalue %92, %113[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %116 = llvm.insertvalue %114, %115[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %117 = llvm.extractvalue %28[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %118 = llvm.bitcast %117 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %119 = llvm.insertvalue %118, %21[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %120 = llvm.extractvalue %28[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %121 = llvm.bitcast %120 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %122 = llvm.insertvalue %121, %119[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %123 = llvm.extractvalue %28[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %124 = llvm.extractvalue %28[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %125 = llvm.extractvalue %28[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %126 = llvm.mul %82, %123  : i64
          %127 = llvm.add %125, %126  : i64
          %128 = llvm.mul %86, %124  : i64
          %129 = llvm.add %127, %128  : i64
          %130 = llvm.insertvalue %129, %122[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %131 = llvm.insertvalue %96, %130[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %132 = llvm.insertvalue %111, %131[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %133 = llvm.insertvalue %92, %132[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %134 = llvm.insertvalue %114, %133[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %135 = llvm.extractvalue %64[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %136 = llvm.bitcast %135 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %137 = llvm.insertvalue %136, %59[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %138 = llvm.extractvalue %64[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %139 = llvm.bitcast %138 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %140 = llvm.insertvalue %139, %137[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %141 = llvm.extractvalue %64[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %142 = llvm.extractvalue %64[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %143 = llvm.mul %86, %141  : i64
          %144 = llvm.add %142, %143  : i64
          %145 = llvm.insertvalue %144, %140[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %146 = llvm.insertvalue %96, %145[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %147 = llvm.insertvalue %111, %146[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          llvm.br ^bb5(%1 : i64)
        ^bb5(%148: i64):  // 2 preds: ^bb4, ^bb8
          %149 = llvm.icmp "slt" %148, %92 : i64
          llvm.cond_br %149, ^bb6(%1 : i64), ^bb9
        ^bb6(%150: i64):  // 2 preds: ^bb5, ^bb7
          %151 = llvm.icmp "slt" %150, %96 : i64
          llvm.cond_br %151, ^bb7, ^bb8
        ^bb7:  // pred: ^bb6
          %152 = llvm.extractvalue %116[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %153 = llvm.extractvalue %116[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %154 = llvm.mul %148, %0  : i64
          %155 = llvm.add %153, %154  : i64
          %156 = llvm.add %155, %150  : i64
          %157 = llvm.getelementptr %152[%156] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
          %158 = llvm.load %157 : !llvm.ptr<f32>
          %159 = llvm.extractvalue %134[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %160 = llvm.extractvalue %134[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %161 = llvm.add %160, %154  : i64
          %162 = llvm.add %161, %150  : i64
          %163 = llvm.getelementptr %159[%162] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
          %164 = llvm.load %163 : !llvm.ptr<f32>
          %165 = llvm.extractvalue %51[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
          %166 = llvm.load %165 : !llvm.ptr<f32>
          %167 = llvm.fadd %158, %164  : f32
          %168 = llvm.fsub %167, %166  : f32
          %169 = llvm.fmul %168, %4  : f32
          %170 = "llvm.intr.floor"(%169) : (f32) -> f32
          %171 = llvm.fmul %170, %3  : f32
          %172 = llvm.fsub %168, %171  : f32
          %173 = llvm.fmul %172, %172  : f32
          %174 = llvm.fmul %173, %173  : f32
          %175 = "llvm.intr.fma"(%5, %172, %5) : (f32, f32, f32) -> f32
          %176 = "llvm.intr.fma"(%7, %172, %6) : (f32, f32, f32) -> f32
          %177 = "llvm.intr.fma"(%9, %172, %8) : (f32, f32, f32) -> f32
          %178 = "llvm.intr.fma"(%176, %173, %175) : (f32, f32, f32) -> f32
          %179 = "llvm.intr.fma"(%177, %174, %178) : (f32, f32, f32) -> f32
          %180 = llvm.fptosi %170 : f32 to i32
          %181 = llvm.add %180, %15  : i32
          %182 = llvm.shl %181, %10  : i32
          %183 = llvm.bitcast %182 : i32 to f32
          %184 = llvm.fmul %179, %183  : f32
          %185 = llvm.icmp "sle" %180, %15 : i32
          %186 = llvm.icmp "sge" %180, %16 : i32
          %187 = llvm.fcmp "oeq" %168, %13 : f32
          %188 = llvm.fcmp "ogt" %168, %11 : f32
          %189 = llvm.and %185, %186  : i1
          %190 = llvm.select %187, %11, %14 : i1, f32
          %191 = llvm.select %188, %12, %190 : i1, f32
          %192 = llvm.select %189, %184, %191 : i1, f32
          %193 = llvm.extractvalue %147[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %194 = llvm.extractvalue %147[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %195 = llvm.add %194, %150  : i64
          %196 = llvm.getelementptr %193[%195] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
          llvm.store %192, %196 : !llvm.ptr<f32>
          %197 = llvm.add %150, %2  : i64
          llvm.br ^bb6(%197 : i64)
        ^bb8:  // pred: ^bb6
          %198 = llvm.add %148, %2  : i64
          llvm.br ^bb5(%198 : i64)
        ^bb9:  // pred: ^bb5
          %199 = llvm.add %86, %85  : i64
          llvm.br ^bb3(%199 : i64)
        ^bb10:  // pred: ^bb3
          %200 = llvm.add %82, %81  : i64
          llvm.br ^bb1(%200 : i64)
        ^bb11:  // pred: ^bb1
          %201 = llvm.mlir.constant(0 : i32) : i32
          llvm.return %201 : i32
        }
      }
    }
  }
  hal.executable @predict_dispatch_6 attributes {sym_visibility = "private"} {
    hal.interface @io {
      hal.interface.binding @s0b0_ro_external, set=0, binding=0, type="StorageBuffer", access="Read"
      hal.interface.binding @s0b1_xw_external, set=0, binding=1, type="StorageBuffer", access="Write|Discard"
    }
    hal.executable.target @llvm_aot, filter="dylib*" {
      hal.executable.entry_point @predict_dispatch_6 attributes {interface = @io, ordinal = 0 : index} {
      ^bb0(%arg0: index, %arg1: index, %arg2: index):  // no predecessors
        %c1 = constant 1 : index
        hal.return %c1, %c1, %c1 : index, index, index
      }
      module  {
        llvm.func internal @predict_dispatch_6(%arg0: !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>, %arg1: !llvm.ptr<array<3 x i32>>) -> i32 {
          %0 = llvm.mlir.constant(0.000000e+00 : f32) : f32
          %1 = llvm.mlir.constant(10 : index) : i64
          %2 = llvm.mlir.constant(0 : index) : i64
          %3 = llvm.mlir.constant(1 : index) : i64
          %4 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %5 = llvm.extractvalue %4[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %6 = llvm.getelementptr %5[%2] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
          %7 = llvm.load %6 : !llvm.ptr<ptr<i8>>
          %8 = llvm.getelementptr %7[%2] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
          %9 = llvm.bitcast %8 : !llvm.ptr<i8> to !llvm.ptr<f32>
          %10 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %11 = llvm.insertvalue %9, %10[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %12 = llvm.insertvalue %9, %11[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %13 = llvm.insertvalue %2, %12[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %14 = llvm.insertvalue %1, %13[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %15 = llvm.insertvalue %3, %14[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %16 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %17 = llvm.extractvalue %16[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %18 = llvm.getelementptr %17[%3] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
          %19 = llvm.load %18 : !llvm.ptr<ptr<i8>>
          %20 = llvm.getelementptr %19[%2] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
          %21 = llvm.bitcast %20 : !llvm.ptr<i8> to !llvm.ptr<f32>
          %22 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
          %23 = llvm.insertvalue %21, %22[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
          %24 = llvm.insertvalue %21, %23[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
          %25 = llvm.insertvalue %2, %24[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
          %26 = llvm.extractvalue %25[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
          llvm.store %0, %26 : !llvm.ptr<f32>
          llvm.br ^bb1(%2 : i64)
        ^bb1(%27: i64):  // 2 preds: ^bb0, ^bb2
          %28 = llvm.icmp "slt" %27, %1 : i64
          llvm.cond_br %28, ^bb2, ^bb3
        ^bb2:  // pred: ^bb1
          %29 = llvm.extractvalue %15[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %30 = llvm.getelementptr %29[%27] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
          %31 = llvm.load %30 : !llvm.ptr<f32>
          %32 = llvm.load %26 : !llvm.ptr<f32>
          %33 = llvm.fadd %31, %32  : f32
          llvm.store %33, %26 : !llvm.ptr<f32>
          %34 = llvm.add %27, %3  : i64
          llvm.br ^bb1(%34 : i64)
        ^bb3:  // pred: ^bb1
          %35 = llvm.mlir.constant(0 : i32) : i32
          llvm.return %35 : i32
        }
      }
    }
  }
  hal.executable @predict_dispatch_7 attributes {sym_visibility = "private"} {
    hal.interface @io {
      hal.interface.binding @s0b0_ro_external, set=0, binding=0, type="StorageBuffer", access="Read"
      hal.interface.binding @s0b1_ro_external, set=0, binding=1, type="StorageBuffer", access="Read"
      hal.interface.binding @s0b2_ro_external, set=0, binding=2, type="StorageBuffer", access="Read"
      hal.interface.binding @s0b3_xw_external, set=0, binding=3, type="StorageBuffer", access="Write|Discard"
    }
    hal.executable.target @llvm_aot, filter="dylib*" {
      hal.executable.entry_point @predict_dispatch_7 attributes {interface = @io, ordinal = 0 : index} {
      ^bb0(%arg0: index, %arg1: index, %arg2: index):  // no predecessors
        %c1 = constant 1 : index
        %0 = affine.apply #map2()[%arg0]
        %1 = affine.apply #map2()[%arg1]
        hal.return %0, %1, %c1 : index, index, index
      }
      module  {
        llvm.mlir.global private constant @__constant_1x10xf32(opaque<"_", "0xDEADBEEF"> : tensor<1x10xf32>) : !llvm.array<1 x array<10 x f32>>
        llvm.func internal @predict_dispatch_7(%arg0: !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>, %arg1: !llvm.ptr<array<3 x i32>>) -> i32 {
          %0 = llvm.mlir.constant(10 : index) : i64
          %1 = llvm.mlir.constant(0 : index) : i64
          %2 = llvm.mlir.constant(1 : index) : i64
          %3 = llvm.mlir.constant(0.693147182 : f32) : f32
          %4 = llvm.mlir.constant(1.44269502 : f32) : f32
          %5 = llvm.mlir.constant(1.000000e+00 : f32) : f32
          %6 = llvm.mlir.constant(0.499705136 : f32) : f32
          %7 = llvm.mlir.constant(0.168738902 : f32) : f32
          %8 = llvm.mlir.constant(0.0366896503 : f32) : f32
          %9 = llvm.mlir.constant(1.314350e-02 : f32) : f32
          %10 = llvm.mlir.constant(23 : i32) : i32
          %11 = llvm.mlir.constant(0.000000e+00 : f32) : f32
          %12 = llvm.mlir.constant(0x7F800000 : f32) : f32
          %13 = llvm.mlir.constant(0xFF800000 : f32) : f32
          %14 = llvm.mlir.constant(1.17549435E-38 : f32) : f32
          %15 = llvm.mlir.constant(127 : i32) : i32
          %16 = llvm.mlir.constant(-127 : i32) : i32
          %17 = llvm.mlir.addressof @__constant_1x10xf32 : !llvm.ptr<array<1 x array<10 x f32>>>
          %18 = llvm.getelementptr %17[%1, %1, %1] : (!llvm.ptr<array<1 x array<10 x f32>>>, i64, i64, i64) -> !llvm.ptr<f32>
          %19 = llvm.mlir.constant(3735928559 : index) : i64
          %20 = llvm.inttoptr %19 : i64 to !llvm.ptr<f32>
          %21 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %22 = llvm.insertvalue %20, %21[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %23 = llvm.insertvalue %18, %22[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %24 = llvm.insertvalue %1, %23[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %25 = llvm.insertvalue %2, %24[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %26 = llvm.insertvalue %0, %25[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %27 = llvm.insertvalue %0, %26[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %28 = llvm.insertvalue %2, %27[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %29 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %30 = llvm.extractvalue %29[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %31 = llvm.getelementptr %30[%1] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
          %32 = llvm.load %31 : !llvm.ptr<ptr<i8>>
          %33 = llvm.getelementptr %32[%1] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
          %34 = llvm.bitcast %33 : !llvm.ptr<i8> to !llvm.ptr<f32>
          %35 = llvm.insertvalue %34, %21[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %36 = llvm.insertvalue %34, %35[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %37 = llvm.insertvalue %1, %36[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %38 = llvm.insertvalue %2, %37[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %39 = llvm.insertvalue %0, %38[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %40 = llvm.insertvalue %0, %39[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %41 = llvm.insertvalue %2, %40[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %42 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %43 = llvm.extractvalue %42[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %44 = llvm.getelementptr %43[%2] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
          %45 = llvm.load %44 : !llvm.ptr<ptr<i8>>
          %46 = llvm.getelementptr %45[%1] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
          %47 = llvm.bitcast %46 : !llvm.ptr<i8> to !llvm.ptr<f32>
          %48 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
          %49 = llvm.insertvalue %47, %48[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
          %50 = llvm.insertvalue %47, %49[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
          %51 = llvm.insertvalue %1, %50[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
          %52 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %53 = llvm.extractvalue %52[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %54 = llvm.mlir.constant(2 : index) : i64
          %55 = llvm.getelementptr %53[%54] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
          %56 = llvm.load %55 : !llvm.ptr<ptr<i8>>
          %57 = llvm.getelementptr %56[%1] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
          %58 = llvm.bitcast %57 : !llvm.ptr<i8> to !llvm.ptr<f32>
          %59 = llvm.insertvalue %58, %48[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
          %60 = llvm.insertvalue %58, %59[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
          %61 = llvm.insertvalue %1, %60[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
          %62 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %63 = llvm.extractvalue %62[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %64 = llvm.mlir.constant(3 : index) : i64
          %65 = llvm.getelementptr %63[%64] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
          %66 = llvm.load %65 : !llvm.ptr<ptr<i8>>
          %67 = llvm.getelementptr %66[%1] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
          %68 = llvm.bitcast %67 : !llvm.ptr<i8> to !llvm.ptr<f32>
          %69 = llvm.insertvalue %68, %21[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %70 = llvm.insertvalue %68, %69[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %71 = llvm.insertvalue %1, %70[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %72 = llvm.insertvalue %2, %71[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %73 = llvm.insertvalue %0, %72[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %74 = llvm.insertvalue %0, %73[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %75 = llvm.insertvalue %2, %74[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %76 = llvm.load %arg1 : !llvm.ptr<array<3 x i32>>
          %77 = llvm.extractvalue %76[0] : !llvm.array<3 x i32>
          %78 = llvm.zext %77 : i32 to i64
          %79 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %80 = llvm.extractvalue %79[0] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %81 = llvm.extractvalue %80[0] : !llvm.array<3 x i32>
          %82 = llvm.zext %81 : i32 to i64
          %83 = llvm.load %arg1 : !llvm.ptr<array<3 x i32>>
          %84 = llvm.extractvalue %83[1] : !llvm.array<3 x i32>
          %85 = llvm.zext %84 : i32 to i64
          %86 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %87 = llvm.extractvalue %86[0] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %88 = llvm.extractvalue %87[1] : !llvm.array<3 x i32>
          %89 = llvm.zext %88 : i32 to i64
          %90 = llvm.mlir.constant(128 : index) : i64
          %91 = llvm.mul %85, %90  : i64
          %92 = llvm.mul %89, %90  : i64
          llvm.br ^bb1(%91 : i64)
        ^bb1(%93: i64):  // 2 preds: ^bb0, ^bb10
          %94 = llvm.icmp "slt" %93, %2 : i64
          llvm.cond_br %94, ^bb2, ^bb11
        ^bb2:  // pred: ^bb1
          %95 = llvm.mul %78, %90  : i64
          %96 = llvm.mul %82, %90  : i64
          llvm.br ^bb3(%95 : i64)
        ^bb3(%97: i64):  // 2 preds: ^bb2, ^bb9
          %98 = llvm.icmp "slt" %97, %0 : i64
          llvm.cond_br %98, ^bb4, ^bb10
        ^bb4:  // pred: ^bb3
          %99 = llvm.mlir.constant(-1 : index) : i64
          %100 = llvm.mul %93, %99  : i64
          %101 = llvm.add %100, %2  : i64
          %102 = llvm.icmp "slt" %90, %101 : i64
          %103 = llvm.select %102, %90, %101 : i1, i64
          %104 = llvm.mul %97, %99  : i64
          %105 = llvm.add %104, %0  : i64
          %106 = llvm.icmp "slt" %90, %105 : i64
          %107 = llvm.select %106, %90, %105 : i1, i64
          %108 = llvm.extractvalue %41[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %109 = llvm.bitcast %108 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %110 = llvm.insertvalue %109, %21[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %111 = llvm.extractvalue %41[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %112 = llvm.bitcast %111 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %113 = llvm.insertvalue %112, %110[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %114 = llvm.extractvalue %41[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %115 = llvm.extractvalue %41[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %116 = llvm.extractvalue %41[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %117 = llvm.mul %93, %114  : i64
          %118 = llvm.add %116, %117  : i64
          %119 = llvm.mul %97, %115  : i64
          %120 = llvm.add %118, %119  : i64
          %121 = llvm.insertvalue %120, %113[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %122 = llvm.mlir.constant(1 : i64) : i64
          %123 = llvm.insertvalue %107, %121[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %124 = llvm.insertvalue %122, %123[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %125 = llvm.mlir.constant(10 : i64) : i64
          %126 = llvm.insertvalue %103, %124[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %127 = llvm.insertvalue %125, %126[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %128 = llvm.extractvalue %28[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %129 = llvm.bitcast %128 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %130 = llvm.insertvalue %129, %21[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %131 = llvm.extractvalue %28[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %132 = llvm.bitcast %131 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %133 = llvm.insertvalue %132, %130[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %134 = llvm.extractvalue %28[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %135 = llvm.extractvalue %28[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %136 = llvm.extractvalue %28[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %137 = llvm.mul %93, %134  : i64
          %138 = llvm.add %136, %137  : i64
          %139 = llvm.mul %97, %135  : i64
          %140 = llvm.add %138, %139  : i64
          %141 = llvm.insertvalue %140, %133[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %142 = llvm.insertvalue %107, %141[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %143 = llvm.insertvalue %122, %142[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %144 = llvm.insertvalue %103, %143[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %145 = llvm.insertvalue %125, %144[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %146 = llvm.extractvalue %75[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %147 = llvm.bitcast %146 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %148 = llvm.insertvalue %147, %21[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %149 = llvm.extractvalue %75[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %150 = llvm.bitcast %149 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %151 = llvm.insertvalue %150, %148[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %152 = llvm.extractvalue %75[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %153 = llvm.extractvalue %75[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %154 = llvm.extractvalue %75[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %155 = llvm.mul %93, %152  : i64
          %156 = llvm.add %154, %155  : i64
          %157 = llvm.mul %97, %153  : i64
          %158 = llvm.add %156, %157  : i64
          %159 = llvm.insertvalue %158, %151[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %160 = llvm.insertvalue %107, %159[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %161 = llvm.insertvalue %122, %160[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %162 = llvm.insertvalue %103, %161[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %163 = llvm.insertvalue %125, %162[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          llvm.br ^bb5(%1 : i64)
        ^bb5(%164: i64):  // 2 preds: ^bb4, ^bb8
          %165 = llvm.icmp "slt" %164, %103 : i64
          llvm.cond_br %165, ^bb6(%1 : i64), ^bb9
        ^bb6(%166: i64):  // 2 preds: ^bb5, ^bb7
          %167 = llvm.icmp "slt" %166, %107 : i64
          llvm.cond_br %167, ^bb7, ^bb8
        ^bb7:  // pred: ^bb6
          %168 = llvm.extractvalue %127[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %169 = llvm.extractvalue %127[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %170 = llvm.mul %164, %0  : i64
          %171 = llvm.add %169, %170  : i64
          %172 = llvm.add %171, %166  : i64
          %173 = llvm.getelementptr %168[%172] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
          %174 = llvm.load %173 : !llvm.ptr<f32>
          %175 = llvm.extractvalue %145[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %176 = llvm.extractvalue %145[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %177 = llvm.add %176, %170  : i64
          %178 = llvm.add %177, %166  : i64
          %179 = llvm.getelementptr %175[%178] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
          %180 = llvm.load %179 : !llvm.ptr<f32>
          %181 = llvm.extractvalue %51[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
          %182 = llvm.load %181 : !llvm.ptr<f32>
          %183 = llvm.extractvalue %61[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
          %184 = llvm.load %183 : !llvm.ptr<f32>
          %185 = llvm.fadd %174, %180  : f32
          %186 = llvm.fsub %185, %182  : f32
          %187 = llvm.fmul %186, %4  : f32
          %188 = "llvm.intr.floor"(%187) : (f32) -> f32
          %189 = llvm.fmul %188, %3  : f32
          %190 = llvm.fsub %186, %189  : f32
          %191 = llvm.fmul %190, %190  : f32
          %192 = llvm.fmul %191, %191  : f32
          %193 = "llvm.intr.fma"(%5, %190, %5) : (f32, f32, f32) -> f32
          %194 = "llvm.intr.fma"(%7, %190, %6) : (f32, f32, f32) -> f32
          %195 = "llvm.intr.fma"(%9, %190, %8) : (f32, f32, f32) -> f32
          %196 = "llvm.intr.fma"(%194, %191, %193) : (f32, f32, f32) -> f32
          %197 = "llvm.intr.fma"(%195, %192, %196) : (f32, f32, f32) -> f32
          %198 = llvm.fptosi %188 : f32 to i32
          %199 = llvm.add %198, %15  : i32
          %200 = llvm.shl %199, %10  : i32
          %201 = llvm.bitcast %200 : i32 to f32
          %202 = llvm.fmul %197, %201  : f32
          %203 = llvm.icmp "sle" %198, %15 : i32
          %204 = llvm.icmp "sge" %198, %16 : i32
          %205 = llvm.fcmp "oeq" %186, %13 : f32
          %206 = llvm.fcmp "ogt" %186, %11 : f32
          %207 = llvm.and %203, %204  : i1
          %208 = llvm.select %205, %11, %14 : i1, f32
          %209 = llvm.select %206, %12, %208 : i1, f32
          %210 = llvm.select %207, %202, %209 : i1, f32
          %211 = llvm.fdiv %210, %184  : f32
          %212 = llvm.extractvalue %163[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %213 = llvm.extractvalue %163[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %214 = llvm.add %213, %170  : i64
          %215 = llvm.add %214, %166  : i64
          %216 = llvm.getelementptr %212[%215] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
          llvm.store %211, %216 : !llvm.ptr<f32>
          %217 = llvm.add %166, %2  : i64
          llvm.br ^bb6(%217 : i64)
        ^bb8:  // pred: ^bb6
          %218 = llvm.add %164, %2  : i64
          llvm.br ^bb5(%218 : i64)
        ^bb9:  // pred: ^bb5
          %219 = llvm.add %97, %96  : i64
          llvm.br ^bb3(%219 : i64)
        ^bb10:  // pred: ^bb3
          %220 = llvm.add %93, %92  : i64
          llvm.br ^bb1(%220 : i64)
        ^bb11:  // pred: ^bb1
          %221 = llvm.mlir.constant(0 : i32) : i32
          llvm.return %221 : i32
        }
      }
    }
  }
  func @predict(%arg0: !hal.buffer) -> !hal.buffer attributes {iree.module.export, iree.reflection = {abi = "sip", abiv = 1 : i32, f = "I15!B11!d1d28d28d1R9!B6!d1d10", fv = "1", sip = "I8!S5!k0_0R3!_0"}} {
    %device = hal.ex.shared_device : !hal.device
    %allocator = hal.device.allocator<%device : !hal.device> : !hal.allocator
    %c50331680_i32 = constant 50331680 : i32
    %c1 = constant 1 : index
    %c28 = constant 28 : index
    %sz = hal.allocator.compute_size<%allocator : !hal.allocator> shape([%c1, %c28, %c28, %c1]) type(%c50331680_i32) : index
    %c10 = constant 10 : index
    %sz_0 = hal.allocator.compute_size<%allocator : !hal.allocator> shape([%c1, %c10]) type(%c50331680_i32) : index
    %buffer = hal.allocator.allocate<%allocator : !hal.allocator> type("HostVisible|DeviceVisible|DeviceLocal") usage("Transfer|Mapping|Dispatch") : !hal.buffer{%sz_0}
    %0 = hal.variable.load @_const_pool_storage_buffer : !hal.buffer
    %c512 = constant 512 : index
    %c401408 = constant 401408 : index
    %buffer_1 = hal.buffer.subspan<%0 : !hal.buffer>[%c512, %c401408] : !hal.buffer
    %c0 = constant 0 : index
    %buffer_2 = hal.buffer.subspan<%0 : !hal.buffer>[%c0, %c512] : !hal.buffer
    %c401920 = constant 401920 : index
    %c5120 = constant 5120 : index
    %buffer_3 = hal.buffer.subspan<%0 : !hal.buffer>[%c401920, %c5120] : !hal.buffer
    %c128 = constant 128 : index
    %sz_4 = hal.allocator.compute_size<%allocator : !hal.allocator> shape([%c1, %c128]) type(%c50331680_i32) : index
    %sz_5 = hal.allocator.compute_size<%allocator : !hal.allocator> shape([%c10]) type(%c50331680_i32) : index
    %sz_6 = hal.allocator.compute_size<%allocator : !hal.allocator> shape([]) type(%c50331680_i32) : index
    %1:8 = hal.allocator.pack<%allocator : !hal.allocator> slices({
      [8, 9] = %sz_4,
      [9, 10] = %sz_4,
      [10, 15] = %sz_0,
      [11, 12] = %sz_5,
      [12, 15] = %sz_6,
      [13, 14] = %sz_5,
      [14, 15] = %sz_6
    }) : index
    %buffer_7 = hal.allocator.allocate<%allocator : !hal.allocator> type("DeviceVisible|DeviceLocal") usage("Transfer|Dispatch") : !hal.buffer{%1#0}
    %buffer_8 = hal.buffer.subspan<%buffer_7 : !hal.buffer>[%1#1, %sz_4] : !hal.buffer
    %buffer_9 = hal.buffer.subspan<%buffer_7 : !hal.buffer>[%1#2, %sz_4] : !hal.buffer
    %buffer_10 = hal.buffer.subspan<%buffer_7 : !hal.buffer>[%1#3, %sz_0] : !hal.buffer
    %buffer_11 = hal.buffer.subspan<%buffer_7 : !hal.buffer>[%1#4, %sz_5] : !hal.buffer
    %buffer_12 = hal.buffer.subspan<%buffer_7 : !hal.buffer>[%1#5, %sz_6] : !hal.buffer
    %buffer_13 = hal.buffer.subspan<%buffer_7 : !hal.buffer>[%1#6, %sz_5] : !hal.buffer
    %buffer_14 = hal.buffer.subspan<%buffer_7 : !hal.buffer>[%1#7, %sz_6] : !hal.buffer
    %cmd = hal.command_buffer.create device(%device : !hal.device) mode("OneShot|AllowInlineExecution") categories("Transfer|Dispatch") : !hal.command_buffer
    hal.command_buffer.begin<%cmd : !hal.command_buffer>
    %c128_15 = constant 128 : index
    %c1_16 = constant 1 : index
    %c10_17 = constant 10 : index
    %executable_layout = hal.executable_layout.lookup device(%device : !hal.device) layouts([[#hal.descriptor_set_layout_binding<0, "StorageBuffer", R>, #hal.descriptor_set_layout_binding<1, "StorageBuffer", R>, #hal.descriptor_set_layout_binding<2, "StorageBuffer", DW>]]) : !hal.executable_layout
    %c2 = constant 2 : index
    hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%executable_layout : !hal.executable_layout)[%c0] bindings([
      %c0 = (%0 : !hal.buffer)[%c512, %c401408], 
      %c1 = (%arg0 : !hal.buffer)[%c0, %sz], 
      %c2 = (%buffer_8 : !hal.buffer)[%c0, %sz_4]
    ])
    hal.device.switch<%device : !hal.device>
    #hal.device.match.id<"dylib*">(%arg1 = %cmd : !hal.command_buffer, %arg2 = %c128_15 : index, %arg3 = %c1_16 : index, %arg4 = %c1_16 : index) {
      %c1_20 = constant 1 : index
      %2 = affine.apply #map0()[%arg2]
      %3 = affine.apply #map1()[%arg3]
      hal.command_buffer.dispatch.symbol<%arg1 : !hal.command_buffer> target(@predict_dispatch_0::@llvm_aot::@predict_dispatch_0) workgroups([%2, %3, %c1_20])
      hal.return
    }
    hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
    hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%executable_layout : !hal.executable_layout)[%c0] bindings([
      %c0 = (%0 : !hal.buffer)[%c0, %c512], 
      %c1 = (%buffer_8 : !hal.buffer)[%c0, %sz_4], 
      %c2 = (%buffer_9 : !hal.buffer)[%c0, %sz_4]
    ])
    hal.device.switch<%device : !hal.device>
    #hal.device.match.id<"dylib*">(%arg1 = %cmd : !hal.command_buffer, %arg2 = %c128_15 : index, %arg3 = %c1_16 : index, %arg4 = %c1_16 : index) {
      %c1_20 = constant 1 : index
      %2 = affine.apply #map2()[%arg2]
      %3 = affine.apply #map2()[%arg3]
      hal.command_buffer.dispatch.symbol<%arg1 : !hal.command_buffer> target(@predict_dispatch_1::@llvm_aot::@predict_dispatch_1) workgroups([%2, %3, %c1_20])
      hal.return
    }
    hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
    hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%executable_layout : !hal.executable_layout)[%c0] bindings([
      %c0 = (%0 : !hal.buffer)[%c401920, %c5120], 
      %c1 = (%buffer_9 : !hal.buffer)[%c0, %sz_4], 
      %c2 = (%buffer_10 : !hal.buffer)[%c0, %sz_0]
    ])
    hal.device.switch<%device : !hal.device>
    #hal.device.match.id<"dylib*">(%arg1 = %cmd : !hal.command_buffer, %arg2 = %c10_17 : index, %arg3 = %c1_16 : index, %arg4 = %c1_16 : index) {
      %c1_20 = constant 1 : index
      %2 = affine.apply #map0()[%arg2]
      %3 = affine.apply #map1()[%arg3]
      hal.command_buffer.dispatch.symbol<%arg1 : !hal.command_buffer> target(@predict_dispatch_2::@llvm_aot::@predict_dispatch_2) workgroups([%2, %3, %c1_20])
      hal.return
    }
    hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
    %executable_layout_18 = hal.executable_layout.lookup device(%device : !hal.device) layouts([[#hal.descriptor_set_layout_binding<0, "StorageBuffer", R>, #hal.descriptor_set_layout_binding<1, "StorageBuffer", DW>]]) : !hal.executable_layout
    hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%executable_layout_18 : !hal.executable_layout)[%c0] bindings([
      %c0 = (%buffer_10 : !hal.buffer)[%c0, %sz_0], 
      %c1 = (%buffer_11 : !hal.buffer)[%c0, %sz_5]
    ])
    hal.device.switch<%device : !hal.device>
    #hal.device.match.id<"dylib*">(%arg1 = %cmd : !hal.command_buffer, %arg2 = %c10_17 : index, %arg3 = %c1_16 : index, %arg4 = %c1_16 : index) {
      %c1_20 = constant 1 : index
      %2 = affine.apply #map2()[%arg2]
      %3 = affine.apply #map2()[%arg3]
      hal.command_buffer.dispatch.symbol<%arg1 : !hal.command_buffer> target(@predict_dispatch_3::@llvm_aot::@predict_dispatch_3) workgroups([%2, %3, %c1_20])
      hal.return
    }
    hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
    hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%executable_layout_18 : !hal.executable_layout)[%c0] bindings([
      %c0 = (%buffer_11 : !hal.buffer)[%c0, %sz_5], 
      %c1 = (%buffer_12 : !hal.buffer)[%c0, %sz_6]
    ])
    hal.device.switch<%device : !hal.device>
    #hal.device.match.id<"dylib*">(%arg1 = %cmd : !hal.command_buffer, %arg2 = %c1_16 : index, %arg3 = %c1_16 : index, %arg4 = %c1_16 : index) {
      %c1_20 = constant 1 : index
      hal.command_buffer.dispatch.symbol<%arg1 : !hal.command_buffer> target(@predict_dispatch_4::@llvm_aot::@predict_dispatch_4) workgroups([%c1_20, %c1_20, %c1_20])
      hal.return
    }
    hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
    hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%executable_layout : !hal.executable_layout)[%c0] bindings([
      %c0 = (%buffer_10 : !hal.buffer)[%c0, %sz_0], 
      %c1 = (%buffer_12 : !hal.buffer)[%c0, %sz_6], 
      %c2 = (%buffer_13 : !hal.buffer)[%c0, %sz_5]
    ])
    hal.device.switch<%device : !hal.device>
    #hal.device.match.id<"dylib*">(%arg1 = %cmd : !hal.command_buffer, %arg2 = %c10_17 : index, %arg3 = %c1_16 : index, %arg4 = %c1_16 : index) {
      %c1_20 = constant 1 : index
      %2 = affine.apply #map2()[%arg2]
      %3 = affine.apply #map2()[%arg3]
      hal.command_buffer.dispatch.symbol<%arg1 : !hal.command_buffer> target(@predict_dispatch_5::@llvm_aot::@predict_dispatch_5) workgroups([%2, %3, %c1_20])
      hal.return
    }
    hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
    hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%executable_layout_18 : !hal.executable_layout)[%c0] bindings([
      %c0 = (%buffer_13 : !hal.buffer)[%c0, %sz_5], 
      %c1 = (%buffer_14 : !hal.buffer)[%c0, %sz_6]
    ])
    hal.device.switch<%device : !hal.device>
    #hal.device.match.id<"dylib*">(%arg1 = %cmd : !hal.command_buffer, %arg2 = %c1_16 : index, %arg3 = %c1_16 : index, %arg4 = %c1_16 : index) {
      %c1_20 = constant 1 : index
      hal.command_buffer.dispatch.symbol<%arg1 : !hal.command_buffer> target(@predict_dispatch_6::@llvm_aot::@predict_dispatch_6) workgroups([%c1_20, %c1_20, %c1_20])
      hal.return
    }
    hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
    %executable_layout_19 = hal.executable_layout.lookup device(%device : !hal.device) layouts([[#hal.descriptor_set_layout_binding<0, "StorageBuffer", R>, #hal.descriptor_set_layout_binding<1, "StorageBuffer", R>, #hal.descriptor_set_layout_binding<2, "StorageBuffer", R>, #hal.descriptor_set_layout_binding<3, "StorageBuffer", DW>]]) : !hal.executable_layout
    %c3 = constant 3 : index
    hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%executable_layout_19 : !hal.executable_layout)[%c0] bindings([
      %c0 = (%buffer_10 : !hal.buffer)[%c0, %sz_0], 
      %c1 = (%buffer_12 : !hal.buffer)[%c0, %sz_6], 
      %c2 = (%buffer_14 : !hal.buffer)[%c0, %sz_6], 
      %c3 = (%buffer : !hal.buffer)[%c0, %sz_0]
    ])
    hal.device.switch<%device : !hal.device>
    #hal.device.match.id<"dylib*">(%arg1 = %cmd : !hal.command_buffer, %arg2 = %c10_17 : index, %arg3 = %c1_16 : index, %arg4 = %c1_16 : index) {
      %c1_20 = constant 1 : index
      %2 = affine.apply #map2()[%arg2]
      %3 = affine.apply #map2()[%arg3]
      hal.command_buffer.dispatch.symbol<%arg1 : !hal.command_buffer> target(@predict_dispatch_7::@llvm_aot::@predict_dispatch_7) workgroups([%2, %3, %c1_20])
      hal.return
    }
    hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
    hal.command_buffer.end<%cmd : !hal.command_buffer>
    hal.ex.submit_and_wait %device, %cmd
    return %buffer : !hal.buffer
  }
}


// *** IR Dump After mlir::iree_compiler::Shape::`anonymous-namespace'::ExpandFunctionRankedShapeDimsPass ***
func private @_const_pool_storage_buffer_initializer() -> !hal.buffer {
  %c0 = constant 0 : index
  %c407040 = constant 407040 : index
  %device = hal.ex.shared_device : !hal.device
  %allocator = hal.device.allocator<%device : !hal.device> : !hal.allocator
  %storage = hal.constant_storage.lookup @_const_pool::@_storage : !iree.byte_buffer
  %mapped = hal.allocator.map<%allocator : !hal.allocator> source(%storage : !iree.byte_buffer)[%c0, %c407040] type("HostVisible|DeviceVisible|DeviceLocal") usage("Constant|Transfer|Mapping|Dispatch") : !hal.buffer
  return %mapped : !hal.buffer
}

// *** IR Dump After Canonicalizer ***
func private @_const_pool_storage_buffer_initializer() -> !hal.buffer {
  %c0 = constant 0 : index
  %c407040 = constant 407040 : index
  %device = hal.ex.shared_device : !hal.device
  %allocator = hal.device.allocator<%device : !hal.device> : !hal.allocator
  %storage = hal.constant_storage.lookup @_const_pool::@_storage : !iree.byte_buffer
  %mapped = hal.allocator.map<%allocator : !hal.allocator> source(%storage : !iree.byte_buffer)[%c0, %c407040] type("HostVisible|DeviceVisible|DeviceLocal") usage("Constant|Transfer|Mapping|Dispatch") : !hal.buffer
  return %mapped : !hal.buffer
}

// *** IR Dump After CSE ***
func private @_const_pool_storage_buffer_initializer() -> !hal.buffer {
  %c0 = constant 0 : index
  %c407040 = constant 407040 : index
  %device = hal.ex.shared_device : !hal.device
  %allocator = hal.device.allocator<%device : !hal.device> : !hal.allocator
  %storage = hal.constant_storage.lookup @_const_pool::@_storage : !iree.byte_buffer
  %mapped = hal.allocator.map<%allocator : !hal.allocator> source(%storage : !iree.byte_buffer)[%c0, %c407040] type("HostVisible|DeviceVisible|DeviceLocal") usage("Constant|Transfer|Mapping|Dispatch") : !hal.buffer
  return %mapped : !hal.buffer
}

// *** IR Dump After mlir::iree_compiler::IREE::HAL::PackAllocationsPass ***
func private @_const_pool_storage_buffer_initializer() -> !hal.buffer {
  %c0 = constant 0 : index
  %c407040 = constant 407040 : index
  %device = hal.ex.shared_device : !hal.device
  %allocator = hal.device.allocator<%device : !hal.device> : !hal.allocator
  %storage = hal.constant_storage.lookup @_const_pool::@_storage : !iree.byte_buffer
  %mapped = hal.allocator.map<%allocator : !hal.allocator> source(%storage : !iree.byte_buffer)[%c0, %c407040] type("HostVisible|DeviceVisible|DeviceLocal") usage("Constant|Transfer|Mapping|Dispatch") : !hal.buffer
  return %mapped : !hal.buffer
}

// *** IR Dump After mlir::iree_compiler::Shape::`anonymous-namespace'::ExpandFunctionRankedShapeDimsPass ***
func @predict(%arg0: !hal.buffer) -> !hal.buffer attributes {iree.module.export, iree.reflection = {abi = "sip", abiv = 1 : i32, f = "I15!B11!d1d28d28d1R9!B6!d1d10", fv = "1", sip = "I8!S5!k0_0R3!_0"}} {
  %device = hal.ex.shared_device : !hal.device
  %allocator = hal.device.allocator<%device : !hal.device> : !hal.allocator
  %c50331680_i32 = constant 50331680 : i32
  %c1 = constant 1 : index
  %c28 = constant 28 : index
  %sz = hal.allocator.compute_size<%allocator : !hal.allocator> shape([%c1, %c28, %c28, %c1]) type(%c50331680_i32) : index
  %c10 = constant 10 : index
  %sz_0 = hal.allocator.compute_size<%allocator : !hal.allocator> shape([%c1, %c10]) type(%c50331680_i32) : index
  %buffer = hal.allocator.allocate<%allocator : !hal.allocator> type("HostVisible|DeviceVisible|DeviceLocal") usage("Transfer|Mapping|Dispatch") : !hal.buffer{%sz_0}
  %0 = hal.variable.load @_const_pool_storage_buffer : !hal.buffer
  %c512 = constant 512 : index
  %c401408 = constant 401408 : index
  %buffer_1 = hal.buffer.subspan<%0 : !hal.buffer>[%c512, %c401408] : !hal.buffer
  %c0 = constant 0 : index
  %buffer_2 = hal.buffer.subspan<%0 : !hal.buffer>[%c0, %c512] : !hal.buffer
  %c401920 = constant 401920 : index
  %c5120 = constant 5120 : index
  %buffer_3 = hal.buffer.subspan<%0 : !hal.buffer>[%c401920, %c5120] : !hal.buffer
  %c128 = constant 128 : index
  %sz_4 = hal.allocator.compute_size<%allocator : !hal.allocator> shape([%c1, %c128]) type(%c50331680_i32) : index
  %sz_5 = hal.allocator.compute_size<%allocator : !hal.allocator> shape([%c10]) type(%c50331680_i32) : index
  %sz_6 = hal.allocator.compute_size<%allocator : !hal.allocator> shape([]) type(%c50331680_i32) : index
  %1:8 = hal.allocator.pack<%allocator : !hal.allocator> slices({
    [8, 9] = %sz_4,
    [9, 10] = %sz_4,
    [10, 15] = %sz_0,
    [11, 12] = %sz_5,
    [12, 15] = %sz_6,
    [13, 14] = %sz_5,
    [14, 15] = %sz_6
  }) : index
  %buffer_7 = hal.allocator.allocate<%allocator : !hal.allocator> type("DeviceVisible|DeviceLocal") usage("Transfer|Dispatch") : !hal.buffer{%1#0}
  %buffer_8 = hal.buffer.subspan<%buffer_7 : !hal.buffer>[%1#1, %sz_4] : !hal.buffer
  %buffer_9 = hal.buffer.subspan<%buffer_7 : !hal.buffer>[%1#2, %sz_4] : !hal.buffer
  %buffer_10 = hal.buffer.subspan<%buffer_7 : !hal.buffer>[%1#3, %sz_0] : !hal.buffer
  %buffer_11 = hal.buffer.subspan<%buffer_7 : !hal.buffer>[%1#4, %sz_5] : !hal.buffer
  %buffer_12 = hal.buffer.subspan<%buffer_7 : !hal.buffer>[%1#5, %sz_6] : !hal.buffer
  %buffer_13 = hal.buffer.subspan<%buffer_7 : !hal.buffer>[%1#6, %sz_5] : !hal.buffer
  %buffer_14 = hal.buffer.subspan<%buffer_7 : !hal.buffer>[%1#7, %sz_6] : !hal.buffer
  %cmd = hal.command_buffer.create device(%device : !hal.device) mode("OneShot|AllowInlineExecution") categories("Transfer|Dispatch") : !hal.command_buffer
  hal.command_buffer.begin<%cmd : !hal.command_buffer>
  %c128_15 = constant 128 : index
  %c1_16 = constant 1 : index
  %c10_17 = constant 10 : index
  %executable_layout = hal.executable_layout.lookup device(%device : !hal.device) layouts([[#hal.descriptor_set_layout_binding<0, "StorageBuffer", R>, #hal.descriptor_set_layout_binding<1, "StorageBuffer", R>, #hal.descriptor_set_layout_binding<2, "StorageBuffer", DW>]]) : !hal.executable_layout
  %c2 = constant 2 : index
  hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%executable_layout : !hal.executable_layout)[%c0] bindings([
    %c0 = (%0 : !hal.buffer)[%c512, %c401408], 
    %c1 = (%arg0 : !hal.buffer)[%c0, %sz], 
    %c2 = (%buffer_8 : !hal.buffer)[%c0, %sz_4]
  ])
  hal.device.switch<%device : !hal.device>
    #hal.device.match.id<"dylib*">(%arg1 = %cmd : !hal.command_buffer, %arg2 = %c128_15 : index, %arg3 = %c1_16 : index, %arg4 = %c1_16 : index) {
    %c1_20 = constant 1 : index
    %2 = affine.apply affine_map<()[s0] -> (s0 ceildiv 64)>()[%arg2]
    %3 = affine.apply affine_map<()[s0] -> (s0 ceildiv 4)>()[%arg3]
    hal.command_buffer.dispatch.symbol<%arg1 : !hal.command_buffer> target(@predict_dispatch_0::@llvm_aot::@predict_dispatch_0) workgroups([%2, %3, %c1_20])
    hal.return
  }
  hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
  hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%executable_layout : !hal.executable_layout)[%c0] bindings([
    %c0 = (%0 : !hal.buffer)[%c0, %c512], 
    %c1 = (%buffer_8 : !hal.buffer)[%c0, %sz_4], 
    %c2 = (%buffer_9 : !hal.buffer)[%c0, %sz_4]
  ])
  hal.device.switch<%device : !hal.device>
    #hal.device.match.id<"dylib*">(%arg1 = %cmd : !hal.command_buffer, %arg2 = %c128_15 : index, %arg3 = %c1_16 : index, %arg4 = %c1_16 : index) {
    %c1_20 = constant 1 : index
    %2 = affine.apply affine_map<()[s0] -> (s0 ceildiv 128)>()[%arg2]
    %3 = affine.apply affine_map<()[s0] -> (s0 ceildiv 128)>()[%arg3]
    hal.command_buffer.dispatch.symbol<%arg1 : !hal.command_buffer> target(@predict_dispatch_1::@llvm_aot::@predict_dispatch_1) workgroups([%2, %3, %c1_20])
    hal.return
  }
  hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
  hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%executable_layout : !hal.executable_layout)[%c0] bindings([
    %c0 = (%0 : !hal.buffer)[%c401920, %c5120], 
    %c1 = (%buffer_9 : !hal.buffer)[%c0, %sz_4], 
    %c2 = (%buffer_10 : !hal.buffer)[%c0, %sz_0]
  ])
  hal.device.switch<%device : !hal.device>
    #hal.device.match.id<"dylib*">(%arg1 = %cmd : !hal.command_buffer, %arg2 = %c10_17 : index, %arg3 = %c1_16 : index, %arg4 = %c1_16 : index) {
    %c1_20 = constant 1 : index
    %2 = affine.apply affine_map<()[s0] -> (s0 ceildiv 64)>()[%arg2]
    %3 = affine.apply affine_map<()[s0] -> (s0 ceildiv 4)>()[%arg3]
    hal.command_buffer.dispatch.symbol<%arg1 : !hal.command_buffer> target(@predict_dispatch_2::@llvm_aot::@predict_dispatch_2) workgroups([%2, %3, %c1_20])
    hal.return
  }
  hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
  %executable_layout_18 = hal.executable_layout.lookup device(%device : !hal.device) layouts([[#hal.descriptor_set_layout_binding<0, "StorageBuffer", R>, #hal.descriptor_set_layout_binding<1, "StorageBuffer", DW>]]) : !hal.executable_layout
  hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%executable_layout_18 : !hal.executable_layout)[%c0] bindings([
    %c0 = (%buffer_10 : !hal.buffer)[%c0, %sz_0], 
    %c1 = (%buffer_11 : !hal.buffer)[%c0, %sz_5]
  ])
  hal.device.switch<%device : !hal.device>
    #hal.device.match.id<"dylib*">(%arg1 = %cmd : !hal.command_buffer, %arg2 = %c10_17 : index, %arg3 = %c1_16 : index, %arg4 = %c1_16 : index) {
    %c1_20 = constant 1 : index
    %2 = affine.apply affine_map<()[s0] -> (s0 ceildiv 128)>()[%arg2]
    %3 = affine.apply affine_map<()[s0] -> (s0 ceildiv 128)>()[%arg3]
    hal.command_buffer.dispatch.symbol<%arg1 : !hal.command_buffer> target(@predict_dispatch_3::@llvm_aot::@predict_dispatch_3) workgroups([%2, %3, %c1_20])
    hal.return
  }
  hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
  hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%executable_layout_18 : !hal.executable_layout)[%c0] bindings([
    %c0 = (%buffer_11 : !hal.buffer)[%c0, %sz_5], 
    %c1 = (%buffer_12 : !hal.buffer)[%c0, %sz_6]
  ])
  hal.device.switch<%device : !hal.device>
    #hal.device.match.id<"dylib*">(%arg1 = %cmd : !hal.command_buffer, %arg2 = %c1_16 : index, %arg3 = %c1_16 : index, %arg4 = %c1_16 : index) {
    %c1_20 = constant 1 : index
    hal.command_buffer.dispatch.symbol<%arg1 : !hal.command_buffer> target(@predict_dispatch_4::@llvm_aot::@predict_dispatch_4) workgroups([%c1_20, %c1_20, %c1_20])
    hal.return
  }
  hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
  hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%executable_layout : !hal.executable_layout)[%c0] bindings([
    %c0 = (%buffer_10 : !hal.buffer)[%c0, %sz_0], 
    %c1 = (%buffer_12 : !hal.buffer)[%c0, %sz_6], 
    %c2 = (%buffer_13 : !hal.buffer)[%c0, %sz_5]
  ])
  hal.device.switch<%device : !hal.device>
    #hal.device.match.id<"dylib*">(%arg1 = %cmd : !hal.command_buffer, %arg2 = %c10_17 : index, %arg3 = %c1_16 : index, %arg4 = %c1_16 : index) {
    %c1_20 = constant 1 : index
    %2 = affine.apply affine_map<()[s0] -> (s0 ceildiv 128)>()[%arg2]
    %3 = affine.apply affine_map<()[s0] -> (s0 ceildiv 128)>()[%arg3]
    hal.command_buffer.dispatch.symbol<%arg1 : !hal.command_buffer> target(@predict_dispatch_5::@llvm_aot::@predict_dispatch_5) workgroups([%2, %3, %c1_20])
    hal.return
  }
  hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
  hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%executable_layout_18 : !hal.executable_layout)[%c0] bindings([
    %c0 = (%buffer_13 : !hal.buffer)[%c0, %sz_5], 
    %c1 = (%buffer_14 : !hal.buffer)[%c0, %sz_6]
  ])
  hal.device.switch<%device : !hal.device>
    #hal.device.match.id<"dylib*">(%arg1 = %cmd : !hal.command_buffer, %arg2 = %c1_16 : index, %arg3 = %c1_16 : index, %arg4 = %c1_16 : index) {
    %c1_20 = constant 1 : index
    hal.command_buffer.dispatch.symbol<%arg1 : !hal.command_buffer> target(@predict_dispatch_6::@llvm_aot::@predict_dispatch_6) workgroups([%c1_20, %c1_20, %c1_20])
    hal.return
  }
  hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
  %executable_layout_19 = hal.executable_layout.lookup device(%device : !hal.device) layouts([[#hal.descriptor_set_layout_binding<0, "StorageBuffer", R>, #hal.descriptor_set_layout_binding<1, "StorageBuffer", R>, #hal.descriptor_set_layout_binding<2, "StorageBuffer", R>, #hal.descriptor_set_layout_binding<3, "StorageBuffer", DW>]]) : !hal.executable_layout
  %c3 = constant 3 : index
  hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%executable_layout_19 : !hal.executable_layout)[%c0] bindings([
    %c0 = (%buffer_10 : !hal.buffer)[%c0, %sz_0], 
    %c1 = (%buffer_12 : !hal.buffer)[%c0, %sz_6], 
    %c2 = (%buffer_14 : !hal.buffer)[%c0, %sz_6], 
    %c3 = (%buffer : !hal.buffer)[%c0, %sz_0]
  ])
  hal.device.switch<%device : !hal.device>
    #hal.device.match.id<"dylib*">(%arg1 = %cmd : !hal.command_buffer, %arg2 = %c10_17 : index, %arg3 = %c1_16 : index, %arg4 = %c1_16 : index) {
    %c1_20 = constant 1 : index
    %2 = affine.apply affine_map<()[s0] -> (s0 ceildiv 128)>()[%arg2]
    %3 = affine.apply affine_map<()[s0] -> (s0 ceildiv 128)>()[%arg3]
    hal.command_buffer.dispatch.symbol<%arg1 : !hal.command_buffer> target(@predict_dispatch_7::@llvm_aot::@predict_dispatch_7) workgroups([%2, %3, %c1_20])
    hal.return
  }
  hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
  hal.command_buffer.end<%cmd : !hal.command_buffer>
  hal.ex.submit_and_wait %device, %cmd
  return %buffer : !hal.buffer
}

// *** IR Dump After Canonicalizer ***
func @predict(%arg0: !hal.buffer) -> !hal.buffer attributes {iree.module.export, iree.reflection = {abi = "sip", abiv = 1 : i32, f = "I15!B11!d1d28d28d1R9!B6!d1d10", fv = "1", sip = "I8!S5!k0_0R3!_0"}} {
  %c3136 = constant 3136 : index
  %c401408 = constant 401408 : index
  %c0 = constant 0 : index
  %c401920 = constant 401920 : index
  %c5120 = constant 5120 : index
  %c512 = constant 512 : index
  %c40 = constant 40 : index
  %c4 = constant 4 : index
  %c128 = constant 128 : index
  %c1 = constant 1 : index
  %c10 = constant 10 : index
  %c2 = constant 2 : index
  %c3 = constant 3 : index
  %device = hal.ex.shared_device : !hal.device
  %allocator = hal.device.allocator<%device : !hal.device> : !hal.allocator
  %buffer = hal.allocator.allocate<%allocator : !hal.allocator> type("HostVisible|DeviceVisible|DeviceLocal") usage("Transfer|Mapping|Dispatch") : !hal.buffer{%c40}
  %0 = hal.variable.load @_const_pool_storage_buffer : !hal.buffer
  %1:8 = hal.allocator.pack<%allocator : !hal.allocator> slices({
    [8, 9] = %c512,
    [9, 10] = %c512,
    [10, 15] = %c40,
    [11, 12] = %c40,
    [12, 15] = %c4,
    [13, 14] = %c40,
    [14, 15] = %c4
  }) : index
  %buffer_0 = hal.allocator.allocate<%allocator : !hal.allocator> type("DeviceVisible|DeviceLocal") usage("Transfer|Dispatch") : !hal.buffer{%1#0}
  %cmd = hal.command_buffer.create device(%device : !hal.device) mode("OneShot|AllowInlineExecution") categories("Transfer|Dispatch") : !hal.command_buffer
  hal.command_buffer.begin<%cmd : !hal.command_buffer>
  %executable_layout = hal.executable_layout.lookup device(%device : !hal.device) layouts([[#hal.descriptor_set_layout_binding<0, "StorageBuffer", R>, #hal.descriptor_set_layout_binding<1, "StorageBuffer", R>, #hal.descriptor_set_layout_binding<2, "StorageBuffer", DW>]]) : !hal.executable_layout
  hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%executable_layout : !hal.executable_layout)[%c0] bindings([
    %c0 = (%0 : !hal.buffer)[%c512, %c401408], 
    %c1 = (%arg0 : !hal.buffer)[%c0, %c3136], 
    %c2 = (%buffer_0 : !hal.buffer)[%1#1, %c512]
  ])
  hal.device.switch<%device : !hal.device>
    #hal.device.match.id<"dylib*">(%arg1 = %cmd : !hal.command_buffer, %arg2 = %c128 : index, %arg3 = %c1 : index, %arg4 = %c1 : index) {
    %c1_3 = constant 1 : index
    %2 = affine.apply affine_map<()[s0] -> (s0 ceildiv 64)>()[%arg2]
    %3 = affine.apply affine_map<()[s0] -> (s0 ceildiv 4)>()[%arg3]
    hal.command_buffer.dispatch.symbol<%arg1 : !hal.command_buffer> target(@predict_dispatch_0::@llvm_aot::@predict_dispatch_0) workgroups([%2, %3, %c1_3])
    hal.return
  }
  hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
  hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%executable_layout : !hal.executable_layout)[%c0] bindings([
    %c0 = (%0 : !hal.buffer)[%c0, %c512], 
    %c1 = (%buffer_0 : !hal.buffer)[%1#1, %c512], 
    %c2 = (%buffer_0 : !hal.buffer)[%1#2, %c512]
  ])
  hal.device.switch<%device : !hal.device>
    #hal.device.match.id<"dylib*">(%arg1 = %cmd : !hal.command_buffer, %arg2 = %c128 : index, %arg3 = %c1 : index, %arg4 = %c1 : index) {
    %c1_3 = constant 1 : index
    %2 = affine.apply affine_map<()[s0] -> (s0 ceildiv 128)>()[%arg2]
    %3 = affine.apply affine_map<()[s0] -> (s0 ceildiv 128)>()[%arg3]
    hal.command_buffer.dispatch.symbol<%arg1 : !hal.command_buffer> target(@predict_dispatch_1::@llvm_aot::@predict_dispatch_1) workgroups([%2, %3, %c1_3])
    hal.return
  }
  hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
  hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%executable_layout : !hal.executable_layout)[%c0] bindings([
    %c0 = (%0 : !hal.buffer)[%c401920, %c5120], 
    %c1 = (%buffer_0 : !hal.buffer)[%1#2, %c512], 
    %c2 = (%buffer_0 : !hal.buffer)[%1#3, %c40]
  ])
  hal.device.switch<%device : !hal.device>
    #hal.device.match.id<"dylib*">(%arg1 = %cmd : !hal.command_buffer, %arg2 = %c10 : index, %arg3 = %c1 : index, %arg4 = %c1 : index) {
    %c1_3 = constant 1 : index
    %2 = affine.apply affine_map<()[s0] -> (s0 ceildiv 64)>()[%arg2]
    %3 = affine.apply affine_map<()[s0] -> (s0 ceildiv 4)>()[%arg3]
    hal.command_buffer.dispatch.symbol<%arg1 : !hal.command_buffer> target(@predict_dispatch_2::@llvm_aot::@predict_dispatch_2) workgroups([%2, %3, %c1_3])
    hal.return
  }
  hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
  %executable_layout_1 = hal.executable_layout.lookup device(%device : !hal.device) layouts([[#hal.descriptor_set_layout_binding<0, "StorageBuffer", R>, #hal.descriptor_set_layout_binding<1, "StorageBuffer", DW>]]) : !hal.executable_layout
  hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%executable_layout_1 : !hal.executable_layout)[%c0] bindings([
    %c0 = (%buffer_0 : !hal.buffer)[%1#3, %c40], 
    %c1 = (%buffer_0 : !hal.buffer)[%1#4, %c40]
  ])
  hal.device.switch<%device : !hal.device>
    #hal.device.match.id<"dylib*">(%arg1 = %cmd : !hal.command_buffer, %arg2 = %c10 : index, %arg3 = %c1 : index, %arg4 = %c1 : index) {
    %c1_3 = constant 1 : index
    %2 = affine.apply affine_map<()[s0] -> (s0 ceildiv 128)>()[%arg2]
    %3 = affine.apply affine_map<()[s0] -> (s0 ceildiv 128)>()[%arg3]
    hal.command_buffer.dispatch.symbol<%arg1 : !hal.command_buffer> target(@predict_dispatch_3::@llvm_aot::@predict_dispatch_3) workgroups([%2, %3, %c1_3])
    hal.return
  }
  hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
  hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%executable_layout_1 : !hal.executable_layout)[%c0] bindings([
    %c0 = (%buffer_0 : !hal.buffer)[%1#4, %c40], 
    %c1 = (%buffer_0 : !hal.buffer)[%1#5, %c4]
  ])
  hal.device.switch<%device : !hal.device>
    #hal.device.match.id<"dylib*">(%arg1 = %cmd : !hal.command_buffer, %arg2 = %c1 : index, %arg3 = %c1 : index, %arg4 = %c1 : index) {
    %c1_3 = constant 1 : index
    hal.command_buffer.dispatch.symbol<%arg1 : !hal.command_buffer> target(@predict_dispatch_4::@llvm_aot::@predict_dispatch_4) workgroups([%c1_3, %c1_3, %c1_3])
    hal.return
  }
  hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
  hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%executable_layout : !hal.executable_layout)[%c0] bindings([
    %c0 = (%buffer_0 : !hal.buffer)[%1#3, %c40], 
    %c1 = (%buffer_0 : !hal.buffer)[%1#5, %c4], 
    %c2 = (%buffer_0 : !hal.buffer)[%1#6, %c40]
  ])
  hal.device.switch<%device : !hal.device>
    #hal.device.match.id<"dylib*">(%arg1 = %cmd : !hal.command_buffer, %arg2 = %c10 : index, %arg3 = %c1 : index, %arg4 = %c1 : index) {
    %c1_3 = constant 1 : index
    %2 = affine.apply affine_map<()[s0] -> (s0 ceildiv 128)>()[%arg2]
    %3 = affine.apply affine_map<()[s0] -> (s0 ceildiv 128)>()[%arg3]
    hal.command_buffer.dispatch.symbol<%arg1 : !hal.command_buffer> target(@predict_dispatch_5::@llvm_aot::@predict_dispatch_5) workgroups([%2, %3, %c1_3])
    hal.return
  }
  hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
  hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%executable_layout_1 : !hal.executable_layout)[%c0] bindings([
    %c0 = (%buffer_0 : !hal.buffer)[%1#6, %c40], 
    %c1 = (%buffer_0 : !hal.buffer)[%1#7, %c4]
  ])
  hal.device.switch<%device : !hal.device>
    #hal.device.match.id<"dylib*">(%arg1 = %cmd : !hal.command_buffer, %arg2 = %c1 : index, %arg3 = %c1 : index, %arg4 = %c1 : index) {
    %c1_3 = constant 1 : index
    hal.command_buffer.dispatch.symbol<%arg1 : !hal.command_buffer> target(@predict_dispatch_6::@llvm_aot::@predict_dispatch_6) workgroups([%c1_3, %c1_3, %c1_3])
    hal.return
  }
  hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
  %executable_layout_2 = hal.executable_layout.lookup device(%device : !hal.device) layouts([[#hal.descriptor_set_layout_binding<0, "StorageBuffer", R>, #hal.descriptor_set_layout_binding<1, "StorageBuffer", R>, #hal.descriptor_set_layout_binding<2, "StorageBuffer", R>, #hal.descriptor_set_layout_binding<3, "StorageBuffer", DW>]]) : !hal.executable_layout
  hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%executable_layout_2 : !hal.executable_layout)[%c0] bindings([
    %c0 = (%buffer_0 : !hal.buffer)[%1#3, %c40], 
    %c1 = (%buffer_0 : !hal.buffer)[%1#5, %c4], 
    %c2 = (%buffer_0 : !hal.buffer)[%1#7, %c4], 
    %c3 = (%buffer : !hal.buffer)[%c0, %c40]
  ])
  hal.device.switch<%device : !hal.device>
    #hal.device.match.id<"dylib*">(%arg1 = %cmd : !hal.command_buffer, %arg2 = %c10 : index, %arg3 = %c1 : index, %arg4 = %c1 : index) {
    %c1_3 = constant 1 : index
    %2 = affine.apply affine_map<()[s0] -> (s0 ceildiv 128)>()[%arg2]
    %3 = affine.apply affine_map<()[s0] -> (s0 ceildiv 128)>()[%arg3]
    hal.command_buffer.dispatch.symbol<%arg1 : !hal.command_buffer> target(@predict_dispatch_7::@llvm_aot::@predict_dispatch_7) workgroups([%2, %3, %c1_3])
    hal.return
  }
  hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
  hal.command_buffer.end<%cmd : !hal.command_buffer>
  hal.ex.submit_and_wait %device, %cmd
  return %buffer : !hal.buffer
}

// *** IR Dump After CSE ***
func @predict(%arg0: !hal.buffer) -> !hal.buffer attributes {iree.module.export, iree.reflection = {abi = "sip", abiv = 1 : i32, f = "I15!B11!d1d28d28d1R9!B6!d1d10", fv = "1", sip = "I8!S5!k0_0R3!_0"}} {
  %c3136 = constant 3136 : index
  %c401408 = constant 401408 : index
  %c0 = constant 0 : index
  %c401920 = constant 401920 : index
  %c5120 = constant 5120 : index
  %c512 = constant 512 : index
  %c40 = constant 40 : index
  %c4 = constant 4 : index
  %c128 = constant 128 : index
  %c1 = constant 1 : index
  %c10 = constant 10 : index
  %c2 = constant 2 : index
  %c3 = constant 3 : index
  %device = hal.ex.shared_device : !hal.device
  %allocator = hal.device.allocator<%device : !hal.device> : !hal.allocator
  %buffer = hal.allocator.allocate<%allocator : !hal.allocator> type("HostVisible|DeviceVisible|DeviceLocal") usage("Transfer|Mapping|Dispatch") : !hal.buffer{%c40}
  %0 = hal.variable.load @_const_pool_storage_buffer : !hal.buffer
  %1:8 = hal.allocator.pack<%allocator : !hal.allocator> slices({
    [8, 9] = %c512,
    [9, 10] = %c512,
    [10, 15] = %c40,
    [11, 12] = %c40,
    [12, 15] = %c4,
    [13, 14] = %c40,
    [14, 15] = %c4
  }) : index
  %buffer_0 = hal.allocator.allocate<%allocator : !hal.allocator> type("DeviceVisible|DeviceLocal") usage("Transfer|Dispatch") : !hal.buffer{%1#0}
  %cmd = hal.command_buffer.create device(%device : !hal.device) mode("OneShot|AllowInlineExecution") categories("Transfer|Dispatch") : !hal.command_buffer
  hal.command_buffer.begin<%cmd : !hal.command_buffer>
  %executable_layout = hal.executable_layout.lookup device(%device : !hal.device) layouts([[#hal.descriptor_set_layout_binding<0, "StorageBuffer", R>, #hal.descriptor_set_layout_binding<1, "StorageBuffer", R>, #hal.descriptor_set_layout_binding<2, "StorageBuffer", DW>]]) : !hal.executable_layout
  hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%executable_layout : !hal.executable_layout)[%c0] bindings([
    %c0 = (%0 : !hal.buffer)[%c512, %c401408], 
    %c1 = (%arg0 : !hal.buffer)[%c0, %c3136], 
    %c2 = (%buffer_0 : !hal.buffer)[%1#1, %c512]
  ])
  hal.device.switch<%device : !hal.device>
    #hal.device.match.id<"dylib*">(%arg1 = %cmd : !hal.command_buffer, %arg2 = %c128 : index, %arg3 = %c1 : index, %arg4 = %c1 : index) {
    %c1_3 = constant 1 : index
    %2 = affine.apply affine_map<()[s0] -> (s0 ceildiv 64)>()[%arg2]
    %3 = affine.apply affine_map<()[s0] -> (s0 ceildiv 4)>()[%arg3]
    hal.command_buffer.dispatch.symbol<%arg1 : !hal.command_buffer> target(@predict_dispatch_0::@llvm_aot::@predict_dispatch_0) workgroups([%2, %3, %c1_3])
    hal.return
  }
  hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
  hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%executable_layout : !hal.executable_layout)[%c0] bindings([
    %c0 = (%0 : !hal.buffer)[%c0, %c512], 
    %c1 = (%buffer_0 : !hal.buffer)[%1#1, %c512], 
    %c2 = (%buffer_0 : !hal.buffer)[%1#2, %c512]
  ])
  hal.device.switch<%device : !hal.device>
    #hal.device.match.id<"dylib*">(%arg1 = %cmd : !hal.command_buffer, %arg2 = %c128 : index, %arg3 = %c1 : index, %arg4 = %c1 : index) {
    %c1_3 = constant 1 : index
    %2 = affine.apply affine_map<()[s0] -> (s0 ceildiv 128)>()[%arg2]
    %3 = affine.apply affine_map<()[s0] -> (s0 ceildiv 128)>()[%arg3]
    hal.command_buffer.dispatch.symbol<%arg1 : !hal.command_buffer> target(@predict_dispatch_1::@llvm_aot::@predict_dispatch_1) workgroups([%2, %3, %c1_3])
    hal.return
  }
  hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
  hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%executable_layout : !hal.executable_layout)[%c0] bindings([
    %c0 = (%0 : !hal.buffer)[%c401920, %c5120], 
    %c1 = (%buffer_0 : !hal.buffer)[%1#2, %c512], 
    %c2 = (%buffer_0 : !hal.buffer)[%1#3, %c40]
  ])
  hal.device.switch<%device : !hal.device>
    #hal.device.match.id<"dylib*">(%arg1 = %cmd : !hal.command_buffer, %arg2 = %c10 : index, %arg3 = %c1 : index, %arg4 = %c1 : index) {
    %c1_3 = constant 1 : index
    %2 = affine.apply affine_map<()[s0] -> (s0 ceildiv 64)>()[%arg2]
    %3 = affine.apply affine_map<()[s0] -> (s0 ceildiv 4)>()[%arg3]
    hal.command_buffer.dispatch.symbol<%arg1 : !hal.command_buffer> target(@predict_dispatch_2::@llvm_aot::@predict_dispatch_2) workgroups([%2, %3, %c1_3])
    hal.return
  }
  hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
  %executable_layout_1 = hal.executable_layout.lookup device(%device : !hal.device) layouts([[#hal.descriptor_set_layout_binding<0, "StorageBuffer", R>, #hal.descriptor_set_layout_binding<1, "StorageBuffer", DW>]]) : !hal.executable_layout
  hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%executable_layout_1 : !hal.executable_layout)[%c0] bindings([
    %c0 = (%buffer_0 : !hal.buffer)[%1#3, %c40], 
    %c1 = (%buffer_0 : !hal.buffer)[%1#4, %c40]
  ])
  hal.device.switch<%device : !hal.device>
    #hal.device.match.id<"dylib*">(%arg1 = %cmd : !hal.command_buffer, %arg2 = %c10 : index, %arg3 = %c1 : index, %arg4 = %c1 : index) {
    %c1_3 = constant 1 : index
    %2 = affine.apply affine_map<()[s0] -> (s0 ceildiv 128)>()[%arg2]
    %3 = affine.apply affine_map<()[s0] -> (s0 ceildiv 128)>()[%arg3]
    hal.command_buffer.dispatch.symbol<%arg1 : !hal.command_buffer> target(@predict_dispatch_3::@llvm_aot::@predict_dispatch_3) workgroups([%2, %3, %c1_3])
    hal.return
  }
  hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
  hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%executable_layout_1 : !hal.executable_layout)[%c0] bindings([
    %c0 = (%buffer_0 : !hal.buffer)[%1#4, %c40], 
    %c1 = (%buffer_0 : !hal.buffer)[%1#5, %c4]
  ])
  hal.device.switch<%device : !hal.device>
    #hal.device.match.id<"dylib*">(%arg1 = %cmd : !hal.command_buffer, %arg2 = %c1 : index, %arg3 = %c1 : index, %arg4 = %c1 : index) {
    %c1_3 = constant 1 : index
    hal.command_buffer.dispatch.symbol<%arg1 : !hal.command_buffer> target(@predict_dispatch_4::@llvm_aot::@predict_dispatch_4) workgroups([%c1_3, %c1_3, %c1_3])
    hal.return
  }
  hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
  hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%executable_layout : !hal.executable_layout)[%c0] bindings([
    %c0 = (%buffer_0 : !hal.buffer)[%1#3, %c40], 
    %c1 = (%buffer_0 : !hal.buffer)[%1#5, %c4], 
    %c2 = (%buffer_0 : !hal.buffer)[%1#6, %c40]
  ])
  hal.device.switch<%device : !hal.device>
    #hal.device.match.id<"dylib*">(%arg1 = %cmd : !hal.command_buffer, %arg2 = %c10 : index, %arg3 = %c1 : index, %arg4 = %c1 : index) {
    %c1_3 = constant 1 : index
    %2 = affine.apply affine_map<()[s0] -> (s0 ceildiv 128)>()[%arg2]
    %3 = affine.apply affine_map<()[s0] -> (s0 ceildiv 128)>()[%arg3]
    hal.command_buffer.dispatch.symbol<%arg1 : !hal.command_buffer> target(@predict_dispatch_5::@llvm_aot::@predict_dispatch_5) workgroups([%2, %3, %c1_3])
    hal.return
  }
  hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
  hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%executable_layout_1 : !hal.executable_layout)[%c0] bindings([
    %c0 = (%buffer_0 : !hal.buffer)[%1#6, %c40], 
    %c1 = (%buffer_0 : !hal.buffer)[%1#7, %c4]
  ])
  hal.device.switch<%device : !hal.device>
    #hal.device.match.id<"dylib*">(%arg1 = %cmd : !hal.command_buffer, %arg2 = %c1 : index, %arg3 = %c1 : index, %arg4 = %c1 : index) {
    %c1_3 = constant 1 : index
    hal.command_buffer.dispatch.symbol<%arg1 : !hal.command_buffer> target(@predict_dispatch_6::@llvm_aot::@predict_dispatch_6) workgroups([%c1_3, %c1_3, %c1_3])
    hal.return
  }
  hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
  %executable_layout_2 = hal.executable_layout.lookup device(%device : !hal.device) layouts([[#hal.descriptor_set_layout_binding<0, "StorageBuffer", R>, #hal.descriptor_set_layout_binding<1, "StorageBuffer", R>, #hal.descriptor_set_layout_binding<2, "StorageBuffer", R>, #hal.descriptor_set_layout_binding<3, "StorageBuffer", DW>]]) : !hal.executable_layout
  hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%executable_layout_2 : !hal.executable_layout)[%c0] bindings([
    %c0 = (%buffer_0 : !hal.buffer)[%1#3, %c40], 
    %c1 = (%buffer_0 : !hal.buffer)[%1#5, %c4], 
    %c2 = (%buffer_0 : !hal.buffer)[%1#7, %c4], 
    %c3 = (%buffer : !hal.buffer)[%c0, %c40]
  ])
  hal.device.switch<%device : !hal.device>
    #hal.device.match.id<"dylib*">(%arg1 = %cmd : !hal.command_buffer, %arg2 = %c10 : index, %arg3 = %c1 : index, %arg4 = %c1 : index) {
    %c1_3 = constant 1 : index
    %2 = affine.apply affine_map<()[s0] -> (s0 ceildiv 128)>()[%arg2]
    %3 = affine.apply affine_map<()[s0] -> (s0 ceildiv 128)>()[%arg3]
    hal.command_buffer.dispatch.symbol<%arg1 : !hal.command_buffer> target(@predict_dispatch_7::@llvm_aot::@predict_dispatch_7) workgroups([%2, %3, %c1_3])
    hal.return
  }
  hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
  hal.command_buffer.end<%cmd : !hal.command_buffer>
  hal.ex.submit_and_wait %device, %cmd
  return %buffer : !hal.buffer
}

// *** IR Dump After mlir::iree_compiler::IREE::HAL::PackAllocationsPass ***
func @predict(%arg0: !hal.buffer) -> !hal.buffer attributes {iree.module.export, iree.reflection = {abi = "sip", abiv = 1 : i32, f = "I15!B11!d1d28d28d1R9!B6!d1d10", fv = "1", sip = "I8!S5!k0_0R3!_0"}} {
  %c3136 = constant 3136 : index
  %c401408 = constant 401408 : index
  %c0 = constant 0 : index
  %c401920 = constant 401920 : index
  %c5120 = constant 5120 : index
  %c512 = constant 512 : index
  %c40 = constant 40 : index
  %c4 = constant 4 : index
  %c128 = constant 128 : index
  %c1 = constant 1 : index
  %c10 = constant 10 : index
  %c2 = constant 2 : index
  %c3 = constant 3 : index
  %device = hal.ex.shared_device : !hal.device
  %allocator = hal.device.allocator<%device : !hal.device> : !hal.allocator
  %buffer = hal.allocator.allocate<%allocator : !hal.allocator> type("HostVisible|DeviceVisible|DeviceLocal") usage("Transfer|Mapping|Dispatch") : !hal.buffer{%c40}
  %0 = hal.variable.load @_const_pool_storage_buffer : !hal.buffer
  %c0_0 = constant 0 : index
  %c0_1 = constant 0 : index
  %c512_2 = constant 512 : index
  %c512_3 = constant 512 : index
  %c0_4 = constant 0 : index
  %c48 = constant 48 : index
  %c48_5 = constant 48 : index
  %c96 = constant 96 : index
  %c96_6 = constant 96 : index
  %c48_7 = constant 48 : index
  %c48_8 = constant 48 : index
  %c112 = constant 112 : index
  %c112_9 = constant 112 : index
  %c1024 = constant 1024 : index
  %c1024_10 = constant 1024 : index
  %buffer_11 = hal.allocator.allocate<%allocator : !hal.allocator> type("DeviceVisible|DeviceLocal") usage("Transfer|Dispatch") : !hal.buffer{%c1024_10}
  %cmd = hal.command_buffer.create device(%device : !hal.device) mode("OneShot|AllowInlineExecution") categories("Transfer|Dispatch") : !hal.command_buffer
  hal.command_buffer.begin<%cmd : !hal.command_buffer>
  %executable_layout = hal.executable_layout.lookup device(%device : !hal.device) layouts([[#hal.descriptor_set_layout_binding<0, "StorageBuffer", R>, #hal.descriptor_set_layout_binding<1, "StorageBuffer", R>, #hal.descriptor_set_layout_binding<2, "StorageBuffer", DW>]]) : !hal.executable_layout
  hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%executable_layout : !hal.executable_layout)[%c0] bindings([
    %c0 = (%0 : !hal.buffer)[%c512, %c401408], 
    %c1 = (%arg0 : !hal.buffer)[%c0, %c3136], 
    %c2 = (%buffer_11 : !hal.buffer)[%c0_0, %c512]
  ])
  hal.device.switch<%device : !hal.device>
    #hal.device.match.id<"dylib*">(%arg1 = %cmd : !hal.command_buffer, %arg2 = %c128 : index, %arg3 = %c1 : index, %arg4 = %c1 : index) {
    %c1_14 = constant 1 : index
    %1 = affine.apply affine_map<()[s0] -> (s0 ceildiv 64)>()[%arg2]
    %2 = affine.apply affine_map<()[s0] -> (s0 ceildiv 4)>()[%arg3]
    hal.command_buffer.dispatch.symbol<%arg1 : !hal.command_buffer> target(@predict_dispatch_0::@llvm_aot::@predict_dispatch_0) workgroups([%1, %2, %c1_14])
    hal.return
  }
  hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
  hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%executable_layout : !hal.executable_layout)[%c0] bindings([
    %c0 = (%0 : !hal.buffer)[%c0, %c512], 
    %c1 = (%buffer_11 : !hal.buffer)[%c0_0, %c512], 
    %c2 = (%buffer_11 : !hal.buffer)[%c512_3, %c512]
  ])
  hal.device.switch<%device : !hal.device>
    #hal.device.match.id<"dylib*">(%arg1 = %cmd : !hal.command_buffer, %arg2 = %c128 : index, %arg3 = %c1 : index, %arg4 = %c1 : index) {
    %c1_14 = constant 1 : index
    %1 = affine.apply affine_map<()[s0] -> (s0 ceildiv 128)>()[%arg2]
    %2 = affine.apply affine_map<()[s0] -> (s0 ceildiv 128)>()[%arg3]
    hal.command_buffer.dispatch.symbol<%arg1 : !hal.command_buffer> target(@predict_dispatch_1::@llvm_aot::@predict_dispatch_1) workgroups([%1, %2, %c1_14])
    hal.return
  }
  hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
  hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%executable_layout : !hal.executable_layout)[%c0] bindings([
    %c0 = (%0 : !hal.buffer)[%c401920, %c5120], 
    %c1 = (%buffer_11 : !hal.buffer)[%c512_3, %c512], 
    %c2 = (%buffer_11 : !hal.buffer)[%c0_0, %c40]
  ])
  hal.device.switch<%device : !hal.device>
    #hal.device.match.id<"dylib*">(%arg1 = %cmd : !hal.command_buffer, %arg2 = %c10 : index, %arg3 = %c1 : index, %arg4 = %c1 : index) {
    %c1_14 = constant 1 : index
    %1 = affine.apply affine_map<()[s0] -> (s0 ceildiv 64)>()[%arg2]
    %2 = affine.apply affine_map<()[s0] -> (s0 ceildiv 4)>()[%arg3]
    hal.command_buffer.dispatch.symbol<%arg1 : !hal.command_buffer> target(@predict_dispatch_2::@llvm_aot::@predict_dispatch_2) workgroups([%1, %2, %c1_14])
    hal.return
  }
  hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
  %executable_layout_12 = hal.executable_layout.lookup device(%device : !hal.device) layouts([[#hal.descriptor_set_layout_binding<0, "StorageBuffer", R>, #hal.descriptor_set_layout_binding<1, "StorageBuffer", DW>]]) : !hal.executable_layout
  hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%executable_layout_12 : !hal.executable_layout)[%c0] bindings([
    %c0 = (%buffer_11 : !hal.buffer)[%c0_0, %c40], 
    %c1 = (%buffer_11 : !hal.buffer)[%c48_5, %c40]
  ])
  hal.device.switch<%device : !hal.device>
    #hal.device.match.id<"dylib*">(%arg1 = %cmd : !hal.command_buffer, %arg2 = %c10 : index, %arg3 = %c1 : index, %arg4 = %c1 : index) {
    %c1_14 = constant 1 : index
    %1 = affine.apply affine_map<()[s0] -> (s0 ceildiv 128)>()[%arg2]
    %2 = affine.apply affine_map<()[s0] -> (s0 ceildiv 128)>()[%arg3]
    hal.command_buffer.dispatch.symbol<%arg1 : !hal.command_buffer> target(@predict_dispatch_3::@llvm_aot::@predict_dispatch_3) workgroups([%1, %2, %c1_14])
    hal.return
  }
  hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
  hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%executable_layout_12 : !hal.executable_layout)[%c0] bindings([
    %c0 = (%buffer_11 : !hal.buffer)[%c48_5, %c40], 
    %c1 = (%buffer_11 : !hal.buffer)[%c96_6, %c4]
  ])
  hal.device.switch<%device : !hal.device>
    #hal.device.match.id<"dylib*">(%arg1 = %cmd : !hal.command_buffer, %arg2 = %c1 : index, %arg3 = %c1 : index, %arg4 = %c1 : index) {
    %c1_14 = constant 1 : index
    hal.command_buffer.dispatch.symbol<%arg1 : !hal.command_buffer> target(@predict_dispatch_4::@llvm_aot::@predict_dispatch_4) workgroups([%c1_14, %c1_14, %c1_14])
    hal.return
  }
  hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
  hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%executable_layout : !hal.executable_layout)[%c0] bindings([
    %c0 = (%buffer_11 : !hal.buffer)[%c0_0, %c40], 
    %c1 = (%buffer_11 : !hal.buffer)[%c96_6, %c4], 
    %c2 = (%buffer_11 : !hal.buffer)[%c48_8, %c40]
  ])
  hal.device.switch<%device : !hal.device>
    #hal.device.match.id<"dylib*">(%arg1 = %cmd : !hal.command_buffer, %arg2 = %c10 : index, %arg3 = %c1 : index, %arg4 = %c1 : index) {
    %c1_14 = constant 1 : index
    %1 = affine.apply affine_map<()[s0] -> (s0 ceildiv 128)>()[%arg2]
    %2 = affine.apply affine_map<()[s0] -> (s0 ceildiv 128)>()[%arg3]
    hal.command_buffer.dispatch.symbol<%arg1 : !hal.command_buffer> target(@predict_dispatch_5::@llvm_aot::@predict_dispatch_5) workgroups([%1, %2, %c1_14])
    hal.return
  }
  hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
  hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%executable_layout_12 : !hal.executable_layout)[%c0] bindings([
    %c0 = (%buffer_11 : !hal.buffer)[%c48_8, %c40], 
    %c1 = (%buffer_11 : !hal.buffer)[%c112_9, %c4]
  ])
  hal.device.switch<%device : !hal.device>
    #hal.device.match.id<"dylib*">(%arg1 = %cmd : !hal.command_buffer, %arg2 = %c1 : index, %arg3 = %c1 : index, %arg4 = %c1 : index) {
    %c1_14 = constant 1 : index
    hal.command_buffer.dispatch.symbol<%arg1 : !hal.command_buffer> target(@predict_dispatch_6::@llvm_aot::@predict_dispatch_6) workgroups([%c1_14, %c1_14, %c1_14])
    hal.return
  }
  hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
  %executable_layout_13 = hal.executable_layout.lookup device(%device : !hal.device) layouts([[#hal.descriptor_set_layout_binding<0, "StorageBuffer", R>, #hal.descriptor_set_layout_binding<1, "StorageBuffer", R>, #hal.descriptor_set_layout_binding<2, "StorageBuffer", R>, #hal.descriptor_set_layout_binding<3, "StorageBuffer", DW>]]) : !hal.executable_layout
  hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%executable_layout_13 : !hal.executable_layout)[%c0] bindings([
    %c0 = (%buffer_11 : !hal.buffer)[%c0_0, %c40], 
    %c1 = (%buffer_11 : !hal.buffer)[%c96_6, %c4], 
    %c2 = (%buffer_11 : !hal.buffer)[%c112_9, %c4], 
    %c3 = (%buffer : !hal.buffer)[%c0, %c40]
  ])
  hal.device.switch<%device : !hal.device>
    #hal.device.match.id<"dylib*">(%arg1 = %cmd : !hal.command_buffer, %arg2 = %c10 : index, %arg3 = %c1 : index, %arg4 = %c1 : index) {
    %c1_14 = constant 1 : index
    %1 = affine.apply affine_map<()[s0] -> (s0 ceildiv 128)>()[%arg2]
    %2 = affine.apply affine_map<()[s0] -> (s0 ceildiv 128)>()[%arg3]
    hal.command_buffer.dispatch.symbol<%arg1 : !hal.command_buffer> target(@predict_dispatch_7::@llvm_aot::@predict_dispatch_7) workgroups([%1, %2, %c1_14])
    hal.return
  }
  hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
  hal.command_buffer.end<%cmd : !hal.command_buffer>
  hal.ex.submit_and_wait %device, %cmd
  return %buffer : !hal.buffer
}

// *** IR Dump After mlir::iree_compiler::IREE::HAL::`anonymous-namespace'::PublicABIGenerationPass ***
#map0 = affine_map<()[s0] -> (s0 ceildiv 64)>
#map1 = affine_map<()[s0] -> (s0 ceildiv 4)>
#map2 = affine_map<()[s0] -> (s0 ceildiv 128)>
module  {
  hal.constant_pool @_const_pool attributes {buffer_constraints = #hal.buffer_constraints<max_allocation_size = 1073741824, min_buffer_offset_alignment = 16, max_buffer_range = 1073741824, min_buffer_range_alignment = 16>, sym_visibility = "private"} {
    hal.constant_storage @_storage = opaque<"_", "0xDEADBEEF"> : vector<407040xi8> attributes {sym_visibility = "nested"}
  }
  hal.variable @_const_pool_storage_buffer init(@_const_pool_storage_buffer_initializer) : !hal.buffer attributes {sym_visibility = "private"}
  func private @_const_pool_storage_buffer_initializer() -> !hal.buffer {
    %c0 = constant 0 : index
    %c407040 = constant 407040 : index
    %device = hal.ex.shared_device : !hal.device
    %allocator = hal.device.allocator<%device : !hal.device> : !hal.allocator
    %storage = hal.constant_storage.lookup @_const_pool::@_storage : !iree.byte_buffer
    %mapped = hal.allocator.map<%allocator : !hal.allocator> source(%storage : !iree.byte_buffer)[%c0, %c407040] type("HostVisible|DeviceVisible|DeviceLocal") usage("Constant|Transfer|Mapping|Dispatch") : !hal.buffer
    return %mapped : !hal.buffer
  }
  hal.executable @predict_dispatch_0 attributes {sym_visibility = "private"} {
    hal.interface @io {
      hal.interface.binding @s0b0_ro_constant, set=0, binding=0, type="StorageBuffer", access="Read"
      hal.interface.binding @s0b1_ro_external, set=0, binding=1, type="StorageBuffer", access="Read"
      hal.interface.binding @s0b2_xw_external, set=0, binding=2, type="StorageBuffer", access="Write|Discard"
    }
    hal.executable.target @llvm_aot, filter="dylib*" {
      hal.executable.entry_point @predict_dispatch_0 attributes {interface = @io, ordinal = 0 : index} {
      ^bb0(%arg0: index, %arg1: index, %arg2: index):  // no predecessors
        %c1 = constant 1 : index
        %0 = affine.apply #map0()[%arg0]
        %1 = affine.apply #map1()[%arg1]
        hal.return %0, %1, %c1 : index, index, index
      }
      module  {
        llvm.func internal @predict_dispatch_0(%arg0: !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>, %arg1: !llvm.ptr<array<3 x i32>>) -> i32 {
          %0 = llvm.mlir.constant(0.000000e+00 : f32) : f32
          %1 = llvm.mlir.constant(128 : index) : i64
          %2 = llvm.mlir.constant(784 : index) : i64
          %3 = llvm.mlir.constant(28 : index) : i64
          %4 = llvm.mlir.constant(32 : index) : i64
          %5 = llvm.mlir.constant(64 : index) : i64
          %6 = llvm.mlir.constant(4 : index) : i64
          %7 = llvm.mlir.constant(0 : index) : i64
          %8 = llvm.mlir.constant(1 : index) : i64
          %9 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %10 = llvm.extractvalue %9[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %11 = llvm.getelementptr %10[%8] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
          %12 = llvm.load %11 : !llvm.ptr<ptr<i8>>
          %13 = llvm.getelementptr %12[%7] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
          %14 = llvm.bitcast %13 : !llvm.ptr<i8> to !llvm.ptr<f32>
          %15 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %16 = llvm.insertvalue %14, %15[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %17 = llvm.insertvalue %14, %16[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %18 = llvm.insertvalue %7, %17[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %19 = llvm.insertvalue %8, %18[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %20 = llvm.insertvalue %2, %19[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %21 = llvm.insertvalue %2, %20[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %22 = llvm.insertvalue %8, %21[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %23 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %24 = llvm.extractvalue %23[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %25 = llvm.getelementptr %24[%7] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
          %26 = llvm.load %25 : !llvm.ptr<ptr<i8>>
          %27 = llvm.getelementptr %26[%7] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
          %28 = llvm.bitcast %27 : !llvm.ptr<i8> to !llvm.ptr<f32>
          %29 = llvm.insertvalue %28, %15[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %30 = llvm.insertvalue %28, %29[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %31 = llvm.insertvalue %7, %30[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %32 = llvm.insertvalue %2, %31[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %33 = llvm.insertvalue %1, %32[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %34 = llvm.insertvalue %1, %33[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %35 = llvm.insertvalue %8, %34[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %36 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %37 = llvm.extractvalue %36[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %38 = llvm.mlir.constant(2 : index) : i64
          %39 = llvm.getelementptr %37[%38] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
          %40 = llvm.load %39 : !llvm.ptr<ptr<i8>>
          %41 = llvm.getelementptr %40[%7] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
          %42 = llvm.bitcast %41 : !llvm.ptr<i8> to !llvm.ptr<f32>
          %43 = llvm.insertvalue %42, %15[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %44 = llvm.insertvalue %42, %43[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %45 = llvm.insertvalue %7, %44[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %46 = llvm.insertvalue %8, %45[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %47 = llvm.insertvalue %1, %46[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %48 = llvm.insertvalue %1, %47[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %49 = llvm.insertvalue %8, %48[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %50 = llvm.load %arg1 : !llvm.ptr<array<3 x i32>>
          %51 = llvm.extractvalue %50[0] : !llvm.array<3 x i32>
          %52 = llvm.zext %51 : i32 to i64
          %53 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %54 = llvm.extractvalue %53[0] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %55 = llvm.extractvalue %54[0] : !llvm.array<3 x i32>
          %56 = llvm.zext %55 : i32 to i64
          %57 = llvm.load %arg1 : !llvm.ptr<array<3 x i32>>
          %58 = llvm.extractvalue %57[1] : !llvm.array<3 x i32>
          %59 = llvm.zext %58 : i32 to i64
          %60 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %61 = llvm.extractvalue %60[0] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %62 = llvm.extractvalue %61[1] : !llvm.array<3 x i32>
          %63 = llvm.zext %62 : i32 to i64
          %64 = llvm.mul %59, %6  : i64
          %65 = llvm.mul %63, %6  : i64
          llvm.br ^bb1(%64 : i64)
        ^bb1(%66: i64):  // 2 preds: ^bb0, ^bb30
          %67 = llvm.icmp "slt" %66, %8 : i64
          llvm.cond_br %67, ^bb2, ^bb31
        ^bb2:  // pred: ^bb1
          %68 = llvm.mul %52, %5  : i64
          %69 = llvm.mul %56, %5  : i64
          llvm.br ^bb3(%68 : i64)
        ^bb3(%70: i64):  // 2 preds: ^bb2, ^bb29
          %71 = llvm.icmp "slt" %70, %1 : i64
          llvm.cond_br %71, ^bb4, ^bb30
        ^bb4:  // pred: ^bb3
          %72 = llvm.mlir.constant(-1 : index) : i64
          %73 = llvm.mul %66, %72  : i64
          %74 = llvm.add %73, %8  : i64
          %75 = llvm.icmp "slt" %6, %74 : i64
          %76 = llvm.select %75, %6, %74 : i1, i64
          %77 = llvm.extractvalue %22[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %78 = llvm.bitcast %77 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %79 = llvm.insertvalue %78, %15[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %80 = llvm.extractvalue %22[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %81 = llvm.bitcast %80 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %82 = llvm.insertvalue %81, %79[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %83 = llvm.extractvalue %22[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %84 = llvm.extractvalue %22[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %85 = llvm.extractvalue %22[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %86 = llvm.mul %66, %83  : i64
          %87 = llvm.add %85, %86  : i64
          %88 = llvm.mlir.constant(0 : i64) : i64
          %89 = llvm.mul %88, %84  : i64
          %90 = llvm.add %87, %89  : i64
          %91 = llvm.insertvalue %90, %82[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %92 = llvm.mlir.constant(784 : i64) : i64
          %93 = llvm.mlir.constant(1 : i64) : i64
          %94 = llvm.insertvalue %92, %91[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %95 = llvm.insertvalue %93, %94[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %96 = llvm.insertvalue %76, %95[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %97 = llvm.insertvalue %92, %96[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %98 = llvm.extractvalue %35[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %99 = llvm.bitcast %98 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %100 = llvm.insertvalue %99, %15[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %101 = llvm.extractvalue %35[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %102 = llvm.bitcast %101 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %103 = llvm.insertvalue %102, %100[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %104 = llvm.extractvalue %35[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %105 = llvm.extractvalue %35[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %106 = llvm.extractvalue %35[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %107 = llvm.mul %88, %104  : i64
          %108 = llvm.add %106, %107  : i64
          %109 = llvm.mul %70, %105  : i64
          %110 = llvm.add %108, %109  : i64
          %111 = llvm.insertvalue %110, %103[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %112 = llvm.mlir.constant(64 : i64) : i64
          %113 = llvm.insertvalue %112, %111[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %114 = llvm.insertvalue %93, %113[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %115 = llvm.mlir.constant(128 : i64) : i64
          %116 = llvm.insertvalue %92, %114[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %117 = llvm.insertvalue %115, %116[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %118 = llvm.extractvalue %49[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %119 = llvm.bitcast %118 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %120 = llvm.insertvalue %119, %15[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %121 = llvm.extractvalue %49[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %122 = llvm.bitcast %121 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %123 = llvm.insertvalue %122, %120[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %124 = llvm.extractvalue %49[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %125 = llvm.extractvalue %49[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %126 = llvm.extractvalue %49[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %127 = llvm.mul %66, %124  : i64
          %128 = llvm.add %126, %127  : i64
          %129 = llvm.mul %70, %125  : i64
          %130 = llvm.add %128, %129  : i64
          %131 = llvm.insertvalue %130, %123[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %132 = llvm.insertvalue %112, %131[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %133 = llvm.insertvalue %93, %132[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %134 = llvm.insertvalue %76, %133[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %135 = llvm.insertvalue %115, %134[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          llvm.br ^bb5(%7 : i64)
        ^bb5(%136: i64):  // 2 preds: ^bb4, ^bb8
          %137 = llvm.icmp "slt" %136, %76 : i64
          llvm.cond_br %137, ^bb6(%7 : i64), ^bb9(%7 : i64)
        ^bb6(%138: i64):  // 2 preds: ^bb5, ^bb7
          %139 = llvm.icmp "slt" %138, %5 : i64
          llvm.cond_br %139, ^bb7, ^bb8
        ^bb7:  // pred: ^bb6
          %140 = llvm.extractvalue %135[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %141 = llvm.extractvalue %135[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %142 = llvm.mul %136, %1  : i64
          %143 = llvm.add %141, %142  : i64
          %144 = llvm.add %143, %138  : i64
          %145 = llvm.getelementptr %140[%144] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
          llvm.store %0, %145 : !llvm.ptr<f32>
          %146 = llvm.add %138, %8  : i64
          llvm.br ^bb6(%146 : i64)
        ^bb8:  // pred: ^bb6
          %147 = llvm.add %136, %8  : i64
          llvm.br ^bb5(%147 : i64)
        ^bb9(%148: i64):  // 2 preds: ^bb5, ^bb28
          %149 = llvm.icmp "slt" %148, %76 : i64
          llvm.cond_br %149, ^bb10(%7 : i64), ^bb29
        ^bb10(%150: i64):  // 2 preds: ^bb9, ^bb27
          %151 = llvm.icmp "slt" %150, %5 : i64
          llvm.cond_br %151, ^bb11(%7 : i64), ^bb28
        ^bb11(%152: i64):  // 2 preds: ^bb10, ^bb26
          %153 = llvm.icmp "slt" %152, %2 : i64
          llvm.cond_br %153, ^bb12, ^bb27
        ^bb12:  // pred: ^bb11
          %154 = llvm.mul %148, %72  : i64
          %155 = llvm.add %76, %154  : i64
          %156 = llvm.icmp "slt" %6, %155 : i64
          %157 = llvm.select %156, %6, %155 : i1, i64
          %158 = llvm.extractvalue %97[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %159 = llvm.bitcast %158 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %160 = llvm.insertvalue %159, %15[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %161 = llvm.extractvalue %97[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %162 = llvm.bitcast %161 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %163 = llvm.insertvalue %162, %160[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %164 = llvm.extractvalue %97[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %165 = llvm.extractvalue %97[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %166 = llvm.extractvalue %97[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %167 = llvm.mul %148, %164  : i64
          %168 = llvm.add %166, %167  : i64
          %169 = llvm.mul %152, %165  : i64
          %170 = llvm.add %168, %169  : i64
          %171 = llvm.insertvalue %170, %163[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %172 = llvm.mlir.constant(28 : i64) : i64
          %173 = llvm.insertvalue %172, %171[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %174 = llvm.insertvalue %93, %173[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %175 = llvm.insertvalue %157, %174[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %176 = llvm.insertvalue %92, %175[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %177 = llvm.extractvalue %117[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %178 = llvm.bitcast %177 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %179 = llvm.insertvalue %178, %15[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %180 = llvm.extractvalue %117[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %181 = llvm.bitcast %180 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %182 = llvm.insertvalue %181, %179[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %183 = llvm.extractvalue %117[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %184 = llvm.extractvalue %117[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %185 = llvm.extractvalue %117[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %186 = llvm.mul %152, %183  : i64
          %187 = llvm.add %185, %186  : i64
          %188 = llvm.mul %150, %184  : i64
          %189 = llvm.add %187, %188  : i64
          %190 = llvm.insertvalue %189, %182[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %191 = llvm.mlir.constant(32 : i64) : i64
          %192 = llvm.insertvalue %191, %190[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %193 = llvm.insertvalue %93, %192[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %194 = llvm.insertvalue %172, %193[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %195 = llvm.insertvalue %115, %194[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %196 = llvm.extractvalue %135[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %197 = llvm.bitcast %196 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %198 = llvm.insertvalue %197, %15[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %199 = llvm.extractvalue %135[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %200 = llvm.bitcast %199 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %201 = llvm.insertvalue %200, %198[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %202 = llvm.extractvalue %135[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %203 = llvm.extractvalue %135[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %204 = llvm.extractvalue %135[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %205 = llvm.mul %148, %202  : i64
          %206 = llvm.add %204, %205  : i64
          %207 = llvm.mul %150, %203  : i64
          %208 = llvm.add %206, %207  : i64
          %209 = llvm.insertvalue %208, %201[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %210 = llvm.insertvalue %191, %209[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %211 = llvm.insertvalue %93, %210[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %212 = llvm.insertvalue %157, %211[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %213 = llvm.insertvalue %115, %212[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          llvm.br ^bb13(%7 : i64)
        ^bb13(%214: i64):  // 2 preds: ^bb12, ^bb25
          %215 = llvm.icmp "slt" %214, %157 : i64
          llvm.cond_br %215, ^bb14(%7 : i64), ^bb26
        ^bb14(%216: i64):  // 2 preds: ^bb13, ^bb24
          %217 = llvm.icmp "slt" %216, %4 : i64
          llvm.cond_br %217, ^bb15(%7 : i64), ^bb25
        ^bb15(%218: i64):  // 2 preds: ^bb14, ^bb23
          %219 = llvm.icmp "slt" %218, %3 : i64
          llvm.cond_br %219, ^bb16, ^bb24
        ^bb16:  // pred: ^bb15
          %220 = llvm.mul %214, %72  : i64
          %221 = llvm.add %157, %220  : i64
          %222 = llvm.icmp "slt" %6, %221 : i64
          %223 = llvm.select %222, %6, %221 : i1, i64
          %224 = llvm.extractvalue %176[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %225 = llvm.bitcast %224 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %226 = llvm.insertvalue %225, %15[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %227 = llvm.extractvalue %176[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %228 = llvm.bitcast %227 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %229 = llvm.insertvalue %228, %226[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %230 = llvm.extractvalue %176[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %231 = llvm.extractvalue %176[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %232 = llvm.extractvalue %176[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %233 = llvm.mul %214, %230  : i64
          %234 = llvm.add %232, %233  : i64
          %235 = llvm.mul %218, %231  : i64
          %236 = llvm.add %234, %235  : i64
          %237 = llvm.insertvalue %236, %229[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %238 = llvm.mlir.constant(4 : i64) : i64
          %239 = llvm.insertvalue %238, %237[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %240 = llvm.insertvalue %93, %239[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %241 = llvm.insertvalue %223, %240[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %242 = llvm.insertvalue %92, %241[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %243 = llvm.extractvalue %195[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %244 = llvm.bitcast %243 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %245 = llvm.insertvalue %244, %15[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %246 = llvm.extractvalue %195[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %247 = llvm.bitcast %246 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %248 = llvm.insertvalue %247, %245[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %249 = llvm.extractvalue %195[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %250 = llvm.extractvalue %195[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %251 = llvm.extractvalue %195[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %252 = llvm.mul %218, %249  : i64
          %253 = llvm.add %251, %252  : i64
          %254 = llvm.mul %216, %250  : i64
          %255 = llvm.add %253, %254  : i64
          %256 = llvm.insertvalue %255, %248[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %257 = llvm.insertvalue %238, %256[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %258 = llvm.insertvalue %93, %257[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %259 = llvm.insertvalue %238, %258[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %260 = llvm.insertvalue %115, %259[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %261 = llvm.extractvalue %213[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %262 = llvm.bitcast %261 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %263 = llvm.insertvalue %262, %15[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %264 = llvm.extractvalue %213[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %265 = llvm.bitcast %264 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %266 = llvm.insertvalue %265, %263[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %267 = llvm.extractvalue %213[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %268 = llvm.extractvalue %213[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %269 = llvm.extractvalue %213[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %270 = llvm.mul %214, %267  : i64
          %271 = llvm.add %269, %270  : i64
          %272 = llvm.mul %216, %268  : i64
          %273 = llvm.add %271, %272  : i64
          %274 = llvm.insertvalue %273, %266[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %275 = llvm.insertvalue %238, %274[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %276 = llvm.insertvalue %93, %275[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %277 = llvm.insertvalue %223, %276[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %278 = llvm.insertvalue %115, %277[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          llvm.br ^bb17(%7 : i64)
        ^bb17(%279: i64):  // 2 preds: ^bb16, ^bb22
          %280 = llvm.icmp "slt" %279, %223 : i64
          llvm.cond_br %280, ^bb18(%7 : i64), ^bb23
        ^bb18(%281: i64):  // 2 preds: ^bb17, ^bb21
          %282 = llvm.icmp "slt" %281, %6 : i64
          llvm.cond_br %282, ^bb19(%7 : i64), ^bb22
        ^bb19(%283: i64):  // 2 preds: ^bb18, ^bb20
          %284 = llvm.icmp "slt" %283, %6 : i64
          llvm.cond_br %284, ^bb20, ^bb21
        ^bb20:  // pred: ^bb19
          %285 = llvm.extractvalue %242[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %286 = llvm.extractvalue %242[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %287 = llvm.mul %279, %2  : i64
          %288 = llvm.add %286, %287  : i64
          %289 = llvm.add %288, %283  : i64
          %290 = llvm.getelementptr %285[%289] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
          %291 = llvm.load %290 : !llvm.ptr<f32>
          %292 = llvm.extractvalue %260[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %293 = llvm.extractvalue %260[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %294 = llvm.mul %283, %1  : i64
          %295 = llvm.add %293, %294  : i64
          %296 = llvm.add %295, %281  : i64
          %297 = llvm.getelementptr %292[%296] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
          %298 = llvm.load %297 : !llvm.ptr<f32>
          %299 = llvm.extractvalue %278[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %300 = llvm.extractvalue %278[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %301 = llvm.mul %279, %1  : i64
          %302 = llvm.add %300, %301  : i64
          %303 = llvm.add %302, %281  : i64
          %304 = llvm.getelementptr %299[%303] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
          %305 = llvm.load %304 : !llvm.ptr<f32>
          %306 = llvm.fmul %291, %298  : f32
          %307 = llvm.fadd %305, %306  : f32
          llvm.store %307, %304 : !llvm.ptr<f32>
          %308 = llvm.add %283, %8  : i64
          llvm.br ^bb19(%308 : i64)
        ^bb21:  // pred: ^bb19
          %309 = llvm.add %281, %8  : i64
          llvm.br ^bb18(%309 : i64)
        ^bb22:  // pred: ^bb18
          %310 = llvm.add %279, %8  : i64
          llvm.br ^bb17(%310 : i64)
        ^bb23:  // pred: ^bb17
          %311 = llvm.add %218, %6  : i64
          llvm.br ^bb15(%311 : i64)
        ^bb24:  // pred: ^bb15
          %312 = llvm.add %216, %6  : i64
          llvm.br ^bb14(%312 : i64)
        ^bb25:  // pred: ^bb14
          %313 = llvm.add %214, %6  : i64
          llvm.br ^bb13(%313 : i64)
        ^bb26:  // pred: ^bb13
          %314 = llvm.add %152, %3  : i64
          llvm.br ^bb11(%314 : i64)
        ^bb27:  // pred: ^bb11
          %315 = llvm.add %150, %4  : i64
          llvm.br ^bb10(%315 : i64)
        ^bb28:  // pred: ^bb10
          %316 = llvm.add %148, %6  : i64
          llvm.br ^bb9(%316 : i64)
        ^bb29:  // pred: ^bb9
          %317 = llvm.add %70, %69  : i64
          llvm.br ^bb3(%317 : i64)
        ^bb30:  // pred: ^bb3
          %318 = llvm.add %66, %65  : i64
          llvm.br ^bb1(%318 : i64)
        ^bb31:  // pred: ^bb1
          %319 = llvm.mlir.constant(0 : i32) : i32
          llvm.return %319 : i32
        }
      }
    }
  }
  hal.executable @predict_dispatch_1 attributes {sym_visibility = "private"} {
    hal.interface @io {
      hal.interface.binding @s0b0_ro_constant, set=0, binding=0, type="StorageBuffer", access="Read"
      hal.interface.binding @s0b1_ro_external, set=0, binding=1, type="StorageBuffer", access="Read"
      hal.interface.binding @s0b2_xw_external, set=0, binding=2, type="StorageBuffer", access="Write|Discard"
    }
    hal.executable.target @llvm_aot, filter="dylib*" {
      hal.executable.entry_point @predict_dispatch_1 attributes {interface = @io, ordinal = 0 : index} {
      ^bb0(%arg0: index, %arg1: index, %arg2: index):  // no predecessors
        %c1 = constant 1 : index
        %0 = affine.apply #map2()[%arg0]
        %1 = affine.apply #map2()[%arg1]
        hal.return %0, %1, %c1 : index, index, index
      }
      module  {
        llvm.func internal @predict_dispatch_1(%arg0: !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>, %arg1: !llvm.ptr<array<3 x i32>>) -> i32 {
          %0 = llvm.mlir.constant(0x7FC00000 : f32) : f32
          %1 = llvm.mlir.constant(0.000000e+00 : f32) : f32
          %2 = llvm.mlir.constant(128 : index) : i64
          %3 = llvm.mlir.constant(0 : index) : i64
          %4 = llvm.mlir.constant(1 : index) : i64
          %5 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %6 = llvm.extractvalue %5[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %7 = llvm.getelementptr %6[%4] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
          %8 = llvm.load %7 : !llvm.ptr<ptr<i8>>
          %9 = llvm.getelementptr %8[%3] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
          %10 = llvm.bitcast %9 : !llvm.ptr<i8> to !llvm.ptr<f32>
          %11 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %12 = llvm.insertvalue %10, %11[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %13 = llvm.insertvalue %10, %12[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %14 = llvm.insertvalue %3, %13[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %15 = llvm.insertvalue %4, %14[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %16 = llvm.insertvalue %2, %15[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %17 = llvm.insertvalue %2, %16[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %18 = llvm.insertvalue %4, %17[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %19 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %20 = llvm.extractvalue %19[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %21 = llvm.getelementptr %20[%3] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
          %22 = llvm.load %21 : !llvm.ptr<ptr<i8>>
          %23 = llvm.getelementptr %22[%3] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
          %24 = llvm.bitcast %23 : !llvm.ptr<i8> to !llvm.ptr<f32>
          %25 = llvm.insertvalue %24, %11[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %26 = llvm.insertvalue %24, %25[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %27 = llvm.insertvalue %3, %26[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %28 = llvm.insertvalue %4, %27[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %29 = llvm.insertvalue %2, %28[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %30 = llvm.insertvalue %2, %29[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %31 = llvm.insertvalue %4, %30[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %32 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %33 = llvm.extractvalue %32[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %34 = llvm.mlir.constant(2 : index) : i64
          %35 = llvm.getelementptr %33[%34] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
          %36 = llvm.load %35 : !llvm.ptr<ptr<i8>>
          %37 = llvm.getelementptr %36[%3] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
          %38 = llvm.bitcast %37 : !llvm.ptr<i8> to !llvm.ptr<f32>
          %39 = llvm.insertvalue %38, %11[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %40 = llvm.insertvalue %38, %39[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %41 = llvm.insertvalue %3, %40[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %42 = llvm.insertvalue %4, %41[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %43 = llvm.insertvalue %2, %42[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %44 = llvm.insertvalue %2, %43[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %45 = llvm.insertvalue %4, %44[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %46 = llvm.load %arg1 : !llvm.ptr<array<3 x i32>>
          %47 = llvm.extractvalue %46[0] : !llvm.array<3 x i32>
          %48 = llvm.zext %47 : i32 to i64
          %49 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %50 = llvm.extractvalue %49[0] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %51 = llvm.extractvalue %50[0] : !llvm.array<3 x i32>
          %52 = llvm.zext %51 : i32 to i64
          %53 = llvm.load %arg1 : !llvm.ptr<array<3 x i32>>
          %54 = llvm.extractvalue %53[1] : !llvm.array<3 x i32>
          %55 = llvm.zext %54 : i32 to i64
          %56 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %57 = llvm.extractvalue %56[0] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %58 = llvm.extractvalue %57[1] : !llvm.array<3 x i32>
          %59 = llvm.zext %58 : i32 to i64
          %60 = llvm.mul %55, %2  : i64
          %61 = llvm.mul %59, %2  : i64
          llvm.br ^bb1(%60 : i64)
        ^bb1(%62: i64):  // 2 preds: ^bb0, ^bb10
          %63 = llvm.icmp "slt" %62, %4 : i64
          llvm.cond_br %63, ^bb2, ^bb11
        ^bb2:  // pred: ^bb1
          %64 = llvm.mul %48, %2  : i64
          %65 = llvm.mul %52, %2  : i64
          llvm.br ^bb3(%64 : i64)
        ^bb3(%66: i64):  // 2 preds: ^bb2, ^bb9
          %67 = llvm.icmp "slt" %66, %2 : i64
          llvm.cond_br %67, ^bb4, ^bb10
        ^bb4:  // pred: ^bb3
          %68 = llvm.mlir.constant(-1 : index) : i64
          %69 = llvm.mul %62, %68  : i64
          %70 = llvm.add %69, %4  : i64
          %71 = llvm.icmp "slt" %2, %70 : i64
          %72 = llvm.select %71, %2, %70 : i1, i64
          %73 = llvm.extractvalue %18[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %74 = llvm.bitcast %73 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %75 = llvm.insertvalue %74, %11[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %76 = llvm.extractvalue %18[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %77 = llvm.bitcast %76 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %78 = llvm.insertvalue %77, %75[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %79 = llvm.extractvalue %18[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %80 = llvm.extractvalue %18[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %81 = llvm.extractvalue %18[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %82 = llvm.mul %62, %79  : i64
          %83 = llvm.add %81, %82  : i64
          %84 = llvm.mul %66, %80  : i64
          %85 = llvm.add %83, %84  : i64
          %86 = llvm.insertvalue %85, %78[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %87 = llvm.mlir.constant(128 : i64) : i64
          %88 = llvm.mlir.constant(1 : i64) : i64
          %89 = llvm.insertvalue %87, %86[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %90 = llvm.insertvalue %88, %89[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %91 = llvm.insertvalue %72, %90[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %92 = llvm.insertvalue %87, %91[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %93 = llvm.extractvalue %31[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %94 = llvm.bitcast %93 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %95 = llvm.insertvalue %94, %11[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %96 = llvm.extractvalue %31[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %97 = llvm.bitcast %96 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %98 = llvm.insertvalue %97, %95[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %99 = llvm.extractvalue %31[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %100 = llvm.extractvalue %31[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %101 = llvm.extractvalue %31[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %102 = llvm.mul %62, %99  : i64
          %103 = llvm.add %101, %102  : i64
          %104 = llvm.mul %66, %100  : i64
          %105 = llvm.add %103, %104  : i64
          %106 = llvm.insertvalue %105, %98[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %107 = llvm.insertvalue %87, %106[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %108 = llvm.insertvalue %88, %107[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %109 = llvm.insertvalue %72, %108[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %110 = llvm.insertvalue %87, %109[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %111 = llvm.extractvalue %45[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %112 = llvm.bitcast %111 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %113 = llvm.insertvalue %112, %11[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %114 = llvm.extractvalue %45[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %115 = llvm.bitcast %114 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %116 = llvm.insertvalue %115, %113[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %117 = llvm.extractvalue %45[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %118 = llvm.extractvalue %45[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %119 = llvm.extractvalue %45[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %120 = llvm.mul %62, %117  : i64
          %121 = llvm.add %119, %120  : i64
          %122 = llvm.mul %66, %118  : i64
          %123 = llvm.add %121, %122  : i64
          %124 = llvm.insertvalue %123, %116[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %125 = llvm.insertvalue %87, %124[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %126 = llvm.insertvalue %88, %125[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %127 = llvm.insertvalue %72, %126[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %128 = llvm.insertvalue %87, %127[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          llvm.br ^bb5(%3 : i64)
        ^bb5(%129: i64):  // 2 preds: ^bb4, ^bb8
          %130 = llvm.icmp "slt" %129, %72 : i64
          llvm.cond_br %130, ^bb6(%3 : i64), ^bb9
        ^bb6(%131: i64):  // 2 preds: ^bb5, ^bb7
          %132 = llvm.icmp "slt" %131, %2 : i64
          llvm.cond_br %132, ^bb7, ^bb8
        ^bb7:  // pred: ^bb6
          %133 = llvm.extractvalue %92[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %134 = llvm.extractvalue %92[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %135 = llvm.mul %129, %2  : i64
          %136 = llvm.add %134, %135  : i64
          %137 = llvm.add %136, %131  : i64
          %138 = llvm.getelementptr %133[%137] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
          %139 = llvm.load %138 : !llvm.ptr<f32>
          %140 = llvm.extractvalue %110[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %141 = llvm.extractvalue %110[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %142 = llvm.add %141, %135  : i64
          %143 = llvm.add %142, %131  : i64
          %144 = llvm.getelementptr %140[%143] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
          %145 = llvm.load %144 : !llvm.ptr<f32>
          %146 = llvm.fadd %139, %145  : f32
          %147 = llvm.fcmp "ogt" %146, %1 : f32
          %148 = llvm.select %147, %146, %1 : i1, f32
          %149 = llvm.fcmp "uno" %146, %1 : f32
          %150 = llvm.select %149, %0, %148 : i1, f32
          %151 = llvm.extractvalue %128[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %152 = llvm.extractvalue %128[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %153 = llvm.add %152, %135  : i64
          %154 = llvm.add %153, %131  : i64
          %155 = llvm.getelementptr %151[%154] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
          llvm.store %150, %155 : !llvm.ptr<f32>
          %156 = llvm.add %131, %4  : i64
          llvm.br ^bb6(%156 : i64)
        ^bb8:  // pred: ^bb6
          %157 = llvm.add %129, %4  : i64
          llvm.br ^bb5(%157 : i64)
        ^bb9:  // pred: ^bb5
          %158 = llvm.add %66, %65  : i64
          llvm.br ^bb3(%158 : i64)
        ^bb10:  // pred: ^bb3
          %159 = llvm.add %62, %61  : i64
          llvm.br ^bb1(%159 : i64)
        ^bb11:  // pred: ^bb1
          %160 = llvm.mlir.constant(0 : i32) : i32
          llvm.return %160 : i32
        }
      }
    }
  }
  hal.executable @predict_dispatch_2 attributes {sym_visibility = "private"} {
    hal.interface @io {
      hal.interface.binding @s0b0_ro_constant, set=0, binding=0, type="StorageBuffer", access="Read"
      hal.interface.binding @s0b1_ro_external, set=0, binding=1, type="StorageBuffer", access="Read"
      hal.interface.binding @s0b2_xw_external, set=0, binding=2, type="StorageBuffer", access="Write|Discard"
    }
    hal.executable.target @llvm_aot, filter="dylib*" {
      hal.executable.entry_point @predict_dispatch_2 attributes {interface = @io, ordinal = 0 : index} {
      ^bb0(%arg0: index, %arg1: index, %arg2: index):  // no predecessors
        %c1 = constant 1 : index
        %0 = affine.apply #map0()[%arg0]
        %1 = affine.apply #map1()[%arg1]
        hal.return %0, %1, %c1 : index, index, index
      }
      module  {
        llvm.func internal @predict_dispatch_2(%arg0: !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>, %arg1: !llvm.ptr<array<3 x i32>>) -> i32 {
          %0 = llvm.mlir.constant(0.000000e+00 : f32) : f32
          %1 = llvm.mlir.constant(10 : index) : i64
          %2 = llvm.mlir.constant(128 : index) : i64
          %3 = llvm.mlir.constant(32 : index) : i64
          %4 = llvm.mlir.constant(4 : index) : i64
          %5 = llvm.mlir.constant(0 : index) : i64
          %6 = llvm.mlir.constant(1 : index) : i64
          %7 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %8 = llvm.extractvalue %7[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %9 = llvm.getelementptr %8[%6] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
          %10 = llvm.load %9 : !llvm.ptr<ptr<i8>>
          %11 = llvm.getelementptr %10[%5] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
          %12 = llvm.bitcast %11 : !llvm.ptr<i8> to !llvm.ptr<f32>
          %13 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %14 = llvm.insertvalue %12, %13[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %15 = llvm.insertvalue %12, %14[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %16 = llvm.insertvalue %5, %15[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %17 = llvm.insertvalue %6, %16[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %18 = llvm.insertvalue %2, %17[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %19 = llvm.insertvalue %2, %18[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %20 = llvm.insertvalue %6, %19[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %21 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %22 = llvm.extractvalue %21[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %23 = llvm.getelementptr %22[%5] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
          %24 = llvm.load %23 : !llvm.ptr<ptr<i8>>
          %25 = llvm.getelementptr %24[%5] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
          %26 = llvm.bitcast %25 : !llvm.ptr<i8> to !llvm.ptr<f32>
          %27 = llvm.insertvalue %26, %13[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %28 = llvm.insertvalue %26, %27[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %29 = llvm.insertvalue %5, %28[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %30 = llvm.insertvalue %2, %29[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %31 = llvm.insertvalue %1, %30[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %32 = llvm.insertvalue %1, %31[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %33 = llvm.insertvalue %6, %32[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %34 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %35 = llvm.extractvalue %34[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %36 = llvm.mlir.constant(2 : index) : i64
          %37 = llvm.getelementptr %35[%36] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
          %38 = llvm.load %37 : !llvm.ptr<ptr<i8>>
          %39 = llvm.getelementptr %38[%5] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
          %40 = llvm.bitcast %39 : !llvm.ptr<i8> to !llvm.ptr<f32>
          %41 = llvm.insertvalue %40, %13[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %42 = llvm.insertvalue %40, %41[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %43 = llvm.insertvalue %5, %42[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %44 = llvm.insertvalue %6, %43[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %45 = llvm.insertvalue %1, %44[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %46 = llvm.insertvalue %1, %45[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %47 = llvm.insertvalue %6, %46[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %48 = llvm.load %arg1 : !llvm.ptr<array<3 x i32>>
          %49 = llvm.extractvalue %48[0] : !llvm.array<3 x i32>
          %50 = llvm.zext %49 : i32 to i64
          %51 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %52 = llvm.extractvalue %51[0] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %53 = llvm.extractvalue %52[0] : !llvm.array<3 x i32>
          %54 = llvm.zext %53 : i32 to i64
          %55 = llvm.load %arg1 : !llvm.ptr<array<3 x i32>>
          %56 = llvm.extractvalue %55[1] : !llvm.array<3 x i32>
          %57 = llvm.zext %56 : i32 to i64
          %58 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %59 = llvm.extractvalue %58[0] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %60 = llvm.extractvalue %59[1] : !llvm.array<3 x i32>
          %61 = llvm.zext %60 : i32 to i64
          %62 = llvm.mul %57, %4  : i64
          %63 = llvm.mul %61, %4  : i64
          llvm.br ^bb1(%62 : i64)
        ^bb1(%64: i64):  // 2 preds: ^bb0, ^bb30
          %65 = llvm.icmp "slt" %64, %6 : i64
          llvm.cond_br %65, ^bb2, ^bb31
        ^bb2:  // pred: ^bb1
          %66 = llvm.mlir.constant(64 : index) : i64
          %67 = llvm.mul %50, %66  : i64
          %68 = llvm.mul %54, %66  : i64
          llvm.br ^bb3(%67 : i64)
        ^bb3(%69: i64):  // 2 preds: ^bb2, ^bb29
          %70 = llvm.icmp "slt" %69, %1 : i64
          llvm.cond_br %70, ^bb4, ^bb30
        ^bb4:  // pred: ^bb3
          %71 = llvm.mlir.constant(-1 : index) : i64
          %72 = llvm.mul %64, %71  : i64
          %73 = llvm.add %72, %6  : i64
          %74 = llvm.icmp "slt" %4, %73 : i64
          %75 = llvm.select %74, %4, %73 : i1, i64
          %76 = llvm.extractvalue %20[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %77 = llvm.bitcast %76 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %78 = llvm.insertvalue %77, %13[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %79 = llvm.extractvalue %20[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %80 = llvm.bitcast %79 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %81 = llvm.insertvalue %80, %78[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %82 = llvm.extractvalue %20[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %83 = llvm.extractvalue %20[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %84 = llvm.extractvalue %20[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %85 = llvm.mul %64, %82  : i64
          %86 = llvm.add %84, %85  : i64
          %87 = llvm.mlir.constant(0 : i64) : i64
          %88 = llvm.mul %87, %83  : i64
          %89 = llvm.add %86, %88  : i64
          %90 = llvm.insertvalue %89, %81[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %91 = llvm.mlir.constant(128 : i64) : i64
          %92 = llvm.mlir.constant(1 : i64) : i64
          %93 = llvm.insertvalue %91, %90[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %94 = llvm.insertvalue %92, %93[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %95 = llvm.insertvalue %75, %94[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %96 = llvm.insertvalue %91, %95[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %97 = llvm.mul %69, %71  : i64
          %98 = llvm.add %97, %1  : i64
          %99 = llvm.icmp "slt" %66, %98 : i64
          %100 = llvm.select %99, %66, %98 : i1, i64
          %101 = llvm.extractvalue %33[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %102 = llvm.bitcast %101 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %103 = llvm.insertvalue %102, %13[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %104 = llvm.extractvalue %33[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %105 = llvm.bitcast %104 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %106 = llvm.insertvalue %105, %103[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %107 = llvm.extractvalue %33[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %108 = llvm.extractvalue %33[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %109 = llvm.extractvalue %33[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %110 = llvm.mul %87, %107  : i64
          %111 = llvm.add %109, %110  : i64
          %112 = llvm.mul %69, %108  : i64
          %113 = llvm.add %111, %112  : i64
          %114 = llvm.insertvalue %113, %106[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %115 = llvm.insertvalue %100, %114[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %116 = llvm.insertvalue %92, %115[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %117 = llvm.mlir.constant(10 : i64) : i64
          %118 = llvm.insertvalue %91, %116[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %119 = llvm.insertvalue %117, %118[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %120 = llvm.extractvalue %47[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %121 = llvm.bitcast %120 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %122 = llvm.insertvalue %121, %13[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %123 = llvm.extractvalue %47[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %124 = llvm.bitcast %123 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %125 = llvm.insertvalue %124, %122[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %126 = llvm.extractvalue %47[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %127 = llvm.extractvalue %47[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %128 = llvm.extractvalue %47[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %129 = llvm.mul %64, %126  : i64
          %130 = llvm.add %128, %129  : i64
          %131 = llvm.mul %69, %127  : i64
          %132 = llvm.add %130, %131  : i64
          %133 = llvm.insertvalue %132, %125[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %134 = llvm.insertvalue %100, %133[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %135 = llvm.insertvalue %92, %134[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %136 = llvm.insertvalue %75, %135[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %137 = llvm.insertvalue %117, %136[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          llvm.br ^bb5(%5 : i64)
        ^bb5(%138: i64):  // 2 preds: ^bb4, ^bb8
          %139 = llvm.icmp "slt" %138, %75 : i64
          llvm.cond_br %139, ^bb6(%5 : i64), ^bb9(%5 : i64)
        ^bb6(%140: i64):  // 2 preds: ^bb5, ^bb7
          %141 = llvm.icmp "slt" %140, %100 : i64
          llvm.cond_br %141, ^bb7, ^bb8
        ^bb7:  // pred: ^bb6
          %142 = llvm.extractvalue %137[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %143 = llvm.extractvalue %137[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %144 = llvm.mul %138, %1  : i64
          %145 = llvm.add %143, %144  : i64
          %146 = llvm.add %145, %140  : i64
          %147 = llvm.getelementptr %142[%146] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
          llvm.store %0, %147 : !llvm.ptr<f32>
          %148 = llvm.add %140, %6  : i64
          llvm.br ^bb6(%148 : i64)
        ^bb8:  // pred: ^bb6
          %149 = llvm.add %138, %6  : i64
          llvm.br ^bb5(%149 : i64)
        ^bb9(%150: i64):  // 2 preds: ^bb5, ^bb28
          %151 = llvm.icmp "slt" %150, %75 : i64
          llvm.cond_br %151, ^bb10(%5 : i64), ^bb29
        ^bb10(%152: i64):  // 2 preds: ^bb9, ^bb27
          %153 = llvm.icmp "slt" %152, %100 : i64
          llvm.cond_br %153, ^bb11(%5 : i64), ^bb28
        ^bb11(%154: i64):  // 2 preds: ^bb10, ^bb26
          %155 = llvm.icmp "slt" %154, %2 : i64
          llvm.cond_br %155, ^bb12, ^bb27
        ^bb12:  // pred: ^bb11
          %156 = llvm.mul %150, %71  : i64
          %157 = llvm.add %75, %156  : i64
          %158 = llvm.icmp "slt" %4, %157 : i64
          %159 = llvm.select %158, %4, %157 : i1, i64
          %160 = llvm.extractvalue %96[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %161 = llvm.bitcast %160 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %162 = llvm.insertvalue %161, %13[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %163 = llvm.extractvalue %96[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %164 = llvm.bitcast %163 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %165 = llvm.insertvalue %164, %162[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %166 = llvm.extractvalue %96[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %167 = llvm.extractvalue %96[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %168 = llvm.extractvalue %96[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %169 = llvm.mul %150, %166  : i64
          %170 = llvm.add %168, %169  : i64
          %171 = llvm.mul %154, %167  : i64
          %172 = llvm.add %170, %171  : i64
          %173 = llvm.insertvalue %172, %165[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %174 = llvm.mlir.constant(32 : i64) : i64
          %175 = llvm.insertvalue %174, %173[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %176 = llvm.insertvalue %92, %175[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %177 = llvm.insertvalue %159, %176[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %178 = llvm.insertvalue %91, %177[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %179 = llvm.mul %152, %71  : i64
          %180 = llvm.add %100, %179  : i64
          %181 = llvm.icmp "slt" %3, %180 : i64
          %182 = llvm.select %181, %3, %180 : i1, i64
          %183 = llvm.extractvalue %119[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %184 = llvm.bitcast %183 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %185 = llvm.insertvalue %184, %13[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %186 = llvm.extractvalue %119[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %187 = llvm.bitcast %186 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %188 = llvm.insertvalue %187, %185[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %189 = llvm.extractvalue %119[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %190 = llvm.extractvalue %119[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %191 = llvm.extractvalue %119[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %192 = llvm.mul %154, %189  : i64
          %193 = llvm.add %191, %192  : i64
          %194 = llvm.mul %152, %190  : i64
          %195 = llvm.add %193, %194  : i64
          %196 = llvm.insertvalue %195, %188[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %197 = llvm.insertvalue %182, %196[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %198 = llvm.insertvalue %92, %197[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %199 = llvm.insertvalue %174, %198[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %200 = llvm.insertvalue %117, %199[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %201 = llvm.extractvalue %137[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %202 = llvm.bitcast %201 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %203 = llvm.insertvalue %202, %13[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %204 = llvm.extractvalue %137[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %205 = llvm.bitcast %204 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %206 = llvm.insertvalue %205, %203[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %207 = llvm.extractvalue %137[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %208 = llvm.extractvalue %137[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %209 = llvm.extractvalue %137[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %210 = llvm.mul %150, %207  : i64
          %211 = llvm.add %209, %210  : i64
          %212 = llvm.mul %152, %208  : i64
          %213 = llvm.add %211, %212  : i64
          %214 = llvm.insertvalue %213, %206[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %215 = llvm.insertvalue %182, %214[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %216 = llvm.insertvalue %92, %215[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %217 = llvm.insertvalue %159, %216[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %218 = llvm.insertvalue %117, %217[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          llvm.br ^bb13(%5 : i64)
        ^bb13(%219: i64):  // 2 preds: ^bb12, ^bb25
          %220 = llvm.icmp "slt" %219, %159 : i64
          llvm.cond_br %220, ^bb14(%5 : i64), ^bb26
        ^bb14(%221: i64):  // 2 preds: ^bb13, ^bb24
          %222 = llvm.icmp "slt" %221, %182 : i64
          llvm.cond_br %222, ^bb15(%5 : i64), ^bb25
        ^bb15(%223: i64):  // 2 preds: ^bb14, ^bb23
          %224 = llvm.icmp "slt" %223, %3 : i64
          llvm.cond_br %224, ^bb16, ^bb24
        ^bb16:  // pred: ^bb15
          %225 = llvm.mul %219, %71  : i64
          %226 = llvm.add %159, %225  : i64
          %227 = llvm.icmp "slt" %4, %226 : i64
          %228 = llvm.select %227, %4, %226 : i1, i64
          %229 = llvm.extractvalue %178[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %230 = llvm.bitcast %229 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %231 = llvm.insertvalue %230, %13[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %232 = llvm.extractvalue %178[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %233 = llvm.bitcast %232 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %234 = llvm.insertvalue %233, %231[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %235 = llvm.extractvalue %178[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %236 = llvm.extractvalue %178[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %237 = llvm.extractvalue %178[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %238 = llvm.mul %219, %235  : i64
          %239 = llvm.add %237, %238  : i64
          %240 = llvm.mul %223, %236  : i64
          %241 = llvm.add %239, %240  : i64
          %242 = llvm.insertvalue %241, %234[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %243 = llvm.mlir.constant(4 : i64) : i64
          %244 = llvm.insertvalue %243, %242[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %245 = llvm.insertvalue %92, %244[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %246 = llvm.insertvalue %228, %245[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %247 = llvm.insertvalue %91, %246[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %248 = llvm.mul %221, %71  : i64
          %249 = llvm.add %182, %248  : i64
          %250 = llvm.icmp "slt" %4, %249 : i64
          %251 = llvm.select %250, %4, %249 : i1, i64
          %252 = llvm.extractvalue %200[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %253 = llvm.bitcast %252 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %254 = llvm.insertvalue %253, %13[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %255 = llvm.extractvalue %200[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %256 = llvm.bitcast %255 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %257 = llvm.insertvalue %256, %254[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %258 = llvm.extractvalue %200[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %259 = llvm.extractvalue %200[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %260 = llvm.extractvalue %200[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %261 = llvm.mul %223, %258  : i64
          %262 = llvm.add %260, %261  : i64
          %263 = llvm.mul %221, %259  : i64
          %264 = llvm.add %262, %263  : i64
          %265 = llvm.insertvalue %264, %257[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %266 = llvm.insertvalue %251, %265[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %267 = llvm.insertvalue %92, %266[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %268 = llvm.insertvalue %243, %267[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %269 = llvm.insertvalue %117, %268[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %270 = llvm.extractvalue %218[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %271 = llvm.bitcast %270 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %272 = llvm.insertvalue %271, %13[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %273 = llvm.extractvalue %218[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %274 = llvm.bitcast %273 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %275 = llvm.insertvalue %274, %272[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %276 = llvm.extractvalue %218[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %277 = llvm.extractvalue %218[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %278 = llvm.extractvalue %218[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %279 = llvm.mul %219, %276  : i64
          %280 = llvm.add %278, %279  : i64
          %281 = llvm.mul %221, %277  : i64
          %282 = llvm.add %280, %281  : i64
          %283 = llvm.insertvalue %282, %275[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %284 = llvm.insertvalue %251, %283[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %285 = llvm.insertvalue %92, %284[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %286 = llvm.insertvalue %228, %285[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %287 = llvm.insertvalue %117, %286[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          llvm.br ^bb17(%5 : i64)
        ^bb17(%288: i64):  // 2 preds: ^bb16, ^bb22
          %289 = llvm.icmp "slt" %288, %228 : i64
          llvm.cond_br %289, ^bb18(%5 : i64), ^bb23
        ^bb18(%290: i64):  // 2 preds: ^bb17, ^bb21
          %291 = llvm.icmp "slt" %290, %251 : i64
          llvm.cond_br %291, ^bb19(%5 : i64), ^bb22
        ^bb19(%292: i64):  // 2 preds: ^bb18, ^bb20
          %293 = llvm.icmp "slt" %292, %4 : i64
          llvm.cond_br %293, ^bb20, ^bb21
        ^bb20:  // pred: ^bb19
          %294 = llvm.extractvalue %247[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %295 = llvm.extractvalue %247[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %296 = llvm.mul %288, %2  : i64
          %297 = llvm.add %295, %296  : i64
          %298 = llvm.add %297, %292  : i64
          %299 = llvm.getelementptr %294[%298] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
          %300 = llvm.load %299 : !llvm.ptr<f32>
          %301 = llvm.extractvalue %269[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %302 = llvm.extractvalue %269[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %303 = llvm.mul %292, %1  : i64
          %304 = llvm.add %302, %303  : i64
          %305 = llvm.add %304, %290  : i64
          %306 = llvm.getelementptr %301[%305] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
          %307 = llvm.load %306 : !llvm.ptr<f32>
          %308 = llvm.extractvalue %287[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %309 = llvm.extractvalue %287[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %310 = llvm.mul %288, %1  : i64
          %311 = llvm.add %309, %310  : i64
          %312 = llvm.add %311, %290  : i64
          %313 = llvm.getelementptr %308[%312] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
          %314 = llvm.load %313 : !llvm.ptr<f32>
          %315 = llvm.fmul %300, %307  : f32
          %316 = llvm.fadd %314, %315  : f32
          llvm.store %316, %313 : !llvm.ptr<f32>
          %317 = llvm.add %292, %6  : i64
          llvm.br ^bb19(%317 : i64)
        ^bb21:  // pred: ^bb19
          %318 = llvm.add %290, %6  : i64
          llvm.br ^bb18(%318 : i64)
        ^bb22:  // pred: ^bb18
          %319 = llvm.add %288, %6  : i64
          llvm.br ^bb17(%319 : i64)
        ^bb23:  // pred: ^bb17
          %320 = llvm.add %223, %4  : i64
          llvm.br ^bb15(%320 : i64)
        ^bb24:  // pred: ^bb15
          %321 = llvm.add %221, %4  : i64
          llvm.br ^bb14(%321 : i64)
        ^bb25:  // pred: ^bb14
          %322 = llvm.add %219, %4  : i64
          llvm.br ^bb13(%322 : i64)
        ^bb26:  // pred: ^bb13
          %323 = llvm.add %154, %3  : i64
          llvm.br ^bb11(%323 : i64)
        ^bb27:  // pred: ^bb11
          %324 = llvm.add %152, %3  : i64
          llvm.br ^bb10(%324 : i64)
        ^bb28:  // pred: ^bb10
          %325 = llvm.add %150, %4  : i64
          llvm.br ^bb9(%325 : i64)
        ^bb29:  // pred: ^bb9
          %326 = llvm.add %69, %68  : i64
          llvm.br ^bb3(%326 : i64)
        ^bb30:  // pred: ^bb3
          %327 = llvm.add %64, %63  : i64
          llvm.br ^bb1(%327 : i64)
        ^bb31:  // pred: ^bb1
          %328 = llvm.mlir.constant(0 : i32) : i32
          llvm.return %328 : i32
        }
      }
    }
  }
  hal.executable @predict_dispatch_3 attributes {sym_visibility = "private"} {
    hal.interface @io {
      hal.interface.binding @s0b0_ro_external, set=0, binding=0, type="StorageBuffer", access="Read"
      hal.interface.binding @s0b1_xw_external, set=0, binding=1, type="StorageBuffer", access="Write|Discard"
    }
    hal.executable.target @llvm_aot, filter="dylib*" {
      hal.executable.entry_point @predict_dispatch_3 attributes {interface = @io, ordinal = 0 : index} {
      ^bb0(%arg0: index, %arg1: index, %arg2: index):  // no predecessors
        %c1 = constant 1 : index
        %0 = affine.apply #map2()[%arg0]
        %1 = affine.apply #map2()[%arg1]
        hal.return %0, %1, %c1 : index, index, index
      }
      module  {
        llvm.mlir.global private constant @__constant_1x10xf32(opaque<"_", "0xDEADBEEF"> : tensor<1x10xf32>) : !llvm.array<1 x array<10 x f32>>
        llvm.func internal @predict_dispatch_3(%arg0: !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>, %arg1: !llvm.ptr<array<3 x i32>>) -> i32 {
          %0 = llvm.mlir.constant(10 : index) : i64
          %1 = llvm.mlir.constant(0 : index) : i64
          %2 = llvm.mlir.constant(1 : index) : i64
          %3 = llvm.mlir.addressof @__constant_1x10xf32 : !llvm.ptr<array<1 x array<10 x f32>>>
          %4 = llvm.getelementptr %3[%1, %1, %1] : (!llvm.ptr<array<1 x array<10 x f32>>>, i64, i64, i64) -> !llvm.ptr<f32>
          %5 = llvm.mlir.constant(3735928559 : index) : i64
          %6 = llvm.inttoptr %5 : i64 to !llvm.ptr<f32>
          %7 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %8 = llvm.insertvalue %6, %7[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %9 = llvm.insertvalue %4, %8[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %10 = llvm.insertvalue %1, %9[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %11 = llvm.insertvalue %2, %10[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %12 = llvm.insertvalue %0, %11[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %13 = llvm.insertvalue %0, %12[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %14 = llvm.insertvalue %2, %13[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %15 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %16 = llvm.extractvalue %15[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %17 = llvm.getelementptr %16[%1] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
          %18 = llvm.load %17 : !llvm.ptr<ptr<i8>>
          %19 = llvm.getelementptr %18[%1] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
          %20 = llvm.bitcast %19 : !llvm.ptr<i8> to !llvm.ptr<f32>
          %21 = llvm.insertvalue %20, %7[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %22 = llvm.insertvalue %20, %21[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %23 = llvm.insertvalue %1, %22[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %24 = llvm.insertvalue %2, %23[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %25 = llvm.insertvalue %0, %24[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %26 = llvm.insertvalue %0, %25[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %27 = llvm.insertvalue %2, %26[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %28 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %29 = llvm.extractvalue %28[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %30 = llvm.getelementptr %29[%2] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
          %31 = llvm.load %30 : !llvm.ptr<ptr<i8>>
          %32 = llvm.getelementptr %31[%1] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
          %33 = llvm.bitcast %32 : !llvm.ptr<i8> to !llvm.ptr<f32>
          %34 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %35 = llvm.insertvalue %33, %34[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %36 = llvm.insertvalue %33, %35[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %37 = llvm.insertvalue %1, %36[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %38 = llvm.insertvalue %0, %37[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %39 = llvm.insertvalue %2, %38[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %40 = llvm.load %arg1 : !llvm.ptr<array<3 x i32>>
          %41 = llvm.extractvalue %40[0] : !llvm.array<3 x i32>
          %42 = llvm.zext %41 : i32 to i64
          %43 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %44 = llvm.extractvalue %43[0] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %45 = llvm.extractvalue %44[0] : !llvm.array<3 x i32>
          %46 = llvm.zext %45 : i32 to i64
          %47 = llvm.load %arg1 : !llvm.ptr<array<3 x i32>>
          %48 = llvm.extractvalue %47[1] : !llvm.array<3 x i32>
          %49 = llvm.zext %48 : i32 to i64
          %50 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %51 = llvm.extractvalue %50[0] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %52 = llvm.extractvalue %51[1] : !llvm.array<3 x i32>
          %53 = llvm.zext %52 : i32 to i64
          %54 = llvm.mlir.constant(128 : index) : i64
          %55 = llvm.mul %49, %54  : i64
          %56 = llvm.mul %53, %54  : i64
          llvm.br ^bb1(%55 : i64)
        ^bb1(%57: i64):  // 2 preds: ^bb0, ^bb10
          %58 = llvm.icmp "slt" %57, %2 : i64
          llvm.cond_br %58, ^bb2, ^bb11
        ^bb2:  // pred: ^bb1
          %59 = llvm.mul %42, %54  : i64
          %60 = llvm.mul %46, %54  : i64
          llvm.br ^bb3(%59 : i64)
        ^bb3(%61: i64):  // 2 preds: ^bb2, ^bb9
          %62 = llvm.icmp "slt" %61, %0 : i64
          llvm.cond_br %62, ^bb4, ^bb10
        ^bb4:  // pred: ^bb3
          %63 = llvm.mlir.constant(-1 : index) : i64
          %64 = llvm.mul %57, %63  : i64
          %65 = llvm.add %64, %2  : i64
          %66 = llvm.icmp "slt" %54, %65 : i64
          %67 = llvm.select %66, %54, %65 : i1, i64
          %68 = llvm.mul %61, %63  : i64
          %69 = llvm.add %68, %0  : i64
          %70 = llvm.icmp "slt" %54, %69 : i64
          %71 = llvm.select %70, %54, %69 : i1, i64
          %72 = llvm.extractvalue %27[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %73 = llvm.bitcast %72 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %74 = llvm.insertvalue %73, %7[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %75 = llvm.extractvalue %27[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %76 = llvm.bitcast %75 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %77 = llvm.insertvalue %76, %74[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %78 = llvm.extractvalue %27[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %79 = llvm.extractvalue %27[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %80 = llvm.extractvalue %27[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %81 = llvm.mul %57, %78  : i64
          %82 = llvm.add %80, %81  : i64
          %83 = llvm.mul %61, %79  : i64
          %84 = llvm.add %82, %83  : i64
          %85 = llvm.insertvalue %84, %77[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %86 = llvm.mlir.constant(1 : i64) : i64
          %87 = llvm.insertvalue %71, %85[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %88 = llvm.insertvalue %86, %87[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %89 = llvm.mlir.constant(10 : i64) : i64
          %90 = llvm.insertvalue %67, %88[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %91 = llvm.insertvalue %89, %90[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %92 = llvm.extractvalue %14[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %93 = llvm.bitcast %92 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %94 = llvm.insertvalue %93, %7[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %95 = llvm.extractvalue %14[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %96 = llvm.bitcast %95 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %97 = llvm.insertvalue %96, %94[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %98 = llvm.extractvalue %14[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %99 = llvm.extractvalue %14[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %100 = llvm.extractvalue %14[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %101 = llvm.mul %57, %98  : i64
          %102 = llvm.add %100, %101  : i64
          %103 = llvm.mul %61, %99  : i64
          %104 = llvm.add %102, %103  : i64
          %105 = llvm.insertvalue %104, %97[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %106 = llvm.insertvalue %71, %105[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %107 = llvm.insertvalue %86, %106[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %108 = llvm.insertvalue %67, %107[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %109 = llvm.insertvalue %89, %108[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %110 = llvm.extractvalue %39[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %111 = llvm.bitcast %110 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %112 = llvm.insertvalue %111, %34[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %113 = llvm.extractvalue %39[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %114 = llvm.bitcast %113 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %115 = llvm.insertvalue %114, %112[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %116 = llvm.extractvalue %39[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %117 = llvm.extractvalue %39[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %118 = llvm.mul %61, %116  : i64
          %119 = llvm.add %117, %118  : i64
          %120 = llvm.insertvalue %119, %115[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %121 = llvm.insertvalue %71, %120[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %122 = llvm.insertvalue %86, %121[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          llvm.br ^bb5(%1 : i64)
        ^bb5(%123: i64):  // 2 preds: ^bb4, ^bb8
          %124 = llvm.icmp "slt" %123, %67 : i64
          llvm.cond_br %124, ^bb6(%1 : i64), ^bb9
        ^bb6(%125: i64):  // 2 preds: ^bb5, ^bb7
          %126 = llvm.icmp "slt" %125, %71 : i64
          llvm.cond_br %126, ^bb7, ^bb8
        ^bb7:  // pred: ^bb6
          %127 = llvm.extractvalue %91[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %128 = llvm.extractvalue %91[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %129 = llvm.mul %123, %0  : i64
          %130 = llvm.add %128, %129  : i64
          %131 = llvm.add %130, %125  : i64
          %132 = llvm.getelementptr %127[%131] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
          %133 = llvm.load %132 : !llvm.ptr<f32>
          %134 = llvm.extractvalue %109[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %135 = llvm.extractvalue %109[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %136 = llvm.add %135, %129  : i64
          %137 = llvm.add %136, %125  : i64
          %138 = llvm.getelementptr %134[%137] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
          %139 = llvm.load %138 : !llvm.ptr<f32>
          %140 = llvm.fadd %133, %139  : f32
          %141 = llvm.extractvalue %122[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %142 = llvm.extractvalue %122[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %143 = llvm.add %142, %125  : i64
          %144 = llvm.getelementptr %141[%143] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
          llvm.store %140, %144 : !llvm.ptr<f32>
          %145 = llvm.add %125, %2  : i64
          llvm.br ^bb6(%145 : i64)
        ^bb8:  // pred: ^bb6
          %146 = llvm.add %123, %2  : i64
          llvm.br ^bb5(%146 : i64)
        ^bb9:  // pred: ^bb5
          %147 = llvm.add %61, %60  : i64
          llvm.br ^bb3(%147 : i64)
        ^bb10:  // pred: ^bb3
          %148 = llvm.add %57, %56  : i64
          llvm.br ^bb1(%148 : i64)
        ^bb11:  // pred: ^bb1
          %149 = llvm.mlir.constant(0 : i32) : i32
          llvm.return %149 : i32
        }
      }
    }
  }
  hal.executable @predict_dispatch_4 attributes {sym_visibility = "private"} {
    hal.interface @io {
      hal.interface.binding @s0b0_ro_external, set=0, binding=0, type="StorageBuffer", access="Read"
      hal.interface.binding @s0b1_xw_external, set=0, binding=1, type="StorageBuffer", access="Write|Discard"
    }
    hal.executable.target @llvm_aot, filter="dylib*" {
      hal.executable.entry_point @predict_dispatch_4 attributes {interface = @io, ordinal = 0 : index} {
      ^bb0(%arg0: index, %arg1: index, %arg2: index):  // no predecessors
        %c1 = constant 1 : index
        hal.return %c1, %c1, %c1 : index, index, index
      }
      module  {
        llvm.func internal @predict_dispatch_4(%arg0: !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>, %arg1: !llvm.ptr<array<3 x i32>>) -> i32 {
          %0 = llvm.mlir.constant(0x7FC00000 : f32) : f32
          %1 = llvm.mlir.constant(0xFF800000 : f32) : f32
          %2 = llvm.mlir.constant(10 : index) : i64
          %3 = llvm.mlir.constant(0 : index) : i64
          %4 = llvm.mlir.constant(1 : index) : i64
          %5 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %6 = llvm.extractvalue %5[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %7 = llvm.getelementptr %6[%3] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
          %8 = llvm.load %7 : !llvm.ptr<ptr<i8>>
          %9 = llvm.getelementptr %8[%3] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
          %10 = llvm.bitcast %9 : !llvm.ptr<i8> to !llvm.ptr<f32>
          %11 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %12 = llvm.insertvalue %10, %11[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %13 = llvm.insertvalue %10, %12[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %14 = llvm.insertvalue %3, %13[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %15 = llvm.insertvalue %2, %14[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %16 = llvm.insertvalue %4, %15[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %17 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %18 = llvm.extractvalue %17[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %19 = llvm.getelementptr %18[%4] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
          %20 = llvm.load %19 : !llvm.ptr<ptr<i8>>
          %21 = llvm.getelementptr %20[%3] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
          %22 = llvm.bitcast %21 : !llvm.ptr<i8> to !llvm.ptr<f32>
          %23 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
          %24 = llvm.insertvalue %22, %23[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
          %25 = llvm.insertvalue %22, %24[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
          %26 = llvm.insertvalue %3, %25[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
          %27 = llvm.extractvalue %26[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
          llvm.store %1, %27 : !llvm.ptr<f32>
          llvm.br ^bb1(%3 : i64)
        ^bb1(%28: i64):  // 2 preds: ^bb0, ^bb2
          %29 = llvm.icmp "slt" %28, %2 : i64
          llvm.cond_br %29, ^bb2, ^bb3
        ^bb2:  // pred: ^bb1
          %30 = llvm.extractvalue %16[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %31 = llvm.getelementptr %30[%28] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
          %32 = llvm.load %31 : !llvm.ptr<f32>
          %33 = llvm.load %27 : !llvm.ptr<f32>
          %34 = llvm.fcmp "ogt" %32, %33 : f32
          %35 = llvm.select %34, %32, %33 : i1, f32
          %36 = llvm.fcmp "uno" %32, %33 : f32
          %37 = llvm.select %36, %0, %35 : i1, f32
          llvm.store %37, %27 : !llvm.ptr<f32>
          %38 = llvm.add %28, %4  : i64
          llvm.br ^bb1(%38 : i64)
        ^bb3:  // pred: ^bb1
          %39 = llvm.mlir.constant(0 : i32) : i32
          llvm.return %39 : i32
        }
      }
    }
  }
  hal.executable @predict_dispatch_5 attributes {sym_visibility = "private"} {
    hal.interface @io {
      hal.interface.binding @s0b0_ro_external, set=0, binding=0, type="StorageBuffer", access="Read"
      hal.interface.binding @s0b1_ro_external, set=0, binding=1, type="StorageBuffer", access="Read"
      hal.interface.binding @s0b2_xw_external, set=0, binding=2, type="StorageBuffer", access="Write|Discard"
    }
    hal.executable.target @llvm_aot, filter="dylib*" {
      hal.executable.entry_point @predict_dispatch_5 attributes {interface = @io, ordinal = 0 : index} {
      ^bb0(%arg0: index, %arg1: index, %arg2: index):  // no predecessors
        %c1 = constant 1 : index
        %0 = affine.apply #map2()[%arg0]
        %1 = affine.apply #map2()[%arg1]
        hal.return %0, %1, %c1 : index, index, index
      }
      module  {
        llvm.mlir.global private constant @__constant_1x10xf32(opaque<"_", "0xDEADBEEF"> : tensor<1x10xf32>) : !llvm.array<1 x array<10 x f32>>
        llvm.func internal @predict_dispatch_5(%arg0: !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>, %arg1: !llvm.ptr<array<3 x i32>>) -> i32 {
          %0 = llvm.mlir.constant(10 : index) : i64
          %1 = llvm.mlir.constant(0 : index) : i64
          %2 = llvm.mlir.constant(1 : index) : i64
          %3 = llvm.mlir.constant(0.693147182 : f32) : f32
          %4 = llvm.mlir.constant(1.44269502 : f32) : f32
          %5 = llvm.mlir.constant(1.000000e+00 : f32) : f32
          %6 = llvm.mlir.constant(0.499705136 : f32) : f32
          %7 = llvm.mlir.constant(0.168738902 : f32) : f32
          %8 = llvm.mlir.constant(0.0366896503 : f32) : f32
          %9 = llvm.mlir.constant(1.314350e-02 : f32) : f32
          %10 = llvm.mlir.constant(23 : i32) : i32
          %11 = llvm.mlir.constant(0.000000e+00 : f32) : f32
          %12 = llvm.mlir.constant(0x7F800000 : f32) : f32
          %13 = llvm.mlir.constant(0xFF800000 : f32) : f32
          %14 = llvm.mlir.constant(1.17549435E-38 : f32) : f32
          %15 = llvm.mlir.constant(127 : i32) : i32
          %16 = llvm.mlir.constant(-127 : i32) : i32
          %17 = llvm.mlir.addressof @__constant_1x10xf32 : !llvm.ptr<array<1 x array<10 x f32>>>
          %18 = llvm.getelementptr %17[%1, %1, %1] : (!llvm.ptr<array<1 x array<10 x f32>>>, i64, i64, i64) -> !llvm.ptr<f32>
          %19 = llvm.mlir.constant(3735928559 : index) : i64
          %20 = llvm.inttoptr %19 : i64 to !llvm.ptr<f32>
          %21 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %22 = llvm.insertvalue %20, %21[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %23 = llvm.insertvalue %18, %22[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %24 = llvm.insertvalue %1, %23[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %25 = llvm.insertvalue %2, %24[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %26 = llvm.insertvalue %0, %25[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %27 = llvm.insertvalue %0, %26[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %28 = llvm.insertvalue %2, %27[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %29 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %30 = llvm.extractvalue %29[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %31 = llvm.getelementptr %30[%1] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
          %32 = llvm.load %31 : !llvm.ptr<ptr<i8>>
          %33 = llvm.getelementptr %32[%1] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
          %34 = llvm.bitcast %33 : !llvm.ptr<i8> to !llvm.ptr<f32>
          %35 = llvm.insertvalue %34, %21[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %36 = llvm.insertvalue %34, %35[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %37 = llvm.insertvalue %1, %36[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %38 = llvm.insertvalue %2, %37[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %39 = llvm.insertvalue %0, %38[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %40 = llvm.insertvalue %0, %39[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %41 = llvm.insertvalue %2, %40[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %42 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %43 = llvm.extractvalue %42[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %44 = llvm.getelementptr %43[%2] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
          %45 = llvm.load %44 : !llvm.ptr<ptr<i8>>
          %46 = llvm.getelementptr %45[%1] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
          %47 = llvm.bitcast %46 : !llvm.ptr<i8> to !llvm.ptr<f32>
          %48 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
          %49 = llvm.insertvalue %47, %48[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
          %50 = llvm.insertvalue %47, %49[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
          %51 = llvm.insertvalue %1, %50[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
          %52 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %53 = llvm.extractvalue %52[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %54 = llvm.mlir.constant(2 : index) : i64
          %55 = llvm.getelementptr %53[%54] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
          %56 = llvm.load %55 : !llvm.ptr<ptr<i8>>
          %57 = llvm.getelementptr %56[%1] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
          %58 = llvm.bitcast %57 : !llvm.ptr<i8> to !llvm.ptr<f32>
          %59 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %60 = llvm.insertvalue %58, %59[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %61 = llvm.insertvalue %58, %60[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %62 = llvm.insertvalue %1, %61[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %63 = llvm.insertvalue %0, %62[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %64 = llvm.insertvalue %2, %63[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %65 = llvm.load %arg1 : !llvm.ptr<array<3 x i32>>
          %66 = llvm.extractvalue %65[0] : !llvm.array<3 x i32>
          %67 = llvm.zext %66 : i32 to i64
          %68 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %69 = llvm.extractvalue %68[0] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %70 = llvm.extractvalue %69[0] : !llvm.array<3 x i32>
          %71 = llvm.zext %70 : i32 to i64
          %72 = llvm.load %arg1 : !llvm.ptr<array<3 x i32>>
          %73 = llvm.extractvalue %72[1] : !llvm.array<3 x i32>
          %74 = llvm.zext %73 : i32 to i64
          %75 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %76 = llvm.extractvalue %75[0] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %77 = llvm.extractvalue %76[1] : !llvm.array<3 x i32>
          %78 = llvm.zext %77 : i32 to i64
          %79 = llvm.mlir.constant(128 : index) : i64
          %80 = llvm.mul %74, %79  : i64
          %81 = llvm.mul %78, %79  : i64
          llvm.br ^bb1(%80 : i64)
        ^bb1(%82: i64):  // 2 preds: ^bb0, ^bb10
          %83 = llvm.icmp "slt" %82, %2 : i64
          llvm.cond_br %83, ^bb2, ^bb11
        ^bb2:  // pred: ^bb1
          %84 = llvm.mul %67, %79  : i64
          %85 = llvm.mul %71, %79  : i64
          llvm.br ^bb3(%84 : i64)
        ^bb3(%86: i64):  // 2 preds: ^bb2, ^bb9
          %87 = llvm.icmp "slt" %86, %0 : i64
          llvm.cond_br %87, ^bb4, ^bb10
        ^bb4:  // pred: ^bb3
          %88 = llvm.mlir.constant(-1 : index) : i64
          %89 = llvm.mul %82, %88  : i64
          %90 = llvm.add %89, %2  : i64
          %91 = llvm.icmp "slt" %79, %90 : i64
          %92 = llvm.select %91, %79, %90 : i1, i64
          %93 = llvm.mul %86, %88  : i64
          %94 = llvm.add %93, %0  : i64
          %95 = llvm.icmp "slt" %79, %94 : i64
          %96 = llvm.select %95, %79, %94 : i1, i64
          %97 = llvm.extractvalue %41[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %98 = llvm.bitcast %97 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %99 = llvm.insertvalue %98, %21[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %100 = llvm.extractvalue %41[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %101 = llvm.bitcast %100 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %102 = llvm.insertvalue %101, %99[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %103 = llvm.extractvalue %41[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %104 = llvm.extractvalue %41[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %105 = llvm.extractvalue %41[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %106 = llvm.mul %82, %103  : i64
          %107 = llvm.add %105, %106  : i64
          %108 = llvm.mul %86, %104  : i64
          %109 = llvm.add %107, %108  : i64
          %110 = llvm.insertvalue %109, %102[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %111 = llvm.mlir.constant(1 : i64) : i64
          %112 = llvm.insertvalue %96, %110[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %113 = llvm.insertvalue %111, %112[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %114 = llvm.mlir.constant(10 : i64) : i64
          %115 = llvm.insertvalue %92, %113[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %116 = llvm.insertvalue %114, %115[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %117 = llvm.extractvalue %28[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %118 = llvm.bitcast %117 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %119 = llvm.insertvalue %118, %21[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %120 = llvm.extractvalue %28[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %121 = llvm.bitcast %120 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %122 = llvm.insertvalue %121, %119[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %123 = llvm.extractvalue %28[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %124 = llvm.extractvalue %28[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %125 = llvm.extractvalue %28[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %126 = llvm.mul %82, %123  : i64
          %127 = llvm.add %125, %126  : i64
          %128 = llvm.mul %86, %124  : i64
          %129 = llvm.add %127, %128  : i64
          %130 = llvm.insertvalue %129, %122[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %131 = llvm.insertvalue %96, %130[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %132 = llvm.insertvalue %111, %131[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %133 = llvm.insertvalue %92, %132[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %134 = llvm.insertvalue %114, %133[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %135 = llvm.extractvalue %64[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %136 = llvm.bitcast %135 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %137 = llvm.insertvalue %136, %59[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %138 = llvm.extractvalue %64[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %139 = llvm.bitcast %138 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %140 = llvm.insertvalue %139, %137[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %141 = llvm.extractvalue %64[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %142 = llvm.extractvalue %64[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %143 = llvm.mul %86, %141  : i64
          %144 = llvm.add %142, %143  : i64
          %145 = llvm.insertvalue %144, %140[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %146 = llvm.insertvalue %96, %145[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %147 = llvm.insertvalue %111, %146[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          llvm.br ^bb5(%1 : i64)
        ^bb5(%148: i64):  // 2 preds: ^bb4, ^bb8
          %149 = llvm.icmp "slt" %148, %92 : i64
          llvm.cond_br %149, ^bb6(%1 : i64), ^bb9
        ^bb6(%150: i64):  // 2 preds: ^bb5, ^bb7
          %151 = llvm.icmp "slt" %150, %96 : i64
          llvm.cond_br %151, ^bb7, ^bb8
        ^bb7:  // pred: ^bb6
          %152 = llvm.extractvalue %116[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %153 = llvm.extractvalue %116[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %154 = llvm.mul %148, %0  : i64
          %155 = llvm.add %153, %154  : i64
          %156 = llvm.add %155, %150  : i64
          %157 = llvm.getelementptr %152[%156] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
          %158 = llvm.load %157 : !llvm.ptr<f32>
          %159 = llvm.extractvalue %134[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %160 = llvm.extractvalue %134[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %161 = llvm.add %160, %154  : i64
          %162 = llvm.add %161, %150  : i64
          %163 = llvm.getelementptr %159[%162] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
          %164 = llvm.load %163 : !llvm.ptr<f32>
          %165 = llvm.extractvalue %51[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
          %166 = llvm.load %165 : !llvm.ptr<f32>
          %167 = llvm.fadd %158, %164  : f32
          %168 = llvm.fsub %167, %166  : f32
          %169 = llvm.fmul %168, %4  : f32
          %170 = "llvm.intr.floor"(%169) : (f32) -> f32
          %171 = llvm.fmul %170, %3  : f32
          %172 = llvm.fsub %168, %171  : f32
          %173 = llvm.fmul %172, %172  : f32
          %174 = llvm.fmul %173, %173  : f32
          %175 = "llvm.intr.fma"(%5, %172, %5) : (f32, f32, f32) -> f32
          %176 = "llvm.intr.fma"(%7, %172, %6) : (f32, f32, f32) -> f32
          %177 = "llvm.intr.fma"(%9, %172, %8) : (f32, f32, f32) -> f32
          %178 = "llvm.intr.fma"(%176, %173, %175) : (f32, f32, f32) -> f32
          %179 = "llvm.intr.fma"(%177, %174, %178) : (f32, f32, f32) -> f32
          %180 = llvm.fptosi %170 : f32 to i32
          %181 = llvm.add %180, %15  : i32
          %182 = llvm.shl %181, %10  : i32
          %183 = llvm.bitcast %182 : i32 to f32
          %184 = llvm.fmul %179, %183  : f32
          %185 = llvm.icmp "sle" %180, %15 : i32
          %186 = llvm.icmp "sge" %180, %16 : i32
          %187 = llvm.fcmp "oeq" %168, %13 : f32
          %188 = llvm.fcmp "ogt" %168, %11 : f32
          %189 = llvm.and %185, %186  : i1
          %190 = llvm.select %187, %11, %14 : i1, f32
          %191 = llvm.select %188, %12, %190 : i1, f32
          %192 = llvm.select %189, %184, %191 : i1, f32
          %193 = llvm.extractvalue %147[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %194 = llvm.extractvalue %147[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %195 = llvm.add %194, %150  : i64
          %196 = llvm.getelementptr %193[%195] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
          llvm.store %192, %196 : !llvm.ptr<f32>
          %197 = llvm.add %150, %2  : i64
          llvm.br ^bb6(%197 : i64)
        ^bb8:  // pred: ^bb6
          %198 = llvm.add %148, %2  : i64
          llvm.br ^bb5(%198 : i64)
        ^bb9:  // pred: ^bb5
          %199 = llvm.add %86, %85  : i64
          llvm.br ^bb3(%199 : i64)
        ^bb10:  // pred: ^bb3
          %200 = llvm.add %82, %81  : i64
          llvm.br ^bb1(%200 : i64)
        ^bb11:  // pred: ^bb1
          %201 = llvm.mlir.constant(0 : i32) : i32
          llvm.return %201 : i32
        }
      }
    }
  }
  hal.executable @predict_dispatch_6 attributes {sym_visibility = "private"} {
    hal.interface @io {
      hal.interface.binding @s0b0_ro_external, set=0, binding=0, type="StorageBuffer", access="Read"
      hal.interface.binding @s0b1_xw_external, set=0, binding=1, type="StorageBuffer", access="Write|Discard"
    }
    hal.executable.target @llvm_aot, filter="dylib*" {
      hal.executable.entry_point @predict_dispatch_6 attributes {interface = @io, ordinal = 0 : index} {
      ^bb0(%arg0: index, %arg1: index, %arg2: index):  // no predecessors
        %c1 = constant 1 : index
        hal.return %c1, %c1, %c1 : index, index, index
      }
      module  {
        llvm.func internal @predict_dispatch_6(%arg0: !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>, %arg1: !llvm.ptr<array<3 x i32>>) -> i32 {
          %0 = llvm.mlir.constant(0.000000e+00 : f32) : f32
          %1 = llvm.mlir.constant(10 : index) : i64
          %2 = llvm.mlir.constant(0 : index) : i64
          %3 = llvm.mlir.constant(1 : index) : i64
          %4 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %5 = llvm.extractvalue %4[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %6 = llvm.getelementptr %5[%2] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
          %7 = llvm.load %6 : !llvm.ptr<ptr<i8>>
          %8 = llvm.getelementptr %7[%2] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
          %9 = llvm.bitcast %8 : !llvm.ptr<i8> to !llvm.ptr<f32>
          %10 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %11 = llvm.insertvalue %9, %10[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %12 = llvm.insertvalue %9, %11[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %13 = llvm.insertvalue %2, %12[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %14 = llvm.insertvalue %1, %13[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %15 = llvm.insertvalue %3, %14[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %16 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %17 = llvm.extractvalue %16[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %18 = llvm.getelementptr %17[%3] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
          %19 = llvm.load %18 : !llvm.ptr<ptr<i8>>
          %20 = llvm.getelementptr %19[%2] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
          %21 = llvm.bitcast %20 : !llvm.ptr<i8> to !llvm.ptr<f32>
          %22 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
          %23 = llvm.insertvalue %21, %22[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
          %24 = llvm.insertvalue %21, %23[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
          %25 = llvm.insertvalue %2, %24[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
          %26 = llvm.extractvalue %25[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
          llvm.store %0, %26 : !llvm.ptr<f32>
          llvm.br ^bb1(%2 : i64)
        ^bb1(%27: i64):  // 2 preds: ^bb0, ^bb2
          %28 = llvm.icmp "slt" %27, %1 : i64
          llvm.cond_br %28, ^bb2, ^bb3
        ^bb2:  // pred: ^bb1
          %29 = llvm.extractvalue %15[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %30 = llvm.getelementptr %29[%27] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
          %31 = llvm.load %30 : !llvm.ptr<f32>
          %32 = llvm.load %26 : !llvm.ptr<f32>
          %33 = llvm.fadd %31, %32  : f32
          llvm.store %33, %26 : !llvm.ptr<f32>
          %34 = llvm.add %27, %3  : i64
          llvm.br ^bb1(%34 : i64)
        ^bb3:  // pred: ^bb1
          %35 = llvm.mlir.constant(0 : i32) : i32
          llvm.return %35 : i32
        }
      }
    }
  }
  hal.executable @predict_dispatch_7 attributes {sym_visibility = "private"} {
    hal.interface @io {
      hal.interface.binding @s0b0_ro_external, set=0, binding=0, type="StorageBuffer", access="Read"
      hal.interface.binding @s0b1_ro_external, set=0, binding=1, type="StorageBuffer", access="Read"
      hal.interface.binding @s0b2_ro_external, set=0, binding=2, type="StorageBuffer", access="Read"
      hal.interface.binding @s0b3_xw_external, set=0, binding=3, type="StorageBuffer", access="Write|Discard"
    }
    hal.executable.target @llvm_aot, filter="dylib*" {
      hal.executable.entry_point @predict_dispatch_7 attributes {interface = @io, ordinal = 0 : index} {
      ^bb0(%arg0: index, %arg1: index, %arg2: index):  // no predecessors
        %c1 = constant 1 : index
        %0 = affine.apply #map2()[%arg0]
        %1 = affine.apply #map2()[%arg1]
        hal.return %0, %1, %c1 : index, index, index
      }
      module  {
        llvm.mlir.global private constant @__constant_1x10xf32(opaque<"_", "0xDEADBEEF"> : tensor<1x10xf32>) : !llvm.array<1 x array<10 x f32>>
        llvm.func internal @predict_dispatch_7(%arg0: !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>, %arg1: !llvm.ptr<array<3 x i32>>) -> i32 {
          %0 = llvm.mlir.constant(10 : index) : i64
          %1 = llvm.mlir.constant(0 : index) : i64
          %2 = llvm.mlir.constant(1 : index) : i64
          %3 = llvm.mlir.constant(0.693147182 : f32) : f32
          %4 = llvm.mlir.constant(1.44269502 : f32) : f32
          %5 = llvm.mlir.constant(1.000000e+00 : f32) : f32
          %6 = llvm.mlir.constant(0.499705136 : f32) : f32
          %7 = llvm.mlir.constant(0.168738902 : f32) : f32
          %8 = llvm.mlir.constant(0.0366896503 : f32) : f32
          %9 = llvm.mlir.constant(1.314350e-02 : f32) : f32
          %10 = llvm.mlir.constant(23 : i32) : i32
          %11 = llvm.mlir.constant(0.000000e+00 : f32) : f32
          %12 = llvm.mlir.constant(0x7F800000 : f32) : f32
          %13 = llvm.mlir.constant(0xFF800000 : f32) : f32
          %14 = llvm.mlir.constant(1.17549435E-38 : f32) : f32
          %15 = llvm.mlir.constant(127 : i32) : i32
          %16 = llvm.mlir.constant(-127 : i32) : i32
          %17 = llvm.mlir.addressof @__constant_1x10xf32 : !llvm.ptr<array<1 x array<10 x f32>>>
          %18 = llvm.getelementptr %17[%1, %1, %1] : (!llvm.ptr<array<1 x array<10 x f32>>>, i64, i64, i64) -> !llvm.ptr<f32>
          %19 = llvm.mlir.constant(3735928559 : index) : i64
          %20 = llvm.inttoptr %19 : i64 to !llvm.ptr<f32>
          %21 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %22 = llvm.insertvalue %20, %21[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %23 = llvm.insertvalue %18, %22[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %24 = llvm.insertvalue %1, %23[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %25 = llvm.insertvalue %2, %24[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %26 = llvm.insertvalue %0, %25[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %27 = llvm.insertvalue %0, %26[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %28 = llvm.insertvalue %2, %27[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %29 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %30 = llvm.extractvalue %29[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %31 = llvm.getelementptr %30[%1] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
          %32 = llvm.load %31 : !llvm.ptr<ptr<i8>>
          %33 = llvm.getelementptr %32[%1] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
          %34 = llvm.bitcast %33 : !llvm.ptr<i8> to !llvm.ptr<f32>
          %35 = llvm.insertvalue %34, %21[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %36 = llvm.insertvalue %34, %35[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %37 = llvm.insertvalue %1, %36[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %38 = llvm.insertvalue %2, %37[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %39 = llvm.insertvalue %0, %38[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %40 = llvm.insertvalue %0, %39[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %41 = llvm.insertvalue %2, %40[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %42 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %43 = llvm.extractvalue %42[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %44 = llvm.getelementptr %43[%2] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
          %45 = llvm.load %44 : !llvm.ptr<ptr<i8>>
          %46 = llvm.getelementptr %45[%1] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
          %47 = llvm.bitcast %46 : !llvm.ptr<i8> to !llvm.ptr<f32>
          %48 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
          %49 = llvm.insertvalue %47, %48[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
          %50 = llvm.insertvalue %47, %49[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
          %51 = llvm.insertvalue %1, %50[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
          %52 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %53 = llvm.extractvalue %52[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %54 = llvm.mlir.constant(2 : index) : i64
          %55 = llvm.getelementptr %53[%54] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
          %56 = llvm.load %55 : !llvm.ptr<ptr<i8>>
          %57 = llvm.getelementptr %56[%1] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
          %58 = llvm.bitcast %57 : !llvm.ptr<i8> to !llvm.ptr<f32>
          %59 = llvm.insertvalue %58, %48[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
          %60 = llvm.insertvalue %58, %59[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
          %61 = llvm.insertvalue %1, %60[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
          %62 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %63 = llvm.extractvalue %62[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %64 = llvm.mlir.constant(3 : index) : i64
          %65 = llvm.getelementptr %63[%64] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
          %66 = llvm.load %65 : !llvm.ptr<ptr<i8>>
          %67 = llvm.getelementptr %66[%1] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
          %68 = llvm.bitcast %67 : !llvm.ptr<i8> to !llvm.ptr<f32>
          %69 = llvm.insertvalue %68, %21[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %70 = llvm.insertvalue %68, %69[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %71 = llvm.insertvalue %1, %70[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %72 = llvm.insertvalue %2, %71[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %73 = llvm.insertvalue %0, %72[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %74 = llvm.insertvalue %0, %73[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %75 = llvm.insertvalue %2, %74[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %76 = llvm.load %arg1 : !llvm.ptr<array<3 x i32>>
          %77 = llvm.extractvalue %76[0] : !llvm.array<3 x i32>
          %78 = llvm.zext %77 : i32 to i64
          %79 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %80 = llvm.extractvalue %79[0] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %81 = llvm.extractvalue %80[0] : !llvm.array<3 x i32>
          %82 = llvm.zext %81 : i32 to i64
          %83 = llvm.load %arg1 : !llvm.ptr<array<3 x i32>>
          %84 = llvm.extractvalue %83[1] : !llvm.array<3 x i32>
          %85 = llvm.zext %84 : i32 to i64
          %86 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %87 = llvm.extractvalue %86[0] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %88 = llvm.extractvalue %87[1] : !llvm.array<3 x i32>
          %89 = llvm.zext %88 : i32 to i64
          %90 = llvm.mlir.constant(128 : index) : i64
          %91 = llvm.mul %85, %90  : i64
          %92 = llvm.mul %89, %90  : i64
          llvm.br ^bb1(%91 : i64)
        ^bb1(%93: i64):  // 2 preds: ^bb0, ^bb10
          %94 = llvm.icmp "slt" %93, %2 : i64
          llvm.cond_br %94, ^bb2, ^bb11
        ^bb2:  // pred: ^bb1
          %95 = llvm.mul %78, %90  : i64
          %96 = llvm.mul %82, %90  : i64
          llvm.br ^bb3(%95 : i64)
        ^bb3(%97: i64):  // 2 preds: ^bb2, ^bb9
          %98 = llvm.icmp "slt" %97, %0 : i64
          llvm.cond_br %98, ^bb4, ^bb10
        ^bb4:  // pred: ^bb3
          %99 = llvm.mlir.constant(-1 : index) : i64
          %100 = llvm.mul %93, %99  : i64
          %101 = llvm.add %100, %2  : i64
          %102 = llvm.icmp "slt" %90, %101 : i64
          %103 = llvm.select %102, %90, %101 : i1, i64
          %104 = llvm.mul %97, %99  : i64
          %105 = llvm.add %104, %0  : i64
          %106 = llvm.icmp "slt" %90, %105 : i64
          %107 = llvm.select %106, %90, %105 : i1, i64
          %108 = llvm.extractvalue %41[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %109 = llvm.bitcast %108 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %110 = llvm.insertvalue %109, %21[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %111 = llvm.extractvalue %41[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %112 = llvm.bitcast %111 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %113 = llvm.insertvalue %112, %110[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %114 = llvm.extractvalue %41[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %115 = llvm.extractvalue %41[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %116 = llvm.extractvalue %41[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %117 = llvm.mul %93, %114  : i64
          %118 = llvm.add %116, %117  : i64
          %119 = llvm.mul %97, %115  : i64
          %120 = llvm.add %118, %119  : i64
          %121 = llvm.insertvalue %120, %113[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %122 = llvm.mlir.constant(1 : i64) : i64
          %123 = llvm.insertvalue %107, %121[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %124 = llvm.insertvalue %122, %123[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %125 = llvm.mlir.constant(10 : i64) : i64
          %126 = llvm.insertvalue %103, %124[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %127 = llvm.insertvalue %125, %126[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %128 = llvm.extractvalue %28[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %129 = llvm.bitcast %128 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %130 = llvm.insertvalue %129, %21[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %131 = llvm.extractvalue %28[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %132 = llvm.bitcast %131 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %133 = llvm.insertvalue %132, %130[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %134 = llvm.extractvalue %28[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %135 = llvm.extractvalue %28[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %136 = llvm.extractvalue %28[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %137 = llvm.mul %93, %134  : i64
          %138 = llvm.add %136, %137  : i64
          %139 = llvm.mul %97, %135  : i64
          %140 = llvm.add %138, %139  : i64
          %141 = llvm.insertvalue %140, %133[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %142 = llvm.insertvalue %107, %141[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %143 = llvm.insertvalue %122, %142[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %144 = llvm.insertvalue %103, %143[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %145 = llvm.insertvalue %125, %144[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %146 = llvm.extractvalue %75[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %147 = llvm.bitcast %146 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %148 = llvm.insertvalue %147, %21[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %149 = llvm.extractvalue %75[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %150 = llvm.bitcast %149 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %151 = llvm.insertvalue %150, %148[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %152 = llvm.extractvalue %75[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %153 = llvm.extractvalue %75[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %154 = llvm.extractvalue %75[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %155 = llvm.mul %93, %152  : i64
          %156 = llvm.add %154, %155  : i64
          %157 = llvm.mul %97, %153  : i64
          %158 = llvm.add %156, %157  : i64
          %159 = llvm.insertvalue %158, %151[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %160 = llvm.insertvalue %107, %159[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %161 = llvm.insertvalue %122, %160[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %162 = llvm.insertvalue %103, %161[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %163 = llvm.insertvalue %125, %162[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          llvm.br ^bb5(%1 : i64)
        ^bb5(%164: i64):  // 2 preds: ^bb4, ^bb8
          %165 = llvm.icmp "slt" %164, %103 : i64
          llvm.cond_br %165, ^bb6(%1 : i64), ^bb9
        ^bb6(%166: i64):  // 2 preds: ^bb5, ^bb7
          %167 = llvm.icmp "slt" %166, %107 : i64
          llvm.cond_br %167, ^bb7, ^bb8
        ^bb7:  // pred: ^bb6
          %168 = llvm.extractvalue %127[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %169 = llvm.extractvalue %127[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %170 = llvm.mul %164, %0  : i64
          %171 = llvm.add %169, %170  : i64
          %172 = llvm.add %171, %166  : i64
          %173 = llvm.getelementptr %168[%172] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
          %174 = llvm.load %173 : !llvm.ptr<f32>
          %175 = llvm.extractvalue %145[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %176 = llvm.extractvalue %145[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %177 = llvm.add %176, %170  : i64
          %178 = llvm.add %177, %166  : i64
          %179 = llvm.getelementptr %175[%178] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
          %180 = llvm.load %179 : !llvm.ptr<f32>
          %181 = llvm.extractvalue %51[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
          %182 = llvm.load %181 : !llvm.ptr<f32>
          %183 = llvm.extractvalue %61[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
          %184 = llvm.load %183 : !llvm.ptr<f32>
          %185 = llvm.fadd %174, %180  : f32
          %186 = llvm.fsub %185, %182  : f32
          %187 = llvm.fmul %186, %4  : f32
          %188 = "llvm.intr.floor"(%187) : (f32) -> f32
          %189 = llvm.fmul %188, %3  : f32
          %190 = llvm.fsub %186, %189  : f32
          %191 = llvm.fmul %190, %190  : f32
          %192 = llvm.fmul %191, %191  : f32
          %193 = "llvm.intr.fma"(%5, %190, %5) : (f32, f32, f32) -> f32
          %194 = "llvm.intr.fma"(%7, %190, %6) : (f32, f32, f32) -> f32
          %195 = "llvm.intr.fma"(%9, %190, %8) : (f32, f32, f32) -> f32
          %196 = "llvm.intr.fma"(%194, %191, %193) : (f32, f32, f32) -> f32
          %197 = "llvm.intr.fma"(%195, %192, %196) : (f32, f32, f32) -> f32
          %198 = llvm.fptosi %188 : f32 to i32
          %199 = llvm.add %198, %15  : i32
          %200 = llvm.shl %199, %10  : i32
          %201 = llvm.bitcast %200 : i32 to f32
          %202 = llvm.fmul %197, %201  : f32
          %203 = llvm.icmp "sle" %198, %15 : i32
          %204 = llvm.icmp "sge" %198, %16 : i32
          %205 = llvm.fcmp "oeq" %186, %13 : f32
          %206 = llvm.fcmp "ogt" %186, %11 : f32
          %207 = llvm.and %203, %204  : i1
          %208 = llvm.select %205, %11, %14 : i1, f32
          %209 = llvm.select %206, %12, %208 : i1, f32
          %210 = llvm.select %207, %202, %209 : i1, f32
          %211 = llvm.fdiv %210, %184  : f32
          %212 = llvm.extractvalue %163[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %213 = llvm.extractvalue %163[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %214 = llvm.add %213, %170  : i64
          %215 = llvm.add %214, %166  : i64
          %216 = llvm.getelementptr %212[%215] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
          llvm.store %211, %216 : !llvm.ptr<f32>
          %217 = llvm.add %166, %2  : i64
          llvm.br ^bb6(%217 : i64)
        ^bb8:  // pred: ^bb6
          %218 = llvm.add %164, %2  : i64
          llvm.br ^bb5(%218 : i64)
        ^bb9:  // pred: ^bb5
          %219 = llvm.add %97, %96  : i64
          llvm.br ^bb3(%219 : i64)
        ^bb10:  // pred: ^bb3
          %220 = llvm.add %93, %92  : i64
          llvm.br ^bb1(%220 : i64)
        ^bb11:  // pred: ^bb1
          %221 = llvm.mlir.constant(0 : i32) : i32
          llvm.return %221 : i32
        }
      }
    }
  }
  func @predict(%arg0: !hal.buffer) -> !hal.buffer attributes {noinline} {
    %c3136 = constant 3136 : index
    %c401408 = constant 401408 : index
    %c0 = constant 0 : index
    %c401920 = constant 401920 : index
    %c5120 = constant 5120 : index
    %c512 = constant 512 : index
    %c40 = constant 40 : index
    %c4 = constant 4 : index
    %c128 = constant 128 : index
    %c1 = constant 1 : index
    %c10 = constant 10 : index
    %c2 = constant 2 : index
    %c3 = constant 3 : index
    %device = hal.ex.shared_device : !hal.device
    %allocator = hal.device.allocator<%device : !hal.device> : !hal.allocator
    %buffer = hal.allocator.allocate<%allocator : !hal.allocator> type("HostVisible|DeviceVisible|DeviceLocal") usage("Transfer|Mapping|Dispatch") : !hal.buffer{%c40}
    %0 = hal.variable.load @_const_pool_storage_buffer : !hal.buffer
    %c0_0 = constant 0 : index
    %c0_1 = constant 0 : index
    %c512_2 = constant 512 : index
    %c512_3 = constant 512 : index
    %c0_4 = constant 0 : index
    %c48 = constant 48 : index
    %c48_5 = constant 48 : index
    %c96 = constant 96 : index
    %c96_6 = constant 96 : index
    %c48_7 = constant 48 : index
    %c48_8 = constant 48 : index
    %c112 = constant 112 : index
    %c112_9 = constant 112 : index
    %c1024 = constant 1024 : index
    %c1024_10 = constant 1024 : index
    %buffer_11 = hal.allocator.allocate<%allocator : !hal.allocator> type("DeviceVisible|DeviceLocal") usage("Transfer|Dispatch") : !hal.buffer{%c1024_10}
    %cmd = hal.command_buffer.create device(%device : !hal.device) mode("OneShot|AllowInlineExecution") categories("Transfer|Dispatch") : !hal.command_buffer
    hal.command_buffer.begin<%cmd : !hal.command_buffer>
    %executable_layout = hal.executable_layout.lookup device(%device : !hal.device) layouts([[#hal.descriptor_set_layout_binding<0, "StorageBuffer", R>, #hal.descriptor_set_layout_binding<1, "StorageBuffer", R>, #hal.descriptor_set_layout_binding<2, "StorageBuffer", DW>]]) : !hal.executable_layout
    hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%executable_layout : !hal.executable_layout)[%c0] bindings([
      %c0 = (%0 : !hal.buffer)[%c512, %c401408], 
      %c1 = (%arg0 : !hal.buffer)[%c0, %c3136], 
      %c2 = (%buffer_11 : !hal.buffer)[%c0_0, %c512]
    ])
    hal.device.switch<%device : !hal.device>
    #hal.device.match.id<"dylib*">(%arg1 = %cmd : !hal.command_buffer, %arg2 = %c128 : index, %arg3 = %c1 : index, %arg4 = %c1 : index) {
      %c1_14 = constant 1 : index
      %1 = affine.apply #map0()[%arg2]
      %2 = affine.apply #map1()[%arg3]
      hal.command_buffer.dispatch.symbol<%arg1 : !hal.command_buffer> target(@predict_dispatch_0::@llvm_aot::@predict_dispatch_0) workgroups([%1, %2, %c1_14])
      hal.return
    }
    hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
    hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%executable_layout : !hal.executable_layout)[%c0] bindings([
      %c0 = (%0 : !hal.buffer)[%c0, %c512], 
      %c1 = (%buffer_11 : !hal.buffer)[%c0_0, %c512], 
      %c2 = (%buffer_11 : !hal.buffer)[%c512_3, %c512]
    ])
    hal.device.switch<%device : !hal.device>
    #hal.device.match.id<"dylib*">(%arg1 = %cmd : !hal.command_buffer, %arg2 = %c128 : index, %arg3 = %c1 : index, %arg4 = %c1 : index) {
      %c1_14 = constant 1 : index
      %1 = affine.apply #map2()[%arg2]
      %2 = affine.apply #map2()[%arg3]
      hal.command_buffer.dispatch.symbol<%arg1 : !hal.command_buffer> target(@predict_dispatch_1::@llvm_aot::@predict_dispatch_1) workgroups([%1, %2, %c1_14])
      hal.return
    }
    hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
    hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%executable_layout : !hal.executable_layout)[%c0] bindings([
      %c0 = (%0 : !hal.buffer)[%c401920, %c5120], 
      %c1 = (%buffer_11 : !hal.buffer)[%c512_3, %c512], 
      %c2 = (%buffer_11 : !hal.buffer)[%c0_0, %c40]
    ])
    hal.device.switch<%device : !hal.device>
    #hal.device.match.id<"dylib*">(%arg1 = %cmd : !hal.command_buffer, %arg2 = %c10 : index, %arg3 = %c1 : index, %arg4 = %c1 : index) {
      %c1_14 = constant 1 : index
      %1 = affine.apply #map0()[%arg2]
      %2 = affine.apply #map1()[%arg3]
      hal.command_buffer.dispatch.symbol<%arg1 : !hal.command_buffer> target(@predict_dispatch_2::@llvm_aot::@predict_dispatch_2) workgroups([%1, %2, %c1_14])
      hal.return
    }
    hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
    %executable_layout_12 = hal.executable_layout.lookup device(%device : !hal.device) layouts([[#hal.descriptor_set_layout_binding<0, "StorageBuffer", R>, #hal.descriptor_set_layout_binding<1, "StorageBuffer", DW>]]) : !hal.executable_layout
    hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%executable_layout_12 : !hal.executable_layout)[%c0] bindings([
      %c0 = (%buffer_11 : !hal.buffer)[%c0_0, %c40], 
      %c1 = (%buffer_11 : !hal.buffer)[%c48_5, %c40]
    ])
    hal.device.switch<%device : !hal.device>
    #hal.device.match.id<"dylib*">(%arg1 = %cmd : !hal.command_buffer, %arg2 = %c10 : index, %arg3 = %c1 : index, %arg4 = %c1 : index) {
      %c1_14 = constant 1 : index
      %1 = affine.apply #map2()[%arg2]
      %2 = affine.apply #map2()[%arg3]
      hal.command_buffer.dispatch.symbol<%arg1 : !hal.command_buffer> target(@predict_dispatch_3::@llvm_aot::@predict_dispatch_3) workgroups([%1, %2, %c1_14])
      hal.return
    }
    hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
    hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%executable_layout_12 : !hal.executable_layout)[%c0] bindings([
      %c0 = (%buffer_11 : !hal.buffer)[%c48_5, %c40], 
      %c1 = (%buffer_11 : !hal.buffer)[%c96_6, %c4]
    ])
    hal.device.switch<%device : !hal.device>
    #hal.device.match.id<"dylib*">(%arg1 = %cmd : !hal.command_buffer, %arg2 = %c1 : index, %arg3 = %c1 : index, %arg4 = %c1 : index) {
      %c1_14 = constant 1 : index
      hal.command_buffer.dispatch.symbol<%arg1 : !hal.command_buffer> target(@predict_dispatch_4::@llvm_aot::@predict_dispatch_4) workgroups([%c1_14, %c1_14, %c1_14])
      hal.return
    }
    hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
    hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%executable_layout : !hal.executable_layout)[%c0] bindings([
      %c0 = (%buffer_11 : !hal.buffer)[%c0_0, %c40], 
      %c1 = (%buffer_11 : !hal.buffer)[%c96_6, %c4], 
      %c2 = (%buffer_11 : !hal.buffer)[%c48_8, %c40]
    ])
    hal.device.switch<%device : !hal.device>
    #hal.device.match.id<"dylib*">(%arg1 = %cmd : !hal.command_buffer, %arg2 = %c10 : index, %arg3 = %c1 : index, %arg4 = %c1 : index) {
      %c1_14 = constant 1 : index
      %1 = affine.apply #map2()[%arg2]
      %2 = affine.apply #map2()[%arg3]
      hal.command_buffer.dispatch.symbol<%arg1 : !hal.command_buffer> target(@predict_dispatch_5::@llvm_aot::@predict_dispatch_5) workgroups([%1, %2, %c1_14])
      hal.return
    }
    hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
    hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%executable_layout_12 : !hal.executable_layout)[%c0] bindings([
      %c0 = (%buffer_11 : !hal.buffer)[%c48_8, %c40], 
      %c1 = (%buffer_11 : !hal.buffer)[%c112_9, %c4]
    ])
    hal.device.switch<%device : !hal.device>
    #hal.device.match.id<"dylib*">(%arg1 = %cmd : !hal.command_buffer, %arg2 = %c1 : index, %arg3 = %c1 : index, %arg4 = %c1 : index) {
      %c1_14 = constant 1 : index
      hal.command_buffer.dispatch.symbol<%arg1 : !hal.command_buffer> target(@predict_dispatch_6::@llvm_aot::@predict_dispatch_6) workgroups([%c1_14, %c1_14, %c1_14])
      hal.return
    }
    hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
    %executable_layout_13 = hal.executable_layout.lookup device(%device : !hal.device) layouts([[#hal.descriptor_set_layout_binding<0, "StorageBuffer", R>, #hal.descriptor_set_layout_binding<1, "StorageBuffer", R>, #hal.descriptor_set_layout_binding<2, "StorageBuffer", R>, #hal.descriptor_set_layout_binding<3, "StorageBuffer", DW>]]) : !hal.executable_layout
    hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%executable_layout_13 : !hal.executable_layout)[%c0] bindings([
      %c0 = (%buffer_11 : !hal.buffer)[%c0_0, %c40], 
      %c1 = (%buffer_11 : !hal.buffer)[%c96_6, %c4], 
      %c2 = (%buffer_11 : !hal.buffer)[%c112_9, %c4], 
      %c3 = (%buffer : !hal.buffer)[%c0, %c40]
    ])
    hal.device.switch<%device : !hal.device>
    #hal.device.match.id<"dylib*">(%arg1 = %cmd : !hal.command_buffer, %arg2 = %c10 : index, %arg3 = %c1 : index, %arg4 = %c1 : index) {
      %c1_14 = constant 1 : index
      %1 = affine.apply #map2()[%arg2]
      %2 = affine.apply #map2()[%arg3]
      hal.command_buffer.dispatch.symbol<%arg1 : !hal.command_buffer> target(@predict_dispatch_7::@llvm_aot::@predict_dispatch_7) workgroups([%1, %2, %c1_14])
      hal.return
    }
    hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
    hal.command_buffer.end<%cmd : !hal.command_buffer>
    hal.ex.submit_and_wait %device, %cmd
    return %buffer : !hal.buffer
  }
  func @predict$async(%arg0: !hal.semaphore, %arg1: index, %arg2: !hal.buffer_view, %arg3: !hal.semaphore, %arg4: index) -> !hal.buffer_view attributes {iree.module.export = "predict$async"} {
    %0 = hal.semaphore.await<%arg0 : !hal.semaphore> until(%arg1) : i32
    hal.check_success %0, "semaphore wait failed"
    %buffer = hal.buffer_view.buffer %arg2 : !hal.buffer
    %1 = call @predict(%buffer) : (!hal.buffer) -> !hal.buffer
    %c1 = constant 1 : index
    %c10 = constant 10 : index
    %c50331680_i32 = constant 50331680 : i32
    %view = hal.buffer_view.create %1, element_type = %c50331680_i32, shape = [%c1, %c10] : !hal.buffer -> !hal.buffer_view
    hal.semaphore.signal<%arg3 : !hal.semaphore> value(%arg4)
    return %view : !hal.buffer_view
  }
  func @predict$sync(%arg0: !hal.buffer_view) -> !hal.buffer_view attributes {iree.abi.stub, iree.module.export = "predict", iree.reflection = {abi = "sip", abiv = 1 : i32, f = "I15!B11!d1d28d28d1R9!B6!d1d10", fv = "1", sip = "I8!S5!k0_0R3!_0"}} {
    %c0 = constant 0 : index
    %c1 = constant 1 : index
    %device = hal.ex.shared_device : !hal.device
    %semaphore = hal.semaphore.create device(%device : !hal.device) initial(%c0) : !hal.semaphore
    %0 = call @predict$async(%semaphore, %c0, %arg0, %semaphore, %c1) : (!hal.semaphore, index, !hal.buffer_view, !hal.semaphore, index) -> !hal.buffer_view
    %1 = hal.semaphore.await<%semaphore : !hal.semaphore> until(%c1) : i32
    hal.check_success %1, "semaphore wait failed"
    return %0 : !hal.buffer_view
  }
}


// *** IR Dump After mlir::iree_compiler::IREE::HAL::LinkExecutablesPass ***
#map0 = affine_map<()[s0] -> (s0 ceildiv 64)>
#map1 = affine_map<()[s0] -> (s0 ceildiv 4)>
#map2 = affine_map<()[s0] -> (s0 ceildiv 128)>
module  {
  hal.executable @mnist_linked_llvm_aot attributes {sym_visibility = "private"} {
    hal.interface @io_0 {
      hal.interface.binding @s0b0_ro_constant, set=0, binding=0, type="StorageBuffer", access="Read"
      hal.interface.binding @s0b1_ro_external, set=0, binding=1, type="StorageBuffer", access="Read"
      hal.interface.binding @s0b2_xw_external, set=0, binding=2, type="StorageBuffer", access="Write|Discard"
    }
    hal.interface @io_1 {
      hal.interface.binding @s0b0_ro_external, set=0, binding=0, type="StorageBuffer", access="Read"
      hal.interface.binding @s0b1_xw_external, set=0, binding=1, type="StorageBuffer", access="Write|Discard"
    }
    hal.interface @io_2 {
      hal.interface.binding @s0b0_ro_external, set=0, binding=0, type="StorageBuffer", access="Read"
      hal.interface.binding @s0b1_ro_external, set=0, binding=1, type="StorageBuffer", access="Read"
      hal.interface.binding @s0b2_xw_external, set=0, binding=2, type="StorageBuffer", access="Write|Discard"
    }
    hal.interface @io_3 {
      hal.interface.binding @s0b0_ro_external, set=0, binding=0, type="StorageBuffer", access="Read"
      hal.interface.binding @s0b1_ro_external, set=0, binding=1, type="StorageBuffer", access="Read"
      hal.interface.binding @s0b2_ro_external, set=0, binding=2, type="StorageBuffer", access="Read"
      hal.interface.binding @s0b3_xw_external, set=0, binding=3, type="StorageBuffer", access="Write|Discard"
    }
    hal.executable.target @llvm_aot, filter="dylib*" {
      hal.executable.entry_point @predict_dispatch_0 attributes {interface = @io_0, ordinal = 0 : index}
      hal.executable.entry_point @predict_dispatch_1 attributes {interface = @io_0, ordinal = 1 : index}
      hal.executable.entry_point @predict_dispatch_2 attributes {interface = @io_0, ordinal = 2 : index}
      hal.executable.entry_point @predict_dispatch_3 attributes {interface = @io_1, ordinal = 3 : index}
      hal.executable.entry_point @predict_dispatch_4 attributes {interface = @io_1, ordinal = 4 : index}
      hal.executable.entry_point @predict_dispatch_5 attributes {interface = @io_2, ordinal = 5 : index}
      hal.executable.entry_point @predict_dispatch_6 attributes {interface = @io_1, ordinal = 6 : index}
      hal.executable.entry_point @predict_dispatch_7 attributes {interface = @io_3, ordinal = 7 : index}
      module  {
        llvm.func internal @predict_dispatch_0(%arg0: !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>, %arg1: !llvm.ptr<array<3 x i32>>) -> i32 {
          %0 = llvm.mlir.constant(0.000000e+00 : f32) : f32
          %1 = llvm.mlir.constant(128 : index) : i64
          %2 = llvm.mlir.constant(784 : index) : i64
          %3 = llvm.mlir.constant(28 : index) : i64
          %4 = llvm.mlir.constant(32 : index) : i64
          %5 = llvm.mlir.constant(64 : index) : i64
          %6 = llvm.mlir.constant(4 : index) : i64
          %7 = llvm.mlir.constant(0 : index) : i64
          %8 = llvm.mlir.constant(1 : index) : i64
          %9 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %10 = llvm.extractvalue %9[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %11 = llvm.getelementptr %10[%8] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
          %12 = llvm.load %11 : !llvm.ptr<ptr<i8>>
          %13 = llvm.getelementptr %12[%7] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
          %14 = llvm.bitcast %13 : !llvm.ptr<i8> to !llvm.ptr<f32>
          %15 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %16 = llvm.insertvalue %14, %15[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %17 = llvm.insertvalue %14, %16[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %18 = llvm.insertvalue %7, %17[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %19 = llvm.insertvalue %8, %18[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %20 = llvm.insertvalue %2, %19[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %21 = llvm.insertvalue %2, %20[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %22 = llvm.insertvalue %8, %21[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %23 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %24 = llvm.extractvalue %23[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %25 = llvm.getelementptr %24[%7] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
          %26 = llvm.load %25 : !llvm.ptr<ptr<i8>>
          %27 = llvm.getelementptr %26[%7] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
          %28 = llvm.bitcast %27 : !llvm.ptr<i8> to !llvm.ptr<f32>
          %29 = llvm.insertvalue %28, %15[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %30 = llvm.insertvalue %28, %29[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %31 = llvm.insertvalue %7, %30[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %32 = llvm.insertvalue %2, %31[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %33 = llvm.insertvalue %1, %32[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %34 = llvm.insertvalue %1, %33[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %35 = llvm.insertvalue %8, %34[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %36 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %37 = llvm.extractvalue %36[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %38 = llvm.mlir.constant(2 : index) : i64
          %39 = llvm.getelementptr %37[%38] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
          %40 = llvm.load %39 : !llvm.ptr<ptr<i8>>
          %41 = llvm.getelementptr %40[%7] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
          %42 = llvm.bitcast %41 : !llvm.ptr<i8> to !llvm.ptr<f32>
          %43 = llvm.insertvalue %42, %15[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %44 = llvm.insertvalue %42, %43[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %45 = llvm.insertvalue %7, %44[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %46 = llvm.insertvalue %8, %45[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %47 = llvm.insertvalue %1, %46[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %48 = llvm.insertvalue %1, %47[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %49 = llvm.insertvalue %8, %48[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %50 = llvm.load %arg1 : !llvm.ptr<array<3 x i32>>
          %51 = llvm.extractvalue %50[0] : !llvm.array<3 x i32>
          %52 = llvm.zext %51 : i32 to i64
          %53 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %54 = llvm.extractvalue %53[0] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %55 = llvm.extractvalue %54[0] : !llvm.array<3 x i32>
          %56 = llvm.zext %55 : i32 to i64
          %57 = llvm.load %arg1 : !llvm.ptr<array<3 x i32>>
          %58 = llvm.extractvalue %57[1] : !llvm.array<3 x i32>
          %59 = llvm.zext %58 : i32 to i64
          %60 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %61 = llvm.extractvalue %60[0] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %62 = llvm.extractvalue %61[1] : !llvm.array<3 x i32>
          %63 = llvm.zext %62 : i32 to i64
          %64 = llvm.mul %59, %6  : i64
          %65 = llvm.mul %63, %6  : i64
          llvm.br ^bb1(%64 : i64)
        ^bb1(%66: i64):  // 2 preds: ^bb0, ^bb30
          %67 = llvm.icmp "slt" %66, %8 : i64
          llvm.cond_br %67, ^bb2, ^bb31
        ^bb2:  // pred: ^bb1
          %68 = llvm.mul %52, %5  : i64
          %69 = llvm.mul %56, %5  : i64
          llvm.br ^bb3(%68 : i64)
        ^bb3(%70: i64):  // 2 preds: ^bb2, ^bb29
          %71 = llvm.icmp "slt" %70, %1 : i64
          llvm.cond_br %71, ^bb4, ^bb30
        ^bb4:  // pred: ^bb3
          %72 = llvm.mlir.constant(-1 : index) : i64
          %73 = llvm.mul %66, %72  : i64
          %74 = llvm.add %73, %8  : i64
          %75 = llvm.icmp "slt" %6, %74 : i64
          %76 = llvm.select %75, %6, %74 : i1, i64
          %77 = llvm.extractvalue %22[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %78 = llvm.bitcast %77 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %79 = llvm.insertvalue %78, %15[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %80 = llvm.extractvalue %22[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %81 = llvm.bitcast %80 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %82 = llvm.insertvalue %81, %79[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %83 = llvm.extractvalue %22[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %84 = llvm.extractvalue %22[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %85 = llvm.extractvalue %22[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %86 = llvm.mul %66, %83  : i64
          %87 = llvm.add %85, %86  : i64
          %88 = llvm.mlir.constant(0 : i64) : i64
          %89 = llvm.mul %88, %84  : i64
          %90 = llvm.add %87, %89  : i64
          %91 = llvm.insertvalue %90, %82[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %92 = llvm.mlir.constant(784 : i64) : i64
          %93 = llvm.mlir.constant(1 : i64) : i64
          %94 = llvm.insertvalue %92, %91[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %95 = llvm.insertvalue %93, %94[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %96 = llvm.insertvalue %76, %95[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %97 = llvm.insertvalue %92, %96[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %98 = llvm.extractvalue %35[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %99 = llvm.bitcast %98 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %100 = llvm.insertvalue %99, %15[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %101 = llvm.extractvalue %35[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %102 = llvm.bitcast %101 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %103 = llvm.insertvalue %102, %100[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %104 = llvm.extractvalue %35[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %105 = llvm.extractvalue %35[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %106 = llvm.extractvalue %35[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %107 = llvm.mul %88, %104  : i64
          %108 = llvm.add %106, %107  : i64
          %109 = llvm.mul %70, %105  : i64
          %110 = llvm.add %108, %109  : i64
          %111 = llvm.insertvalue %110, %103[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %112 = llvm.mlir.constant(64 : i64) : i64
          %113 = llvm.insertvalue %112, %111[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %114 = llvm.insertvalue %93, %113[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %115 = llvm.mlir.constant(128 : i64) : i64
          %116 = llvm.insertvalue %92, %114[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %117 = llvm.insertvalue %115, %116[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %118 = llvm.extractvalue %49[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %119 = llvm.bitcast %118 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %120 = llvm.insertvalue %119, %15[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %121 = llvm.extractvalue %49[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %122 = llvm.bitcast %121 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %123 = llvm.insertvalue %122, %120[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %124 = llvm.extractvalue %49[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %125 = llvm.extractvalue %49[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %126 = llvm.extractvalue %49[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %127 = llvm.mul %66, %124  : i64
          %128 = llvm.add %126, %127  : i64
          %129 = llvm.mul %70, %125  : i64
          %130 = llvm.add %128, %129  : i64
          %131 = llvm.insertvalue %130, %123[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %132 = llvm.insertvalue %112, %131[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %133 = llvm.insertvalue %93, %132[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %134 = llvm.insertvalue %76, %133[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %135 = llvm.insertvalue %115, %134[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          llvm.br ^bb5(%7 : i64)
        ^bb5(%136: i64):  // 2 preds: ^bb4, ^bb8
          %137 = llvm.icmp "slt" %136, %76 : i64
          llvm.cond_br %137, ^bb6(%7 : i64), ^bb9(%7 : i64)
        ^bb6(%138: i64):  // 2 preds: ^bb5, ^bb7
          %139 = llvm.icmp "slt" %138, %5 : i64
          llvm.cond_br %139, ^bb7, ^bb8
        ^bb7:  // pred: ^bb6
          %140 = llvm.extractvalue %135[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %141 = llvm.extractvalue %135[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %142 = llvm.mul %136, %1  : i64
          %143 = llvm.add %141, %142  : i64
          %144 = llvm.add %143, %138  : i64
          %145 = llvm.getelementptr %140[%144] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
          llvm.store %0, %145 : !llvm.ptr<f32>
          %146 = llvm.add %138, %8  : i64
          llvm.br ^bb6(%146 : i64)
        ^bb8:  // pred: ^bb6
          %147 = llvm.add %136, %8  : i64
          llvm.br ^bb5(%147 : i64)
        ^bb9(%148: i64):  // 2 preds: ^bb5, ^bb28
          %149 = llvm.icmp "slt" %148, %76 : i64
          llvm.cond_br %149, ^bb10(%7 : i64), ^bb29
        ^bb10(%150: i64):  // 2 preds: ^bb9, ^bb27
          %151 = llvm.icmp "slt" %150, %5 : i64
          llvm.cond_br %151, ^bb11(%7 : i64), ^bb28
        ^bb11(%152: i64):  // 2 preds: ^bb10, ^bb26
          %153 = llvm.icmp "slt" %152, %2 : i64
          llvm.cond_br %153, ^bb12, ^bb27
        ^bb12:  // pred: ^bb11
          %154 = llvm.mul %148, %72  : i64
          %155 = llvm.add %76, %154  : i64
          %156 = llvm.icmp "slt" %6, %155 : i64
          %157 = llvm.select %156, %6, %155 : i1, i64
          %158 = llvm.extractvalue %97[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %159 = llvm.bitcast %158 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %160 = llvm.insertvalue %159, %15[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %161 = llvm.extractvalue %97[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %162 = llvm.bitcast %161 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %163 = llvm.insertvalue %162, %160[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %164 = llvm.extractvalue %97[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %165 = llvm.extractvalue %97[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %166 = llvm.extractvalue %97[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %167 = llvm.mul %148, %164  : i64
          %168 = llvm.add %166, %167  : i64
          %169 = llvm.mul %152, %165  : i64
          %170 = llvm.add %168, %169  : i64
          %171 = llvm.insertvalue %170, %163[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %172 = llvm.mlir.constant(28 : i64) : i64
          %173 = llvm.insertvalue %172, %171[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %174 = llvm.insertvalue %93, %173[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %175 = llvm.insertvalue %157, %174[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %176 = llvm.insertvalue %92, %175[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %177 = llvm.extractvalue %117[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %178 = llvm.bitcast %177 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %179 = llvm.insertvalue %178, %15[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %180 = llvm.extractvalue %117[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %181 = llvm.bitcast %180 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %182 = llvm.insertvalue %181, %179[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %183 = llvm.extractvalue %117[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %184 = llvm.extractvalue %117[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %185 = llvm.extractvalue %117[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %186 = llvm.mul %152, %183  : i64
          %187 = llvm.add %185, %186  : i64
          %188 = llvm.mul %150, %184  : i64
          %189 = llvm.add %187, %188  : i64
          %190 = llvm.insertvalue %189, %182[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %191 = llvm.mlir.constant(32 : i64) : i64
          %192 = llvm.insertvalue %191, %190[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %193 = llvm.insertvalue %93, %192[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %194 = llvm.insertvalue %172, %193[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %195 = llvm.insertvalue %115, %194[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %196 = llvm.extractvalue %135[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %197 = llvm.bitcast %196 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %198 = llvm.insertvalue %197, %15[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %199 = llvm.extractvalue %135[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %200 = llvm.bitcast %199 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %201 = llvm.insertvalue %200, %198[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %202 = llvm.extractvalue %135[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %203 = llvm.extractvalue %135[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %204 = llvm.extractvalue %135[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %205 = llvm.mul %148, %202  : i64
          %206 = llvm.add %204, %205  : i64
          %207 = llvm.mul %150, %203  : i64
          %208 = llvm.add %206, %207  : i64
          %209 = llvm.insertvalue %208, %201[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %210 = llvm.insertvalue %191, %209[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %211 = llvm.insertvalue %93, %210[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %212 = llvm.insertvalue %157, %211[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %213 = llvm.insertvalue %115, %212[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          llvm.br ^bb13(%7 : i64)
        ^bb13(%214: i64):  // 2 preds: ^bb12, ^bb25
          %215 = llvm.icmp "slt" %214, %157 : i64
          llvm.cond_br %215, ^bb14(%7 : i64), ^bb26
        ^bb14(%216: i64):  // 2 preds: ^bb13, ^bb24
          %217 = llvm.icmp "slt" %216, %4 : i64
          llvm.cond_br %217, ^bb15(%7 : i64), ^bb25
        ^bb15(%218: i64):  // 2 preds: ^bb14, ^bb23
          %219 = llvm.icmp "slt" %218, %3 : i64
          llvm.cond_br %219, ^bb16, ^bb24
        ^bb16:  // pred: ^bb15
          %220 = llvm.mul %214, %72  : i64
          %221 = llvm.add %157, %220  : i64
          %222 = llvm.icmp "slt" %6, %221 : i64
          %223 = llvm.select %222, %6, %221 : i1, i64
          %224 = llvm.extractvalue %176[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %225 = llvm.bitcast %224 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %226 = llvm.insertvalue %225, %15[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %227 = llvm.extractvalue %176[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %228 = llvm.bitcast %227 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %229 = llvm.insertvalue %228, %226[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %230 = llvm.extractvalue %176[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %231 = llvm.extractvalue %176[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %232 = llvm.extractvalue %176[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %233 = llvm.mul %214, %230  : i64
          %234 = llvm.add %232, %233  : i64
          %235 = llvm.mul %218, %231  : i64
          %236 = llvm.add %234, %235  : i64
          %237 = llvm.insertvalue %236, %229[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %238 = llvm.mlir.constant(4 : i64) : i64
          %239 = llvm.insertvalue %238, %237[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %240 = llvm.insertvalue %93, %239[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %241 = llvm.insertvalue %223, %240[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %242 = llvm.insertvalue %92, %241[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %243 = llvm.extractvalue %195[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %244 = llvm.bitcast %243 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %245 = llvm.insertvalue %244, %15[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %246 = llvm.extractvalue %195[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %247 = llvm.bitcast %246 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %248 = llvm.insertvalue %247, %245[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %249 = llvm.extractvalue %195[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %250 = llvm.extractvalue %195[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %251 = llvm.extractvalue %195[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %252 = llvm.mul %218, %249  : i64
          %253 = llvm.add %251, %252  : i64
          %254 = llvm.mul %216, %250  : i64
          %255 = llvm.add %253, %254  : i64
          %256 = llvm.insertvalue %255, %248[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %257 = llvm.insertvalue %238, %256[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %258 = llvm.insertvalue %93, %257[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %259 = llvm.insertvalue %238, %258[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %260 = llvm.insertvalue %115, %259[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %261 = llvm.extractvalue %213[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %262 = llvm.bitcast %261 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %263 = llvm.insertvalue %262, %15[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %264 = llvm.extractvalue %213[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %265 = llvm.bitcast %264 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %266 = llvm.insertvalue %265, %263[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %267 = llvm.extractvalue %213[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %268 = llvm.extractvalue %213[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %269 = llvm.extractvalue %213[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %270 = llvm.mul %214, %267  : i64
          %271 = llvm.add %269, %270  : i64
          %272 = llvm.mul %216, %268  : i64
          %273 = llvm.add %271, %272  : i64
          %274 = llvm.insertvalue %273, %266[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %275 = llvm.insertvalue %238, %274[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %276 = llvm.insertvalue %93, %275[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %277 = llvm.insertvalue %223, %276[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %278 = llvm.insertvalue %115, %277[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          llvm.br ^bb17(%7 : i64)
        ^bb17(%279: i64):  // 2 preds: ^bb16, ^bb22
          %280 = llvm.icmp "slt" %279, %223 : i64
          llvm.cond_br %280, ^bb18(%7 : i64), ^bb23
        ^bb18(%281: i64):  // 2 preds: ^bb17, ^bb21
          %282 = llvm.icmp "slt" %281, %6 : i64
          llvm.cond_br %282, ^bb19(%7 : i64), ^bb22
        ^bb19(%283: i64):  // 2 preds: ^bb18, ^bb20
          %284 = llvm.icmp "slt" %283, %6 : i64
          llvm.cond_br %284, ^bb20, ^bb21
        ^bb20:  // pred: ^bb19
          %285 = llvm.extractvalue %242[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %286 = llvm.extractvalue %242[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %287 = llvm.mul %279, %2  : i64
          %288 = llvm.add %286, %287  : i64
          %289 = llvm.add %288, %283  : i64
          %290 = llvm.getelementptr %285[%289] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
          %291 = llvm.load %290 : !llvm.ptr<f32>
          %292 = llvm.extractvalue %260[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %293 = llvm.extractvalue %260[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %294 = llvm.mul %283, %1  : i64
          %295 = llvm.add %293, %294  : i64
          %296 = llvm.add %295, %281  : i64
          %297 = llvm.getelementptr %292[%296] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
          %298 = llvm.load %297 : !llvm.ptr<f32>
          %299 = llvm.extractvalue %278[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %300 = llvm.extractvalue %278[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %301 = llvm.mul %279, %1  : i64
          %302 = llvm.add %300, %301  : i64
          %303 = llvm.add %302, %281  : i64
          %304 = llvm.getelementptr %299[%303] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
          %305 = llvm.load %304 : !llvm.ptr<f32>
          %306 = llvm.fmul %291, %298  : f32
          %307 = llvm.fadd %305, %306  : f32
          llvm.store %307, %304 : !llvm.ptr<f32>
          %308 = llvm.add %283, %8  : i64
          llvm.br ^bb19(%308 : i64)
        ^bb21:  // pred: ^bb19
          %309 = llvm.add %281, %8  : i64
          llvm.br ^bb18(%309 : i64)
        ^bb22:  // pred: ^bb18
          %310 = llvm.add %279, %8  : i64
          llvm.br ^bb17(%310 : i64)
        ^bb23:  // pred: ^bb17
          %311 = llvm.add %218, %6  : i64
          llvm.br ^bb15(%311 : i64)
        ^bb24:  // pred: ^bb15
          %312 = llvm.add %216, %6  : i64
          llvm.br ^bb14(%312 : i64)
        ^bb25:  // pred: ^bb14
          %313 = llvm.add %214, %6  : i64
          llvm.br ^bb13(%313 : i64)
        ^bb26:  // pred: ^bb13
          %314 = llvm.add %152, %3  : i64
          llvm.br ^bb11(%314 : i64)
        ^bb27:  // pred: ^bb11
          %315 = llvm.add %150, %4  : i64
          llvm.br ^bb10(%315 : i64)
        ^bb28:  // pred: ^bb10
          %316 = llvm.add %148, %6  : i64
          llvm.br ^bb9(%316 : i64)
        ^bb29:  // pred: ^bb9
          %317 = llvm.add %70, %69  : i64
          llvm.br ^bb3(%317 : i64)
        ^bb30:  // pred: ^bb3
          %318 = llvm.add %66, %65  : i64
          llvm.br ^bb1(%318 : i64)
        ^bb31:  // pred: ^bb1
          %319 = llvm.mlir.constant(0 : i32) : i32
          llvm.return %319 : i32
        }
        llvm.func internal @predict_dispatch_1(%arg0: !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>, %arg1: !llvm.ptr<array<3 x i32>>) -> i32 {
          %0 = llvm.mlir.constant(0x7FC00000 : f32) : f32
          %1 = llvm.mlir.constant(0.000000e+00 : f32) : f32
          %2 = llvm.mlir.constant(128 : index) : i64
          %3 = llvm.mlir.constant(0 : index) : i64
          %4 = llvm.mlir.constant(1 : index) : i64
          %5 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %6 = llvm.extractvalue %5[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %7 = llvm.getelementptr %6[%4] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
          %8 = llvm.load %7 : !llvm.ptr<ptr<i8>>
          %9 = llvm.getelementptr %8[%3] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
          %10 = llvm.bitcast %9 : !llvm.ptr<i8> to !llvm.ptr<f32>
          %11 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %12 = llvm.insertvalue %10, %11[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %13 = llvm.insertvalue %10, %12[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %14 = llvm.insertvalue %3, %13[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %15 = llvm.insertvalue %4, %14[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %16 = llvm.insertvalue %2, %15[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %17 = llvm.insertvalue %2, %16[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %18 = llvm.insertvalue %4, %17[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %19 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %20 = llvm.extractvalue %19[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %21 = llvm.getelementptr %20[%3] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
          %22 = llvm.load %21 : !llvm.ptr<ptr<i8>>
          %23 = llvm.getelementptr %22[%3] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
          %24 = llvm.bitcast %23 : !llvm.ptr<i8> to !llvm.ptr<f32>
          %25 = llvm.insertvalue %24, %11[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %26 = llvm.insertvalue %24, %25[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %27 = llvm.insertvalue %3, %26[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %28 = llvm.insertvalue %4, %27[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %29 = llvm.insertvalue %2, %28[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %30 = llvm.insertvalue %2, %29[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %31 = llvm.insertvalue %4, %30[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %32 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %33 = llvm.extractvalue %32[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %34 = llvm.mlir.constant(2 : index) : i64
          %35 = llvm.getelementptr %33[%34] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
          %36 = llvm.load %35 : !llvm.ptr<ptr<i8>>
          %37 = llvm.getelementptr %36[%3] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
          %38 = llvm.bitcast %37 : !llvm.ptr<i8> to !llvm.ptr<f32>
          %39 = llvm.insertvalue %38, %11[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %40 = llvm.insertvalue %38, %39[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %41 = llvm.insertvalue %3, %40[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %42 = llvm.insertvalue %4, %41[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %43 = llvm.insertvalue %2, %42[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %44 = llvm.insertvalue %2, %43[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %45 = llvm.insertvalue %4, %44[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %46 = llvm.load %arg1 : !llvm.ptr<array<3 x i32>>
          %47 = llvm.extractvalue %46[0] : !llvm.array<3 x i32>
          %48 = llvm.zext %47 : i32 to i64
          %49 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %50 = llvm.extractvalue %49[0] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %51 = llvm.extractvalue %50[0] : !llvm.array<3 x i32>
          %52 = llvm.zext %51 : i32 to i64
          %53 = llvm.load %arg1 : !llvm.ptr<array<3 x i32>>
          %54 = llvm.extractvalue %53[1] : !llvm.array<3 x i32>
          %55 = llvm.zext %54 : i32 to i64
          %56 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %57 = llvm.extractvalue %56[0] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %58 = llvm.extractvalue %57[1] : !llvm.array<3 x i32>
          %59 = llvm.zext %58 : i32 to i64
          %60 = llvm.mul %55, %2  : i64
          %61 = llvm.mul %59, %2  : i64
          llvm.br ^bb1(%60 : i64)
        ^bb1(%62: i64):  // 2 preds: ^bb0, ^bb10
          %63 = llvm.icmp "slt" %62, %4 : i64
          llvm.cond_br %63, ^bb2, ^bb11
        ^bb2:  // pred: ^bb1
          %64 = llvm.mul %48, %2  : i64
          %65 = llvm.mul %52, %2  : i64
          llvm.br ^bb3(%64 : i64)
        ^bb3(%66: i64):  // 2 preds: ^bb2, ^bb9
          %67 = llvm.icmp "slt" %66, %2 : i64
          llvm.cond_br %67, ^bb4, ^bb10
        ^bb4:  // pred: ^bb3
          %68 = llvm.mlir.constant(-1 : index) : i64
          %69 = llvm.mul %62, %68  : i64
          %70 = llvm.add %69, %4  : i64
          %71 = llvm.icmp "slt" %2, %70 : i64
          %72 = llvm.select %71, %2, %70 : i1, i64
          %73 = llvm.extractvalue %18[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %74 = llvm.bitcast %73 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %75 = llvm.insertvalue %74, %11[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %76 = llvm.extractvalue %18[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %77 = llvm.bitcast %76 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %78 = llvm.insertvalue %77, %75[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %79 = llvm.extractvalue %18[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %80 = llvm.extractvalue %18[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %81 = llvm.extractvalue %18[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %82 = llvm.mul %62, %79  : i64
          %83 = llvm.add %81, %82  : i64
          %84 = llvm.mul %66, %80  : i64
          %85 = llvm.add %83, %84  : i64
          %86 = llvm.insertvalue %85, %78[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %87 = llvm.mlir.constant(128 : i64) : i64
          %88 = llvm.mlir.constant(1 : i64) : i64
          %89 = llvm.insertvalue %87, %86[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %90 = llvm.insertvalue %88, %89[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %91 = llvm.insertvalue %72, %90[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %92 = llvm.insertvalue %87, %91[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %93 = llvm.extractvalue %31[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %94 = llvm.bitcast %93 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %95 = llvm.insertvalue %94, %11[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %96 = llvm.extractvalue %31[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %97 = llvm.bitcast %96 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %98 = llvm.insertvalue %97, %95[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %99 = llvm.extractvalue %31[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %100 = llvm.extractvalue %31[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %101 = llvm.extractvalue %31[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %102 = llvm.mul %62, %99  : i64
          %103 = llvm.add %101, %102  : i64
          %104 = llvm.mul %66, %100  : i64
          %105 = llvm.add %103, %104  : i64
          %106 = llvm.insertvalue %105, %98[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %107 = llvm.insertvalue %87, %106[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %108 = llvm.insertvalue %88, %107[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %109 = llvm.insertvalue %72, %108[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %110 = llvm.insertvalue %87, %109[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %111 = llvm.extractvalue %45[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %112 = llvm.bitcast %111 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %113 = llvm.insertvalue %112, %11[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %114 = llvm.extractvalue %45[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %115 = llvm.bitcast %114 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %116 = llvm.insertvalue %115, %113[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %117 = llvm.extractvalue %45[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %118 = llvm.extractvalue %45[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %119 = llvm.extractvalue %45[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %120 = llvm.mul %62, %117  : i64
          %121 = llvm.add %119, %120  : i64
          %122 = llvm.mul %66, %118  : i64
          %123 = llvm.add %121, %122  : i64
          %124 = llvm.insertvalue %123, %116[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %125 = llvm.insertvalue %87, %124[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %126 = llvm.insertvalue %88, %125[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %127 = llvm.insertvalue %72, %126[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %128 = llvm.insertvalue %87, %127[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          llvm.br ^bb5(%3 : i64)
        ^bb5(%129: i64):  // 2 preds: ^bb4, ^bb8
          %130 = llvm.icmp "slt" %129, %72 : i64
          llvm.cond_br %130, ^bb6(%3 : i64), ^bb9
        ^bb6(%131: i64):  // 2 preds: ^bb5, ^bb7
          %132 = llvm.icmp "slt" %131, %2 : i64
          llvm.cond_br %132, ^bb7, ^bb8
        ^bb7:  // pred: ^bb6
          %133 = llvm.extractvalue %92[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %134 = llvm.extractvalue %92[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %135 = llvm.mul %129, %2  : i64
          %136 = llvm.add %134, %135  : i64
          %137 = llvm.add %136, %131  : i64
          %138 = llvm.getelementptr %133[%137] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
          %139 = llvm.load %138 : !llvm.ptr<f32>
          %140 = llvm.extractvalue %110[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %141 = llvm.extractvalue %110[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %142 = llvm.add %141, %135  : i64
          %143 = llvm.add %142, %131  : i64
          %144 = llvm.getelementptr %140[%143] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
          %145 = llvm.load %144 : !llvm.ptr<f32>
          %146 = llvm.fadd %139, %145  : f32
          %147 = llvm.fcmp "ogt" %146, %1 : f32
          %148 = llvm.select %147, %146, %1 : i1, f32
          %149 = llvm.fcmp "uno" %146, %1 : f32
          %150 = llvm.select %149, %0, %148 : i1, f32
          %151 = llvm.extractvalue %128[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %152 = llvm.extractvalue %128[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %153 = llvm.add %152, %135  : i64
          %154 = llvm.add %153, %131  : i64
          %155 = llvm.getelementptr %151[%154] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
          llvm.store %150, %155 : !llvm.ptr<f32>
          %156 = llvm.add %131, %4  : i64
          llvm.br ^bb6(%156 : i64)
        ^bb8:  // pred: ^bb6
          %157 = llvm.add %129, %4  : i64
          llvm.br ^bb5(%157 : i64)
        ^bb9:  // pred: ^bb5
          %158 = llvm.add %66, %65  : i64
          llvm.br ^bb3(%158 : i64)
        ^bb10:  // pred: ^bb3
          %159 = llvm.add %62, %61  : i64
          llvm.br ^bb1(%159 : i64)
        ^bb11:  // pred: ^bb1
          %160 = llvm.mlir.constant(0 : i32) : i32
          llvm.return %160 : i32
        }
        llvm.func internal @predict_dispatch_2(%arg0: !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>, %arg1: !llvm.ptr<array<3 x i32>>) -> i32 {
          %0 = llvm.mlir.constant(0.000000e+00 : f32) : f32
          %1 = llvm.mlir.constant(10 : index) : i64
          %2 = llvm.mlir.constant(128 : index) : i64
          %3 = llvm.mlir.constant(32 : index) : i64
          %4 = llvm.mlir.constant(4 : index) : i64
          %5 = llvm.mlir.constant(0 : index) : i64
          %6 = llvm.mlir.constant(1 : index) : i64
          %7 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %8 = llvm.extractvalue %7[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %9 = llvm.getelementptr %8[%6] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
          %10 = llvm.load %9 : !llvm.ptr<ptr<i8>>
          %11 = llvm.getelementptr %10[%5] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
          %12 = llvm.bitcast %11 : !llvm.ptr<i8> to !llvm.ptr<f32>
          %13 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %14 = llvm.insertvalue %12, %13[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %15 = llvm.insertvalue %12, %14[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %16 = llvm.insertvalue %5, %15[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %17 = llvm.insertvalue %6, %16[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %18 = llvm.insertvalue %2, %17[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %19 = llvm.insertvalue %2, %18[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %20 = llvm.insertvalue %6, %19[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %21 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %22 = llvm.extractvalue %21[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %23 = llvm.getelementptr %22[%5] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
          %24 = llvm.load %23 : !llvm.ptr<ptr<i8>>
          %25 = llvm.getelementptr %24[%5] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
          %26 = llvm.bitcast %25 : !llvm.ptr<i8> to !llvm.ptr<f32>
          %27 = llvm.insertvalue %26, %13[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %28 = llvm.insertvalue %26, %27[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %29 = llvm.insertvalue %5, %28[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %30 = llvm.insertvalue %2, %29[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %31 = llvm.insertvalue %1, %30[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %32 = llvm.insertvalue %1, %31[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %33 = llvm.insertvalue %6, %32[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %34 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %35 = llvm.extractvalue %34[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %36 = llvm.mlir.constant(2 : index) : i64
          %37 = llvm.getelementptr %35[%36] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
          %38 = llvm.load %37 : !llvm.ptr<ptr<i8>>
          %39 = llvm.getelementptr %38[%5] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
          %40 = llvm.bitcast %39 : !llvm.ptr<i8> to !llvm.ptr<f32>
          %41 = llvm.insertvalue %40, %13[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %42 = llvm.insertvalue %40, %41[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %43 = llvm.insertvalue %5, %42[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %44 = llvm.insertvalue %6, %43[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %45 = llvm.insertvalue %1, %44[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %46 = llvm.insertvalue %1, %45[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %47 = llvm.insertvalue %6, %46[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %48 = llvm.load %arg1 : !llvm.ptr<array<3 x i32>>
          %49 = llvm.extractvalue %48[0] : !llvm.array<3 x i32>
          %50 = llvm.zext %49 : i32 to i64
          %51 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %52 = llvm.extractvalue %51[0] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %53 = llvm.extractvalue %52[0] : !llvm.array<3 x i32>
          %54 = llvm.zext %53 : i32 to i64
          %55 = llvm.load %arg1 : !llvm.ptr<array<3 x i32>>
          %56 = llvm.extractvalue %55[1] : !llvm.array<3 x i32>
          %57 = llvm.zext %56 : i32 to i64
          %58 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %59 = llvm.extractvalue %58[0] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %60 = llvm.extractvalue %59[1] : !llvm.array<3 x i32>
          %61 = llvm.zext %60 : i32 to i64
          %62 = llvm.mul %57, %4  : i64
          %63 = llvm.mul %61, %4  : i64
          llvm.br ^bb1(%62 : i64)
        ^bb1(%64: i64):  // 2 preds: ^bb0, ^bb30
          %65 = llvm.icmp "slt" %64, %6 : i64
          llvm.cond_br %65, ^bb2, ^bb31
        ^bb2:  // pred: ^bb1
          %66 = llvm.mlir.constant(64 : index) : i64
          %67 = llvm.mul %50, %66  : i64
          %68 = llvm.mul %54, %66  : i64
          llvm.br ^bb3(%67 : i64)
        ^bb3(%69: i64):  // 2 preds: ^bb2, ^bb29
          %70 = llvm.icmp "slt" %69, %1 : i64
          llvm.cond_br %70, ^bb4, ^bb30
        ^bb4:  // pred: ^bb3
          %71 = llvm.mlir.constant(-1 : index) : i64
          %72 = llvm.mul %64, %71  : i64
          %73 = llvm.add %72, %6  : i64
          %74 = llvm.icmp "slt" %4, %73 : i64
          %75 = llvm.select %74, %4, %73 : i1, i64
          %76 = llvm.extractvalue %20[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %77 = llvm.bitcast %76 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %78 = llvm.insertvalue %77, %13[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %79 = llvm.extractvalue %20[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %80 = llvm.bitcast %79 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %81 = llvm.insertvalue %80, %78[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %82 = llvm.extractvalue %20[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %83 = llvm.extractvalue %20[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %84 = llvm.extractvalue %20[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %85 = llvm.mul %64, %82  : i64
          %86 = llvm.add %84, %85  : i64
          %87 = llvm.mlir.constant(0 : i64) : i64
          %88 = llvm.mul %87, %83  : i64
          %89 = llvm.add %86, %88  : i64
          %90 = llvm.insertvalue %89, %81[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %91 = llvm.mlir.constant(128 : i64) : i64
          %92 = llvm.mlir.constant(1 : i64) : i64
          %93 = llvm.insertvalue %91, %90[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %94 = llvm.insertvalue %92, %93[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %95 = llvm.insertvalue %75, %94[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %96 = llvm.insertvalue %91, %95[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %97 = llvm.mul %69, %71  : i64
          %98 = llvm.add %97, %1  : i64
          %99 = llvm.icmp "slt" %66, %98 : i64
          %100 = llvm.select %99, %66, %98 : i1, i64
          %101 = llvm.extractvalue %33[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %102 = llvm.bitcast %101 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %103 = llvm.insertvalue %102, %13[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %104 = llvm.extractvalue %33[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %105 = llvm.bitcast %104 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %106 = llvm.insertvalue %105, %103[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %107 = llvm.extractvalue %33[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %108 = llvm.extractvalue %33[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %109 = llvm.extractvalue %33[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %110 = llvm.mul %87, %107  : i64
          %111 = llvm.add %109, %110  : i64
          %112 = llvm.mul %69, %108  : i64
          %113 = llvm.add %111, %112  : i64
          %114 = llvm.insertvalue %113, %106[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %115 = llvm.insertvalue %100, %114[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %116 = llvm.insertvalue %92, %115[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %117 = llvm.mlir.constant(10 : i64) : i64
          %118 = llvm.insertvalue %91, %116[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %119 = llvm.insertvalue %117, %118[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %120 = llvm.extractvalue %47[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %121 = llvm.bitcast %120 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %122 = llvm.insertvalue %121, %13[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %123 = llvm.extractvalue %47[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %124 = llvm.bitcast %123 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %125 = llvm.insertvalue %124, %122[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %126 = llvm.extractvalue %47[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %127 = llvm.extractvalue %47[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %128 = llvm.extractvalue %47[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %129 = llvm.mul %64, %126  : i64
          %130 = llvm.add %128, %129  : i64
          %131 = llvm.mul %69, %127  : i64
          %132 = llvm.add %130, %131  : i64
          %133 = llvm.insertvalue %132, %125[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %134 = llvm.insertvalue %100, %133[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %135 = llvm.insertvalue %92, %134[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %136 = llvm.insertvalue %75, %135[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %137 = llvm.insertvalue %117, %136[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          llvm.br ^bb5(%5 : i64)
        ^bb5(%138: i64):  // 2 preds: ^bb4, ^bb8
          %139 = llvm.icmp "slt" %138, %75 : i64
          llvm.cond_br %139, ^bb6(%5 : i64), ^bb9(%5 : i64)
        ^bb6(%140: i64):  // 2 preds: ^bb5, ^bb7
          %141 = llvm.icmp "slt" %140, %100 : i64
          llvm.cond_br %141, ^bb7, ^bb8
        ^bb7:  // pred: ^bb6
          %142 = llvm.extractvalue %137[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %143 = llvm.extractvalue %137[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %144 = llvm.mul %138, %1  : i64
          %145 = llvm.add %143, %144  : i64
          %146 = llvm.add %145, %140  : i64
          %147 = llvm.getelementptr %142[%146] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
          llvm.store %0, %147 : !llvm.ptr<f32>
          %148 = llvm.add %140, %6  : i64
          llvm.br ^bb6(%148 : i64)
        ^bb8:  // pred: ^bb6
          %149 = llvm.add %138, %6  : i64
          llvm.br ^bb5(%149 : i64)
        ^bb9(%150: i64):  // 2 preds: ^bb5, ^bb28
          %151 = llvm.icmp "slt" %150, %75 : i64
          llvm.cond_br %151, ^bb10(%5 : i64), ^bb29
        ^bb10(%152: i64):  // 2 preds: ^bb9, ^bb27
          %153 = llvm.icmp "slt" %152, %100 : i64
          llvm.cond_br %153, ^bb11(%5 : i64), ^bb28
        ^bb11(%154: i64):  // 2 preds: ^bb10, ^bb26
          %155 = llvm.icmp "slt" %154, %2 : i64
          llvm.cond_br %155, ^bb12, ^bb27
        ^bb12:  // pred: ^bb11
          %156 = llvm.mul %150, %71  : i64
          %157 = llvm.add %75, %156  : i64
          %158 = llvm.icmp "slt" %4, %157 : i64
          %159 = llvm.select %158, %4, %157 : i1, i64
          %160 = llvm.extractvalue %96[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %161 = llvm.bitcast %160 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %162 = llvm.insertvalue %161, %13[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %163 = llvm.extractvalue %96[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %164 = llvm.bitcast %163 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %165 = llvm.insertvalue %164, %162[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %166 = llvm.extractvalue %96[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %167 = llvm.extractvalue %96[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %168 = llvm.extractvalue %96[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %169 = llvm.mul %150, %166  : i64
          %170 = llvm.add %168, %169  : i64
          %171 = llvm.mul %154, %167  : i64
          %172 = llvm.add %170, %171  : i64
          %173 = llvm.insertvalue %172, %165[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %174 = llvm.mlir.constant(32 : i64) : i64
          %175 = llvm.insertvalue %174, %173[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %176 = llvm.insertvalue %92, %175[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %177 = llvm.insertvalue %159, %176[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %178 = llvm.insertvalue %91, %177[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %179 = llvm.mul %152, %71  : i64
          %180 = llvm.add %100, %179  : i64
          %181 = llvm.icmp "slt" %3, %180 : i64
          %182 = llvm.select %181, %3, %180 : i1, i64
          %183 = llvm.extractvalue %119[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %184 = llvm.bitcast %183 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %185 = llvm.insertvalue %184, %13[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %186 = llvm.extractvalue %119[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %187 = llvm.bitcast %186 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %188 = llvm.insertvalue %187, %185[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %189 = llvm.extractvalue %119[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %190 = llvm.extractvalue %119[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %191 = llvm.extractvalue %119[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %192 = llvm.mul %154, %189  : i64
          %193 = llvm.add %191, %192  : i64
          %194 = llvm.mul %152, %190  : i64
          %195 = llvm.add %193, %194  : i64
          %196 = llvm.insertvalue %195, %188[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %197 = llvm.insertvalue %182, %196[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %198 = llvm.insertvalue %92, %197[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %199 = llvm.insertvalue %174, %198[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %200 = llvm.insertvalue %117, %199[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %201 = llvm.extractvalue %137[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %202 = llvm.bitcast %201 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %203 = llvm.insertvalue %202, %13[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %204 = llvm.extractvalue %137[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %205 = llvm.bitcast %204 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %206 = llvm.insertvalue %205, %203[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %207 = llvm.extractvalue %137[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %208 = llvm.extractvalue %137[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %209 = llvm.extractvalue %137[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %210 = llvm.mul %150, %207  : i64
          %211 = llvm.add %209, %210  : i64
          %212 = llvm.mul %152, %208  : i64
          %213 = llvm.add %211, %212  : i64
          %214 = llvm.insertvalue %213, %206[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %215 = llvm.insertvalue %182, %214[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %216 = llvm.insertvalue %92, %215[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %217 = llvm.insertvalue %159, %216[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %218 = llvm.insertvalue %117, %217[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          llvm.br ^bb13(%5 : i64)
        ^bb13(%219: i64):  // 2 preds: ^bb12, ^bb25
          %220 = llvm.icmp "slt" %219, %159 : i64
          llvm.cond_br %220, ^bb14(%5 : i64), ^bb26
        ^bb14(%221: i64):  // 2 preds: ^bb13, ^bb24
          %222 = llvm.icmp "slt" %221, %182 : i64
          llvm.cond_br %222, ^bb15(%5 : i64), ^bb25
        ^bb15(%223: i64):  // 2 preds: ^bb14, ^bb23
          %224 = llvm.icmp "slt" %223, %3 : i64
          llvm.cond_br %224, ^bb16, ^bb24
        ^bb16:  // pred: ^bb15
          %225 = llvm.mul %219, %71  : i64
          %226 = llvm.add %159, %225  : i64
          %227 = llvm.icmp "slt" %4, %226 : i64
          %228 = llvm.select %227, %4, %226 : i1, i64
          %229 = llvm.extractvalue %178[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %230 = llvm.bitcast %229 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %231 = llvm.insertvalue %230, %13[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %232 = llvm.extractvalue %178[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %233 = llvm.bitcast %232 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %234 = llvm.insertvalue %233, %231[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %235 = llvm.extractvalue %178[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %236 = llvm.extractvalue %178[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %237 = llvm.extractvalue %178[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %238 = llvm.mul %219, %235  : i64
          %239 = llvm.add %237, %238  : i64
          %240 = llvm.mul %223, %236  : i64
          %241 = llvm.add %239, %240  : i64
          %242 = llvm.insertvalue %241, %234[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %243 = llvm.mlir.constant(4 : i64) : i64
          %244 = llvm.insertvalue %243, %242[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %245 = llvm.insertvalue %92, %244[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %246 = llvm.insertvalue %228, %245[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %247 = llvm.insertvalue %91, %246[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %248 = llvm.mul %221, %71  : i64
          %249 = llvm.add %182, %248  : i64
          %250 = llvm.icmp "slt" %4, %249 : i64
          %251 = llvm.select %250, %4, %249 : i1, i64
          %252 = llvm.extractvalue %200[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %253 = llvm.bitcast %252 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %254 = llvm.insertvalue %253, %13[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %255 = llvm.extractvalue %200[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %256 = llvm.bitcast %255 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %257 = llvm.insertvalue %256, %254[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %258 = llvm.extractvalue %200[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %259 = llvm.extractvalue %200[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %260 = llvm.extractvalue %200[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %261 = llvm.mul %223, %258  : i64
          %262 = llvm.add %260, %261  : i64
          %263 = llvm.mul %221, %259  : i64
          %264 = llvm.add %262, %263  : i64
          %265 = llvm.insertvalue %264, %257[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %266 = llvm.insertvalue %251, %265[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %267 = llvm.insertvalue %92, %266[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %268 = llvm.insertvalue %243, %267[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %269 = llvm.insertvalue %117, %268[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %270 = llvm.extractvalue %218[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %271 = llvm.bitcast %270 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %272 = llvm.insertvalue %271, %13[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %273 = llvm.extractvalue %218[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %274 = llvm.bitcast %273 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %275 = llvm.insertvalue %274, %272[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %276 = llvm.extractvalue %218[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %277 = llvm.extractvalue %218[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %278 = llvm.extractvalue %218[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %279 = llvm.mul %219, %276  : i64
          %280 = llvm.add %278, %279  : i64
          %281 = llvm.mul %221, %277  : i64
          %282 = llvm.add %280, %281  : i64
          %283 = llvm.insertvalue %282, %275[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %284 = llvm.insertvalue %251, %283[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %285 = llvm.insertvalue %92, %284[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %286 = llvm.insertvalue %228, %285[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %287 = llvm.insertvalue %117, %286[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          llvm.br ^bb17(%5 : i64)
        ^bb17(%288: i64):  // 2 preds: ^bb16, ^bb22
          %289 = llvm.icmp "slt" %288, %228 : i64
          llvm.cond_br %289, ^bb18(%5 : i64), ^bb23
        ^bb18(%290: i64):  // 2 preds: ^bb17, ^bb21
          %291 = llvm.icmp "slt" %290, %251 : i64
          llvm.cond_br %291, ^bb19(%5 : i64), ^bb22
        ^bb19(%292: i64):  // 2 preds: ^bb18, ^bb20
          %293 = llvm.icmp "slt" %292, %4 : i64
          llvm.cond_br %293, ^bb20, ^bb21
        ^bb20:  // pred: ^bb19
          %294 = llvm.extractvalue %247[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %295 = llvm.extractvalue %247[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %296 = llvm.mul %288, %2  : i64
          %297 = llvm.add %295, %296  : i64
          %298 = llvm.add %297, %292  : i64
          %299 = llvm.getelementptr %294[%298] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
          %300 = llvm.load %299 : !llvm.ptr<f32>
          %301 = llvm.extractvalue %269[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %302 = llvm.extractvalue %269[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %303 = llvm.mul %292, %1  : i64
          %304 = llvm.add %302, %303  : i64
          %305 = llvm.add %304, %290  : i64
          %306 = llvm.getelementptr %301[%305] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
          %307 = llvm.load %306 : !llvm.ptr<f32>
          %308 = llvm.extractvalue %287[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %309 = llvm.extractvalue %287[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %310 = llvm.mul %288, %1  : i64
          %311 = llvm.add %309, %310  : i64
          %312 = llvm.add %311, %290  : i64
          %313 = llvm.getelementptr %308[%312] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
          %314 = llvm.load %313 : !llvm.ptr<f32>
          %315 = llvm.fmul %300, %307  : f32
          %316 = llvm.fadd %314, %315  : f32
          llvm.store %316, %313 : !llvm.ptr<f32>
          %317 = llvm.add %292, %6  : i64
          llvm.br ^bb19(%317 : i64)
        ^bb21:  // pred: ^bb19
          %318 = llvm.add %290, %6  : i64
          llvm.br ^bb18(%318 : i64)
        ^bb22:  // pred: ^bb18
          %319 = llvm.add %288, %6  : i64
          llvm.br ^bb17(%319 : i64)
        ^bb23:  // pred: ^bb17
          %320 = llvm.add %223, %4  : i64
          llvm.br ^bb15(%320 : i64)
        ^bb24:  // pred: ^bb15
          %321 = llvm.add %221, %4  : i64
          llvm.br ^bb14(%321 : i64)
        ^bb25:  // pred: ^bb14
          %322 = llvm.add %219, %4  : i64
          llvm.br ^bb13(%322 : i64)
        ^bb26:  // pred: ^bb13
          %323 = llvm.add %154, %3  : i64
          llvm.br ^bb11(%323 : i64)
        ^bb27:  // pred: ^bb11
          %324 = llvm.add %152, %3  : i64
          llvm.br ^bb10(%324 : i64)
        ^bb28:  // pred: ^bb10
          %325 = llvm.add %150, %4  : i64
          llvm.br ^bb9(%325 : i64)
        ^bb29:  // pred: ^bb9
          %326 = llvm.add %69, %68  : i64
          llvm.br ^bb3(%326 : i64)
        ^bb30:  // pred: ^bb3
          %327 = llvm.add %64, %63  : i64
          llvm.br ^bb1(%327 : i64)
        ^bb31:  // pred: ^bb1
          %328 = llvm.mlir.constant(0 : i32) : i32
          llvm.return %328 : i32
        }
        llvm.mlir.global private constant @__constant_1x10xf32_3(opaque<"_", "0xDEADBEEF"> : tensor<1x10xf32>) : !llvm.array<1 x array<10 x f32>>
        llvm.func internal @predict_dispatch_3(%arg0: !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>, %arg1: !llvm.ptr<array<3 x i32>>) -> i32 {
          %0 = llvm.mlir.constant(10 : index) : i64
          %1 = llvm.mlir.constant(0 : index) : i64
          %2 = llvm.mlir.constant(1 : index) : i64
          %3 = llvm.mlir.addressof @__constant_1x10xf32_3 : !llvm.ptr<array<1 x array<10 x f32>>>
          %4 = llvm.getelementptr %3[%1, %1, %1] : (!llvm.ptr<array<1 x array<10 x f32>>>, i64, i64, i64) -> !llvm.ptr<f32>
          %5 = llvm.mlir.constant(3735928559 : index) : i64
          %6 = llvm.inttoptr %5 : i64 to !llvm.ptr<f32>
          %7 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %8 = llvm.insertvalue %6, %7[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %9 = llvm.insertvalue %4, %8[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %10 = llvm.insertvalue %1, %9[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %11 = llvm.insertvalue %2, %10[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %12 = llvm.insertvalue %0, %11[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %13 = llvm.insertvalue %0, %12[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %14 = llvm.insertvalue %2, %13[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %15 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %16 = llvm.extractvalue %15[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %17 = llvm.getelementptr %16[%1] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
          %18 = llvm.load %17 : !llvm.ptr<ptr<i8>>
          %19 = llvm.getelementptr %18[%1] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
          %20 = llvm.bitcast %19 : !llvm.ptr<i8> to !llvm.ptr<f32>
          %21 = llvm.insertvalue %20, %7[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %22 = llvm.insertvalue %20, %21[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %23 = llvm.insertvalue %1, %22[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %24 = llvm.insertvalue %2, %23[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %25 = llvm.insertvalue %0, %24[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %26 = llvm.insertvalue %0, %25[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %27 = llvm.insertvalue %2, %26[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %28 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %29 = llvm.extractvalue %28[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %30 = llvm.getelementptr %29[%2] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
          %31 = llvm.load %30 : !llvm.ptr<ptr<i8>>
          %32 = llvm.getelementptr %31[%1] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
          %33 = llvm.bitcast %32 : !llvm.ptr<i8> to !llvm.ptr<f32>
          %34 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %35 = llvm.insertvalue %33, %34[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %36 = llvm.insertvalue %33, %35[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %37 = llvm.insertvalue %1, %36[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %38 = llvm.insertvalue %0, %37[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %39 = llvm.insertvalue %2, %38[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %40 = llvm.load %arg1 : !llvm.ptr<array<3 x i32>>
          %41 = llvm.extractvalue %40[0] : !llvm.array<3 x i32>
          %42 = llvm.zext %41 : i32 to i64
          %43 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %44 = llvm.extractvalue %43[0] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %45 = llvm.extractvalue %44[0] : !llvm.array<3 x i32>
          %46 = llvm.zext %45 : i32 to i64
          %47 = llvm.load %arg1 : !llvm.ptr<array<3 x i32>>
          %48 = llvm.extractvalue %47[1] : !llvm.array<3 x i32>
          %49 = llvm.zext %48 : i32 to i64
          %50 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %51 = llvm.extractvalue %50[0] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %52 = llvm.extractvalue %51[1] : !llvm.array<3 x i32>
          %53 = llvm.zext %52 : i32 to i64
          %54 = llvm.mlir.constant(128 : index) : i64
          %55 = llvm.mul %49, %54  : i64
          %56 = llvm.mul %53, %54  : i64
          llvm.br ^bb1(%55 : i64)
        ^bb1(%57: i64):  // 2 preds: ^bb0, ^bb10
          %58 = llvm.icmp "slt" %57, %2 : i64
          llvm.cond_br %58, ^bb2, ^bb11
        ^bb2:  // pred: ^bb1
          %59 = llvm.mul %42, %54  : i64
          %60 = llvm.mul %46, %54  : i64
          llvm.br ^bb3(%59 : i64)
        ^bb3(%61: i64):  // 2 preds: ^bb2, ^bb9
          %62 = llvm.icmp "slt" %61, %0 : i64
          llvm.cond_br %62, ^bb4, ^bb10
        ^bb4:  // pred: ^bb3
          %63 = llvm.mlir.constant(-1 : index) : i64
          %64 = llvm.mul %57, %63  : i64
          %65 = llvm.add %64, %2  : i64
          %66 = llvm.icmp "slt" %54, %65 : i64
          %67 = llvm.select %66, %54, %65 : i1, i64
          %68 = llvm.mul %61, %63  : i64
          %69 = llvm.add %68, %0  : i64
          %70 = llvm.icmp "slt" %54, %69 : i64
          %71 = llvm.select %70, %54, %69 : i1, i64
          %72 = llvm.extractvalue %27[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %73 = llvm.bitcast %72 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %74 = llvm.insertvalue %73, %7[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %75 = llvm.extractvalue %27[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %76 = llvm.bitcast %75 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %77 = llvm.insertvalue %76, %74[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %78 = llvm.extractvalue %27[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %79 = llvm.extractvalue %27[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %80 = llvm.extractvalue %27[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %81 = llvm.mul %57, %78  : i64
          %82 = llvm.add %80, %81  : i64
          %83 = llvm.mul %61, %79  : i64
          %84 = llvm.add %82, %83  : i64
          %85 = llvm.insertvalue %84, %77[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %86 = llvm.mlir.constant(1 : i64) : i64
          %87 = llvm.insertvalue %71, %85[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %88 = llvm.insertvalue %86, %87[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %89 = llvm.mlir.constant(10 : i64) : i64
          %90 = llvm.insertvalue %67, %88[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %91 = llvm.insertvalue %89, %90[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %92 = llvm.extractvalue %14[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %93 = llvm.bitcast %92 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %94 = llvm.insertvalue %93, %7[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %95 = llvm.extractvalue %14[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %96 = llvm.bitcast %95 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %97 = llvm.insertvalue %96, %94[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %98 = llvm.extractvalue %14[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %99 = llvm.extractvalue %14[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %100 = llvm.extractvalue %14[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %101 = llvm.mul %57, %98  : i64
          %102 = llvm.add %100, %101  : i64
          %103 = llvm.mul %61, %99  : i64
          %104 = llvm.add %102, %103  : i64
          %105 = llvm.insertvalue %104, %97[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %106 = llvm.insertvalue %71, %105[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %107 = llvm.insertvalue %86, %106[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %108 = llvm.insertvalue %67, %107[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %109 = llvm.insertvalue %89, %108[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %110 = llvm.extractvalue %39[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %111 = llvm.bitcast %110 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %112 = llvm.insertvalue %111, %34[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %113 = llvm.extractvalue %39[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %114 = llvm.bitcast %113 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %115 = llvm.insertvalue %114, %112[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %116 = llvm.extractvalue %39[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %117 = llvm.extractvalue %39[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %118 = llvm.mul %61, %116  : i64
          %119 = llvm.add %117, %118  : i64
          %120 = llvm.insertvalue %119, %115[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %121 = llvm.insertvalue %71, %120[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %122 = llvm.insertvalue %86, %121[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          llvm.br ^bb5(%1 : i64)
        ^bb5(%123: i64):  // 2 preds: ^bb4, ^bb8
          %124 = llvm.icmp "slt" %123, %67 : i64
          llvm.cond_br %124, ^bb6(%1 : i64), ^bb9
        ^bb6(%125: i64):  // 2 preds: ^bb5, ^bb7
          %126 = llvm.icmp "slt" %125, %71 : i64
          llvm.cond_br %126, ^bb7, ^bb8
        ^bb7:  // pred: ^bb6
          %127 = llvm.extractvalue %91[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %128 = llvm.extractvalue %91[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %129 = llvm.mul %123, %0  : i64
          %130 = llvm.add %128, %129  : i64
          %131 = llvm.add %130, %125  : i64
          %132 = llvm.getelementptr %127[%131] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
          %133 = llvm.load %132 : !llvm.ptr<f32>
          %134 = llvm.extractvalue %109[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %135 = llvm.extractvalue %109[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %136 = llvm.add %135, %129  : i64
          %137 = llvm.add %136, %125  : i64
          %138 = llvm.getelementptr %134[%137] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
          %139 = llvm.load %138 : !llvm.ptr<f32>
          %140 = llvm.fadd %133, %139  : f32
          %141 = llvm.extractvalue %122[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %142 = llvm.extractvalue %122[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %143 = llvm.add %142, %125  : i64
          %144 = llvm.getelementptr %141[%143] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
          llvm.store %140, %144 : !llvm.ptr<f32>
          %145 = llvm.add %125, %2  : i64
          llvm.br ^bb6(%145 : i64)
        ^bb8:  // pred: ^bb6
          %146 = llvm.add %123, %2  : i64
          llvm.br ^bb5(%146 : i64)
        ^bb9:  // pred: ^bb5
          %147 = llvm.add %61, %60  : i64
          llvm.br ^bb3(%147 : i64)
        ^bb10:  // pred: ^bb3
          %148 = llvm.add %57, %56  : i64
          llvm.br ^bb1(%148 : i64)
        ^bb11:  // pred: ^bb1
          %149 = llvm.mlir.constant(0 : i32) : i32
          llvm.return %149 : i32
        }
        llvm.func internal @predict_dispatch_4(%arg0: !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>, %arg1: !llvm.ptr<array<3 x i32>>) -> i32 {
          %0 = llvm.mlir.constant(0x7FC00000 : f32) : f32
          %1 = llvm.mlir.constant(0xFF800000 : f32) : f32
          %2 = llvm.mlir.constant(10 : index) : i64
          %3 = llvm.mlir.constant(0 : index) : i64
          %4 = llvm.mlir.constant(1 : index) : i64
          %5 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %6 = llvm.extractvalue %5[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %7 = llvm.getelementptr %6[%3] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
          %8 = llvm.load %7 : !llvm.ptr<ptr<i8>>
          %9 = llvm.getelementptr %8[%3] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
          %10 = llvm.bitcast %9 : !llvm.ptr<i8> to !llvm.ptr<f32>
          %11 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %12 = llvm.insertvalue %10, %11[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %13 = llvm.insertvalue %10, %12[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %14 = llvm.insertvalue %3, %13[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %15 = llvm.insertvalue %2, %14[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %16 = llvm.insertvalue %4, %15[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %17 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %18 = llvm.extractvalue %17[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %19 = llvm.getelementptr %18[%4] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
          %20 = llvm.load %19 : !llvm.ptr<ptr<i8>>
          %21 = llvm.getelementptr %20[%3] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
          %22 = llvm.bitcast %21 : !llvm.ptr<i8> to !llvm.ptr<f32>
          %23 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
          %24 = llvm.insertvalue %22, %23[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
          %25 = llvm.insertvalue %22, %24[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
          %26 = llvm.insertvalue %3, %25[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
          %27 = llvm.extractvalue %26[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
          llvm.store %1, %27 : !llvm.ptr<f32>
          llvm.br ^bb1(%3 : i64)
        ^bb1(%28: i64):  // 2 preds: ^bb0, ^bb2
          %29 = llvm.icmp "slt" %28, %2 : i64
          llvm.cond_br %29, ^bb2, ^bb3
        ^bb2:  // pred: ^bb1
          %30 = llvm.extractvalue %16[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %31 = llvm.getelementptr %30[%28] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
          %32 = llvm.load %31 : !llvm.ptr<f32>
          %33 = llvm.load %27 : !llvm.ptr<f32>
          %34 = llvm.fcmp "ogt" %32, %33 : f32
          %35 = llvm.select %34, %32, %33 : i1, f32
          %36 = llvm.fcmp "uno" %32, %33 : f32
          %37 = llvm.select %36, %0, %35 : i1, f32
          llvm.store %37, %27 : !llvm.ptr<f32>
          %38 = llvm.add %28, %4  : i64
          llvm.br ^bb1(%38 : i64)
        ^bb3:  // pred: ^bb1
          %39 = llvm.mlir.constant(0 : i32) : i32
          llvm.return %39 : i32
        }
        llvm.mlir.global private constant @__constant_1x10xf32_5(opaque<"_", "0xDEADBEEF"> : tensor<1x10xf32>) : !llvm.array<1 x array<10 x f32>>
        llvm.func internal @predict_dispatch_5(%arg0: !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>, %arg1: !llvm.ptr<array<3 x i32>>) -> i32 {
          %0 = llvm.mlir.constant(10 : index) : i64
          %1 = llvm.mlir.constant(0 : index) : i64
          %2 = llvm.mlir.constant(1 : index) : i64
          %3 = llvm.mlir.constant(0.693147182 : f32) : f32
          %4 = llvm.mlir.constant(1.44269502 : f32) : f32
          %5 = llvm.mlir.constant(1.000000e+00 : f32) : f32
          %6 = llvm.mlir.constant(0.499705136 : f32) : f32
          %7 = llvm.mlir.constant(0.168738902 : f32) : f32
          %8 = llvm.mlir.constant(0.0366896503 : f32) : f32
          %9 = llvm.mlir.constant(1.314350e-02 : f32) : f32
          %10 = llvm.mlir.constant(23 : i32) : i32
          %11 = llvm.mlir.constant(0.000000e+00 : f32) : f32
          %12 = llvm.mlir.constant(0x7F800000 : f32) : f32
          %13 = llvm.mlir.constant(0xFF800000 : f32) : f32
          %14 = llvm.mlir.constant(1.17549435E-38 : f32) : f32
          %15 = llvm.mlir.constant(127 : i32) : i32
          %16 = llvm.mlir.constant(-127 : i32) : i32
          %17 = llvm.mlir.addressof @__constant_1x10xf32_5 : !llvm.ptr<array<1 x array<10 x f32>>>
          %18 = llvm.getelementptr %17[%1, %1, %1] : (!llvm.ptr<array<1 x array<10 x f32>>>, i64, i64, i64) -> !llvm.ptr<f32>
          %19 = llvm.mlir.constant(3735928559 : index) : i64
          %20 = llvm.inttoptr %19 : i64 to !llvm.ptr<f32>
          %21 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %22 = llvm.insertvalue %20, %21[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %23 = llvm.insertvalue %18, %22[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %24 = llvm.insertvalue %1, %23[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %25 = llvm.insertvalue %2, %24[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %26 = llvm.insertvalue %0, %25[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %27 = llvm.insertvalue %0, %26[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %28 = llvm.insertvalue %2, %27[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %29 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %30 = llvm.extractvalue %29[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %31 = llvm.getelementptr %30[%1] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
          %32 = llvm.load %31 : !llvm.ptr<ptr<i8>>
          %33 = llvm.getelementptr %32[%1] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
          %34 = llvm.bitcast %33 : !llvm.ptr<i8> to !llvm.ptr<f32>
          %35 = llvm.insertvalue %34, %21[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %36 = llvm.insertvalue %34, %35[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %37 = llvm.insertvalue %1, %36[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %38 = llvm.insertvalue %2, %37[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %39 = llvm.insertvalue %0, %38[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %40 = llvm.insertvalue %0, %39[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %41 = llvm.insertvalue %2, %40[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %42 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %43 = llvm.extractvalue %42[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %44 = llvm.getelementptr %43[%2] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
          %45 = llvm.load %44 : !llvm.ptr<ptr<i8>>
          %46 = llvm.getelementptr %45[%1] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
          %47 = llvm.bitcast %46 : !llvm.ptr<i8> to !llvm.ptr<f32>
          %48 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
          %49 = llvm.insertvalue %47, %48[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
          %50 = llvm.insertvalue %47, %49[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
          %51 = llvm.insertvalue %1, %50[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
          %52 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %53 = llvm.extractvalue %52[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %54 = llvm.mlir.constant(2 : index) : i64
          %55 = llvm.getelementptr %53[%54] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
          %56 = llvm.load %55 : !llvm.ptr<ptr<i8>>
          %57 = llvm.getelementptr %56[%1] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
          %58 = llvm.bitcast %57 : !llvm.ptr<i8> to !llvm.ptr<f32>
          %59 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %60 = llvm.insertvalue %58, %59[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %61 = llvm.insertvalue %58, %60[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %62 = llvm.insertvalue %1, %61[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %63 = llvm.insertvalue %0, %62[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %64 = llvm.insertvalue %2, %63[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %65 = llvm.load %arg1 : !llvm.ptr<array<3 x i32>>
          %66 = llvm.extractvalue %65[0] : !llvm.array<3 x i32>
          %67 = llvm.zext %66 : i32 to i64
          %68 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %69 = llvm.extractvalue %68[0] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %70 = llvm.extractvalue %69[0] : !llvm.array<3 x i32>
          %71 = llvm.zext %70 : i32 to i64
          %72 = llvm.load %arg1 : !llvm.ptr<array<3 x i32>>
          %73 = llvm.extractvalue %72[1] : !llvm.array<3 x i32>
          %74 = llvm.zext %73 : i32 to i64
          %75 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %76 = llvm.extractvalue %75[0] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %77 = llvm.extractvalue %76[1] : !llvm.array<3 x i32>
          %78 = llvm.zext %77 : i32 to i64
          %79 = llvm.mlir.constant(128 : index) : i64
          %80 = llvm.mul %74, %79  : i64
          %81 = llvm.mul %78, %79  : i64
          llvm.br ^bb1(%80 : i64)
        ^bb1(%82: i64):  // 2 preds: ^bb0, ^bb10
          %83 = llvm.icmp "slt" %82, %2 : i64
          llvm.cond_br %83, ^bb2, ^bb11
        ^bb2:  // pred: ^bb1
          %84 = llvm.mul %67, %79  : i64
          %85 = llvm.mul %71, %79  : i64
          llvm.br ^bb3(%84 : i64)
        ^bb3(%86: i64):  // 2 preds: ^bb2, ^bb9
          %87 = llvm.icmp "slt" %86, %0 : i64
          llvm.cond_br %87, ^bb4, ^bb10
        ^bb4:  // pred: ^bb3
          %88 = llvm.mlir.constant(-1 : index) : i64
          %89 = llvm.mul %82, %88  : i64
          %90 = llvm.add %89, %2  : i64
          %91 = llvm.icmp "slt" %79, %90 : i64
          %92 = llvm.select %91, %79, %90 : i1, i64
          %93 = llvm.mul %86, %88  : i64
          %94 = llvm.add %93, %0  : i64
          %95 = llvm.icmp "slt" %79, %94 : i64
          %96 = llvm.select %95, %79, %94 : i1, i64
          %97 = llvm.extractvalue %41[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %98 = llvm.bitcast %97 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %99 = llvm.insertvalue %98, %21[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %100 = llvm.extractvalue %41[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %101 = llvm.bitcast %100 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %102 = llvm.insertvalue %101, %99[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %103 = llvm.extractvalue %41[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %104 = llvm.extractvalue %41[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %105 = llvm.extractvalue %41[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %106 = llvm.mul %82, %103  : i64
          %107 = llvm.add %105, %106  : i64
          %108 = llvm.mul %86, %104  : i64
          %109 = llvm.add %107, %108  : i64
          %110 = llvm.insertvalue %109, %102[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %111 = llvm.mlir.constant(1 : i64) : i64
          %112 = llvm.insertvalue %96, %110[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %113 = llvm.insertvalue %111, %112[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %114 = llvm.mlir.constant(10 : i64) : i64
          %115 = llvm.insertvalue %92, %113[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %116 = llvm.insertvalue %114, %115[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %117 = llvm.extractvalue %28[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %118 = llvm.bitcast %117 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %119 = llvm.insertvalue %118, %21[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %120 = llvm.extractvalue %28[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %121 = llvm.bitcast %120 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %122 = llvm.insertvalue %121, %119[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %123 = llvm.extractvalue %28[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %124 = llvm.extractvalue %28[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %125 = llvm.extractvalue %28[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %126 = llvm.mul %82, %123  : i64
          %127 = llvm.add %125, %126  : i64
          %128 = llvm.mul %86, %124  : i64
          %129 = llvm.add %127, %128  : i64
          %130 = llvm.insertvalue %129, %122[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %131 = llvm.insertvalue %96, %130[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %132 = llvm.insertvalue %111, %131[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %133 = llvm.insertvalue %92, %132[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %134 = llvm.insertvalue %114, %133[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %135 = llvm.extractvalue %64[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %136 = llvm.bitcast %135 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %137 = llvm.insertvalue %136, %59[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %138 = llvm.extractvalue %64[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %139 = llvm.bitcast %138 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %140 = llvm.insertvalue %139, %137[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %141 = llvm.extractvalue %64[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %142 = llvm.extractvalue %64[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %143 = llvm.mul %86, %141  : i64
          %144 = llvm.add %142, %143  : i64
          %145 = llvm.insertvalue %144, %140[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %146 = llvm.insertvalue %96, %145[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %147 = llvm.insertvalue %111, %146[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          llvm.br ^bb5(%1 : i64)
        ^bb5(%148: i64):  // 2 preds: ^bb4, ^bb8
          %149 = llvm.icmp "slt" %148, %92 : i64
          llvm.cond_br %149, ^bb6(%1 : i64), ^bb9
        ^bb6(%150: i64):  // 2 preds: ^bb5, ^bb7
          %151 = llvm.icmp "slt" %150, %96 : i64
          llvm.cond_br %151, ^bb7, ^bb8
        ^bb7:  // pred: ^bb6
          %152 = llvm.extractvalue %116[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %153 = llvm.extractvalue %116[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %154 = llvm.mul %148, %0  : i64
          %155 = llvm.add %153, %154  : i64
          %156 = llvm.add %155, %150  : i64
          %157 = llvm.getelementptr %152[%156] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
          %158 = llvm.load %157 : !llvm.ptr<f32>
          %159 = llvm.extractvalue %134[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %160 = llvm.extractvalue %134[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %161 = llvm.add %160, %154  : i64
          %162 = llvm.add %161, %150  : i64
          %163 = llvm.getelementptr %159[%162] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
          %164 = llvm.load %163 : !llvm.ptr<f32>
          %165 = llvm.extractvalue %51[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
          %166 = llvm.load %165 : !llvm.ptr<f32>
          %167 = llvm.fadd %158, %164  : f32
          %168 = llvm.fsub %167, %166  : f32
          %169 = llvm.fmul %168, %4  : f32
          %170 = "llvm.intr.floor"(%169) : (f32) -> f32
          %171 = llvm.fmul %170, %3  : f32
          %172 = llvm.fsub %168, %171  : f32
          %173 = llvm.fmul %172, %172  : f32
          %174 = llvm.fmul %173, %173  : f32
          %175 = "llvm.intr.fma"(%5, %172, %5) : (f32, f32, f32) -> f32
          %176 = "llvm.intr.fma"(%7, %172, %6) : (f32, f32, f32) -> f32
          %177 = "llvm.intr.fma"(%9, %172, %8) : (f32, f32, f32) -> f32
          %178 = "llvm.intr.fma"(%176, %173, %175) : (f32, f32, f32) -> f32
          %179 = "llvm.intr.fma"(%177, %174, %178) : (f32, f32, f32) -> f32
          %180 = llvm.fptosi %170 : f32 to i32
          %181 = llvm.add %180, %15  : i32
          %182 = llvm.shl %181, %10  : i32
          %183 = llvm.bitcast %182 : i32 to f32
          %184 = llvm.fmul %179, %183  : f32
          %185 = llvm.icmp "sle" %180, %15 : i32
          %186 = llvm.icmp "sge" %180, %16 : i32
          %187 = llvm.fcmp "oeq" %168, %13 : f32
          %188 = llvm.fcmp "ogt" %168, %11 : f32
          %189 = llvm.and %185, %186  : i1
          %190 = llvm.select %187, %11, %14 : i1, f32
          %191 = llvm.select %188, %12, %190 : i1, f32
          %192 = llvm.select %189, %184, %191 : i1, f32
          %193 = llvm.extractvalue %147[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %194 = llvm.extractvalue %147[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %195 = llvm.add %194, %150  : i64
          %196 = llvm.getelementptr %193[%195] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
          llvm.store %192, %196 : !llvm.ptr<f32>
          %197 = llvm.add %150, %2  : i64
          llvm.br ^bb6(%197 : i64)
        ^bb8:  // pred: ^bb6
          %198 = llvm.add %148, %2  : i64
          llvm.br ^bb5(%198 : i64)
        ^bb9:  // pred: ^bb5
          %199 = llvm.add %86, %85  : i64
          llvm.br ^bb3(%199 : i64)
        ^bb10:  // pred: ^bb3
          %200 = llvm.add %82, %81  : i64
          llvm.br ^bb1(%200 : i64)
        ^bb11:  // pred: ^bb1
          %201 = llvm.mlir.constant(0 : i32) : i32
          llvm.return %201 : i32
        }
        llvm.func internal @predict_dispatch_6(%arg0: !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>, %arg1: !llvm.ptr<array<3 x i32>>) -> i32 {
          %0 = llvm.mlir.constant(0.000000e+00 : f32) : f32
          %1 = llvm.mlir.constant(10 : index) : i64
          %2 = llvm.mlir.constant(0 : index) : i64
          %3 = llvm.mlir.constant(1 : index) : i64
          %4 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %5 = llvm.extractvalue %4[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %6 = llvm.getelementptr %5[%2] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
          %7 = llvm.load %6 : !llvm.ptr<ptr<i8>>
          %8 = llvm.getelementptr %7[%2] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
          %9 = llvm.bitcast %8 : !llvm.ptr<i8> to !llvm.ptr<f32>
          %10 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %11 = llvm.insertvalue %9, %10[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %12 = llvm.insertvalue %9, %11[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %13 = llvm.insertvalue %2, %12[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %14 = llvm.insertvalue %1, %13[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %15 = llvm.insertvalue %3, %14[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %16 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %17 = llvm.extractvalue %16[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %18 = llvm.getelementptr %17[%3] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
          %19 = llvm.load %18 : !llvm.ptr<ptr<i8>>
          %20 = llvm.getelementptr %19[%2] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
          %21 = llvm.bitcast %20 : !llvm.ptr<i8> to !llvm.ptr<f32>
          %22 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
          %23 = llvm.insertvalue %21, %22[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
          %24 = llvm.insertvalue %21, %23[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
          %25 = llvm.insertvalue %2, %24[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
          %26 = llvm.extractvalue %25[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
          llvm.store %0, %26 : !llvm.ptr<f32>
          llvm.br ^bb1(%2 : i64)
        ^bb1(%27: i64):  // 2 preds: ^bb0, ^bb2
          %28 = llvm.icmp "slt" %27, %1 : i64
          llvm.cond_br %28, ^bb2, ^bb3
        ^bb2:  // pred: ^bb1
          %29 = llvm.extractvalue %15[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %30 = llvm.getelementptr %29[%27] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
          %31 = llvm.load %30 : !llvm.ptr<f32>
          %32 = llvm.load %26 : !llvm.ptr<f32>
          %33 = llvm.fadd %31, %32  : f32
          llvm.store %33, %26 : !llvm.ptr<f32>
          %34 = llvm.add %27, %3  : i64
          llvm.br ^bb1(%34 : i64)
        ^bb3:  // pred: ^bb1
          %35 = llvm.mlir.constant(0 : i32) : i32
          llvm.return %35 : i32
        }
        llvm.mlir.global private constant @__constant_1x10xf32_7(opaque<"_", "0xDEADBEEF"> : tensor<1x10xf32>) : !llvm.array<1 x array<10 x f32>>
        llvm.func internal @predict_dispatch_7(%arg0: !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>, %arg1: !llvm.ptr<array<3 x i32>>) -> i32 {
          %0 = llvm.mlir.constant(10 : index) : i64
          %1 = llvm.mlir.constant(0 : index) : i64
          %2 = llvm.mlir.constant(1 : index) : i64
          %3 = llvm.mlir.constant(0.693147182 : f32) : f32
          %4 = llvm.mlir.constant(1.44269502 : f32) : f32
          %5 = llvm.mlir.constant(1.000000e+00 : f32) : f32
          %6 = llvm.mlir.constant(0.499705136 : f32) : f32
          %7 = llvm.mlir.constant(0.168738902 : f32) : f32
          %8 = llvm.mlir.constant(0.0366896503 : f32) : f32
          %9 = llvm.mlir.constant(1.314350e-02 : f32) : f32
          %10 = llvm.mlir.constant(23 : i32) : i32
          %11 = llvm.mlir.constant(0.000000e+00 : f32) : f32
          %12 = llvm.mlir.constant(0x7F800000 : f32) : f32
          %13 = llvm.mlir.constant(0xFF800000 : f32) : f32
          %14 = llvm.mlir.constant(1.17549435E-38 : f32) : f32
          %15 = llvm.mlir.constant(127 : i32) : i32
          %16 = llvm.mlir.constant(-127 : i32) : i32
          %17 = llvm.mlir.addressof @__constant_1x10xf32_7 : !llvm.ptr<array<1 x array<10 x f32>>>
          %18 = llvm.getelementptr %17[%1, %1, %1] : (!llvm.ptr<array<1 x array<10 x f32>>>, i64, i64, i64) -> !llvm.ptr<f32>
          %19 = llvm.mlir.constant(3735928559 : index) : i64
          %20 = llvm.inttoptr %19 : i64 to !llvm.ptr<f32>
          %21 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %22 = llvm.insertvalue %20, %21[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %23 = llvm.insertvalue %18, %22[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %24 = llvm.insertvalue %1, %23[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %25 = llvm.insertvalue %2, %24[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %26 = llvm.insertvalue %0, %25[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %27 = llvm.insertvalue %0, %26[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %28 = llvm.insertvalue %2, %27[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %29 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %30 = llvm.extractvalue %29[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %31 = llvm.getelementptr %30[%1] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
          %32 = llvm.load %31 : !llvm.ptr<ptr<i8>>
          %33 = llvm.getelementptr %32[%1] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
          %34 = llvm.bitcast %33 : !llvm.ptr<i8> to !llvm.ptr<f32>
          %35 = llvm.insertvalue %34, %21[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %36 = llvm.insertvalue %34, %35[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %37 = llvm.insertvalue %1, %36[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %38 = llvm.insertvalue %2, %37[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %39 = llvm.insertvalue %0, %38[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %40 = llvm.insertvalue %0, %39[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %41 = llvm.insertvalue %2, %40[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %42 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %43 = llvm.extractvalue %42[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %44 = llvm.getelementptr %43[%2] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
          %45 = llvm.load %44 : !llvm.ptr<ptr<i8>>
          %46 = llvm.getelementptr %45[%1] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
          %47 = llvm.bitcast %46 : !llvm.ptr<i8> to !llvm.ptr<f32>
          %48 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
          %49 = llvm.insertvalue %47, %48[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
          %50 = llvm.insertvalue %47, %49[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
          %51 = llvm.insertvalue %1, %50[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
          %52 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %53 = llvm.extractvalue %52[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %54 = llvm.mlir.constant(2 : index) : i64
          %55 = llvm.getelementptr %53[%54] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
          %56 = llvm.load %55 : !llvm.ptr<ptr<i8>>
          %57 = llvm.getelementptr %56[%1] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
          %58 = llvm.bitcast %57 : !llvm.ptr<i8> to !llvm.ptr<f32>
          %59 = llvm.insertvalue %58, %48[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
          %60 = llvm.insertvalue %58, %59[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
          %61 = llvm.insertvalue %1, %60[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
          %62 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %63 = llvm.extractvalue %62[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %64 = llvm.mlir.constant(3 : index) : i64
          %65 = llvm.getelementptr %63[%64] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
          %66 = llvm.load %65 : !llvm.ptr<ptr<i8>>
          %67 = llvm.getelementptr %66[%1] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
          %68 = llvm.bitcast %67 : !llvm.ptr<i8> to !llvm.ptr<f32>
          %69 = llvm.insertvalue %68, %21[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %70 = llvm.insertvalue %68, %69[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %71 = llvm.insertvalue %1, %70[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %72 = llvm.insertvalue %2, %71[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %73 = llvm.insertvalue %0, %72[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %74 = llvm.insertvalue %0, %73[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %75 = llvm.insertvalue %2, %74[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %76 = llvm.load %arg1 : !llvm.ptr<array<3 x i32>>
          %77 = llvm.extractvalue %76[0] : !llvm.array<3 x i32>
          %78 = llvm.zext %77 : i32 to i64
          %79 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %80 = llvm.extractvalue %79[0] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %81 = llvm.extractvalue %80[0] : !llvm.array<3 x i32>
          %82 = llvm.zext %81 : i32 to i64
          %83 = llvm.load %arg1 : !llvm.ptr<array<3 x i32>>
          %84 = llvm.extractvalue %83[1] : !llvm.array<3 x i32>
          %85 = llvm.zext %84 : i32 to i64
          %86 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %87 = llvm.extractvalue %86[0] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %88 = llvm.extractvalue %87[1] : !llvm.array<3 x i32>
          %89 = llvm.zext %88 : i32 to i64
          %90 = llvm.mlir.constant(128 : index) : i64
          %91 = llvm.mul %85, %90  : i64
          %92 = llvm.mul %89, %90  : i64
          llvm.br ^bb1(%91 : i64)
        ^bb1(%93: i64):  // 2 preds: ^bb0, ^bb10
          %94 = llvm.icmp "slt" %93, %2 : i64
          llvm.cond_br %94, ^bb2, ^bb11
        ^bb2:  // pred: ^bb1
          %95 = llvm.mul %78, %90  : i64
          %96 = llvm.mul %82, %90  : i64
          llvm.br ^bb3(%95 : i64)
        ^bb3(%97: i64):  // 2 preds: ^bb2, ^bb9
          %98 = llvm.icmp "slt" %97, %0 : i64
          llvm.cond_br %98, ^bb4, ^bb10
        ^bb4:  // pred: ^bb3
          %99 = llvm.mlir.constant(-1 : index) : i64
          %100 = llvm.mul %93, %99  : i64
          %101 = llvm.add %100, %2  : i64
          %102 = llvm.icmp "slt" %90, %101 : i64
          %103 = llvm.select %102, %90, %101 : i1, i64
          %104 = llvm.mul %97, %99  : i64
          %105 = llvm.add %104, %0  : i64
          %106 = llvm.icmp "slt" %90, %105 : i64
          %107 = llvm.select %106, %90, %105 : i1, i64
          %108 = llvm.extractvalue %41[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %109 = llvm.bitcast %108 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %110 = llvm.insertvalue %109, %21[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %111 = llvm.extractvalue %41[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %112 = llvm.bitcast %111 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %113 = llvm.insertvalue %112, %110[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %114 = llvm.extractvalue %41[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %115 = llvm.extractvalue %41[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %116 = llvm.extractvalue %41[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %117 = llvm.mul %93, %114  : i64
          %118 = llvm.add %116, %117  : i64
          %119 = llvm.mul %97, %115  : i64
          %120 = llvm.add %118, %119  : i64
          %121 = llvm.insertvalue %120, %113[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %122 = llvm.mlir.constant(1 : i64) : i64
          %123 = llvm.insertvalue %107, %121[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %124 = llvm.insertvalue %122, %123[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %125 = llvm.mlir.constant(10 : i64) : i64
          %126 = llvm.insertvalue %103, %124[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %127 = llvm.insertvalue %125, %126[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %128 = llvm.extractvalue %28[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %129 = llvm.bitcast %128 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %130 = llvm.insertvalue %129, %21[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %131 = llvm.extractvalue %28[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %132 = llvm.bitcast %131 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %133 = llvm.insertvalue %132, %130[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %134 = llvm.extractvalue %28[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %135 = llvm.extractvalue %28[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %136 = llvm.extractvalue %28[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %137 = llvm.mul %93, %134  : i64
          %138 = llvm.add %136, %137  : i64
          %139 = llvm.mul %97, %135  : i64
          %140 = llvm.add %138, %139  : i64
          %141 = llvm.insertvalue %140, %133[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %142 = llvm.insertvalue %107, %141[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %143 = llvm.insertvalue %122, %142[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %144 = llvm.insertvalue %103, %143[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %145 = llvm.insertvalue %125, %144[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %146 = llvm.extractvalue %75[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %147 = llvm.bitcast %146 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %148 = llvm.insertvalue %147, %21[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %149 = llvm.extractvalue %75[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %150 = llvm.bitcast %149 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %151 = llvm.insertvalue %150, %148[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %152 = llvm.extractvalue %75[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %153 = llvm.extractvalue %75[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %154 = llvm.extractvalue %75[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %155 = llvm.mul %93, %152  : i64
          %156 = llvm.add %154, %155  : i64
          %157 = llvm.mul %97, %153  : i64
          %158 = llvm.add %156, %157  : i64
          %159 = llvm.insertvalue %158, %151[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %160 = llvm.insertvalue %107, %159[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %161 = llvm.insertvalue %122, %160[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %162 = llvm.insertvalue %103, %161[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %163 = llvm.insertvalue %125, %162[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          llvm.br ^bb5(%1 : i64)
        ^bb5(%164: i64):  // 2 preds: ^bb4, ^bb8
          %165 = llvm.icmp "slt" %164, %103 : i64
          llvm.cond_br %165, ^bb6(%1 : i64), ^bb9
        ^bb6(%166: i64):  // 2 preds: ^bb5, ^bb7
          %167 = llvm.icmp "slt" %166, %107 : i64
          llvm.cond_br %167, ^bb7, ^bb8
        ^bb7:  // pred: ^bb6
          %168 = llvm.extractvalue %127[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %169 = llvm.extractvalue %127[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %170 = llvm.mul %164, %0  : i64
          %171 = llvm.add %169, %170  : i64
          %172 = llvm.add %171, %166  : i64
          %173 = llvm.getelementptr %168[%172] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
          %174 = llvm.load %173 : !llvm.ptr<f32>
          %175 = llvm.extractvalue %145[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %176 = llvm.extractvalue %145[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %177 = llvm.add %176, %170  : i64
          %178 = llvm.add %177, %166  : i64
          %179 = llvm.getelementptr %175[%178] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
          %180 = llvm.load %179 : !llvm.ptr<f32>
          %181 = llvm.extractvalue %51[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
          %182 = llvm.load %181 : !llvm.ptr<f32>
          %183 = llvm.extractvalue %61[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
          %184 = llvm.load %183 : !llvm.ptr<f32>
          %185 = llvm.fadd %174, %180  : f32
          %186 = llvm.fsub %185, %182  : f32
          %187 = llvm.fmul %186, %4  : f32
          %188 = "llvm.intr.floor"(%187) : (f32) -> f32
          %189 = llvm.fmul %188, %3  : f32
          %190 = llvm.fsub %186, %189  : f32
          %191 = llvm.fmul %190, %190  : f32
          %192 = llvm.fmul %191, %191  : f32
          %193 = "llvm.intr.fma"(%5, %190, %5) : (f32, f32, f32) -> f32
          %194 = "llvm.intr.fma"(%7, %190, %6) : (f32, f32, f32) -> f32
          %195 = "llvm.intr.fma"(%9, %190, %8) : (f32, f32, f32) -> f32
          %196 = "llvm.intr.fma"(%194, %191, %193) : (f32, f32, f32) -> f32
          %197 = "llvm.intr.fma"(%195, %192, %196) : (f32, f32, f32) -> f32
          %198 = llvm.fptosi %188 : f32 to i32
          %199 = llvm.add %198, %15  : i32
          %200 = llvm.shl %199, %10  : i32
          %201 = llvm.bitcast %200 : i32 to f32
          %202 = llvm.fmul %197, %201  : f32
          %203 = llvm.icmp "sle" %198, %15 : i32
          %204 = llvm.icmp "sge" %198, %16 : i32
          %205 = llvm.fcmp "oeq" %186, %13 : f32
          %206 = llvm.fcmp "ogt" %186, %11 : f32
          %207 = llvm.and %203, %204  : i1
          %208 = llvm.select %205, %11, %14 : i1, f32
          %209 = llvm.select %206, %12, %208 : i1, f32
          %210 = llvm.select %207, %202, %209 : i1, f32
          %211 = llvm.fdiv %210, %184  : f32
          %212 = llvm.extractvalue %163[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %213 = llvm.extractvalue %163[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %214 = llvm.add %213, %170  : i64
          %215 = llvm.add %214, %166  : i64
          %216 = llvm.getelementptr %212[%215] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
          llvm.store %211, %216 : !llvm.ptr<f32>
          %217 = llvm.add %166, %2  : i64
          llvm.br ^bb6(%217 : i64)
        ^bb8:  // pred: ^bb6
          %218 = llvm.add %164, %2  : i64
          llvm.br ^bb5(%218 : i64)
        ^bb9:  // pred: ^bb5
          %219 = llvm.add %97, %96  : i64
          llvm.br ^bb3(%219 : i64)
        ^bb10:  // pred: ^bb3
          %220 = llvm.add %93, %92  : i64
          llvm.br ^bb1(%220 : i64)
        ^bb11:  // pred: ^bb1
          %221 = llvm.mlir.constant(0 : i32) : i32
          llvm.return %221 : i32
        }
      }
    }
  }
  hal.constant_pool @_const_pool attributes {buffer_constraints = #hal.buffer_constraints<max_allocation_size = 1073741824, min_buffer_offset_alignment = 16, max_buffer_range = 1073741824, min_buffer_range_alignment = 16>, sym_visibility = "private"} {
    hal.constant_storage @_storage = opaque<"_", "0xDEADBEEF"> : vector<407040xi8> attributes {sym_visibility = "nested"}
  }
  hal.variable @_const_pool_storage_buffer init(@_const_pool_storage_buffer_initializer) : !hal.buffer attributes {sym_visibility = "private"}
  func private @_const_pool_storage_buffer_initializer() -> !hal.buffer {
    %c0 = constant 0 : index
    %c407040 = constant 407040 : index
    %device = hal.ex.shared_device : !hal.device
    %allocator = hal.device.allocator<%device : !hal.device> : !hal.allocator
    %storage = hal.constant_storage.lookup @_const_pool::@_storage : !iree.byte_buffer
    %mapped = hal.allocator.map<%allocator : !hal.allocator> source(%storage : !iree.byte_buffer)[%c0, %c407040] type("HostVisible|DeviceVisible|DeviceLocal") usage("Constant|Transfer|Mapping|Dispatch") : !hal.buffer
    return %mapped : !hal.buffer
  }
  func @predict(%arg0: !hal.buffer) -> !hal.buffer attributes {noinline} {
    %c3136 = constant 3136 : index
    %c401408 = constant 401408 : index
    %c0 = constant 0 : index
    %c401920 = constant 401920 : index
    %c5120 = constant 5120 : index
    %c512 = constant 512 : index
    %c40 = constant 40 : index
    %c4 = constant 4 : index
    %c128 = constant 128 : index
    %c1 = constant 1 : index
    %c10 = constant 10 : index
    %c2 = constant 2 : index
    %c3 = constant 3 : index
    %device = hal.ex.shared_device : !hal.device
    %allocator = hal.device.allocator<%device : !hal.device> : !hal.allocator
    %buffer = hal.allocator.allocate<%allocator : !hal.allocator> type("HostVisible|DeviceVisible|DeviceLocal") usage("Transfer|Mapping|Dispatch") : !hal.buffer{%c40}
    %0 = hal.variable.load @_const_pool_storage_buffer : !hal.buffer
    %c0_0 = constant 0 : index
    %c0_1 = constant 0 : index
    %c512_2 = constant 512 : index
    %c512_3 = constant 512 : index
    %c0_4 = constant 0 : index
    %c48 = constant 48 : index
    %c48_5 = constant 48 : index
    %c96 = constant 96 : index
    %c96_6 = constant 96 : index
    %c48_7 = constant 48 : index
    %c48_8 = constant 48 : index
    %c112 = constant 112 : index
    %c112_9 = constant 112 : index
    %c1024 = constant 1024 : index
    %c1024_10 = constant 1024 : index
    %buffer_11 = hal.allocator.allocate<%allocator : !hal.allocator> type("DeviceVisible|DeviceLocal") usage("Transfer|Dispatch") : !hal.buffer{%c1024_10}
    %cmd = hal.command_buffer.create device(%device : !hal.device) mode("OneShot|AllowInlineExecution") categories("Transfer|Dispatch") : !hal.command_buffer
    hal.command_buffer.begin<%cmd : !hal.command_buffer>
    %executable_layout = hal.executable_layout.lookup device(%device : !hal.device) layouts([[#hal.descriptor_set_layout_binding<0, "StorageBuffer", R>, #hal.descriptor_set_layout_binding<1, "StorageBuffer", R>, #hal.descriptor_set_layout_binding<2, "StorageBuffer", DW>]]) : !hal.executable_layout
    hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%executable_layout : !hal.executable_layout)[%c0] bindings([
      %c0 = (%0 : !hal.buffer)[%c512, %c401408], 
      %c1 = (%arg0 : !hal.buffer)[%c0, %c3136], 
      %c2 = (%buffer_11 : !hal.buffer)[%c0_0, %c512]
    ])
    hal.device.switch<%device : !hal.device>
    #hal.device.match.id<"dylib*">(%arg1 = %cmd : !hal.command_buffer, %arg2 = %c128 : index, %arg3 = %c1 : index, %arg4 = %c1 : index) {
      %c1_14 = constant 1 : index
      %1 = affine.apply #map0()[%arg2]
      %2 = affine.apply #map1()[%arg3]
      hal.command_buffer.dispatch.symbol<%arg1 : !hal.command_buffer> target(@mnist_linked_llvm_aot::@llvm_aot::@predict_dispatch_0) workgroups([%1, %2, %c1_14])
      hal.return
    }
    hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
    hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%executable_layout : !hal.executable_layout)[%c0] bindings([
      %c0 = (%0 : !hal.buffer)[%c0, %c512], 
      %c1 = (%buffer_11 : !hal.buffer)[%c0_0, %c512], 
      %c2 = (%buffer_11 : !hal.buffer)[%c512_3, %c512]
    ])
    hal.device.switch<%device : !hal.device>
    #hal.device.match.id<"dylib*">(%arg1 = %cmd : !hal.command_buffer, %arg2 = %c128 : index, %arg3 = %c1 : index, %arg4 = %c1 : index) {
      %c1_14 = constant 1 : index
      %1 = affine.apply #map2()[%arg2]
      %2 = affine.apply #map2()[%arg3]
      hal.command_buffer.dispatch.symbol<%arg1 : !hal.command_buffer> target(@mnist_linked_llvm_aot::@llvm_aot::@predict_dispatch_1) workgroups([%1, %2, %c1_14])
      hal.return
    }
    hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
    hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%executable_layout : !hal.executable_layout)[%c0] bindings([
      %c0 = (%0 : !hal.buffer)[%c401920, %c5120], 
      %c1 = (%buffer_11 : !hal.buffer)[%c512_3, %c512], 
      %c2 = (%buffer_11 : !hal.buffer)[%c0_0, %c40]
    ])
    hal.device.switch<%device : !hal.device>
    #hal.device.match.id<"dylib*">(%arg1 = %cmd : !hal.command_buffer, %arg2 = %c10 : index, %arg3 = %c1 : index, %arg4 = %c1 : index) {
      %c1_14 = constant 1 : index
      %1 = affine.apply #map0()[%arg2]
      %2 = affine.apply #map1()[%arg3]
      hal.command_buffer.dispatch.symbol<%arg1 : !hal.command_buffer> target(@mnist_linked_llvm_aot::@llvm_aot::@predict_dispatch_2) workgroups([%1, %2, %c1_14])
      hal.return
    }
    hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
    %executable_layout_12 = hal.executable_layout.lookup device(%device : !hal.device) layouts([[#hal.descriptor_set_layout_binding<0, "StorageBuffer", R>, #hal.descriptor_set_layout_binding<1, "StorageBuffer", DW>]]) : !hal.executable_layout
    hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%executable_layout_12 : !hal.executable_layout)[%c0] bindings([
      %c0 = (%buffer_11 : !hal.buffer)[%c0_0, %c40], 
      %c1 = (%buffer_11 : !hal.buffer)[%c48_5, %c40]
    ])
    hal.device.switch<%device : !hal.device>
    #hal.device.match.id<"dylib*">(%arg1 = %cmd : !hal.command_buffer, %arg2 = %c10 : index, %arg3 = %c1 : index, %arg4 = %c1 : index) {
      %c1_14 = constant 1 : index
      %1 = affine.apply #map2()[%arg2]
      %2 = affine.apply #map2()[%arg3]
      hal.command_buffer.dispatch.symbol<%arg1 : !hal.command_buffer> target(@mnist_linked_llvm_aot::@llvm_aot::@predict_dispatch_3) workgroups([%1, %2, %c1_14])
      hal.return
    }
    hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
    hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%executable_layout_12 : !hal.executable_layout)[%c0] bindings([
      %c0 = (%buffer_11 : !hal.buffer)[%c48_5, %c40], 
      %c1 = (%buffer_11 : !hal.buffer)[%c96_6, %c4]
    ])
    hal.device.switch<%device : !hal.device>
    #hal.device.match.id<"dylib*">(%arg1 = %cmd : !hal.command_buffer, %arg2 = %c1 : index, %arg3 = %c1 : index, %arg4 = %c1 : index) {
      %c1_14 = constant 1 : index
      hal.command_buffer.dispatch.symbol<%arg1 : !hal.command_buffer> target(@mnist_linked_llvm_aot::@llvm_aot::@predict_dispatch_4) workgroups([%c1_14, %c1_14, %c1_14])
      hal.return
    }
    hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
    hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%executable_layout : !hal.executable_layout)[%c0] bindings([
      %c0 = (%buffer_11 : !hal.buffer)[%c0_0, %c40], 
      %c1 = (%buffer_11 : !hal.buffer)[%c96_6, %c4], 
      %c2 = (%buffer_11 : !hal.buffer)[%c48_8, %c40]
    ])
    hal.device.switch<%device : !hal.device>
    #hal.device.match.id<"dylib*">(%arg1 = %cmd : !hal.command_buffer, %arg2 = %c10 : index, %arg3 = %c1 : index, %arg4 = %c1 : index) {
      %c1_14 = constant 1 : index
      %1 = affine.apply #map2()[%arg2]
      %2 = affine.apply #map2()[%arg3]
      hal.command_buffer.dispatch.symbol<%arg1 : !hal.command_buffer> target(@mnist_linked_llvm_aot::@llvm_aot::@predict_dispatch_5) workgroups([%1, %2, %c1_14])
      hal.return
    }
    hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
    hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%executable_layout_12 : !hal.executable_layout)[%c0] bindings([
      %c0 = (%buffer_11 : !hal.buffer)[%c48_8, %c40], 
      %c1 = (%buffer_11 : !hal.buffer)[%c112_9, %c4]
    ])
    hal.device.switch<%device : !hal.device>
    #hal.device.match.id<"dylib*">(%arg1 = %cmd : !hal.command_buffer, %arg2 = %c1 : index, %arg3 = %c1 : index, %arg4 = %c1 : index) {
      %c1_14 = constant 1 : index
      hal.command_buffer.dispatch.symbol<%arg1 : !hal.command_buffer> target(@mnist_linked_llvm_aot::@llvm_aot::@predict_dispatch_6) workgroups([%c1_14, %c1_14, %c1_14])
      hal.return
    }
    hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
    %executable_layout_13 = hal.executable_layout.lookup device(%device : !hal.device) layouts([[#hal.descriptor_set_layout_binding<0, "StorageBuffer", R>, #hal.descriptor_set_layout_binding<1, "StorageBuffer", R>, #hal.descriptor_set_layout_binding<2, "StorageBuffer", R>, #hal.descriptor_set_layout_binding<3, "StorageBuffer", DW>]]) : !hal.executable_layout
    hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%executable_layout_13 : !hal.executable_layout)[%c0] bindings([
      %c0 = (%buffer_11 : !hal.buffer)[%c0_0, %c40], 
      %c1 = (%buffer_11 : !hal.buffer)[%c96_6, %c4], 
      %c2 = (%buffer_11 : !hal.buffer)[%c112_9, %c4], 
      %c3 = (%buffer : !hal.buffer)[%c0, %c40]
    ])
    hal.device.switch<%device : !hal.device>
    #hal.device.match.id<"dylib*">(%arg1 = %cmd : !hal.command_buffer, %arg2 = %c10 : index, %arg3 = %c1 : index, %arg4 = %c1 : index) {
      %c1_14 = constant 1 : index
      %1 = affine.apply #map2()[%arg2]
      %2 = affine.apply #map2()[%arg3]
      hal.command_buffer.dispatch.symbol<%arg1 : !hal.command_buffer> target(@mnist_linked_llvm_aot::@llvm_aot::@predict_dispatch_7) workgroups([%1, %2, %c1_14])
      hal.return
    }
    hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
    hal.command_buffer.end<%cmd : !hal.command_buffer>
    hal.ex.submit_and_wait %device, %cmd
    return %buffer : !hal.buffer
  }
  func @predict$async(%arg0: !hal.semaphore, %arg1: index, %arg2: !hal.buffer_view, %arg3: !hal.semaphore, %arg4: index) -> !hal.buffer_view attributes {iree.module.export = "predict$async"} {
    %0 = hal.semaphore.await<%arg0 : !hal.semaphore> until(%arg1) : i32
    hal.check_success %0, "semaphore wait failed"
    %buffer = hal.buffer_view.buffer %arg2 : !hal.buffer
    %1 = call @predict(%buffer) : (!hal.buffer) -> !hal.buffer
    %c1 = constant 1 : index
    %c10 = constant 10 : index
    %c50331680_i32 = constant 50331680 : i32
    %view = hal.buffer_view.create %1, element_type = %c50331680_i32, shape = [%c1, %c10] : !hal.buffer -> !hal.buffer_view
    hal.semaphore.signal<%arg3 : !hal.semaphore> value(%arg4)
    return %view : !hal.buffer_view
  }
  func @predict$sync(%arg0: !hal.buffer_view) -> !hal.buffer_view attributes {iree.abi.stub, iree.module.export = "predict", iree.reflection = {abi = "sip", abiv = 1 : i32, f = "I15!B11!d1d28d28d1R9!B6!d1d10", fv = "1", sip = "I8!S5!k0_0R3!_0"}} {
    %c0 = constant 0 : index
    %c1 = constant 1 : index
    %device = hal.ex.shared_device : !hal.device
    %semaphore = hal.semaphore.create device(%device : !hal.device) initial(%c0) : !hal.semaphore
    %0 = call @predict$async(%semaphore, %c0, %arg0, %semaphore, %c1) : (!hal.semaphore, index, !hal.buffer_view, !hal.semaphore, index) -> !hal.buffer_view
    %1 = hal.semaphore.await<%semaphore : !hal.semaphore> until(%c1) : i32
    hal.check_success %1, "semaphore wait failed"
    return %0 : !hal.buffer_view
  }
}


// *** IR Dump After mlir::iree_compiler::IREE::HAL::ResolveEntryPointOrdinalsPass ***
#map0 = affine_map<()[s0] -> (s0 ceildiv 64)>
#map1 = affine_map<()[s0] -> (s0 ceildiv 4)>
#map2 = affine_map<()[s0] -> (s0 ceildiv 128)>
module  {
  hal.executable @mnist_linked_llvm_aot attributes {sym_visibility = "private"} {
    hal.interface @io_0 {
      hal.interface.binding @s0b0_ro_constant, set=0, binding=0, type="StorageBuffer", access="Read"
      hal.interface.binding @s0b1_ro_external, set=0, binding=1, type="StorageBuffer", access="Read"
      hal.interface.binding @s0b2_xw_external, set=0, binding=2, type="StorageBuffer", access="Write|Discard"
    }
    hal.interface @io_1 {
      hal.interface.binding @s0b0_ro_external, set=0, binding=0, type="StorageBuffer", access="Read"
      hal.interface.binding @s0b1_xw_external, set=0, binding=1, type="StorageBuffer", access="Write|Discard"
    }
    hal.interface @io_2 {
      hal.interface.binding @s0b0_ro_external, set=0, binding=0, type="StorageBuffer", access="Read"
      hal.interface.binding @s0b1_ro_external, set=0, binding=1, type="StorageBuffer", access="Read"
      hal.interface.binding @s0b2_xw_external, set=0, binding=2, type="StorageBuffer", access="Write|Discard"
    }
    hal.interface @io_3 {
      hal.interface.binding @s0b0_ro_external, set=0, binding=0, type="StorageBuffer", access="Read"
      hal.interface.binding @s0b1_ro_external, set=0, binding=1, type="StorageBuffer", access="Read"
      hal.interface.binding @s0b2_ro_external, set=0, binding=2, type="StorageBuffer", access="Read"
      hal.interface.binding @s0b3_xw_external, set=0, binding=3, type="StorageBuffer", access="Write|Discard"
    }
    hal.executable.target @llvm_aot, filter="dylib*" {
      hal.executable.entry_point @predict_dispatch_0 attributes {interface = @io_0, ordinal = 0 : index}
      hal.executable.entry_point @predict_dispatch_1 attributes {interface = @io_0, ordinal = 1 : index}
      hal.executable.entry_point @predict_dispatch_2 attributes {interface = @io_0, ordinal = 2 : index}
      hal.executable.entry_point @predict_dispatch_3 attributes {interface = @io_1, ordinal = 3 : index}
      hal.executable.entry_point @predict_dispatch_4 attributes {interface = @io_1, ordinal = 4 : index}
      hal.executable.entry_point @predict_dispatch_5 attributes {interface = @io_2, ordinal = 5 : index}
      hal.executable.entry_point @predict_dispatch_6 attributes {interface = @io_1, ordinal = 6 : index}
      hal.executable.entry_point @predict_dispatch_7 attributes {interface = @io_3, ordinal = 7 : index}
      module  {
        llvm.func internal @predict_dispatch_0(%arg0: !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>, %arg1: !llvm.ptr<array<3 x i32>>) -> i32 {
          %0 = llvm.mlir.constant(0.000000e+00 : f32) : f32
          %1 = llvm.mlir.constant(128 : index) : i64
          %2 = llvm.mlir.constant(784 : index) : i64
          %3 = llvm.mlir.constant(28 : index) : i64
          %4 = llvm.mlir.constant(32 : index) : i64
          %5 = llvm.mlir.constant(64 : index) : i64
          %6 = llvm.mlir.constant(4 : index) : i64
          %7 = llvm.mlir.constant(0 : index) : i64
          %8 = llvm.mlir.constant(1 : index) : i64
          %9 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %10 = llvm.extractvalue %9[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %11 = llvm.getelementptr %10[%8] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
          %12 = llvm.load %11 : !llvm.ptr<ptr<i8>>
          %13 = llvm.getelementptr %12[%7] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
          %14 = llvm.bitcast %13 : !llvm.ptr<i8> to !llvm.ptr<f32>
          %15 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %16 = llvm.insertvalue %14, %15[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %17 = llvm.insertvalue %14, %16[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %18 = llvm.insertvalue %7, %17[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %19 = llvm.insertvalue %8, %18[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %20 = llvm.insertvalue %2, %19[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %21 = llvm.insertvalue %2, %20[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %22 = llvm.insertvalue %8, %21[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %23 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %24 = llvm.extractvalue %23[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %25 = llvm.getelementptr %24[%7] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
          %26 = llvm.load %25 : !llvm.ptr<ptr<i8>>
          %27 = llvm.getelementptr %26[%7] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
          %28 = llvm.bitcast %27 : !llvm.ptr<i8> to !llvm.ptr<f32>
          %29 = llvm.insertvalue %28, %15[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %30 = llvm.insertvalue %28, %29[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %31 = llvm.insertvalue %7, %30[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %32 = llvm.insertvalue %2, %31[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %33 = llvm.insertvalue %1, %32[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %34 = llvm.insertvalue %1, %33[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %35 = llvm.insertvalue %8, %34[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %36 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %37 = llvm.extractvalue %36[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %38 = llvm.mlir.constant(2 : index) : i64
          %39 = llvm.getelementptr %37[%38] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
          %40 = llvm.load %39 : !llvm.ptr<ptr<i8>>
          %41 = llvm.getelementptr %40[%7] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
          %42 = llvm.bitcast %41 : !llvm.ptr<i8> to !llvm.ptr<f32>
          %43 = llvm.insertvalue %42, %15[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %44 = llvm.insertvalue %42, %43[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %45 = llvm.insertvalue %7, %44[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %46 = llvm.insertvalue %8, %45[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %47 = llvm.insertvalue %1, %46[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %48 = llvm.insertvalue %1, %47[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %49 = llvm.insertvalue %8, %48[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %50 = llvm.load %arg1 : !llvm.ptr<array<3 x i32>>
          %51 = llvm.extractvalue %50[0] : !llvm.array<3 x i32>
          %52 = llvm.zext %51 : i32 to i64
          %53 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %54 = llvm.extractvalue %53[0] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %55 = llvm.extractvalue %54[0] : !llvm.array<3 x i32>
          %56 = llvm.zext %55 : i32 to i64
          %57 = llvm.load %arg1 : !llvm.ptr<array<3 x i32>>
          %58 = llvm.extractvalue %57[1] : !llvm.array<3 x i32>
          %59 = llvm.zext %58 : i32 to i64
          %60 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %61 = llvm.extractvalue %60[0] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %62 = llvm.extractvalue %61[1] : !llvm.array<3 x i32>
          %63 = llvm.zext %62 : i32 to i64
          %64 = llvm.mul %59, %6  : i64
          %65 = llvm.mul %63, %6  : i64
          llvm.br ^bb1(%64 : i64)
        ^bb1(%66: i64):  // 2 preds: ^bb0, ^bb30
          %67 = llvm.icmp "slt" %66, %8 : i64
          llvm.cond_br %67, ^bb2, ^bb31
        ^bb2:  // pred: ^bb1
          %68 = llvm.mul %52, %5  : i64
          %69 = llvm.mul %56, %5  : i64
          llvm.br ^bb3(%68 : i64)
        ^bb3(%70: i64):  // 2 preds: ^bb2, ^bb29
          %71 = llvm.icmp "slt" %70, %1 : i64
          llvm.cond_br %71, ^bb4, ^bb30
        ^bb4:  // pred: ^bb3
          %72 = llvm.mlir.constant(-1 : index) : i64
          %73 = llvm.mul %66, %72  : i64
          %74 = llvm.add %73, %8  : i64
          %75 = llvm.icmp "slt" %6, %74 : i64
          %76 = llvm.select %75, %6, %74 : i1, i64
          %77 = llvm.extractvalue %22[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %78 = llvm.bitcast %77 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %79 = llvm.insertvalue %78, %15[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %80 = llvm.extractvalue %22[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %81 = llvm.bitcast %80 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %82 = llvm.insertvalue %81, %79[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %83 = llvm.extractvalue %22[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %84 = llvm.extractvalue %22[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %85 = llvm.extractvalue %22[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %86 = llvm.mul %66, %83  : i64
          %87 = llvm.add %85, %86  : i64
          %88 = llvm.mlir.constant(0 : i64) : i64
          %89 = llvm.mul %88, %84  : i64
          %90 = llvm.add %87, %89  : i64
          %91 = llvm.insertvalue %90, %82[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %92 = llvm.mlir.constant(784 : i64) : i64
          %93 = llvm.mlir.constant(1 : i64) : i64
          %94 = llvm.insertvalue %92, %91[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %95 = llvm.insertvalue %93, %94[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %96 = llvm.insertvalue %76, %95[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %97 = llvm.insertvalue %92, %96[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %98 = llvm.extractvalue %35[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %99 = llvm.bitcast %98 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %100 = llvm.insertvalue %99, %15[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %101 = llvm.extractvalue %35[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %102 = llvm.bitcast %101 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %103 = llvm.insertvalue %102, %100[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %104 = llvm.extractvalue %35[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %105 = llvm.extractvalue %35[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %106 = llvm.extractvalue %35[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %107 = llvm.mul %88, %104  : i64
          %108 = llvm.add %106, %107  : i64
          %109 = llvm.mul %70, %105  : i64
          %110 = llvm.add %108, %109  : i64
          %111 = llvm.insertvalue %110, %103[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %112 = llvm.mlir.constant(64 : i64) : i64
          %113 = llvm.insertvalue %112, %111[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %114 = llvm.insertvalue %93, %113[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %115 = llvm.mlir.constant(128 : i64) : i64
          %116 = llvm.insertvalue %92, %114[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %117 = llvm.insertvalue %115, %116[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %118 = llvm.extractvalue %49[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %119 = llvm.bitcast %118 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %120 = llvm.insertvalue %119, %15[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %121 = llvm.extractvalue %49[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %122 = llvm.bitcast %121 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %123 = llvm.insertvalue %122, %120[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %124 = llvm.extractvalue %49[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %125 = llvm.extractvalue %49[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %126 = llvm.extractvalue %49[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %127 = llvm.mul %66, %124  : i64
          %128 = llvm.add %126, %127  : i64
          %129 = llvm.mul %70, %125  : i64
          %130 = llvm.add %128, %129  : i64
          %131 = llvm.insertvalue %130, %123[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %132 = llvm.insertvalue %112, %131[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %133 = llvm.insertvalue %93, %132[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %134 = llvm.insertvalue %76, %133[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %135 = llvm.insertvalue %115, %134[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          llvm.br ^bb5(%7 : i64)
        ^bb5(%136: i64):  // 2 preds: ^bb4, ^bb8
          %137 = llvm.icmp "slt" %136, %76 : i64
          llvm.cond_br %137, ^bb6(%7 : i64), ^bb9(%7 : i64)
        ^bb6(%138: i64):  // 2 preds: ^bb5, ^bb7
          %139 = llvm.icmp "slt" %138, %5 : i64
          llvm.cond_br %139, ^bb7, ^bb8
        ^bb7:  // pred: ^bb6
          %140 = llvm.extractvalue %135[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %141 = llvm.extractvalue %135[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %142 = llvm.mul %136, %1  : i64
          %143 = llvm.add %141, %142  : i64
          %144 = llvm.add %143, %138  : i64
          %145 = llvm.getelementptr %140[%144] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
          llvm.store %0, %145 : !llvm.ptr<f32>
          %146 = llvm.add %138, %8  : i64
          llvm.br ^bb6(%146 : i64)
        ^bb8:  // pred: ^bb6
          %147 = llvm.add %136, %8  : i64
          llvm.br ^bb5(%147 : i64)
        ^bb9(%148: i64):  // 2 preds: ^bb5, ^bb28
          %149 = llvm.icmp "slt" %148, %76 : i64
          llvm.cond_br %149, ^bb10(%7 : i64), ^bb29
        ^bb10(%150: i64):  // 2 preds: ^bb9, ^bb27
          %151 = llvm.icmp "slt" %150, %5 : i64
          llvm.cond_br %151, ^bb11(%7 : i64), ^bb28
        ^bb11(%152: i64):  // 2 preds: ^bb10, ^bb26
          %153 = llvm.icmp "slt" %152, %2 : i64
          llvm.cond_br %153, ^bb12, ^bb27
        ^bb12:  // pred: ^bb11
          %154 = llvm.mul %148, %72  : i64
          %155 = llvm.add %76, %154  : i64
          %156 = llvm.icmp "slt" %6, %155 : i64
          %157 = llvm.select %156, %6, %155 : i1, i64
          %158 = llvm.extractvalue %97[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %159 = llvm.bitcast %158 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %160 = llvm.insertvalue %159, %15[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %161 = llvm.extractvalue %97[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %162 = llvm.bitcast %161 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %163 = llvm.insertvalue %162, %160[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %164 = llvm.extractvalue %97[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %165 = llvm.extractvalue %97[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %166 = llvm.extractvalue %97[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %167 = llvm.mul %148, %164  : i64
          %168 = llvm.add %166, %167  : i64
          %169 = llvm.mul %152, %165  : i64
          %170 = llvm.add %168, %169  : i64
          %171 = llvm.insertvalue %170, %163[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %172 = llvm.mlir.constant(28 : i64) : i64
          %173 = llvm.insertvalue %172, %171[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %174 = llvm.insertvalue %93, %173[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %175 = llvm.insertvalue %157, %174[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %176 = llvm.insertvalue %92, %175[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %177 = llvm.extractvalue %117[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %178 = llvm.bitcast %177 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %179 = llvm.insertvalue %178, %15[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %180 = llvm.extractvalue %117[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %181 = llvm.bitcast %180 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %182 = llvm.insertvalue %181, %179[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %183 = llvm.extractvalue %117[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %184 = llvm.extractvalue %117[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %185 = llvm.extractvalue %117[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %186 = llvm.mul %152, %183  : i64
          %187 = llvm.add %185, %186  : i64
          %188 = llvm.mul %150, %184  : i64
          %189 = llvm.add %187, %188  : i64
          %190 = llvm.insertvalue %189, %182[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %191 = llvm.mlir.constant(32 : i64) : i64
          %192 = llvm.insertvalue %191, %190[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %193 = llvm.insertvalue %93, %192[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %194 = llvm.insertvalue %172, %193[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %195 = llvm.insertvalue %115, %194[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %196 = llvm.extractvalue %135[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %197 = llvm.bitcast %196 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %198 = llvm.insertvalue %197, %15[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %199 = llvm.extractvalue %135[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %200 = llvm.bitcast %199 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %201 = llvm.insertvalue %200, %198[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %202 = llvm.extractvalue %135[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %203 = llvm.extractvalue %135[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %204 = llvm.extractvalue %135[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %205 = llvm.mul %148, %202  : i64
          %206 = llvm.add %204, %205  : i64
          %207 = llvm.mul %150, %203  : i64
          %208 = llvm.add %206, %207  : i64
          %209 = llvm.insertvalue %208, %201[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %210 = llvm.insertvalue %191, %209[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %211 = llvm.insertvalue %93, %210[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %212 = llvm.insertvalue %157, %211[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %213 = llvm.insertvalue %115, %212[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          llvm.br ^bb13(%7 : i64)
        ^bb13(%214: i64):  // 2 preds: ^bb12, ^bb25
          %215 = llvm.icmp "slt" %214, %157 : i64
          llvm.cond_br %215, ^bb14(%7 : i64), ^bb26
        ^bb14(%216: i64):  // 2 preds: ^bb13, ^bb24
          %217 = llvm.icmp "slt" %216, %4 : i64
          llvm.cond_br %217, ^bb15(%7 : i64), ^bb25
        ^bb15(%218: i64):  // 2 preds: ^bb14, ^bb23
          %219 = llvm.icmp "slt" %218, %3 : i64
          llvm.cond_br %219, ^bb16, ^bb24
        ^bb16:  // pred: ^bb15
          %220 = llvm.mul %214, %72  : i64
          %221 = llvm.add %157, %220  : i64
          %222 = llvm.icmp "slt" %6, %221 : i64
          %223 = llvm.select %222, %6, %221 : i1, i64
          %224 = llvm.extractvalue %176[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %225 = llvm.bitcast %224 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %226 = llvm.insertvalue %225, %15[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %227 = llvm.extractvalue %176[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %228 = llvm.bitcast %227 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %229 = llvm.insertvalue %228, %226[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %230 = llvm.extractvalue %176[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %231 = llvm.extractvalue %176[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %232 = llvm.extractvalue %176[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %233 = llvm.mul %214, %230  : i64
          %234 = llvm.add %232, %233  : i64
          %235 = llvm.mul %218, %231  : i64
          %236 = llvm.add %234, %235  : i64
          %237 = llvm.insertvalue %236, %229[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %238 = llvm.mlir.constant(4 : i64) : i64
          %239 = llvm.insertvalue %238, %237[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %240 = llvm.insertvalue %93, %239[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %241 = llvm.insertvalue %223, %240[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %242 = llvm.insertvalue %92, %241[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %243 = llvm.extractvalue %195[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %244 = llvm.bitcast %243 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %245 = llvm.insertvalue %244, %15[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %246 = llvm.extractvalue %195[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %247 = llvm.bitcast %246 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %248 = llvm.insertvalue %247, %245[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %249 = llvm.extractvalue %195[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %250 = llvm.extractvalue %195[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %251 = llvm.extractvalue %195[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %252 = llvm.mul %218, %249  : i64
          %253 = llvm.add %251, %252  : i64
          %254 = llvm.mul %216, %250  : i64
          %255 = llvm.add %253, %254  : i64
          %256 = llvm.insertvalue %255, %248[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %257 = llvm.insertvalue %238, %256[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %258 = llvm.insertvalue %93, %257[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %259 = llvm.insertvalue %238, %258[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %260 = llvm.insertvalue %115, %259[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %261 = llvm.extractvalue %213[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %262 = llvm.bitcast %261 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %263 = llvm.insertvalue %262, %15[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %264 = llvm.extractvalue %213[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %265 = llvm.bitcast %264 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %266 = llvm.insertvalue %265, %263[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %267 = llvm.extractvalue %213[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %268 = llvm.extractvalue %213[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %269 = llvm.extractvalue %213[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %270 = llvm.mul %214, %267  : i64
          %271 = llvm.add %269, %270  : i64
          %272 = llvm.mul %216, %268  : i64
          %273 = llvm.add %271, %272  : i64
          %274 = llvm.insertvalue %273, %266[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %275 = llvm.insertvalue %238, %274[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %276 = llvm.insertvalue %93, %275[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %277 = llvm.insertvalue %223, %276[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %278 = llvm.insertvalue %115, %277[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          llvm.br ^bb17(%7 : i64)
        ^bb17(%279: i64):  // 2 preds: ^bb16, ^bb22
          %280 = llvm.icmp "slt" %279, %223 : i64
          llvm.cond_br %280, ^bb18(%7 : i64), ^bb23
        ^bb18(%281: i64):  // 2 preds: ^bb17, ^bb21
          %282 = llvm.icmp "slt" %281, %6 : i64
          llvm.cond_br %282, ^bb19(%7 : i64), ^bb22
        ^bb19(%283: i64):  // 2 preds: ^bb18, ^bb20
          %284 = llvm.icmp "slt" %283, %6 : i64
          llvm.cond_br %284, ^bb20, ^bb21
        ^bb20:  // pred: ^bb19
          %285 = llvm.extractvalue %242[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %286 = llvm.extractvalue %242[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %287 = llvm.mul %279, %2  : i64
          %288 = llvm.add %286, %287  : i64
          %289 = llvm.add %288, %283  : i64
          %290 = llvm.getelementptr %285[%289] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
          %291 = llvm.load %290 : !llvm.ptr<f32>
          %292 = llvm.extractvalue %260[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %293 = llvm.extractvalue %260[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %294 = llvm.mul %283, %1  : i64
          %295 = llvm.add %293, %294  : i64
          %296 = llvm.add %295, %281  : i64
          %297 = llvm.getelementptr %292[%296] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
          %298 = llvm.load %297 : !llvm.ptr<f32>
          %299 = llvm.extractvalue %278[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %300 = llvm.extractvalue %278[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %301 = llvm.mul %279, %1  : i64
          %302 = llvm.add %300, %301  : i64
          %303 = llvm.add %302, %281  : i64
          %304 = llvm.getelementptr %299[%303] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
          %305 = llvm.load %304 : !llvm.ptr<f32>
          %306 = llvm.fmul %291, %298  : f32
          %307 = llvm.fadd %305, %306  : f32
          llvm.store %307, %304 : !llvm.ptr<f32>
          %308 = llvm.add %283, %8  : i64
          llvm.br ^bb19(%308 : i64)
        ^bb21:  // pred: ^bb19
          %309 = llvm.add %281, %8  : i64
          llvm.br ^bb18(%309 : i64)
        ^bb22:  // pred: ^bb18
          %310 = llvm.add %279, %8  : i64
          llvm.br ^bb17(%310 : i64)
        ^bb23:  // pred: ^bb17
          %311 = llvm.add %218, %6  : i64
          llvm.br ^bb15(%311 : i64)
        ^bb24:  // pred: ^bb15
          %312 = llvm.add %216, %6  : i64
          llvm.br ^bb14(%312 : i64)
        ^bb25:  // pred: ^bb14
          %313 = llvm.add %214, %6  : i64
          llvm.br ^bb13(%313 : i64)
        ^bb26:  // pred: ^bb13
          %314 = llvm.add %152, %3  : i64
          llvm.br ^bb11(%314 : i64)
        ^bb27:  // pred: ^bb11
          %315 = llvm.add %150, %4  : i64
          llvm.br ^bb10(%315 : i64)
        ^bb28:  // pred: ^bb10
          %316 = llvm.add %148, %6  : i64
          llvm.br ^bb9(%316 : i64)
        ^bb29:  // pred: ^bb9
          %317 = llvm.add %70, %69  : i64
          llvm.br ^bb3(%317 : i64)
        ^bb30:  // pred: ^bb3
          %318 = llvm.add %66, %65  : i64
          llvm.br ^bb1(%318 : i64)
        ^bb31:  // pred: ^bb1
          %319 = llvm.mlir.constant(0 : i32) : i32
          llvm.return %319 : i32
        }
        llvm.func internal @predict_dispatch_1(%arg0: !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>, %arg1: !llvm.ptr<array<3 x i32>>) -> i32 {
          %0 = llvm.mlir.constant(0x7FC00000 : f32) : f32
          %1 = llvm.mlir.constant(0.000000e+00 : f32) : f32
          %2 = llvm.mlir.constant(128 : index) : i64
          %3 = llvm.mlir.constant(0 : index) : i64
          %4 = llvm.mlir.constant(1 : index) : i64
          %5 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %6 = llvm.extractvalue %5[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %7 = llvm.getelementptr %6[%4] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
          %8 = llvm.load %7 : !llvm.ptr<ptr<i8>>
          %9 = llvm.getelementptr %8[%3] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
          %10 = llvm.bitcast %9 : !llvm.ptr<i8> to !llvm.ptr<f32>
          %11 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %12 = llvm.insertvalue %10, %11[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %13 = llvm.insertvalue %10, %12[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %14 = llvm.insertvalue %3, %13[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %15 = llvm.insertvalue %4, %14[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %16 = llvm.insertvalue %2, %15[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %17 = llvm.insertvalue %2, %16[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %18 = llvm.insertvalue %4, %17[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %19 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %20 = llvm.extractvalue %19[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %21 = llvm.getelementptr %20[%3] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
          %22 = llvm.load %21 : !llvm.ptr<ptr<i8>>
          %23 = llvm.getelementptr %22[%3] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
          %24 = llvm.bitcast %23 : !llvm.ptr<i8> to !llvm.ptr<f32>
          %25 = llvm.insertvalue %24, %11[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %26 = llvm.insertvalue %24, %25[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %27 = llvm.insertvalue %3, %26[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %28 = llvm.insertvalue %4, %27[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %29 = llvm.insertvalue %2, %28[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %30 = llvm.insertvalue %2, %29[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %31 = llvm.insertvalue %4, %30[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %32 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %33 = llvm.extractvalue %32[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %34 = llvm.mlir.constant(2 : index) : i64
          %35 = llvm.getelementptr %33[%34] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
          %36 = llvm.load %35 : !llvm.ptr<ptr<i8>>
          %37 = llvm.getelementptr %36[%3] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
          %38 = llvm.bitcast %37 : !llvm.ptr<i8> to !llvm.ptr<f32>
          %39 = llvm.insertvalue %38, %11[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %40 = llvm.insertvalue %38, %39[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %41 = llvm.insertvalue %3, %40[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %42 = llvm.insertvalue %4, %41[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %43 = llvm.insertvalue %2, %42[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %44 = llvm.insertvalue %2, %43[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %45 = llvm.insertvalue %4, %44[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %46 = llvm.load %arg1 : !llvm.ptr<array<3 x i32>>
          %47 = llvm.extractvalue %46[0] : !llvm.array<3 x i32>
          %48 = llvm.zext %47 : i32 to i64
          %49 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %50 = llvm.extractvalue %49[0] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %51 = llvm.extractvalue %50[0] : !llvm.array<3 x i32>
          %52 = llvm.zext %51 : i32 to i64
          %53 = llvm.load %arg1 : !llvm.ptr<array<3 x i32>>
          %54 = llvm.extractvalue %53[1] : !llvm.array<3 x i32>
          %55 = llvm.zext %54 : i32 to i64
          %56 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %57 = llvm.extractvalue %56[0] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %58 = llvm.extractvalue %57[1] : !llvm.array<3 x i32>
          %59 = llvm.zext %58 : i32 to i64
          %60 = llvm.mul %55, %2  : i64
          %61 = llvm.mul %59, %2  : i64
          llvm.br ^bb1(%60 : i64)
        ^bb1(%62: i64):  // 2 preds: ^bb0, ^bb10
          %63 = llvm.icmp "slt" %62, %4 : i64
          llvm.cond_br %63, ^bb2, ^bb11
        ^bb2:  // pred: ^bb1
          %64 = llvm.mul %48, %2  : i64
          %65 = llvm.mul %52, %2  : i64
          llvm.br ^bb3(%64 : i64)
        ^bb3(%66: i64):  // 2 preds: ^bb2, ^bb9
          %67 = llvm.icmp "slt" %66, %2 : i64
          llvm.cond_br %67, ^bb4, ^bb10
        ^bb4:  // pred: ^bb3
          %68 = llvm.mlir.constant(-1 : index) : i64
          %69 = llvm.mul %62, %68  : i64
          %70 = llvm.add %69, %4  : i64
          %71 = llvm.icmp "slt" %2, %70 : i64
          %72 = llvm.select %71, %2, %70 : i1, i64
          %73 = llvm.extractvalue %18[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %74 = llvm.bitcast %73 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %75 = llvm.insertvalue %74, %11[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %76 = llvm.extractvalue %18[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %77 = llvm.bitcast %76 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %78 = llvm.insertvalue %77, %75[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %79 = llvm.extractvalue %18[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %80 = llvm.extractvalue %18[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %81 = llvm.extractvalue %18[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %82 = llvm.mul %62, %79  : i64
          %83 = llvm.add %81, %82  : i64
          %84 = llvm.mul %66, %80  : i64
          %85 = llvm.add %83, %84  : i64
          %86 = llvm.insertvalue %85, %78[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %87 = llvm.mlir.constant(128 : i64) : i64
          %88 = llvm.mlir.constant(1 : i64) : i64
          %89 = llvm.insertvalue %87, %86[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %90 = llvm.insertvalue %88, %89[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %91 = llvm.insertvalue %72, %90[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %92 = llvm.insertvalue %87, %91[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %93 = llvm.extractvalue %31[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %94 = llvm.bitcast %93 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %95 = llvm.insertvalue %94, %11[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %96 = llvm.extractvalue %31[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %97 = llvm.bitcast %96 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %98 = llvm.insertvalue %97, %95[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %99 = llvm.extractvalue %31[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %100 = llvm.extractvalue %31[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %101 = llvm.extractvalue %31[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %102 = llvm.mul %62, %99  : i64
          %103 = llvm.add %101, %102  : i64
          %104 = llvm.mul %66, %100  : i64
          %105 = llvm.add %103, %104  : i64
          %106 = llvm.insertvalue %105, %98[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %107 = llvm.insertvalue %87, %106[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %108 = llvm.insertvalue %88, %107[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %109 = llvm.insertvalue %72, %108[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %110 = llvm.insertvalue %87, %109[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %111 = llvm.extractvalue %45[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %112 = llvm.bitcast %111 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %113 = llvm.insertvalue %112, %11[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %114 = llvm.extractvalue %45[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %115 = llvm.bitcast %114 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %116 = llvm.insertvalue %115, %113[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %117 = llvm.extractvalue %45[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %118 = llvm.extractvalue %45[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %119 = llvm.extractvalue %45[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %120 = llvm.mul %62, %117  : i64
          %121 = llvm.add %119, %120  : i64
          %122 = llvm.mul %66, %118  : i64
          %123 = llvm.add %121, %122  : i64
          %124 = llvm.insertvalue %123, %116[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %125 = llvm.insertvalue %87, %124[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %126 = llvm.insertvalue %88, %125[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %127 = llvm.insertvalue %72, %126[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %128 = llvm.insertvalue %87, %127[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          llvm.br ^bb5(%3 : i64)
        ^bb5(%129: i64):  // 2 preds: ^bb4, ^bb8
          %130 = llvm.icmp "slt" %129, %72 : i64
          llvm.cond_br %130, ^bb6(%3 : i64), ^bb9
        ^bb6(%131: i64):  // 2 preds: ^bb5, ^bb7
          %132 = llvm.icmp "slt" %131, %2 : i64
          llvm.cond_br %132, ^bb7, ^bb8
        ^bb7:  // pred: ^bb6
          %133 = llvm.extractvalue %92[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %134 = llvm.extractvalue %92[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %135 = llvm.mul %129, %2  : i64
          %136 = llvm.add %134, %135  : i64
          %137 = llvm.add %136, %131  : i64
          %138 = llvm.getelementptr %133[%137] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
          %139 = llvm.load %138 : !llvm.ptr<f32>
          %140 = llvm.extractvalue %110[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %141 = llvm.extractvalue %110[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %142 = llvm.add %141, %135  : i64
          %143 = llvm.add %142, %131  : i64
          %144 = llvm.getelementptr %140[%143] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
          %145 = llvm.load %144 : !llvm.ptr<f32>
          %146 = llvm.fadd %139, %145  : f32
          %147 = llvm.fcmp "ogt" %146, %1 : f32
          %148 = llvm.select %147, %146, %1 : i1, f32
          %149 = llvm.fcmp "uno" %146, %1 : f32
          %150 = llvm.select %149, %0, %148 : i1, f32
          %151 = llvm.extractvalue %128[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %152 = llvm.extractvalue %128[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %153 = llvm.add %152, %135  : i64
          %154 = llvm.add %153, %131  : i64
          %155 = llvm.getelementptr %151[%154] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
          llvm.store %150, %155 : !llvm.ptr<f32>
          %156 = llvm.add %131, %4  : i64
          llvm.br ^bb6(%156 : i64)
        ^bb8:  // pred: ^bb6
          %157 = llvm.add %129, %4  : i64
          llvm.br ^bb5(%157 : i64)
        ^bb9:  // pred: ^bb5
          %158 = llvm.add %66, %65  : i64
          llvm.br ^bb3(%158 : i64)
        ^bb10:  // pred: ^bb3
          %159 = llvm.add %62, %61  : i64
          llvm.br ^bb1(%159 : i64)
        ^bb11:  // pred: ^bb1
          %160 = llvm.mlir.constant(0 : i32) : i32
          llvm.return %160 : i32
        }
        llvm.func internal @predict_dispatch_2(%arg0: !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>, %arg1: !llvm.ptr<array<3 x i32>>) -> i32 {
          %0 = llvm.mlir.constant(0.000000e+00 : f32) : f32
          %1 = llvm.mlir.constant(10 : index) : i64
          %2 = llvm.mlir.constant(128 : index) : i64
          %3 = llvm.mlir.constant(32 : index) : i64
          %4 = llvm.mlir.constant(4 : index) : i64
          %5 = llvm.mlir.constant(0 : index) : i64
          %6 = llvm.mlir.constant(1 : index) : i64
          %7 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %8 = llvm.extractvalue %7[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %9 = llvm.getelementptr %8[%6] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
          %10 = llvm.load %9 : !llvm.ptr<ptr<i8>>
          %11 = llvm.getelementptr %10[%5] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
          %12 = llvm.bitcast %11 : !llvm.ptr<i8> to !llvm.ptr<f32>
          %13 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %14 = llvm.insertvalue %12, %13[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %15 = llvm.insertvalue %12, %14[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %16 = llvm.insertvalue %5, %15[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %17 = llvm.insertvalue %6, %16[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %18 = llvm.insertvalue %2, %17[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %19 = llvm.insertvalue %2, %18[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %20 = llvm.insertvalue %6, %19[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %21 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %22 = llvm.extractvalue %21[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %23 = llvm.getelementptr %22[%5] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
          %24 = llvm.load %23 : !llvm.ptr<ptr<i8>>
          %25 = llvm.getelementptr %24[%5] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
          %26 = llvm.bitcast %25 : !llvm.ptr<i8> to !llvm.ptr<f32>
          %27 = llvm.insertvalue %26, %13[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %28 = llvm.insertvalue %26, %27[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %29 = llvm.insertvalue %5, %28[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %30 = llvm.insertvalue %2, %29[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %31 = llvm.insertvalue %1, %30[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %32 = llvm.insertvalue %1, %31[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %33 = llvm.insertvalue %6, %32[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %34 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %35 = llvm.extractvalue %34[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %36 = llvm.mlir.constant(2 : index) : i64
          %37 = llvm.getelementptr %35[%36] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
          %38 = llvm.load %37 : !llvm.ptr<ptr<i8>>
          %39 = llvm.getelementptr %38[%5] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
          %40 = llvm.bitcast %39 : !llvm.ptr<i8> to !llvm.ptr<f32>
          %41 = llvm.insertvalue %40, %13[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %42 = llvm.insertvalue %40, %41[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %43 = llvm.insertvalue %5, %42[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %44 = llvm.insertvalue %6, %43[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %45 = llvm.insertvalue %1, %44[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %46 = llvm.insertvalue %1, %45[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %47 = llvm.insertvalue %6, %46[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %48 = llvm.load %arg1 : !llvm.ptr<array<3 x i32>>
          %49 = llvm.extractvalue %48[0] : !llvm.array<3 x i32>
          %50 = llvm.zext %49 : i32 to i64
          %51 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %52 = llvm.extractvalue %51[0] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %53 = llvm.extractvalue %52[0] : !llvm.array<3 x i32>
          %54 = llvm.zext %53 : i32 to i64
          %55 = llvm.load %arg1 : !llvm.ptr<array<3 x i32>>
          %56 = llvm.extractvalue %55[1] : !llvm.array<3 x i32>
          %57 = llvm.zext %56 : i32 to i64
          %58 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %59 = llvm.extractvalue %58[0] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %60 = llvm.extractvalue %59[1] : !llvm.array<3 x i32>
          %61 = llvm.zext %60 : i32 to i64
          %62 = llvm.mul %57, %4  : i64
          %63 = llvm.mul %61, %4  : i64
          llvm.br ^bb1(%62 : i64)
        ^bb1(%64: i64):  // 2 preds: ^bb0, ^bb30
          %65 = llvm.icmp "slt" %64, %6 : i64
          llvm.cond_br %65, ^bb2, ^bb31
        ^bb2:  // pred: ^bb1
          %66 = llvm.mlir.constant(64 : index) : i64
          %67 = llvm.mul %50, %66  : i64
          %68 = llvm.mul %54, %66  : i64
          llvm.br ^bb3(%67 : i64)
        ^bb3(%69: i64):  // 2 preds: ^bb2, ^bb29
          %70 = llvm.icmp "slt" %69, %1 : i64
          llvm.cond_br %70, ^bb4, ^bb30
        ^bb4:  // pred: ^bb3
          %71 = llvm.mlir.constant(-1 : index) : i64
          %72 = llvm.mul %64, %71  : i64
          %73 = llvm.add %72, %6  : i64
          %74 = llvm.icmp "slt" %4, %73 : i64
          %75 = llvm.select %74, %4, %73 : i1, i64
          %76 = llvm.extractvalue %20[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %77 = llvm.bitcast %76 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %78 = llvm.insertvalue %77, %13[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %79 = llvm.extractvalue %20[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %80 = llvm.bitcast %79 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %81 = llvm.insertvalue %80, %78[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %82 = llvm.extractvalue %20[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %83 = llvm.extractvalue %20[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %84 = llvm.extractvalue %20[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %85 = llvm.mul %64, %82  : i64
          %86 = llvm.add %84, %85  : i64
          %87 = llvm.mlir.constant(0 : i64) : i64
          %88 = llvm.mul %87, %83  : i64
          %89 = llvm.add %86, %88  : i64
          %90 = llvm.insertvalue %89, %81[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %91 = llvm.mlir.constant(128 : i64) : i64
          %92 = llvm.mlir.constant(1 : i64) : i64
          %93 = llvm.insertvalue %91, %90[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %94 = llvm.insertvalue %92, %93[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %95 = llvm.insertvalue %75, %94[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %96 = llvm.insertvalue %91, %95[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %97 = llvm.mul %69, %71  : i64
          %98 = llvm.add %97, %1  : i64
          %99 = llvm.icmp "slt" %66, %98 : i64
          %100 = llvm.select %99, %66, %98 : i1, i64
          %101 = llvm.extractvalue %33[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %102 = llvm.bitcast %101 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %103 = llvm.insertvalue %102, %13[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %104 = llvm.extractvalue %33[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %105 = llvm.bitcast %104 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %106 = llvm.insertvalue %105, %103[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %107 = llvm.extractvalue %33[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %108 = llvm.extractvalue %33[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %109 = llvm.extractvalue %33[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %110 = llvm.mul %87, %107  : i64
          %111 = llvm.add %109, %110  : i64
          %112 = llvm.mul %69, %108  : i64
          %113 = llvm.add %111, %112  : i64
          %114 = llvm.insertvalue %113, %106[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %115 = llvm.insertvalue %100, %114[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %116 = llvm.insertvalue %92, %115[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %117 = llvm.mlir.constant(10 : i64) : i64
          %118 = llvm.insertvalue %91, %116[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %119 = llvm.insertvalue %117, %118[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %120 = llvm.extractvalue %47[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %121 = llvm.bitcast %120 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %122 = llvm.insertvalue %121, %13[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %123 = llvm.extractvalue %47[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %124 = llvm.bitcast %123 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %125 = llvm.insertvalue %124, %122[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %126 = llvm.extractvalue %47[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %127 = llvm.extractvalue %47[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %128 = llvm.extractvalue %47[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %129 = llvm.mul %64, %126  : i64
          %130 = llvm.add %128, %129  : i64
          %131 = llvm.mul %69, %127  : i64
          %132 = llvm.add %130, %131  : i64
          %133 = llvm.insertvalue %132, %125[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %134 = llvm.insertvalue %100, %133[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %135 = llvm.insertvalue %92, %134[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %136 = llvm.insertvalue %75, %135[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %137 = llvm.insertvalue %117, %136[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          llvm.br ^bb5(%5 : i64)
        ^bb5(%138: i64):  // 2 preds: ^bb4, ^bb8
          %139 = llvm.icmp "slt" %138, %75 : i64
          llvm.cond_br %139, ^bb6(%5 : i64), ^bb9(%5 : i64)
        ^bb6(%140: i64):  // 2 preds: ^bb5, ^bb7
          %141 = llvm.icmp "slt" %140, %100 : i64
          llvm.cond_br %141, ^bb7, ^bb8
        ^bb7:  // pred: ^bb6
          %142 = llvm.extractvalue %137[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %143 = llvm.extractvalue %137[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %144 = llvm.mul %138, %1  : i64
          %145 = llvm.add %143, %144  : i64
          %146 = llvm.add %145, %140  : i64
          %147 = llvm.getelementptr %142[%146] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
          llvm.store %0, %147 : !llvm.ptr<f32>
          %148 = llvm.add %140, %6  : i64
          llvm.br ^bb6(%148 : i64)
        ^bb8:  // pred: ^bb6
          %149 = llvm.add %138, %6  : i64
          llvm.br ^bb5(%149 : i64)
        ^bb9(%150: i64):  // 2 preds: ^bb5, ^bb28
          %151 = llvm.icmp "slt" %150, %75 : i64
          llvm.cond_br %151, ^bb10(%5 : i64), ^bb29
        ^bb10(%152: i64):  // 2 preds: ^bb9, ^bb27
          %153 = llvm.icmp "slt" %152, %100 : i64
          llvm.cond_br %153, ^bb11(%5 : i64), ^bb28
        ^bb11(%154: i64):  // 2 preds: ^bb10, ^bb26
          %155 = llvm.icmp "slt" %154, %2 : i64
          llvm.cond_br %155, ^bb12, ^bb27
        ^bb12:  // pred: ^bb11
          %156 = llvm.mul %150, %71  : i64
          %157 = llvm.add %75, %156  : i64
          %158 = llvm.icmp "slt" %4, %157 : i64
          %159 = llvm.select %158, %4, %157 : i1, i64
          %160 = llvm.extractvalue %96[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %161 = llvm.bitcast %160 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %162 = llvm.insertvalue %161, %13[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %163 = llvm.extractvalue %96[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %164 = llvm.bitcast %163 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %165 = llvm.insertvalue %164, %162[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %166 = llvm.extractvalue %96[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %167 = llvm.extractvalue %96[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %168 = llvm.extractvalue %96[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %169 = llvm.mul %150, %166  : i64
          %170 = llvm.add %168, %169  : i64
          %171 = llvm.mul %154, %167  : i64
          %172 = llvm.add %170, %171  : i64
          %173 = llvm.insertvalue %172, %165[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %174 = llvm.mlir.constant(32 : i64) : i64
          %175 = llvm.insertvalue %174, %173[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %176 = llvm.insertvalue %92, %175[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %177 = llvm.insertvalue %159, %176[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %178 = llvm.insertvalue %91, %177[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %179 = llvm.mul %152, %71  : i64
          %180 = llvm.add %100, %179  : i64
          %181 = llvm.icmp "slt" %3, %180 : i64
          %182 = llvm.select %181, %3, %180 : i1, i64
          %183 = llvm.extractvalue %119[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %184 = llvm.bitcast %183 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %185 = llvm.insertvalue %184, %13[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %186 = llvm.extractvalue %119[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %187 = llvm.bitcast %186 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %188 = llvm.insertvalue %187, %185[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %189 = llvm.extractvalue %119[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %190 = llvm.extractvalue %119[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %191 = llvm.extractvalue %119[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %192 = llvm.mul %154, %189  : i64
          %193 = llvm.add %191, %192  : i64
          %194 = llvm.mul %152, %190  : i64
          %195 = llvm.add %193, %194  : i64
          %196 = llvm.insertvalue %195, %188[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %197 = llvm.insertvalue %182, %196[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %198 = llvm.insertvalue %92, %197[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %199 = llvm.insertvalue %174, %198[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %200 = llvm.insertvalue %117, %199[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %201 = llvm.extractvalue %137[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %202 = llvm.bitcast %201 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %203 = llvm.insertvalue %202, %13[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %204 = llvm.extractvalue %137[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %205 = llvm.bitcast %204 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %206 = llvm.insertvalue %205, %203[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %207 = llvm.extractvalue %137[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %208 = llvm.extractvalue %137[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %209 = llvm.extractvalue %137[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %210 = llvm.mul %150, %207  : i64
          %211 = llvm.add %209, %210  : i64
          %212 = llvm.mul %152, %208  : i64
          %213 = llvm.add %211, %212  : i64
          %214 = llvm.insertvalue %213, %206[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %215 = llvm.insertvalue %182, %214[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %216 = llvm.insertvalue %92, %215[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %217 = llvm.insertvalue %159, %216[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %218 = llvm.insertvalue %117, %217[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          llvm.br ^bb13(%5 : i64)
        ^bb13(%219: i64):  // 2 preds: ^bb12, ^bb25
          %220 = llvm.icmp "slt" %219, %159 : i64
          llvm.cond_br %220, ^bb14(%5 : i64), ^bb26
        ^bb14(%221: i64):  // 2 preds: ^bb13, ^bb24
          %222 = llvm.icmp "slt" %221, %182 : i64
          llvm.cond_br %222, ^bb15(%5 : i64), ^bb25
        ^bb15(%223: i64):  // 2 preds: ^bb14, ^bb23
          %224 = llvm.icmp "slt" %223, %3 : i64
          llvm.cond_br %224, ^bb16, ^bb24
        ^bb16:  // pred: ^bb15
          %225 = llvm.mul %219, %71  : i64
          %226 = llvm.add %159, %225  : i64
          %227 = llvm.icmp "slt" %4, %226 : i64
          %228 = llvm.select %227, %4, %226 : i1, i64
          %229 = llvm.extractvalue %178[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %230 = llvm.bitcast %229 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %231 = llvm.insertvalue %230, %13[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %232 = llvm.extractvalue %178[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %233 = llvm.bitcast %232 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %234 = llvm.insertvalue %233, %231[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %235 = llvm.extractvalue %178[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %236 = llvm.extractvalue %178[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %237 = llvm.extractvalue %178[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %238 = llvm.mul %219, %235  : i64
          %239 = llvm.add %237, %238  : i64
          %240 = llvm.mul %223, %236  : i64
          %241 = llvm.add %239, %240  : i64
          %242 = llvm.insertvalue %241, %234[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %243 = llvm.mlir.constant(4 : i64) : i64
          %244 = llvm.insertvalue %243, %242[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %245 = llvm.insertvalue %92, %244[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %246 = llvm.insertvalue %228, %245[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %247 = llvm.insertvalue %91, %246[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %248 = llvm.mul %221, %71  : i64
          %249 = llvm.add %182, %248  : i64
          %250 = llvm.icmp "slt" %4, %249 : i64
          %251 = llvm.select %250, %4, %249 : i1, i64
          %252 = llvm.extractvalue %200[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %253 = llvm.bitcast %252 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %254 = llvm.insertvalue %253, %13[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %255 = llvm.extractvalue %200[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %256 = llvm.bitcast %255 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %257 = llvm.insertvalue %256, %254[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %258 = llvm.extractvalue %200[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %259 = llvm.extractvalue %200[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %260 = llvm.extractvalue %200[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %261 = llvm.mul %223, %258  : i64
          %262 = llvm.add %260, %261  : i64
          %263 = llvm.mul %221, %259  : i64
          %264 = llvm.add %262, %263  : i64
          %265 = llvm.insertvalue %264, %257[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %266 = llvm.insertvalue %251, %265[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %267 = llvm.insertvalue %92, %266[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %268 = llvm.insertvalue %243, %267[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %269 = llvm.insertvalue %117, %268[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %270 = llvm.extractvalue %218[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %271 = llvm.bitcast %270 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %272 = llvm.insertvalue %271, %13[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %273 = llvm.extractvalue %218[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %274 = llvm.bitcast %273 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %275 = llvm.insertvalue %274, %272[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %276 = llvm.extractvalue %218[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %277 = llvm.extractvalue %218[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %278 = llvm.extractvalue %218[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %279 = llvm.mul %219, %276  : i64
          %280 = llvm.add %278, %279  : i64
          %281 = llvm.mul %221, %277  : i64
          %282 = llvm.add %280, %281  : i64
          %283 = llvm.insertvalue %282, %275[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %284 = llvm.insertvalue %251, %283[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %285 = llvm.insertvalue %92, %284[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %286 = llvm.insertvalue %228, %285[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %287 = llvm.insertvalue %117, %286[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          llvm.br ^bb17(%5 : i64)
        ^bb17(%288: i64):  // 2 preds: ^bb16, ^bb22
          %289 = llvm.icmp "slt" %288, %228 : i64
          llvm.cond_br %289, ^bb18(%5 : i64), ^bb23
        ^bb18(%290: i64):  // 2 preds: ^bb17, ^bb21
          %291 = llvm.icmp "slt" %290, %251 : i64
          llvm.cond_br %291, ^bb19(%5 : i64), ^bb22
        ^bb19(%292: i64):  // 2 preds: ^bb18, ^bb20
          %293 = llvm.icmp "slt" %292, %4 : i64
          llvm.cond_br %293, ^bb20, ^bb21
        ^bb20:  // pred: ^bb19
          %294 = llvm.extractvalue %247[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %295 = llvm.extractvalue %247[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %296 = llvm.mul %288, %2  : i64
          %297 = llvm.add %295, %296  : i64
          %298 = llvm.add %297, %292  : i64
          %299 = llvm.getelementptr %294[%298] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
          %300 = llvm.load %299 : !llvm.ptr<f32>
          %301 = llvm.extractvalue %269[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %302 = llvm.extractvalue %269[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %303 = llvm.mul %292, %1  : i64
          %304 = llvm.add %302, %303  : i64
          %305 = llvm.add %304, %290  : i64
          %306 = llvm.getelementptr %301[%305] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
          %307 = llvm.load %306 : !llvm.ptr<f32>
          %308 = llvm.extractvalue %287[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %309 = llvm.extractvalue %287[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %310 = llvm.mul %288, %1  : i64
          %311 = llvm.add %309, %310  : i64
          %312 = llvm.add %311, %290  : i64
          %313 = llvm.getelementptr %308[%312] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
          %314 = llvm.load %313 : !llvm.ptr<f32>
          %315 = llvm.fmul %300, %307  : f32
          %316 = llvm.fadd %314, %315  : f32
          llvm.store %316, %313 : !llvm.ptr<f32>
          %317 = llvm.add %292, %6  : i64
          llvm.br ^bb19(%317 : i64)
        ^bb21:  // pred: ^bb19
          %318 = llvm.add %290, %6  : i64
          llvm.br ^bb18(%318 : i64)
        ^bb22:  // pred: ^bb18
          %319 = llvm.add %288, %6  : i64
          llvm.br ^bb17(%319 : i64)
        ^bb23:  // pred: ^bb17
          %320 = llvm.add %223, %4  : i64
          llvm.br ^bb15(%320 : i64)
        ^bb24:  // pred: ^bb15
          %321 = llvm.add %221, %4  : i64
          llvm.br ^bb14(%321 : i64)
        ^bb25:  // pred: ^bb14
          %322 = llvm.add %219, %4  : i64
          llvm.br ^bb13(%322 : i64)
        ^bb26:  // pred: ^bb13
          %323 = llvm.add %154, %3  : i64
          llvm.br ^bb11(%323 : i64)
        ^bb27:  // pred: ^bb11
          %324 = llvm.add %152, %3  : i64
          llvm.br ^bb10(%324 : i64)
        ^bb28:  // pred: ^bb10
          %325 = llvm.add %150, %4  : i64
          llvm.br ^bb9(%325 : i64)
        ^bb29:  // pred: ^bb9
          %326 = llvm.add %69, %68  : i64
          llvm.br ^bb3(%326 : i64)
        ^bb30:  // pred: ^bb3
          %327 = llvm.add %64, %63  : i64
          llvm.br ^bb1(%327 : i64)
        ^bb31:  // pred: ^bb1
          %328 = llvm.mlir.constant(0 : i32) : i32
          llvm.return %328 : i32
        }
        llvm.mlir.global private constant @__constant_1x10xf32_3(opaque<"_", "0xDEADBEEF"> : tensor<1x10xf32>) : !llvm.array<1 x array<10 x f32>>
        llvm.func internal @predict_dispatch_3(%arg0: !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>, %arg1: !llvm.ptr<array<3 x i32>>) -> i32 {
          %0 = llvm.mlir.constant(10 : index) : i64
          %1 = llvm.mlir.constant(0 : index) : i64
          %2 = llvm.mlir.constant(1 : index) : i64
          %3 = llvm.mlir.addressof @__constant_1x10xf32_3 : !llvm.ptr<array<1 x array<10 x f32>>>
          %4 = llvm.getelementptr %3[%1, %1, %1] : (!llvm.ptr<array<1 x array<10 x f32>>>, i64, i64, i64) -> !llvm.ptr<f32>
          %5 = llvm.mlir.constant(3735928559 : index) : i64
          %6 = llvm.inttoptr %5 : i64 to !llvm.ptr<f32>
          %7 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %8 = llvm.insertvalue %6, %7[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %9 = llvm.insertvalue %4, %8[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %10 = llvm.insertvalue %1, %9[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %11 = llvm.insertvalue %2, %10[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %12 = llvm.insertvalue %0, %11[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %13 = llvm.insertvalue %0, %12[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %14 = llvm.insertvalue %2, %13[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %15 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %16 = llvm.extractvalue %15[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %17 = llvm.getelementptr %16[%1] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
          %18 = llvm.load %17 : !llvm.ptr<ptr<i8>>
          %19 = llvm.getelementptr %18[%1] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
          %20 = llvm.bitcast %19 : !llvm.ptr<i8> to !llvm.ptr<f32>
          %21 = llvm.insertvalue %20, %7[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %22 = llvm.insertvalue %20, %21[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %23 = llvm.insertvalue %1, %22[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %24 = llvm.insertvalue %2, %23[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %25 = llvm.insertvalue %0, %24[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %26 = llvm.insertvalue %0, %25[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %27 = llvm.insertvalue %2, %26[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %28 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %29 = llvm.extractvalue %28[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %30 = llvm.getelementptr %29[%2] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
          %31 = llvm.load %30 : !llvm.ptr<ptr<i8>>
          %32 = llvm.getelementptr %31[%1] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
          %33 = llvm.bitcast %32 : !llvm.ptr<i8> to !llvm.ptr<f32>
          %34 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %35 = llvm.insertvalue %33, %34[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %36 = llvm.insertvalue %33, %35[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %37 = llvm.insertvalue %1, %36[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %38 = llvm.insertvalue %0, %37[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %39 = llvm.insertvalue %2, %38[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %40 = llvm.load %arg1 : !llvm.ptr<array<3 x i32>>
          %41 = llvm.extractvalue %40[0] : !llvm.array<3 x i32>
          %42 = llvm.zext %41 : i32 to i64
          %43 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %44 = llvm.extractvalue %43[0] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %45 = llvm.extractvalue %44[0] : !llvm.array<3 x i32>
          %46 = llvm.zext %45 : i32 to i64
          %47 = llvm.load %arg1 : !llvm.ptr<array<3 x i32>>
          %48 = llvm.extractvalue %47[1] : !llvm.array<3 x i32>
          %49 = llvm.zext %48 : i32 to i64
          %50 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %51 = llvm.extractvalue %50[0] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %52 = llvm.extractvalue %51[1] : !llvm.array<3 x i32>
          %53 = llvm.zext %52 : i32 to i64
          %54 = llvm.mlir.constant(128 : index) : i64
          %55 = llvm.mul %49, %54  : i64
          %56 = llvm.mul %53, %54  : i64
          llvm.br ^bb1(%55 : i64)
        ^bb1(%57: i64):  // 2 preds: ^bb0, ^bb10
          %58 = llvm.icmp "slt" %57, %2 : i64
          llvm.cond_br %58, ^bb2, ^bb11
        ^bb2:  // pred: ^bb1
          %59 = llvm.mul %42, %54  : i64
          %60 = llvm.mul %46, %54  : i64
          llvm.br ^bb3(%59 : i64)
        ^bb3(%61: i64):  // 2 preds: ^bb2, ^bb9
          %62 = llvm.icmp "slt" %61, %0 : i64
          llvm.cond_br %62, ^bb4, ^bb10
        ^bb4:  // pred: ^bb3
          %63 = llvm.mlir.constant(-1 : index) : i64
          %64 = llvm.mul %57, %63  : i64
          %65 = llvm.add %64, %2  : i64
          %66 = llvm.icmp "slt" %54, %65 : i64
          %67 = llvm.select %66, %54, %65 : i1, i64
          %68 = llvm.mul %61, %63  : i64
          %69 = llvm.add %68, %0  : i64
          %70 = llvm.icmp "slt" %54, %69 : i64
          %71 = llvm.select %70, %54, %69 : i1, i64
          %72 = llvm.extractvalue %27[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %73 = llvm.bitcast %72 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %74 = llvm.insertvalue %73, %7[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %75 = llvm.extractvalue %27[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %76 = llvm.bitcast %75 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %77 = llvm.insertvalue %76, %74[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %78 = llvm.extractvalue %27[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %79 = llvm.extractvalue %27[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %80 = llvm.extractvalue %27[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %81 = llvm.mul %57, %78  : i64
          %82 = llvm.add %80, %81  : i64
          %83 = llvm.mul %61, %79  : i64
          %84 = llvm.add %82, %83  : i64
          %85 = llvm.insertvalue %84, %77[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %86 = llvm.mlir.constant(1 : i64) : i64
          %87 = llvm.insertvalue %71, %85[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %88 = llvm.insertvalue %86, %87[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %89 = llvm.mlir.constant(10 : i64) : i64
          %90 = llvm.insertvalue %67, %88[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %91 = llvm.insertvalue %89, %90[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %92 = llvm.extractvalue %14[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %93 = llvm.bitcast %92 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %94 = llvm.insertvalue %93, %7[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %95 = llvm.extractvalue %14[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %96 = llvm.bitcast %95 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %97 = llvm.insertvalue %96, %94[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %98 = llvm.extractvalue %14[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %99 = llvm.extractvalue %14[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %100 = llvm.extractvalue %14[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %101 = llvm.mul %57, %98  : i64
          %102 = llvm.add %100, %101  : i64
          %103 = llvm.mul %61, %99  : i64
          %104 = llvm.add %102, %103  : i64
          %105 = llvm.insertvalue %104, %97[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %106 = llvm.insertvalue %71, %105[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %107 = llvm.insertvalue %86, %106[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %108 = llvm.insertvalue %67, %107[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %109 = llvm.insertvalue %89, %108[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %110 = llvm.extractvalue %39[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %111 = llvm.bitcast %110 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %112 = llvm.insertvalue %111, %34[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %113 = llvm.extractvalue %39[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %114 = llvm.bitcast %113 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %115 = llvm.insertvalue %114, %112[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %116 = llvm.extractvalue %39[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %117 = llvm.extractvalue %39[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %118 = llvm.mul %61, %116  : i64
          %119 = llvm.add %117, %118  : i64
          %120 = llvm.insertvalue %119, %115[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %121 = llvm.insertvalue %71, %120[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %122 = llvm.insertvalue %86, %121[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          llvm.br ^bb5(%1 : i64)
        ^bb5(%123: i64):  // 2 preds: ^bb4, ^bb8
          %124 = llvm.icmp "slt" %123, %67 : i64
          llvm.cond_br %124, ^bb6(%1 : i64), ^bb9
        ^bb6(%125: i64):  // 2 preds: ^bb5, ^bb7
          %126 = llvm.icmp "slt" %125, %71 : i64
          llvm.cond_br %126, ^bb7, ^bb8
        ^bb7:  // pred: ^bb6
          %127 = llvm.extractvalue %91[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %128 = llvm.extractvalue %91[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %129 = llvm.mul %123, %0  : i64
          %130 = llvm.add %128, %129  : i64
          %131 = llvm.add %130, %125  : i64
          %132 = llvm.getelementptr %127[%131] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
          %133 = llvm.load %132 : !llvm.ptr<f32>
          %134 = llvm.extractvalue %109[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %135 = llvm.extractvalue %109[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %136 = llvm.add %135, %129  : i64
          %137 = llvm.add %136, %125  : i64
          %138 = llvm.getelementptr %134[%137] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
          %139 = llvm.load %138 : !llvm.ptr<f32>
          %140 = llvm.fadd %133, %139  : f32
          %141 = llvm.extractvalue %122[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %142 = llvm.extractvalue %122[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %143 = llvm.add %142, %125  : i64
          %144 = llvm.getelementptr %141[%143] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
          llvm.store %140, %144 : !llvm.ptr<f32>
          %145 = llvm.add %125, %2  : i64
          llvm.br ^bb6(%145 : i64)
        ^bb8:  // pred: ^bb6
          %146 = llvm.add %123, %2  : i64
          llvm.br ^bb5(%146 : i64)
        ^bb9:  // pred: ^bb5
          %147 = llvm.add %61, %60  : i64
          llvm.br ^bb3(%147 : i64)
        ^bb10:  // pred: ^bb3
          %148 = llvm.add %57, %56  : i64
          llvm.br ^bb1(%148 : i64)
        ^bb11:  // pred: ^bb1
          %149 = llvm.mlir.constant(0 : i32) : i32
          llvm.return %149 : i32
        }
        llvm.func internal @predict_dispatch_4(%arg0: !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>, %arg1: !llvm.ptr<array<3 x i32>>) -> i32 {
          %0 = llvm.mlir.constant(0x7FC00000 : f32) : f32
          %1 = llvm.mlir.constant(0xFF800000 : f32) : f32
          %2 = llvm.mlir.constant(10 : index) : i64
          %3 = llvm.mlir.constant(0 : index) : i64
          %4 = llvm.mlir.constant(1 : index) : i64
          %5 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %6 = llvm.extractvalue %5[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %7 = llvm.getelementptr %6[%3] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
          %8 = llvm.load %7 : !llvm.ptr<ptr<i8>>
          %9 = llvm.getelementptr %8[%3] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
          %10 = llvm.bitcast %9 : !llvm.ptr<i8> to !llvm.ptr<f32>
          %11 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %12 = llvm.insertvalue %10, %11[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %13 = llvm.insertvalue %10, %12[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %14 = llvm.insertvalue %3, %13[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %15 = llvm.insertvalue %2, %14[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %16 = llvm.insertvalue %4, %15[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %17 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %18 = llvm.extractvalue %17[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %19 = llvm.getelementptr %18[%4] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
          %20 = llvm.load %19 : !llvm.ptr<ptr<i8>>
          %21 = llvm.getelementptr %20[%3] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
          %22 = llvm.bitcast %21 : !llvm.ptr<i8> to !llvm.ptr<f32>
          %23 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
          %24 = llvm.insertvalue %22, %23[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
          %25 = llvm.insertvalue %22, %24[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
          %26 = llvm.insertvalue %3, %25[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
          %27 = llvm.extractvalue %26[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
          llvm.store %1, %27 : !llvm.ptr<f32>
          llvm.br ^bb1(%3 : i64)
        ^bb1(%28: i64):  // 2 preds: ^bb0, ^bb2
          %29 = llvm.icmp "slt" %28, %2 : i64
          llvm.cond_br %29, ^bb2, ^bb3
        ^bb2:  // pred: ^bb1
          %30 = llvm.extractvalue %16[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %31 = llvm.getelementptr %30[%28] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
          %32 = llvm.load %31 : !llvm.ptr<f32>
          %33 = llvm.load %27 : !llvm.ptr<f32>
          %34 = llvm.fcmp "ogt" %32, %33 : f32
          %35 = llvm.select %34, %32, %33 : i1, f32
          %36 = llvm.fcmp "uno" %32, %33 : f32
          %37 = llvm.select %36, %0, %35 : i1, f32
          llvm.store %37, %27 : !llvm.ptr<f32>
          %38 = llvm.add %28, %4  : i64
          llvm.br ^bb1(%38 : i64)
        ^bb3:  // pred: ^bb1
          %39 = llvm.mlir.constant(0 : i32) : i32
          llvm.return %39 : i32
        }
        llvm.mlir.global private constant @__constant_1x10xf32_5(opaque<"_", "0xDEADBEEF"> : tensor<1x10xf32>) : !llvm.array<1 x array<10 x f32>>
        llvm.func internal @predict_dispatch_5(%arg0: !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>, %arg1: !llvm.ptr<array<3 x i32>>) -> i32 {
          %0 = llvm.mlir.constant(10 : index) : i64
          %1 = llvm.mlir.constant(0 : index) : i64
          %2 = llvm.mlir.constant(1 : index) : i64
          %3 = llvm.mlir.constant(0.693147182 : f32) : f32
          %4 = llvm.mlir.constant(1.44269502 : f32) : f32
          %5 = llvm.mlir.constant(1.000000e+00 : f32) : f32
          %6 = llvm.mlir.constant(0.499705136 : f32) : f32
          %7 = llvm.mlir.constant(0.168738902 : f32) : f32
          %8 = llvm.mlir.constant(0.0366896503 : f32) : f32
          %9 = llvm.mlir.constant(1.314350e-02 : f32) : f32
          %10 = llvm.mlir.constant(23 : i32) : i32
          %11 = llvm.mlir.constant(0.000000e+00 : f32) : f32
          %12 = llvm.mlir.constant(0x7F800000 : f32) : f32
          %13 = llvm.mlir.constant(0xFF800000 : f32) : f32
          %14 = llvm.mlir.constant(1.17549435E-38 : f32) : f32
          %15 = llvm.mlir.constant(127 : i32) : i32
          %16 = llvm.mlir.constant(-127 : i32) : i32
          %17 = llvm.mlir.addressof @__constant_1x10xf32_5 : !llvm.ptr<array<1 x array<10 x f32>>>
          %18 = llvm.getelementptr %17[%1, %1, %1] : (!llvm.ptr<array<1 x array<10 x f32>>>, i64, i64, i64) -> !llvm.ptr<f32>
          %19 = llvm.mlir.constant(3735928559 : index) : i64
          %20 = llvm.inttoptr %19 : i64 to !llvm.ptr<f32>
          %21 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %22 = llvm.insertvalue %20, %21[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %23 = llvm.insertvalue %18, %22[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %24 = llvm.insertvalue %1, %23[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %25 = llvm.insertvalue %2, %24[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %26 = llvm.insertvalue %0, %25[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %27 = llvm.insertvalue %0, %26[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %28 = llvm.insertvalue %2, %27[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %29 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %30 = llvm.extractvalue %29[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %31 = llvm.getelementptr %30[%1] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
          %32 = llvm.load %31 : !llvm.ptr<ptr<i8>>
          %33 = llvm.getelementptr %32[%1] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
          %34 = llvm.bitcast %33 : !llvm.ptr<i8> to !llvm.ptr<f32>
          %35 = llvm.insertvalue %34, %21[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %36 = llvm.insertvalue %34, %35[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %37 = llvm.insertvalue %1, %36[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %38 = llvm.insertvalue %2, %37[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %39 = llvm.insertvalue %0, %38[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %40 = llvm.insertvalue %0, %39[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %41 = llvm.insertvalue %2, %40[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %42 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %43 = llvm.extractvalue %42[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %44 = llvm.getelementptr %43[%2] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
          %45 = llvm.load %44 : !llvm.ptr<ptr<i8>>
          %46 = llvm.getelementptr %45[%1] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
          %47 = llvm.bitcast %46 : !llvm.ptr<i8> to !llvm.ptr<f32>
          %48 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
          %49 = llvm.insertvalue %47, %48[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
          %50 = llvm.insertvalue %47, %49[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
          %51 = llvm.insertvalue %1, %50[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
          %52 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %53 = llvm.extractvalue %52[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %54 = llvm.mlir.constant(2 : index) : i64
          %55 = llvm.getelementptr %53[%54] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
          %56 = llvm.load %55 : !llvm.ptr<ptr<i8>>
          %57 = llvm.getelementptr %56[%1] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
          %58 = llvm.bitcast %57 : !llvm.ptr<i8> to !llvm.ptr<f32>
          %59 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %60 = llvm.insertvalue %58, %59[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %61 = llvm.insertvalue %58, %60[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %62 = llvm.insertvalue %1, %61[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %63 = llvm.insertvalue %0, %62[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %64 = llvm.insertvalue %2, %63[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %65 = llvm.load %arg1 : !llvm.ptr<array<3 x i32>>
          %66 = llvm.extractvalue %65[0] : !llvm.array<3 x i32>
          %67 = llvm.zext %66 : i32 to i64
          %68 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %69 = llvm.extractvalue %68[0] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %70 = llvm.extractvalue %69[0] : !llvm.array<3 x i32>
          %71 = llvm.zext %70 : i32 to i64
          %72 = llvm.load %arg1 : !llvm.ptr<array<3 x i32>>
          %73 = llvm.extractvalue %72[1] : !llvm.array<3 x i32>
          %74 = llvm.zext %73 : i32 to i64
          %75 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %76 = llvm.extractvalue %75[0] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %77 = llvm.extractvalue %76[1] : !llvm.array<3 x i32>
          %78 = llvm.zext %77 : i32 to i64
          %79 = llvm.mlir.constant(128 : index) : i64
          %80 = llvm.mul %74, %79  : i64
          %81 = llvm.mul %78, %79  : i64
          llvm.br ^bb1(%80 : i64)
        ^bb1(%82: i64):  // 2 preds: ^bb0, ^bb10
          %83 = llvm.icmp "slt" %82, %2 : i64
          llvm.cond_br %83, ^bb2, ^bb11
        ^bb2:  // pred: ^bb1
          %84 = llvm.mul %67, %79  : i64
          %85 = llvm.mul %71, %79  : i64
          llvm.br ^bb3(%84 : i64)
        ^bb3(%86: i64):  // 2 preds: ^bb2, ^bb9
          %87 = llvm.icmp "slt" %86, %0 : i64
          llvm.cond_br %87, ^bb4, ^bb10
        ^bb4:  // pred: ^bb3
          %88 = llvm.mlir.constant(-1 : index) : i64
          %89 = llvm.mul %82, %88  : i64
          %90 = llvm.add %89, %2  : i64
          %91 = llvm.icmp "slt" %79, %90 : i64
          %92 = llvm.select %91, %79, %90 : i1, i64
          %93 = llvm.mul %86, %88  : i64
          %94 = llvm.add %93, %0  : i64
          %95 = llvm.icmp "slt" %79, %94 : i64
          %96 = llvm.select %95, %79, %94 : i1, i64
          %97 = llvm.extractvalue %41[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %98 = llvm.bitcast %97 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %99 = llvm.insertvalue %98, %21[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %100 = llvm.extractvalue %41[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %101 = llvm.bitcast %100 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %102 = llvm.insertvalue %101, %99[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %103 = llvm.extractvalue %41[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %104 = llvm.extractvalue %41[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %105 = llvm.extractvalue %41[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %106 = llvm.mul %82, %103  : i64
          %107 = llvm.add %105, %106  : i64
          %108 = llvm.mul %86, %104  : i64
          %109 = llvm.add %107, %108  : i64
          %110 = llvm.insertvalue %109, %102[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %111 = llvm.mlir.constant(1 : i64) : i64
          %112 = llvm.insertvalue %96, %110[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %113 = llvm.insertvalue %111, %112[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %114 = llvm.mlir.constant(10 : i64) : i64
          %115 = llvm.insertvalue %92, %113[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %116 = llvm.insertvalue %114, %115[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %117 = llvm.extractvalue %28[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %118 = llvm.bitcast %117 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %119 = llvm.insertvalue %118, %21[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %120 = llvm.extractvalue %28[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %121 = llvm.bitcast %120 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %122 = llvm.insertvalue %121, %119[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %123 = llvm.extractvalue %28[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %124 = llvm.extractvalue %28[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %125 = llvm.extractvalue %28[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %126 = llvm.mul %82, %123  : i64
          %127 = llvm.add %125, %126  : i64
          %128 = llvm.mul %86, %124  : i64
          %129 = llvm.add %127, %128  : i64
          %130 = llvm.insertvalue %129, %122[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %131 = llvm.insertvalue %96, %130[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %132 = llvm.insertvalue %111, %131[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %133 = llvm.insertvalue %92, %132[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %134 = llvm.insertvalue %114, %133[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %135 = llvm.extractvalue %64[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %136 = llvm.bitcast %135 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %137 = llvm.insertvalue %136, %59[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %138 = llvm.extractvalue %64[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %139 = llvm.bitcast %138 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %140 = llvm.insertvalue %139, %137[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %141 = llvm.extractvalue %64[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %142 = llvm.extractvalue %64[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %143 = llvm.mul %86, %141  : i64
          %144 = llvm.add %142, %143  : i64
          %145 = llvm.insertvalue %144, %140[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %146 = llvm.insertvalue %96, %145[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %147 = llvm.insertvalue %111, %146[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          llvm.br ^bb5(%1 : i64)
        ^bb5(%148: i64):  // 2 preds: ^bb4, ^bb8
          %149 = llvm.icmp "slt" %148, %92 : i64
          llvm.cond_br %149, ^bb6(%1 : i64), ^bb9
        ^bb6(%150: i64):  // 2 preds: ^bb5, ^bb7
          %151 = llvm.icmp "slt" %150, %96 : i64
          llvm.cond_br %151, ^bb7, ^bb8
        ^bb7:  // pred: ^bb6
          %152 = llvm.extractvalue %116[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %153 = llvm.extractvalue %116[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %154 = llvm.mul %148, %0  : i64
          %155 = llvm.add %153, %154  : i64
          %156 = llvm.add %155, %150  : i64
          %157 = llvm.getelementptr %152[%156] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
          %158 = llvm.load %157 : !llvm.ptr<f32>
          %159 = llvm.extractvalue %134[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %160 = llvm.extractvalue %134[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %161 = llvm.add %160, %154  : i64
          %162 = llvm.add %161, %150  : i64
          %163 = llvm.getelementptr %159[%162] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
          %164 = llvm.load %163 : !llvm.ptr<f32>
          %165 = llvm.extractvalue %51[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
          %166 = llvm.load %165 : !llvm.ptr<f32>
          %167 = llvm.fadd %158, %164  : f32
          %168 = llvm.fsub %167, %166  : f32
          %169 = llvm.fmul %168, %4  : f32
          %170 = "llvm.intr.floor"(%169) : (f32) -> f32
          %171 = llvm.fmul %170, %3  : f32
          %172 = llvm.fsub %168, %171  : f32
          %173 = llvm.fmul %172, %172  : f32
          %174 = llvm.fmul %173, %173  : f32
          %175 = "llvm.intr.fma"(%5, %172, %5) : (f32, f32, f32) -> f32
          %176 = "llvm.intr.fma"(%7, %172, %6) : (f32, f32, f32) -> f32
          %177 = "llvm.intr.fma"(%9, %172, %8) : (f32, f32, f32) -> f32
          %178 = "llvm.intr.fma"(%176, %173, %175) : (f32, f32, f32) -> f32
          %179 = "llvm.intr.fma"(%177, %174, %178) : (f32, f32, f32) -> f32
          %180 = llvm.fptosi %170 : f32 to i32
          %181 = llvm.add %180, %15  : i32
          %182 = llvm.shl %181, %10  : i32
          %183 = llvm.bitcast %182 : i32 to f32
          %184 = llvm.fmul %179, %183  : f32
          %185 = llvm.icmp "sle" %180, %15 : i32
          %186 = llvm.icmp "sge" %180, %16 : i32
          %187 = llvm.fcmp "oeq" %168, %13 : f32
          %188 = llvm.fcmp "ogt" %168, %11 : f32
          %189 = llvm.and %185, %186  : i1
          %190 = llvm.select %187, %11, %14 : i1, f32
          %191 = llvm.select %188, %12, %190 : i1, f32
          %192 = llvm.select %189, %184, %191 : i1, f32
          %193 = llvm.extractvalue %147[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %194 = llvm.extractvalue %147[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %195 = llvm.add %194, %150  : i64
          %196 = llvm.getelementptr %193[%195] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
          llvm.store %192, %196 : !llvm.ptr<f32>
          %197 = llvm.add %150, %2  : i64
          llvm.br ^bb6(%197 : i64)
        ^bb8:  // pred: ^bb6
          %198 = llvm.add %148, %2  : i64
          llvm.br ^bb5(%198 : i64)
        ^bb9:  // pred: ^bb5
          %199 = llvm.add %86, %85  : i64
          llvm.br ^bb3(%199 : i64)
        ^bb10:  // pred: ^bb3
          %200 = llvm.add %82, %81  : i64
          llvm.br ^bb1(%200 : i64)
        ^bb11:  // pred: ^bb1
          %201 = llvm.mlir.constant(0 : i32) : i32
          llvm.return %201 : i32
        }
        llvm.func internal @predict_dispatch_6(%arg0: !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>, %arg1: !llvm.ptr<array<3 x i32>>) -> i32 {
          %0 = llvm.mlir.constant(0.000000e+00 : f32) : f32
          %1 = llvm.mlir.constant(10 : index) : i64
          %2 = llvm.mlir.constant(0 : index) : i64
          %3 = llvm.mlir.constant(1 : index) : i64
          %4 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %5 = llvm.extractvalue %4[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %6 = llvm.getelementptr %5[%2] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
          %7 = llvm.load %6 : !llvm.ptr<ptr<i8>>
          %8 = llvm.getelementptr %7[%2] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
          %9 = llvm.bitcast %8 : !llvm.ptr<i8> to !llvm.ptr<f32>
          %10 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %11 = llvm.insertvalue %9, %10[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %12 = llvm.insertvalue %9, %11[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %13 = llvm.insertvalue %2, %12[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %14 = llvm.insertvalue %1, %13[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %15 = llvm.insertvalue %3, %14[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %16 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %17 = llvm.extractvalue %16[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %18 = llvm.getelementptr %17[%3] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
          %19 = llvm.load %18 : !llvm.ptr<ptr<i8>>
          %20 = llvm.getelementptr %19[%2] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
          %21 = llvm.bitcast %20 : !llvm.ptr<i8> to !llvm.ptr<f32>
          %22 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
          %23 = llvm.insertvalue %21, %22[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
          %24 = llvm.insertvalue %21, %23[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
          %25 = llvm.insertvalue %2, %24[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
          %26 = llvm.extractvalue %25[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
          llvm.store %0, %26 : !llvm.ptr<f32>
          llvm.br ^bb1(%2 : i64)
        ^bb1(%27: i64):  // 2 preds: ^bb0, ^bb2
          %28 = llvm.icmp "slt" %27, %1 : i64
          llvm.cond_br %28, ^bb2, ^bb3
        ^bb2:  // pred: ^bb1
          %29 = llvm.extractvalue %15[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %30 = llvm.getelementptr %29[%27] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
          %31 = llvm.load %30 : !llvm.ptr<f32>
          %32 = llvm.load %26 : !llvm.ptr<f32>
          %33 = llvm.fadd %31, %32  : f32
          llvm.store %33, %26 : !llvm.ptr<f32>
          %34 = llvm.add %27, %3  : i64
          llvm.br ^bb1(%34 : i64)
        ^bb3:  // pred: ^bb1
          %35 = llvm.mlir.constant(0 : i32) : i32
          llvm.return %35 : i32
        }
        llvm.mlir.global private constant @__constant_1x10xf32_7(opaque<"_", "0xDEADBEEF"> : tensor<1x10xf32>) : !llvm.array<1 x array<10 x f32>>
        llvm.func internal @predict_dispatch_7(%arg0: !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>, %arg1: !llvm.ptr<array<3 x i32>>) -> i32 {
          %0 = llvm.mlir.constant(10 : index) : i64
          %1 = llvm.mlir.constant(0 : index) : i64
          %2 = llvm.mlir.constant(1 : index) : i64
          %3 = llvm.mlir.constant(0.693147182 : f32) : f32
          %4 = llvm.mlir.constant(1.44269502 : f32) : f32
          %5 = llvm.mlir.constant(1.000000e+00 : f32) : f32
          %6 = llvm.mlir.constant(0.499705136 : f32) : f32
          %7 = llvm.mlir.constant(0.168738902 : f32) : f32
          %8 = llvm.mlir.constant(0.0366896503 : f32) : f32
          %9 = llvm.mlir.constant(1.314350e-02 : f32) : f32
          %10 = llvm.mlir.constant(23 : i32) : i32
          %11 = llvm.mlir.constant(0.000000e+00 : f32) : f32
          %12 = llvm.mlir.constant(0x7F800000 : f32) : f32
          %13 = llvm.mlir.constant(0xFF800000 : f32) : f32
          %14 = llvm.mlir.constant(1.17549435E-38 : f32) : f32
          %15 = llvm.mlir.constant(127 : i32) : i32
          %16 = llvm.mlir.constant(-127 : i32) : i32
          %17 = llvm.mlir.addressof @__constant_1x10xf32_7 : !llvm.ptr<array<1 x array<10 x f32>>>
          %18 = llvm.getelementptr %17[%1, %1, %1] : (!llvm.ptr<array<1 x array<10 x f32>>>, i64, i64, i64) -> !llvm.ptr<f32>
          %19 = llvm.mlir.constant(3735928559 : index) : i64
          %20 = llvm.inttoptr %19 : i64 to !llvm.ptr<f32>
          %21 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %22 = llvm.insertvalue %20, %21[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %23 = llvm.insertvalue %18, %22[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %24 = llvm.insertvalue %1, %23[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %25 = llvm.insertvalue %2, %24[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %26 = llvm.insertvalue %0, %25[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %27 = llvm.insertvalue %0, %26[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %28 = llvm.insertvalue %2, %27[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %29 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %30 = llvm.extractvalue %29[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %31 = llvm.getelementptr %30[%1] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
          %32 = llvm.load %31 : !llvm.ptr<ptr<i8>>
          %33 = llvm.getelementptr %32[%1] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
          %34 = llvm.bitcast %33 : !llvm.ptr<i8> to !llvm.ptr<f32>
          %35 = llvm.insertvalue %34, %21[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %36 = llvm.insertvalue %34, %35[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %37 = llvm.insertvalue %1, %36[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %38 = llvm.insertvalue %2, %37[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %39 = llvm.insertvalue %0, %38[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %40 = llvm.insertvalue %0, %39[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %41 = llvm.insertvalue %2, %40[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %42 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %43 = llvm.extractvalue %42[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %44 = llvm.getelementptr %43[%2] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
          %45 = llvm.load %44 : !llvm.ptr<ptr<i8>>
          %46 = llvm.getelementptr %45[%1] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
          %47 = llvm.bitcast %46 : !llvm.ptr<i8> to !llvm.ptr<f32>
          %48 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
          %49 = llvm.insertvalue %47, %48[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
          %50 = llvm.insertvalue %47, %49[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
          %51 = llvm.insertvalue %1, %50[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
          %52 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %53 = llvm.extractvalue %52[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %54 = llvm.mlir.constant(2 : index) : i64
          %55 = llvm.getelementptr %53[%54] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
          %56 = llvm.load %55 : !llvm.ptr<ptr<i8>>
          %57 = llvm.getelementptr %56[%1] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
          %58 = llvm.bitcast %57 : !llvm.ptr<i8> to !llvm.ptr<f32>
          %59 = llvm.insertvalue %58, %48[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
          %60 = llvm.insertvalue %58, %59[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
          %61 = llvm.insertvalue %1, %60[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
          %62 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %63 = llvm.extractvalue %62[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %64 = llvm.mlir.constant(3 : index) : i64
          %65 = llvm.getelementptr %63[%64] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
          %66 = llvm.load %65 : !llvm.ptr<ptr<i8>>
          %67 = llvm.getelementptr %66[%1] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
          %68 = llvm.bitcast %67 : !llvm.ptr<i8> to !llvm.ptr<f32>
          %69 = llvm.insertvalue %68, %21[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %70 = llvm.insertvalue %68, %69[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %71 = llvm.insertvalue %1, %70[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %72 = llvm.insertvalue %2, %71[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %73 = llvm.insertvalue %0, %72[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %74 = llvm.insertvalue %0, %73[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %75 = llvm.insertvalue %2, %74[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %76 = llvm.load %arg1 : !llvm.ptr<array<3 x i32>>
          %77 = llvm.extractvalue %76[0] : !llvm.array<3 x i32>
          %78 = llvm.zext %77 : i32 to i64
          %79 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %80 = llvm.extractvalue %79[0] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %81 = llvm.extractvalue %80[0] : !llvm.array<3 x i32>
          %82 = llvm.zext %81 : i32 to i64
          %83 = llvm.load %arg1 : !llvm.ptr<array<3 x i32>>
          %84 = llvm.extractvalue %83[1] : !llvm.array<3 x i32>
          %85 = llvm.zext %84 : i32 to i64
          %86 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %87 = llvm.extractvalue %86[0] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %88 = llvm.extractvalue %87[1] : !llvm.array<3 x i32>
          %89 = llvm.zext %88 : i32 to i64
          %90 = llvm.mlir.constant(128 : index) : i64
          %91 = llvm.mul %85, %90  : i64
          %92 = llvm.mul %89, %90  : i64
          llvm.br ^bb1(%91 : i64)
        ^bb1(%93: i64):  // 2 preds: ^bb0, ^bb10
          %94 = llvm.icmp "slt" %93, %2 : i64
          llvm.cond_br %94, ^bb2, ^bb11
        ^bb2:  // pred: ^bb1
          %95 = llvm.mul %78, %90  : i64
          %96 = llvm.mul %82, %90  : i64
          llvm.br ^bb3(%95 : i64)
        ^bb3(%97: i64):  // 2 preds: ^bb2, ^bb9
          %98 = llvm.icmp "slt" %97, %0 : i64
          llvm.cond_br %98, ^bb4, ^bb10
        ^bb4:  // pred: ^bb3
          %99 = llvm.mlir.constant(-1 : index) : i64
          %100 = llvm.mul %93, %99  : i64
          %101 = llvm.add %100, %2  : i64
          %102 = llvm.icmp "slt" %90, %101 : i64
          %103 = llvm.select %102, %90, %101 : i1, i64
          %104 = llvm.mul %97, %99  : i64
          %105 = llvm.add %104, %0  : i64
          %106 = llvm.icmp "slt" %90, %105 : i64
          %107 = llvm.select %106, %90, %105 : i1, i64
          %108 = llvm.extractvalue %41[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %109 = llvm.bitcast %108 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %110 = llvm.insertvalue %109, %21[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %111 = llvm.extractvalue %41[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %112 = llvm.bitcast %111 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %113 = llvm.insertvalue %112, %110[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %114 = llvm.extractvalue %41[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %115 = llvm.extractvalue %41[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %116 = llvm.extractvalue %41[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %117 = llvm.mul %93, %114  : i64
          %118 = llvm.add %116, %117  : i64
          %119 = llvm.mul %97, %115  : i64
          %120 = llvm.add %118, %119  : i64
          %121 = llvm.insertvalue %120, %113[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %122 = llvm.mlir.constant(1 : i64) : i64
          %123 = llvm.insertvalue %107, %121[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %124 = llvm.insertvalue %122, %123[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %125 = llvm.mlir.constant(10 : i64) : i64
          %126 = llvm.insertvalue %103, %124[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %127 = llvm.insertvalue %125, %126[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %128 = llvm.extractvalue %28[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %129 = llvm.bitcast %128 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %130 = llvm.insertvalue %129, %21[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %131 = llvm.extractvalue %28[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %132 = llvm.bitcast %131 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %133 = llvm.insertvalue %132, %130[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %134 = llvm.extractvalue %28[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %135 = llvm.extractvalue %28[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %136 = llvm.extractvalue %28[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %137 = llvm.mul %93, %134  : i64
          %138 = llvm.add %136, %137  : i64
          %139 = llvm.mul %97, %135  : i64
          %140 = llvm.add %138, %139  : i64
          %141 = llvm.insertvalue %140, %133[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %142 = llvm.insertvalue %107, %141[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %143 = llvm.insertvalue %122, %142[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %144 = llvm.insertvalue %103, %143[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %145 = llvm.insertvalue %125, %144[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %146 = llvm.extractvalue %75[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %147 = llvm.bitcast %146 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %148 = llvm.insertvalue %147, %21[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %149 = llvm.extractvalue %75[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %150 = llvm.bitcast %149 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %151 = llvm.insertvalue %150, %148[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %152 = llvm.extractvalue %75[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %153 = llvm.extractvalue %75[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %154 = llvm.extractvalue %75[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %155 = llvm.mul %93, %152  : i64
          %156 = llvm.add %154, %155  : i64
          %157 = llvm.mul %97, %153  : i64
          %158 = llvm.add %156, %157  : i64
          %159 = llvm.insertvalue %158, %151[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %160 = llvm.insertvalue %107, %159[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %161 = llvm.insertvalue %122, %160[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %162 = llvm.insertvalue %103, %161[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %163 = llvm.insertvalue %125, %162[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          llvm.br ^bb5(%1 : i64)
        ^bb5(%164: i64):  // 2 preds: ^bb4, ^bb8
          %165 = llvm.icmp "slt" %164, %103 : i64
          llvm.cond_br %165, ^bb6(%1 : i64), ^bb9
        ^bb6(%166: i64):  // 2 preds: ^bb5, ^bb7
          %167 = llvm.icmp "slt" %166, %107 : i64
          llvm.cond_br %167, ^bb7, ^bb8
        ^bb7:  // pred: ^bb6
          %168 = llvm.extractvalue %127[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %169 = llvm.extractvalue %127[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %170 = llvm.mul %164, %0  : i64
          %171 = llvm.add %169, %170  : i64
          %172 = llvm.add %171, %166  : i64
          %173 = llvm.getelementptr %168[%172] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
          %174 = llvm.load %173 : !llvm.ptr<f32>
          %175 = llvm.extractvalue %145[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %176 = llvm.extractvalue %145[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %177 = llvm.add %176, %170  : i64
          %178 = llvm.add %177, %166  : i64
          %179 = llvm.getelementptr %175[%178] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
          %180 = llvm.load %179 : !llvm.ptr<f32>
          %181 = llvm.extractvalue %51[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
          %182 = llvm.load %181 : !llvm.ptr<f32>
          %183 = llvm.extractvalue %61[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
          %184 = llvm.load %183 : !llvm.ptr<f32>
          %185 = llvm.fadd %174, %180  : f32
          %186 = llvm.fsub %185, %182  : f32
          %187 = llvm.fmul %186, %4  : f32
          %188 = "llvm.intr.floor"(%187) : (f32) -> f32
          %189 = llvm.fmul %188, %3  : f32
          %190 = llvm.fsub %186, %189  : f32
          %191 = llvm.fmul %190, %190  : f32
          %192 = llvm.fmul %191, %191  : f32
          %193 = "llvm.intr.fma"(%5, %190, %5) : (f32, f32, f32) -> f32
          %194 = "llvm.intr.fma"(%7, %190, %6) : (f32, f32, f32) -> f32
          %195 = "llvm.intr.fma"(%9, %190, %8) : (f32, f32, f32) -> f32
          %196 = "llvm.intr.fma"(%194, %191, %193) : (f32, f32, f32) -> f32
          %197 = "llvm.intr.fma"(%195, %192, %196) : (f32, f32, f32) -> f32
          %198 = llvm.fptosi %188 : f32 to i32
          %199 = llvm.add %198, %15  : i32
          %200 = llvm.shl %199, %10  : i32
          %201 = llvm.bitcast %200 : i32 to f32
          %202 = llvm.fmul %197, %201  : f32
          %203 = llvm.icmp "sle" %198, %15 : i32
          %204 = llvm.icmp "sge" %198, %16 : i32
          %205 = llvm.fcmp "oeq" %186, %13 : f32
          %206 = llvm.fcmp "ogt" %186, %11 : f32
          %207 = llvm.and %203, %204  : i1
          %208 = llvm.select %205, %11, %14 : i1, f32
          %209 = llvm.select %206, %12, %208 : i1, f32
          %210 = llvm.select %207, %202, %209 : i1, f32
          %211 = llvm.fdiv %210, %184  : f32
          %212 = llvm.extractvalue %163[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %213 = llvm.extractvalue %163[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %214 = llvm.add %213, %170  : i64
          %215 = llvm.add %214, %166  : i64
          %216 = llvm.getelementptr %212[%215] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
          llvm.store %211, %216 : !llvm.ptr<f32>
          %217 = llvm.add %166, %2  : i64
          llvm.br ^bb6(%217 : i64)
        ^bb8:  // pred: ^bb6
          %218 = llvm.add %164, %2  : i64
          llvm.br ^bb5(%218 : i64)
        ^bb9:  // pred: ^bb5
          %219 = llvm.add %97, %96  : i64
          llvm.br ^bb3(%219 : i64)
        ^bb10:  // pred: ^bb3
          %220 = llvm.add %93, %92  : i64
          llvm.br ^bb1(%220 : i64)
        ^bb11:  // pred: ^bb1
          %221 = llvm.mlir.constant(0 : i32) : i32
          llvm.return %221 : i32
        }
      }
    }
  }
  hal.constant_pool @_const_pool attributes {buffer_constraints = #hal.buffer_constraints<max_allocation_size = 1073741824, min_buffer_offset_alignment = 16, max_buffer_range = 1073741824, min_buffer_range_alignment = 16>, sym_visibility = "private"} {
    hal.constant_storage @_storage = opaque<"_", "0xDEADBEEF"> : vector<407040xi8> attributes {sym_visibility = "nested"}
  }
  hal.variable @_const_pool_storage_buffer init(@_const_pool_storage_buffer_initializer) : !hal.buffer attributes {sym_visibility = "private"}
  func private @_const_pool_storage_buffer_initializer() -> !hal.buffer {
    %c0 = constant 0 : index
    %c407040 = constant 407040 : index
    %device = hal.ex.shared_device : !hal.device
    %allocator = hal.device.allocator<%device : !hal.device> : !hal.allocator
    %storage = hal.constant_storage.lookup @_const_pool::@_storage : !iree.byte_buffer
    %mapped = hal.allocator.map<%allocator : !hal.allocator> source(%storage : !iree.byte_buffer)[%c0, %c407040] type("HostVisible|DeviceVisible|DeviceLocal") usage("Constant|Transfer|Mapping|Dispatch") : !hal.buffer
    return %mapped : !hal.buffer
  }
  func @predict(%arg0: !hal.buffer) -> !hal.buffer attributes {noinline} {
    %c3136 = constant 3136 : index
    %c401408 = constant 401408 : index
    %c401920 = constant 401920 : index
    %c5120 = constant 5120 : index
    %c40 = constant 40 : index
    %c4 = constant 4 : index
    %c128 = constant 128 : index
    %c1 = constant 1 : index
    %c10 = constant 10 : index
    %c2 = constant 2 : index
    %c3 = constant 3 : index
    %c0 = constant 0 : index
    %c512 = constant 512 : index
    %c96 = constant 96 : index
    %c48 = constant 48 : index
    %c112 = constant 112 : index
    %c1024 = constant 1024 : index
    %device = hal.ex.shared_device : !hal.device
    %allocator = hal.device.allocator<%device : !hal.device> : !hal.allocator
    %buffer = hal.allocator.allocate<%allocator : !hal.allocator> type("HostVisible|DeviceVisible|DeviceLocal") usage("Transfer|Mapping|Dispatch") : !hal.buffer{%c40}
    %0 = hal.variable.load @_const_pool_storage_buffer : !hal.buffer
    %buffer_0 = hal.allocator.allocate<%allocator : !hal.allocator> type("DeviceVisible|DeviceLocal") usage("Transfer|Dispatch") : !hal.buffer{%c1024}
    %cmd = hal.command_buffer.create device(%device : !hal.device) mode("OneShot|AllowInlineExecution") categories("Transfer|Dispatch") : !hal.command_buffer
    hal.command_buffer.begin<%cmd : !hal.command_buffer>
    %executable_layout = hal.executable_layout.lookup device(%device : !hal.device) layouts([[#hal.descriptor_set_layout_binding<0, "StorageBuffer", R>, #hal.descriptor_set_layout_binding<1, "StorageBuffer", R>, #hal.descriptor_set_layout_binding<2, "StorageBuffer", DW>]]) : !hal.executable_layout
    hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%executable_layout : !hal.executable_layout)[%c0] bindings([
      %c0 = (%0 : !hal.buffer)[%c512, %c401408], 
      %c1 = (%arg0 : !hal.buffer)[%c0, %c3136], 
      %c2 = (%buffer_0 : !hal.buffer)[%c0, %c512]
    ])
    hal.device.switch<%device : !hal.device>
    #hal.device.match.id<"dylib*">(%arg1 = %cmd : !hal.command_buffer, %arg2 = %c128 : index, %arg3 = %c1 : index, %arg4 = %c1 : index) {
      %c1_3 = constant 1 : index
      %1 = affine.apply #map0()[%arg2]
      %2 = affine.apply #map1()[%arg3]
      %3 = hal.command_buffer.device<%arg1 : !hal.command_buffer> : !hal.device
      %exe = hal.executable.lookup device(%3 : !hal.device) executable(@mnist_linked_llvm_aot) : !hal.executable
      hal.command_buffer.dispatch<%arg1 : !hal.command_buffer> target(%exe : !hal.executable)[0] workgroups([%1, %2, %c1_3])
      hal.return
    }
    hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
    hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%executable_layout : !hal.executable_layout)[%c0] bindings([
      %c0 = (%0 : !hal.buffer)[%c0, %c512], 
      %c1 = (%buffer_0 : !hal.buffer)[%c0, %c512], 
      %c2 = (%buffer_0 : !hal.buffer)[%c512, %c512]
    ])
    hal.device.switch<%device : !hal.device>
    #hal.device.match.id<"dylib*">(%arg1 = %cmd : !hal.command_buffer, %arg2 = %c128 : index, %arg3 = %c1 : index, %arg4 = %c1 : index) {
      %c1_3 = constant 1 : index
      %1 = affine.apply #map2()[%arg2]
      %2 = affine.apply #map2()[%arg3]
      %3 = hal.command_buffer.device<%arg1 : !hal.command_buffer> : !hal.device
      %exe = hal.executable.lookup device(%3 : !hal.device) executable(@mnist_linked_llvm_aot) : !hal.executable
      hal.command_buffer.dispatch<%arg1 : !hal.command_buffer> target(%exe : !hal.executable)[1] workgroups([%1, %2, %c1_3])
      hal.return
    }
    hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
    hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%executable_layout : !hal.executable_layout)[%c0] bindings([
      %c0 = (%0 : !hal.buffer)[%c401920, %c5120], 
      %c1 = (%buffer_0 : !hal.buffer)[%c512, %c512], 
      %c2 = (%buffer_0 : !hal.buffer)[%c0, %c40]
    ])
    hal.device.switch<%device : !hal.device>
    #hal.device.match.id<"dylib*">(%arg1 = %cmd : !hal.command_buffer, %arg2 = %c10 : index, %arg3 = %c1 : index, %arg4 = %c1 : index) {
      %c1_3 = constant 1 : index
      %1 = affine.apply #map0()[%arg2]
      %2 = affine.apply #map1()[%arg3]
      %3 = hal.command_buffer.device<%arg1 : !hal.command_buffer> : !hal.device
      %exe = hal.executable.lookup device(%3 : !hal.device) executable(@mnist_linked_llvm_aot) : !hal.executable
      hal.command_buffer.dispatch<%arg1 : !hal.command_buffer> target(%exe : !hal.executable)[2] workgroups([%1, %2, %c1_3])
      hal.return
    }
    hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
    %executable_layout_1 = hal.executable_layout.lookup device(%device : !hal.device) layouts([[#hal.descriptor_set_layout_binding<0, "StorageBuffer", R>, #hal.descriptor_set_layout_binding<1, "StorageBuffer", DW>]]) : !hal.executable_layout
    hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%executable_layout_1 : !hal.executable_layout)[%c0] bindings([
      %c0 = (%buffer_0 : !hal.buffer)[%c0, %c40], 
      %c1 = (%buffer_0 : !hal.buffer)[%c48, %c40]
    ])
    hal.device.switch<%device : !hal.device>
    #hal.device.match.id<"dylib*">(%arg1 = %cmd : !hal.command_buffer, %arg2 = %c10 : index, %arg3 = %c1 : index, %arg4 = %c1 : index) {
      %c1_3 = constant 1 : index
      %1 = affine.apply #map2()[%arg2]
      %2 = affine.apply #map2()[%arg3]
      %3 = hal.command_buffer.device<%arg1 : !hal.command_buffer> : !hal.device
      %exe = hal.executable.lookup device(%3 : !hal.device) executable(@mnist_linked_llvm_aot) : !hal.executable
      hal.command_buffer.dispatch<%arg1 : !hal.command_buffer> target(%exe : !hal.executable)[3] workgroups([%1, %2, %c1_3])
      hal.return
    }
    hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
    hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%executable_layout_1 : !hal.executable_layout)[%c0] bindings([
      %c0 = (%buffer_0 : !hal.buffer)[%c48, %c40], 
      %c1 = (%buffer_0 : !hal.buffer)[%c96, %c4]
    ])
    hal.device.switch<%device : !hal.device>
    #hal.device.match.id<"dylib*">(%arg1 = %cmd : !hal.command_buffer, %arg2 = %c1 : index, %arg3 = %c1 : index, %arg4 = %c1 : index) {
      %c1_3 = constant 1 : index
      %1 = hal.command_buffer.device<%arg1 : !hal.command_buffer> : !hal.device
      %exe = hal.executable.lookup device(%1 : !hal.device) executable(@mnist_linked_llvm_aot) : !hal.executable
      hal.command_buffer.dispatch<%arg1 : !hal.command_buffer> target(%exe : !hal.executable)[4] workgroups([%c1_3, %c1_3, %c1_3])
      hal.return
    }
    hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
    hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%executable_layout : !hal.executable_layout)[%c0] bindings([
      %c0 = (%buffer_0 : !hal.buffer)[%c0, %c40], 
      %c1 = (%buffer_0 : !hal.buffer)[%c96, %c4], 
      %c2 = (%buffer_0 : !hal.buffer)[%c48, %c40]
    ])
    hal.device.switch<%device : !hal.device>
    #hal.device.match.id<"dylib*">(%arg1 = %cmd : !hal.command_buffer, %arg2 = %c10 : index, %arg3 = %c1 : index, %arg4 = %c1 : index) {
      %c1_3 = constant 1 : index
      %1 = affine.apply #map2()[%arg2]
      %2 = affine.apply #map2()[%arg3]
      %3 = hal.command_buffer.device<%arg1 : !hal.command_buffer> : !hal.device
      %exe = hal.executable.lookup device(%3 : !hal.device) executable(@mnist_linked_llvm_aot) : !hal.executable
      hal.command_buffer.dispatch<%arg1 : !hal.command_buffer> target(%exe : !hal.executable)[5] workgroups([%1, %2, %c1_3])
      hal.return
    }
    hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
    hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%executable_layout_1 : !hal.executable_layout)[%c0] bindings([
      %c0 = (%buffer_0 : !hal.buffer)[%c48, %c40], 
      %c1 = (%buffer_0 : !hal.buffer)[%c112, %c4]
    ])
    hal.device.switch<%device : !hal.device>
    #hal.device.match.id<"dylib*">(%arg1 = %cmd : !hal.command_buffer, %arg2 = %c1 : index, %arg3 = %c1 : index, %arg4 = %c1 : index) {
      %c1_3 = constant 1 : index
      %1 = hal.command_buffer.device<%arg1 : !hal.command_buffer> : !hal.device
      %exe = hal.executable.lookup device(%1 : !hal.device) executable(@mnist_linked_llvm_aot) : !hal.executable
      hal.command_buffer.dispatch<%arg1 : !hal.command_buffer> target(%exe : !hal.executable)[6] workgroups([%c1_3, %c1_3, %c1_3])
      hal.return
    }
    hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
    %executable_layout_2 = hal.executable_layout.lookup device(%device : !hal.device) layouts([[#hal.descriptor_set_layout_binding<0, "StorageBuffer", R>, #hal.descriptor_set_layout_binding<1, "StorageBuffer", R>, #hal.descriptor_set_layout_binding<2, "StorageBuffer", R>, #hal.descriptor_set_layout_binding<3, "StorageBuffer", DW>]]) : !hal.executable_layout
    hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%executable_layout_2 : !hal.executable_layout)[%c0] bindings([
      %c0 = (%buffer_0 : !hal.buffer)[%c0, %c40], 
      %c1 = (%buffer_0 : !hal.buffer)[%c96, %c4], 
      %c2 = (%buffer_0 : !hal.buffer)[%c112, %c4], 
      %c3 = (%buffer : !hal.buffer)[%c0, %c40]
    ])
    hal.device.switch<%device : !hal.device>
    #hal.device.match.id<"dylib*">(%arg1 = %cmd : !hal.command_buffer, %arg2 = %c10 : index, %arg3 = %c1 : index, %arg4 = %c1 : index) {
      %c1_3 = constant 1 : index
      %1 = affine.apply #map2()[%arg2]
      %2 = affine.apply #map2()[%arg3]
      %3 = hal.command_buffer.device<%arg1 : !hal.command_buffer> : !hal.device
      %exe = hal.executable.lookup device(%3 : !hal.device) executable(@mnist_linked_llvm_aot) : !hal.executable
      hal.command_buffer.dispatch<%arg1 : !hal.command_buffer> target(%exe : !hal.executable)[7] workgroups([%1, %2, %c1_3])
      hal.return
    }
    hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
    hal.command_buffer.end<%cmd : !hal.command_buffer>
    hal.ex.submit_and_wait %device, %cmd
    return %buffer : !hal.buffer
  }
  func @predict$async(%arg0: !hal.semaphore, %arg1: index, %arg2: !hal.buffer_view, %arg3: !hal.semaphore, %arg4: index) -> !hal.buffer_view attributes {iree.module.export = "predict$async"} {
    %c1 = constant 1 : index
    %c10 = constant 10 : index
    %c50331680_i32 = constant 50331680 : i32
    %0 = hal.semaphore.await<%arg0 : !hal.semaphore> until(%arg1) : i32
    hal.check_success %0, "semaphore wait failed"
    %buffer = hal.buffer_view.buffer %arg2 : !hal.buffer
    %1 = call @predict(%buffer) : (!hal.buffer) -> !hal.buffer
    %view = hal.buffer_view.create %1, element_type = %c50331680_i32, shape = [%c1, %c10] : !hal.buffer -> !hal.buffer_view
    hal.semaphore.signal<%arg3 : !hal.semaphore> value(%arg4)
    return %view : !hal.buffer_view
  }
  func @predict$sync(%arg0: !hal.buffer_view) -> !hal.buffer_view attributes {iree.abi.stub, iree.module.export = "predict", iree.reflection = {abi = "sip", abiv = 1 : i32, f = "I15!B11!d1d28d28d1R9!B6!d1d10", fv = "1", sip = "I8!S5!k0_0R3!_0"}} {
    %c0 = constant 0 : index
    %c1 = constant 1 : index
    %device = hal.ex.shared_device : !hal.device
    %semaphore = hal.semaphore.create device(%device : !hal.device) initial(%c0) : !hal.semaphore
    %0 = call @predict$async(%semaphore, %c0, %arg0, %semaphore, %c1) : (!hal.semaphore, index, !hal.buffer_view, !hal.semaphore, index) -> !hal.buffer_view
    %1 = hal.semaphore.await<%semaphore : !hal.semaphore> until(%c1) : i32
    hal.check_success %1, "semaphore wait failed"
    return %0 : !hal.buffer_view
  }
}


// *** IR Dump After Canonicalizer ***
func private @_const_pool_storage_buffer_initializer() -> !hal.buffer {
  %c0 = constant 0 : index
  %c407040 = constant 407040 : index
  %device = hal.ex.shared_device : !hal.device
  %allocator = hal.device.allocator<%device : !hal.device> : !hal.allocator
  %storage = hal.constant_storage.lookup @_const_pool::@_storage : !iree.byte_buffer
  %mapped = hal.allocator.map<%allocator : !hal.allocator> source(%storage : !iree.byte_buffer)[%c0, %c407040] type("HostVisible|DeviceVisible|DeviceLocal") usage("Constant|Transfer|Mapping|Dispatch") : !hal.buffer
  return %mapped : !hal.buffer
}

// *** IR Dump After CSE ***
func private @_const_pool_storage_buffer_initializer() -> !hal.buffer {
  %c0 = constant 0 : index
  %c407040 = constant 407040 : index
  %device = hal.ex.shared_device : !hal.device
  %allocator = hal.device.allocator<%device : !hal.device> : !hal.allocator
  %storage = hal.constant_storage.lookup @_const_pool::@_storage : !iree.byte_buffer
  %mapped = hal.allocator.map<%allocator : !hal.allocator> source(%storage : !iree.byte_buffer)[%c0, %c407040] type("HostVisible|DeviceVisible|DeviceLocal") usage("Constant|Transfer|Mapping|Dispatch") : !hal.buffer
  return %mapped : !hal.buffer
}

// *** IR Dump After Canonicalizer ***
func @predict(%arg0: !hal.buffer) -> !hal.buffer attributes {noinline} {
  %c3136 = constant 3136 : index
  %c401408 = constant 401408 : index
  %c401920 = constant 401920 : index
  %c5120 = constant 5120 : index
  %c40 = constant 40 : index
  %c4 = constant 4 : index
  %c128 = constant 128 : index
  %c1 = constant 1 : index
  %c10 = constant 10 : index
  %c2 = constant 2 : index
  %c3 = constant 3 : index
  %c0 = constant 0 : index
  %c512 = constant 512 : index
  %c96 = constant 96 : index
  %c48 = constant 48 : index
  %c112 = constant 112 : index
  %c1024 = constant 1024 : index
  %device = hal.ex.shared_device : !hal.device
  %allocator = hal.device.allocator<%device : !hal.device> : !hal.allocator
  %buffer = hal.allocator.allocate<%allocator : !hal.allocator> type("HostVisible|DeviceVisible|DeviceLocal") usage("Transfer|Mapping|Dispatch") : !hal.buffer{%c40}
  %0 = hal.variable.load @_const_pool_storage_buffer : !hal.buffer
  %buffer_0 = hal.allocator.allocate<%allocator : !hal.allocator> type("DeviceVisible|DeviceLocal") usage("Transfer|Dispatch") : !hal.buffer{%c1024}
  %cmd = hal.command_buffer.create device(%device : !hal.device) mode("OneShot|AllowInlineExecution") categories("Transfer|Dispatch") : !hal.command_buffer
  hal.command_buffer.begin<%cmd : !hal.command_buffer>
  %executable_layout = hal.executable_layout.lookup device(%device : !hal.device) layouts([[#hal.descriptor_set_layout_binding<0, "StorageBuffer", R>, #hal.descriptor_set_layout_binding<1, "StorageBuffer", R>, #hal.descriptor_set_layout_binding<2, "StorageBuffer", DW>]]) : !hal.executable_layout
  hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%executable_layout : !hal.executable_layout)[%c0] bindings([
    %c0 = (%0 : !hal.buffer)[%c512, %c401408], 
    %c1 = (%arg0 : !hal.buffer)[%c0, %c3136], 
    %c2 = (%buffer_0 : !hal.buffer)[%c0, %c512]
  ])
  hal.device.switch<%device : !hal.device>
    #hal.device.match.id<"dylib*">(%arg1 = %cmd : !hal.command_buffer, %arg2 = %c128 : index, %arg3 = %c1 : index, %arg4 = %c1 : index) {
    %c1_3 = constant 1 : index
    %1 = affine.apply affine_map<()[s0] -> (s0 ceildiv 64)>()[%arg2]
    %2 = affine.apply affine_map<()[s0] -> (s0 ceildiv 4)>()[%arg3]
    %3 = hal.command_buffer.device<%arg1 : !hal.command_buffer> : !hal.device
    %exe = hal.executable.lookup device(%3 : !hal.device) executable(@mnist_linked_llvm_aot) : !hal.executable
    hal.command_buffer.dispatch<%arg1 : !hal.command_buffer> target(%exe : !hal.executable)[0] workgroups([%1, %2, %c1_3])
    hal.return
  }
  hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
  hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%executable_layout : !hal.executable_layout)[%c0] bindings([
    %c0 = (%0 : !hal.buffer)[%c0, %c512], 
    %c1 = (%buffer_0 : !hal.buffer)[%c0, %c512], 
    %c2 = (%buffer_0 : !hal.buffer)[%c512, %c512]
  ])
  hal.device.switch<%device : !hal.device>
    #hal.device.match.id<"dylib*">(%arg1 = %cmd : !hal.command_buffer, %arg2 = %c128 : index, %arg3 = %c1 : index, %arg4 = %c1 : index) {
    %c1_3 = constant 1 : index
    %1 = affine.apply affine_map<()[s0] -> (s0 ceildiv 128)>()[%arg2]
    %2 = affine.apply affine_map<()[s0] -> (s0 ceildiv 128)>()[%arg3]
    %3 = hal.command_buffer.device<%arg1 : !hal.command_buffer> : !hal.device
    %exe = hal.executable.lookup device(%3 : !hal.device) executable(@mnist_linked_llvm_aot) : !hal.executable
    hal.command_buffer.dispatch<%arg1 : !hal.command_buffer> target(%exe : !hal.executable)[1] workgroups([%1, %2, %c1_3])
    hal.return
  }
  hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
  hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%executable_layout : !hal.executable_layout)[%c0] bindings([
    %c0 = (%0 : !hal.buffer)[%c401920, %c5120], 
    %c1 = (%buffer_0 : !hal.buffer)[%c512, %c512], 
    %c2 = (%buffer_0 : !hal.buffer)[%c0, %c40]
  ])
  hal.device.switch<%device : !hal.device>
    #hal.device.match.id<"dylib*">(%arg1 = %cmd : !hal.command_buffer, %arg2 = %c10 : index, %arg3 = %c1 : index, %arg4 = %c1 : index) {
    %c1_3 = constant 1 : index
    %1 = affine.apply affine_map<()[s0] -> (s0 ceildiv 64)>()[%arg2]
    %2 = affine.apply affine_map<()[s0] -> (s0 ceildiv 4)>()[%arg3]
    %3 = hal.command_buffer.device<%arg1 : !hal.command_buffer> : !hal.device
    %exe = hal.executable.lookup device(%3 : !hal.device) executable(@mnist_linked_llvm_aot) : !hal.executable
    hal.command_buffer.dispatch<%arg1 : !hal.command_buffer> target(%exe : !hal.executable)[2] workgroups([%1, %2, %c1_3])
    hal.return
  }
  hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
  %executable_layout_1 = hal.executable_layout.lookup device(%device : !hal.device) layouts([[#hal.descriptor_set_layout_binding<0, "StorageBuffer", R>, #hal.descriptor_set_layout_binding<1, "StorageBuffer", DW>]]) : !hal.executable_layout
  hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%executable_layout_1 : !hal.executable_layout)[%c0] bindings([
    %c0 = (%buffer_0 : !hal.buffer)[%c0, %c40], 
    %c1 = (%buffer_0 : !hal.buffer)[%c48, %c40]
  ])
  hal.device.switch<%device : !hal.device>
    #hal.device.match.id<"dylib*">(%arg1 = %cmd : !hal.command_buffer, %arg2 = %c10 : index, %arg3 = %c1 : index, %arg4 = %c1 : index) {
    %c1_3 = constant 1 : index
    %1 = affine.apply affine_map<()[s0] -> (s0 ceildiv 128)>()[%arg2]
    %2 = affine.apply affine_map<()[s0] -> (s0 ceildiv 128)>()[%arg3]
    %3 = hal.command_buffer.device<%arg1 : !hal.command_buffer> : !hal.device
    %exe = hal.executable.lookup device(%3 : !hal.device) executable(@mnist_linked_llvm_aot) : !hal.executable
    hal.command_buffer.dispatch<%arg1 : !hal.command_buffer> target(%exe : !hal.executable)[3] workgroups([%1, %2, %c1_3])
    hal.return
  }
  hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
  hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%executable_layout_1 : !hal.executable_layout)[%c0] bindings([
    %c0 = (%buffer_0 : !hal.buffer)[%c48, %c40], 
    %c1 = (%buffer_0 : !hal.buffer)[%c96, %c4]
  ])
  hal.device.switch<%device : !hal.device>
    #hal.device.match.id<"dylib*">(%arg1 = %cmd : !hal.command_buffer, %arg2 = %c1 : index, %arg3 = %c1 : index, %arg4 = %c1 : index) {
    %c1_3 = constant 1 : index
    %1 = hal.command_buffer.device<%arg1 : !hal.command_buffer> : !hal.device
    %exe = hal.executable.lookup device(%1 : !hal.device) executable(@mnist_linked_llvm_aot) : !hal.executable
    hal.command_buffer.dispatch<%arg1 : !hal.command_buffer> target(%exe : !hal.executable)[4] workgroups([%c1_3, %c1_3, %c1_3])
    hal.return
  }
  hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
  hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%executable_layout : !hal.executable_layout)[%c0] bindings([
    %c0 = (%buffer_0 : !hal.buffer)[%c0, %c40], 
    %c1 = (%buffer_0 : !hal.buffer)[%c96, %c4], 
    %c2 = (%buffer_0 : !hal.buffer)[%c48, %c40]
  ])
  hal.device.switch<%device : !hal.device>
    #hal.device.match.id<"dylib*">(%arg1 = %cmd : !hal.command_buffer, %arg2 = %c10 : index, %arg3 = %c1 : index, %arg4 = %c1 : index) {
    %c1_3 = constant 1 : index
    %1 = affine.apply affine_map<()[s0] -> (s0 ceildiv 128)>()[%arg2]
    %2 = affine.apply affine_map<()[s0] -> (s0 ceildiv 128)>()[%arg3]
    %3 = hal.command_buffer.device<%arg1 : !hal.command_buffer> : !hal.device
    %exe = hal.executable.lookup device(%3 : !hal.device) executable(@mnist_linked_llvm_aot) : !hal.executable
    hal.command_buffer.dispatch<%arg1 : !hal.command_buffer> target(%exe : !hal.executable)[5] workgroups([%1, %2, %c1_3])
    hal.return
  }
  hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
  hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%executable_layout_1 : !hal.executable_layout)[%c0] bindings([
    %c0 = (%buffer_0 : !hal.buffer)[%c48, %c40], 
    %c1 = (%buffer_0 : !hal.buffer)[%c112, %c4]
  ])
  hal.device.switch<%device : !hal.device>
    #hal.device.match.id<"dylib*">(%arg1 = %cmd : !hal.command_buffer, %arg2 = %c1 : index, %arg3 = %c1 : index, %arg4 = %c1 : index) {
    %c1_3 = constant 1 : index
    %1 = hal.command_buffer.device<%arg1 : !hal.command_buffer> : !hal.device
    %exe = hal.executable.lookup device(%1 : !hal.device) executable(@mnist_linked_llvm_aot) : !hal.executable
    hal.command_buffer.dispatch<%arg1 : !hal.command_buffer> target(%exe : !hal.executable)[6] workgroups([%c1_3, %c1_3, %c1_3])
    hal.return
  }
  hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
  %executable_layout_2 = hal.executable_layout.lookup device(%device : !hal.device) layouts([[#hal.descriptor_set_layout_binding<0, "StorageBuffer", R>, #hal.descriptor_set_layout_binding<1, "StorageBuffer", R>, #hal.descriptor_set_layout_binding<2, "StorageBuffer", R>, #hal.descriptor_set_layout_binding<3, "StorageBuffer", DW>]]) : !hal.executable_layout
  hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%executable_layout_2 : !hal.executable_layout)[%c0] bindings([
    %c0 = (%buffer_0 : !hal.buffer)[%c0, %c40], 
    %c1 = (%buffer_0 : !hal.buffer)[%c96, %c4], 
    %c2 = (%buffer_0 : !hal.buffer)[%c112, %c4], 
    %c3 = (%buffer : !hal.buffer)[%c0, %c40]
  ])
  hal.device.switch<%device : !hal.device>
    #hal.device.match.id<"dylib*">(%arg1 = %cmd : !hal.command_buffer, %arg2 = %c10 : index, %arg3 = %c1 : index, %arg4 = %c1 : index) {
    %c1_3 = constant 1 : index
    %1 = affine.apply affine_map<()[s0] -> (s0 ceildiv 128)>()[%arg2]
    %2 = affine.apply affine_map<()[s0] -> (s0 ceildiv 128)>()[%arg3]
    %3 = hal.command_buffer.device<%arg1 : !hal.command_buffer> : !hal.device
    %exe = hal.executable.lookup device(%3 : !hal.device) executable(@mnist_linked_llvm_aot) : !hal.executable
    hal.command_buffer.dispatch<%arg1 : !hal.command_buffer> target(%exe : !hal.executable)[7] workgroups([%1, %2, %c1_3])
    hal.return
  }
  hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
  hal.command_buffer.end<%cmd : !hal.command_buffer>
  hal.ex.submit_and_wait %device, %cmd
  return %buffer : !hal.buffer
}

// *** IR Dump After CSE ***
func @predict(%arg0: !hal.buffer) -> !hal.buffer attributes {noinline} {
  %c3136 = constant 3136 : index
  %c401408 = constant 401408 : index
  %c401920 = constant 401920 : index
  %c5120 = constant 5120 : index
  %c40 = constant 40 : index
  %c4 = constant 4 : index
  %c128 = constant 128 : index
  %c1 = constant 1 : index
  %c10 = constant 10 : index
  %c2 = constant 2 : index
  %c3 = constant 3 : index
  %c0 = constant 0 : index
  %c512 = constant 512 : index
  %c96 = constant 96 : index
  %c48 = constant 48 : index
  %c112 = constant 112 : index
  %c1024 = constant 1024 : index
  %device = hal.ex.shared_device : !hal.device
  %allocator = hal.device.allocator<%device : !hal.device> : !hal.allocator
  %buffer = hal.allocator.allocate<%allocator : !hal.allocator> type("HostVisible|DeviceVisible|DeviceLocal") usage("Transfer|Mapping|Dispatch") : !hal.buffer{%c40}
  %0 = hal.variable.load @_const_pool_storage_buffer : !hal.buffer
  %buffer_0 = hal.allocator.allocate<%allocator : !hal.allocator> type("DeviceVisible|DeviceLocal") usage("Transfer|Dispatch") : !hal.buffer{%c1024}
  %cmd = hal.command_buffer.create device(%device : !hal.device) mode("OneShot|AllowInlineExecution") categories("Transfer|Dispatch") : !hal.command_buffer
  hal.command_buffer.begin<%cmd : !hal.command_buffer>
  %executable_layout = hal.executable_layout.lookup device(%device : !hal.device) layouts([[#hal.descriptor_set_layout_binding<0, "StorageBuffer", R>, #hal.descriptor_set_layout_binding<1, "StorageBuffer", R>, #hal.descriptor_set_layout_binding<2, "StorageBuffer", DW>]]) : !hal.executable_layout
  hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%executable_layout : !hal.executable_layout)[%c0] bindings([
    %c0 = (%0 : !hal.buffer)[%c512, %c401408], 
    %c1 = (%arg0 : !hal.buffer)[%c0, %c3136], 
    %c2 = (%buffer_0 : !hal.buffer)[%c0, %c512]
  ])
  hal.device.switch<%device : !hal.device>
    #hal.device.match.id<"dylib*">(%arg1 = %cmd : !hal.command_buffer, %arg2 = %c128 : index, %arg3 = %c1 : index, %arg4 = %c1 : index) {
    %c1_3 = constant 1 : index
    %1 = affine.apply affine_map<()[s0] -> (s0 ceildiv 64)>()[%arg2]
    %2 = affine.apply affine_map<()[s0] -> (s0 ceildiv 4)>()[%arg3]
    %3 = hal.command_buffer.device<%arg1 : !hal.command_buffer> : !hal.device
    %exe = hal.executable.lookup device(%3 : !hal.device) executable(@mnist_linked_llvm_aot) : !hal.executable
    hal.command_buffer.dispatch<%arg1 : !hal.command_buffer> target(%exe : !hal.executable)[0] workgroups([%1, %2, %c1_3])
    hal.return
  }
  hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
  hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%executable_layout : !hal.executable_layout)[%c0] bindings([
    %c0 = (%0 : !hal.buffer)[%c0, %c512], 
    %c1 = (%buffer_0 : !hal.buffer)[%c0, %c512], 
    %c2 = (%buffer_0 : !hal.buffer)[%c512, %c512]
  ])
  hal.device.switch<%device : !hal.device>
    #hal.device.match.id<"dylib*">(%arg1 = %cmd : !hal.command_buffer, %arg2 = %c128 : index, %arg3 = %c1 : index, %arg4 = %c1 : index) {
    %c1_3 = constant 1 : index
    %1 = affine.apply affine_map<()[s0] -> (s0 ceildiv 128)>()[%arg2]
    %2 = affine.apply affine_map<()[s0] -> (s0 ceildiv 128)>()[%arg3]
    %3 = hal.command_buffer.device<%arg1 : !hal.command_buffer> : !hal.device
    %exe = hal.executable.lookup device(%3 : !hal.device) executable(@mnist_linked_llvm_aot) : !hal.executable
    hal.command_buffer.dispatch<%arg1 : !hal.command_buffer> target(%exe : !hal.executable)[1] workgroups([%1, %2, %c1_3])
    hal.return
  }
  hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
  hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%executable_layout : !hal.executable_layout)[%c0] bindings([
    %c0 = (%0 : !hal.buffer)[%c401920, %c5120], 
    %c1 = (%buffer_0 : !hal.buffer)[%c512, %c512], 
    %c2 = (%buffer_0 : !hal.buffer)[%c0, %c40]
  ])
  hal.device.switch<%device : !hal.device>
    #hal.device.match.id<"dylib*">(%arg1 = %cmd : !hal.command_buffer, %arg2 = %c10 : index, %arg3 = %c1 : index, %arg4 = %c1 : index) {
    %c1_3 = constant 1 : index
    %1 = affine.apply affine_map<()[s0] -> (s0 ceildiv 64)>()[%arg2]
    %2 = affine.apply affine_map<()[s0] -> (s0 ceildiv 4)>()[%arg3]
    %3 = hal.command_buffer.device<%arg1 : !hal.command_buffer> : !hal.device
    %exe = hal.executable.lookup device(%3 : !hal.device) executable(@mnist_linked_llvm_aot) : !hal.executable
    hal.command_buffer.dispatch<%arg1 : !hal.command_buffer> target(%exe : !hal.executable)[2] workgroups([%1, %2, %c1_3])
    hal.return
  }
  hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
  %executable_layout_1 = hal.executable_layout.lookup device(%device : !hal.device) layouts([[#hal.descriptor_set_layout_binding<0, "StorageBuffer", R>, #hal.descriptor_set_layout_binding<1, "StorageBuffer", DW>]]) : !hal.executable_layout
  hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%executable_layout_1 : !hal.executable_layout)[%c0] bindings([
    %c0 = (%buffer_0 : !hal.buffer)[%c0, %c40], 
    %c1 = (%buffer_0 : !hal.buffer)[%c48, %c40]
  ])
  hal.device.switch<%device : !hal.device>
    #hal.device.match.id<"dylib*">(%arg1 = %cmd : !hal.command_buffer, %arg2 = %c10 : index, %arg3 = %c1 : index, %arg4 = %c1 : index) {
    %c1_3 = constant 1 : index
    %1 = affine.apply affine_map<()[s0] -> (s0 ceildiv 128)>()[%arg2]
    %2 = affine.apply affine_map<()[s0] -> (s0 ceildiv 128)>()[%arg3]
    %3 = hal.command_buffer.device<%arg1 : !hal.command_buffer> : !hal.device
    %exe = hal.executable.lookup device(%3 : !hal.device) executable(@mnist_linked_llvm_aot) : !hal.executable
    hal.command_buffer.dispatch<%arg1 : !hal.command_buffer> target(%exe : !hal.executable)[3] workgroups([%1, %2, %c1_3])
    hal.return
  }
  hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
  hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%executable_layout_1 : !hal.executable_layout)[%c0] bindings([
    %c0 = (%buffer_0 : !hal.buffer)[%c48, %c40], 
    %c1 = (%buffer_0 : !hal.buffer)[%c96, %c4]
  ])
  hal.device.switch<%device : !hal.device>
    #hal.device.match.id<"dylib*">(%arg1 = %cmd : !hal.command_buffer, %arg2 = %c1 : index, %arg3 = %c1 : index, %arg4 = %c1 : index) {
    %c1_3 = constant 1 : index
    %1 = hal.command_buffer.device<%arg1 : !hal.command_buffer> : !hal.device
    %exe = hal.executable.lookup device(%1 : !hal.device) executable(@mnist_linked_llvm_aot) : !hal.executable
    hal.command_buffer.dispatch<%arg1 : !hal.command_buffer> target(%exe : !hal.executable)[4] workgroups([%c1_3, %c1_3, %c1_3])
    hal.return
  }
  hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
  hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%executable_layout : !hal.executable_layout)[%c0] bindings([
    %c0 = (%buffer_0 : !hal.buffer)[%c0, %c40], 
    %c1 = (%buffer_0 : !hal.buffer)[%c96, %c4], 
    %c2 = (%buffer_0 : !hal.buffer)[%c48, %c40]
  ])
  hal.device.switch<%device : !hal.device>
    #hal.device.match.id<"dylib*">(%arg1 = %cmd : !hal.command_buffer, %arg2 = %c10 : index, %arg3 = %c1 : index, %arg4 = %c1 : index) {
    %c1_3 = constant 1 : index
    %1 = affine.apply affine_map<()[s0] -> (s0 ceildiv 128)>()[%arg2]
    %2 = affine.apply affine_map<()[s0] -> (s0 ceildiv 128)>()[%arg3]
    %3 = hal.command_buffer.device<%arg1 : !hal.command_buffer> : !hal.device
    %exe = hal.executable.lookup device(%3 : !hal.device) executable(@mnist_linked_llvm_aot) : !hal.executable
    hal.command_buffer.dispatch<%arg1 : !hal.command_buffer> target(%exe : !hal.executable)[5] workgroups([%1, %2, %c1_3])
    hal.return
  }
  hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
  hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%executable_layout_1 : !hal.executable_layout)[%c0] bindings([
    %c0 = (%buffer_0 : !hal.buffer)[%c48, %c40], 
    %c1 = (%buffer_0 : !hal.buffer)[%c112, %c4]
  ])
  hal.device.switch<%device : !hal.device>
    #hal.device.match.id<"dylib*">(%arg1 = %cmd : !hal.command_buffer, %arg2 = %c1 : index, %arg3 = %c1 : index, %arg4 = %c1 : index) {
    %c1_3 = constant 1 : index
    %1 = hal.command_buffer.device<%arg1 : !hal.command_buffer> : !hal.device
    %exe = hal.executable.lookup device(%1 : !hal.device) executable(@mnist_linked_llvm_aot) : !hal.executable
    hal.command_buffer.dispatch<%arg1 : !hal.command_buffer> target(%exe : !hal.executable)[6] workgroups([%c1_3, %c1_3, %c1_3])
    hal.return
  }
  hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
  %executable_layout_2 = hal.executable_layout.lookup device(%device : !hal.device) layouts([[#hal.descriptor_set_layout_binding<0, "StorageBuffer", R>, #hal.descriptor_set_layout_binding<1, "StorageBuffer", R>, #hal.descriptor_set_layout_binding<2, "StorageBuffer", R>, #hal.descriptor_set_layout_binding<3, "StorageBuffer", DW>]]) : !hal.executable_layout
  hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%executable_layout_2 : !hal.executable_layout)[%c0] bindings([
    %c0 = (%buffer_0 : !hal.buffer)[%c0, %c40], 
    %c1 = (%buffer_0 : !hal.buffer)[%c96, %c4], 
    %c2 = (%buffer_0 : !hal.buffer)[%c112, %c4], 
    %c3 = (%buffer : !hal.buffer)[%c0, %c40]
  ])
  hal.device.switch<%device : !hal.device>
    #hal.device.match.id<"dylib*">(%arg1 = %cmd : !hal.command_buffer, %arg2 = %c10 : index, %arg3 = %c1 : index, %arg4 = %c1 : index) {
    %c1_3 = constant 1 : index
    %1 = affine.apply affine_map<()[s0] -> (s0 ceildiv 128)>()[%arg2]
    %2 = affine.apply affine_map<()[s0] -> (s0 ceildiv 128)>()[%arg3]
    %3 = hal.command_buffer.device<%arg1 : !hal.command_buffer> : !hal.device
    %exe = hal.executable.lookup device(%3 : !hal.device) executable(@mnist_linked_llvm_aot) : !hal.executable
    hal.command_buffer.dispatch<%arg1 : !hal.command_buffer> target(%exe : !hal.executable)[7] workgroups([%1, %2, %c1_3])
    hal.return
  }
  hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
  hal.command_buffer.end<%cmd : !hal.command_buffer>
  hal.ex.submit_and_wait %device, %cmd
  return %buffer : !hal.buffer
}

// *** IR Dump After Canonicalizer ***
func @predict$async(%arg0: !hal.semaphore, %arg1: index, %arg2: !hal.buffer_view, %arg3: !hal.semaphore, %arg4: index) -> !hal.buffer_view attributes {iree.module.export = "predict$async"} {
  %c1 = constant 1 : index
  %c10 = constant 10 : index
  %c50331680_i32 = constant 50331680 : i32
  %0 = hal.semaphore.await<%arg0 : !hal.semaphore> until(%arg1) : i32
  hal.check_success %0, "semaphore wait failed"
  %buffer = hal.buffer_view.buffer %arg2 : !hal.buffer
  %1 = call @predict(%buffer) : (!hal.buffer) -> !hal.buffer
  %view = hal.buffer_view.create %1, element_type = %c50331680_i32, shape = [%c1, %c10] : !hal.buffer -> !hal.buffer_view
  hal.semaphore.signal<%arg3 : !hal.semaphore> value(%arg4)
  return %view : !hal.buffer_view
}

// *** IR Dump After CSE ***
func @predict$async(%arg0: !hal.semaphore, %arg1: index, %arg2: !hal.buffer_view, %arg3: !hal.semaphore, %arg4: index) -> !hal.buffer_view attributes {iree.module.export = "predict$async"} {
  %c1 = constant 1 : index
  %c10 = constant 10 : index
  %c50331680_i32 = constant 50331680 : i32
  %0 = hal.semaphore.await<%arg0 : !hal.semaphore> until(%arg1) : i32
  hal.check_success %0, "semaphore wait failed"
  %buffer = hal.buffer_view.buffer %arg2 : !hal.buffer
  %1 = call @predict(%buffer) : (!hal.buffer) -> !hal.buffer
  %view = hal.buffer_view.create %1, element_type = %c50331680_i32, shape = [%c1, %c10] : !hal.buffer -> !hal.buffer_view
  hal.semaphore.signal<%arg3 : !hal.semaphore> value(%arg4)
  return %view : !hal.buffer_view
}

// *** IR Dump After Canonicalizer ***
func @predict$sync(%arg0: !hal.buffer_view) -> !hal.buffer_view attributes {iree.abi.stub, iree.module.export = "predict", iree.reflection = {abi = "sip", abiv = 1 : i32, f = "I15!B11!d1d28d28d1R9!B6!d1d10", fv = "1", sip = "I8!S5!k0_0R3!_0"}} {
  %c0 = constant 0 : index
  %c1 = constant 1 : index
  %device = hal.ex.shared_device : !hal.device
  %semaphore = hal.semaphore.create device(%device : !hal.device) initial(%c0) : !hal.semaphore
  %0 = call @predict$async(%semaphore, %c0, %arg0, %semaphore, %c1) : (!hal.semaphore, index, !hal.buffer_view, !hal.semaphore, index) -> !hal.buffer_view
  %1 = hal.semaphore.await<%semaphore : !hal.semaphore> until(%c1) : i32
  hal.check_success %1, "semaphore wait failed"
  return %0 : !hal.buffer_view
}

// *** IR Dump After CSE ***
func @predict$sync(%arg0: !hal.buffer_view) -> !hal.buffer_view attributes {iree.abi.stub, iree.module.export = "predict", iree.reflection = {abi = "sip", abiv = 1 : i32, f = "I15!B11!d1d28d28d1R9!B6!d1d10", fv = "1", sip = "I8!S5!k0_0R3!_0"}} {
  %c0 = constant 0 : index
  %c1 = constant 1 : index
  %device = hal.ex.shared_device : !hal.device
  %semaphore = hal.semaphore.create device(%device : !hal.device) initial(%c0) : !hal.semaphore
  %0 = call @predict$async(%semaphore, %c0, %arg0, %semaphore, %c1) : (!hal.semaphore, index, !hal.buffer_view, !hal.semaphore, index) -> !hal.buffer_view
  %1 = hal.semaphore.await<%semaphore : !hal.semaphore> until(%c1) : i32
  hal.check_success %1, "semaphore wait failed"
  return %0 : !hal.buffer_view
}

// *** IR Dump After mlir::iree_compiler::IREE::HAL::MaterializeResourceCachesPass ***
#map0 = affine_map<()[s0] -> (s0 ceildiv 64)>
#map1 = affine_map<()[s0] -> (s0 ceildiv 4)>
#map2 = affine_map<()[s0] -> (s0 ceildiv 128)>
module  {
  hal.variable @_descriptor_set_layout_0 init(@_descriptor_set_layout_0_initializer) : !hal.descriptor_set_layout attributes {sym_visibility = "private"}
  func private @_descriptor_set_layout_0_initializer() -> !hal.descriptor_set_layout {
    %device = hal.ex.shared_device : !hal.device
    %descriptor_set_layout = hal.descriptor_set_layout.create device(%device : !hal.device) usage(PushOnly) bindings([#hal.descriptor_set_layout_binding<0, "StorageBuffer", R>, #hal.descriptor_set_layout_binding<1, "StorageBuffer", R>, #hal.descriptor_set_layout_binding<2, "StorageBuffer", DW>]) : !hal.descriptor_set_layout
    return %descriptor_set_layout : !hal.descriptor_set_layout
  }
  hal.variable @_executable_layout_0 init(@_executable_layout_0_initializer) : !hal.executable_layout attributes {sym_visibility = "private"}
  func private @_executable_layout_0_initializer() -> !hal.executable_layout {
    %0 = hal.variable.load @_descriptor_set_layout_0 : !hal.descriptor_set_layout
    %device = hal.ex.shared_device : !hal.device
    %executable_layout = hal.executable_layout.create device(%device : !hal.device) push_constants(0) layouts([%0]) : !hal.executable_layout
    return %executable_layout : !hal.executable_layout
  }
  hal.variable @_descriptor_set_layout_1 init(@_descriptor_set_layout_1_initializer) : !hal.descriptor_set_layout attributes {sym_visibility = "private"}
  func private @_descriptor_set_layout_1_initializer() -> !hal.descriptor_set_layout {
    %device = hal.ex.shared_device : !hal.device
    %descriptor_set_layout = hal.descriptor_set_layout.create device(%device : !hal.device) usage(PushOnly) bindings([#hal.descriptor_set_layout_binding<0, "StorageBuffer", R>, #hal.descriptor_set_layout_binding<1, "StorageBuffer", DW>]) : !hal.descriptor_set_layout
    return %descriptor_set_layout : !hal.descriptor_set_layout
  }
  hal.variable @_executable_layout_1 init(@_executable_layout_1_initializer) : !hal.executable_layout attributes {sym_visibility = "private"}
  func private @_executable_layout_1_initializer() -> !hal.executable_layout {
    %0 = hal.variable.load @_descriptor_set_layout_1 : !hal.descriptor_set_layout
    %device = hal.ex.shared_device : !hal.device
    %executable_layout = hal.executable_layout.create device(%device : !hal.device) push_constants(0) layouts([%0]) : !hal.executable_layout
    return %executable_layout : !hal.executable_layout
  }
  hal.variable @_descriptor_set_layout_2 init(@_descriptor_set_layout_2_initializer) : !hal.descriptor_set_layout attributes {sym_visibility = "private"}
  func private @_descriptor_set_layout_2_initializer() -> !hal.descriptor_set_layout {
    %device = hal.ex.shared_device : !hal.device
    %descriptor_set_layout = hal.descriptor_set_layout.create device(%device : !hal.device) usage(PushOnly) bindings([#hal.descriptor_set_layout_binding<0, "StorageBuffer", R>, #hal.descriptor_set_layout_binding<1, "StorageBuffer", R>, #hal.descriptor_set_layout_binding<2, "StorageBuffer", R>, #hal.descriptor_set_layout_binding<3, "StorageBuffer", DW>]) : !hal.descriptor_set_layout
    return %descriptor_set_layout : !hal.descriptor_set_layout
  }
  hal.variable @_executable_layout_2 init(@_executable_layout_2_initializer) : !hal.executable_layout attributes {sym_visibility = "private"}
  func private @_executable_layout_2_initializer() -> !hal.executable_layout {
    %0 = hal.variable.load @_descriptor_set_layout_2 : !hal.descriptor_set_layout
    %device = hal.ex.shared_device : !hal.device
    %executable_layout = hal.executable_layout.create device(%device : !hal.device) push_constants(0) layouts([%0]) : !hal.executable_layout
    return %executable_layout : !hal.executable_layout
  }
  hal.variable @_executable_mnist_linked_llvm_aot init(@_executable_mnist_linked_llvm_aot_initializer) : !hal.executable attributes {sym_visibility = "private"}
  func private @_executable_mnist_linked_llvm_aot_initializer() -> !hal.executable {
    %device = hal.ex.shared_device : !hal.device
    %0 = hal.device.switch<%device : !hal.device> -> !hal.executable
    #hal.device.match.id<"dylib*">(%arg0 = %device : !hal.device) {
      %1 = hal.variable.load @_executable_layout_0 : !hal.executable_layout
      %2 = hal.variable.load @_executable_layout_0 : !hal.executable_layout
      %3 = hal.variable.load @_executable_layout_0 : !hal.executable_layout
      %4 = hal.variable.load @_executable_layout_1 : !hal.executable_layout
      %5 = hal.variable.load @_executable_layout_1 : !hal.executable_layout
      %6 = hal.variable.load @_executable_layout_0 : !hal.executable_layout
      %7 = hal.variable.load @_executable_layout_1 : !hal.executable_layout
      %8 = hal.variable.load @_executable_layout_2 : !hal.executable_layout
      %exe = hal.executable.create device(%arg0 : !hal.device) target(@mnist_linked_llvm_aot::@llvm_aot) layouts([%1, %2, %3, %4, %5, %6, %7, %8]) : !hal.executable
      hal.return %exe : !hal.executable
    },
    #hal.match.always() {
      %1 = iree.null : !hal.executable
      hal.return %1 : !hal.executable
    }
    return %0 : !hal.executable
  }
  hal.executable @mnist_linked_llvm_aot attributes {sym_visibility = "private"} {
    hal.interface @io_0 {
      hal.interface.binding @s0b0_ro_constant, set=0, binding=0, type="StorageBuffer", access="Read"
      hal.interface.binding @s0b1_ro_external, set=0, binding=1, type="StorageBuffer", access="Read"
      hal.interface.binding @s0b2_xw_external, set=0, binding=2, type="StorageBuffer", access="Write|Discard"
    }
    hal.interface @io_1 {
      hal.interface.binding @s0b0_ro_external, set=0, binding=0, type="StorageBuffer", access="Read"
      hal.interface.binding @s0b1_xw_external, set=0, binding=1, type="StorageBuffer", access="Write|Discard"
    }
    hal.interface @io_2 {
      hal.interface.binding @s0b0_ro_external, set=0, binding=0, type="StorageBuffer", access="Read"
      hal.interface.binding @s0b1_ro_external, set=0, binding=1, type="StorageBuffer", access="Read"
      hal.interface.binding @s0b2_xw_external, set=0, binding=2, type="StorageBuffer", access="Write|Discard"
    }
    hal.interface @io_3 {
      hal.interface.binding @s0b0_ro_external, set=0, binding=0, type="StorageBuffer", access="Read"
      hal.interface.binding @s0b1_ro_external, set=0, binding=1, type="StorageBuffer", access="Read"
      hal.interface.binding @s0b2_ro_external, set=0, binding=2, type="StorageBuffer", access="Read"
      hal.interface.binding @s0b3_xw_external, set=0, binding=3, type="StorageBuffer", access="Write|Discard"
    }
    hal.executable.target @llvm_aot, filter="dylib*" {
      hal.executable.entry_point @predict_dispatch_0 attributes {interface = @io_0, ordinal = 0 : index}
      hal.executable.entry_point @predict_dispatch_1 attributes {interface = @io_0, ordinal = 1 : index}
      hal.executable.entry_point @predict_dispatch_2 attributes {interface = @io_0, ordinal = 2 : index}
      hal.executable.entry_point @predict_dispatch_3 attributes {interface = @io_1, ordinal = 3 : index}
      hal.executable.entry_point @predict_dispatch_4 attributes {interface = @io_1, ordinal = 4 : index}
      hal.executable.entry_point @predict_dispatch_5 attributes {interface = @io_2, ordinal = 5 : index}
      hal.executable.entry_point @predict_dispatch_6 attributes {interface = @io_1, ordinal = 6 : index}
      hal.executable.entry_point @predict_dispatch_7 attributes {interface = @io_3, ordinal = 7 : index}
      module  {
        llvm.func internal @predict_dispatch_0(%arg0: !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>, %arg1: !llvm.ptr<array<3 x i32>>) -> i32 {
          %0 = llvm.mlir.constant(0.000000e+00 : f32) : f32
          %1 = llvm.mlir.constant(128 : index) : i64
          %2 = llvm.mlir.constant(784 : index) : i64
          %3 = llvm.mlir.constant(28 : index) : i64
          %4 = llvm.mlir.constant(32 : index) : i64
          %5 = llvm.mlir.constant(64 : index) : i64
          %6 = llvm.mlir.constant(4 : index) : i64
          %7 = llvm.mlir.constant(0 : index) : i64
          %8 = llvm.mlir.constant(1 : index) : i64
          %9 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %10 = llvm.extractvalue %9[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %11 = llvm.getelementptr %10[%8] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
          %12 = llvm.load %11 : !llvm.ptr<ptr<i8>>
          %13 = llvm.getelementptr %12[%7] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
          %14 = llvm.bitcast %13 : !llvm.ptr<i8> to !llvm.ptr<f32>
          %15 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %16 = llvm.insertvalue %14, %15[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %17 = llvm.insertvalue %14, %16[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %18 = llvm.insertvalue %7, %17[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %19 = llvm.insertvalue %8, %18[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %20 = llvm.insertvalue %2, %19[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %21 = llvm.insertvalue %2, %20[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %22 = llvm.insertvalue %8, %21[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %23 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %24 = llvm.extractvalue %23[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %25 = llvm.getelementptr %24[%7] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
          %26 = llvm.load %25 : !llvm.ptr<ptr<i8>>
          %27 = llvm.getelementptr %26[%7] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
          %28 = llvm.bitcast %27 : !llvm.ptr<i8> to !llvm.ptr<f32>
          %29 = llvm.insertvalue %28, %15[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %30 = llvm.insertvalue %28, %29[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %31 = llvm.insertvalue %7, %30[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %32 = llvm.insertvalue %2, %31[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %33 = llvm.insertvalue %1, %32[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %34 = llvm.insertvalue %1, %33[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %35 = llvm.insertvalue %8, %34[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %36 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %37 = llvm.extractvalue %36[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %38 = llvm.mlir.constant(2 : index) : i64
          %39 = llvm.getelementptr %37[%38] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
          %40 = llvm.load %39 : !llvm.ptr<ptr<i8>>
          %41 = llvm.getelementptr %40[%7] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
          %42 = llvm.bitcast %41 : !llvm.ptr<i8> to !llvm.ptr<f32>
          %43 = llvm.insertvalue %42, %15[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %44 = llvm.insertvalue %42, %43[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %45 = llvm.insertvalue %7, %44[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %46 = llvm.insertvalue %8, %45[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %47 = llvm.insertvalue %1, %46[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %48 = llvm.insertvalue %1, %47[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %49 = llvm.insertvalue %8, %48[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %50 = llvm.load %arg1 : !llvm.ptr<array<3 x i32>>
          %51 = llvm.extractvalue %50[0] : !llvm.array<3 x i32>
          %52 = llvm.zext %51 : i32 to i64
          %53 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %54 = llvm.extractvalue %53[0] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %55 = llvm.extractvalue %54[0] : !llvm.array<3 x i32>
          %56 = llvm.zext %55 : i32 to i64
          %57 = llvm.load %arg1 : !llvm.ptr<array<3 x i32>>
          %58 = llvm.extractvalue %57[1] : !llvm.array<3 x i32>
          %59 = llvm.zext %58 : i32 to i64
          %60 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %61 = llvm.extractvalue %60[0] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %62 = llvm.extractvalue %61[1] : !llvm.array<3 x i32>
          %63 = llvm.zext %62 : i32 to i64
          %64 = llvm.mul %59, %6  : i64
          %65 = llvm.mul %63, %6  : i64
          llvm.br ^bb1(%64 : i64)
        ^bb1(%66: i64):  // 2 preds: ^bb0, ^bb30
          %67 = llvm.icmp "slt" %66, %8 : i64
          llvm.cond_br %67, ^bb2, ^bb31
        ^bb2:  // pred: ^bb1
          %68 = llvm.mul %52, %5  : i64
          %69 = llvm.mul %56, %5  : i64
          llvm.br ^bb3(%68 : i64)
        ^bb3(%70: i64):  // 2 preds: ^bb2, ^bb29
          %71 = llvm.icmp "slt" %70, %1 : i64
          llvm.cond_br %71, ^bb4, ^bb30
        ^bb4:  // pred: ^bb3
          %72 = llvm.mlir.constant(-1 : index) : i64
          %73 = llvm.mul %66, %72  : i64
          %74 = llvm.add %73, %8  : i64
          %75 = llvm.icmp "slt" %6, %74 : i64
          %76 = llvm.select %75, %6, %74 : i1, i64
          %77 = llvm.extractvalue %22[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %78 = llvm.bitcast %77 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %79 = llvm.insertvalue %78, %15[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %80 = llvm.extractvalue %22[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %81 = llvm.bitcast %80 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %82 = llvm.insertvalue %81, %79[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %83 = llvm.extractvalue %22[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %84 = llvm.extractvalue %22[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %85 = llvm.extractvalue %22[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %86 = llvm.mul %66, %83  : i64
          %87 = llvm.add %85, %86  : i64
          %88 = llvm.mlir.constant(0 : i64) : i64
          %89 = llvm.mul %88, %84  : i64
          %90 = llvm.add %87, %89  : i64
          %91 = llvm.insertvalue %90, %82[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %92 = llvm.mlir.constant(784 : i64) : i64
          %93 = llvm.mlir.constant(1 : i64) : i64
          %94 = llvm.insertvalue %92, %91[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %95 = llvm.insertvalue %93, %94[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %96 = llvm.insertvalue %76, %95[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %97 = llvm.insertvalue %92, %96[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %98 = llvm.extractvalue %35[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %99 = llvm.bitcast %98 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %100 = llvm.insertvalue %99, %15[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %101 = llvm.extractvalue %35[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %102 = llvm.bitcast %101 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %103 = llvm.insertvalue %102, %100[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %104 = llvm.extractvalue %35[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %105 = llvm.extractvalue %35[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %106 = llvm.extractvalue %35[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %107 = llvm.mul %88, %104  : i64
          %108 = llvm.add %106, %107  : i64
          %109 = llvm.mul %70, %105  : i64
          %110 = llvm.add %108, %109  : i64
          %111 = llvm.insertvalue %110, %103[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %112 = llvm.mlir.constant(64 : i64) : i64
          %113 = llvm.insertvalue %112, %111[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %114 = llvm.insertvalue %93, %113[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %115 = llvm.mlir.constant(128 : i64) : i64
          %116 = llvm.insertvalue %92, %114[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %117 = llvm.insertvalue %115, %116[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %118 = llvm.extractvalue %49[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %119 = llvm.bitcast %118 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %120 = llvm.insertvalue %119, %15[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %121 = llvm.extractvalue %49[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %122 = llvm.bitcast %121 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %123 = llvm.insertvalue %122, %120[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %124 = llvm.extractvalue %49[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %125 = llvm.extractvalue %49[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %126 = llvm.extractvalue %49[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %127 = llvm.mul %66, %124  : i64
          %128 = llvm.add %126, %127  : i64
          %129 = llvm.mul %70, %125  : i64
          %130 = llvm.add %128, %129  : i64
          %131 = llvm.insertvalue %130, %123[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %132 = llvm.insertvalue %112, %131[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %133 = llvm.insertvalue %93, %132[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %134 = llvm.insertvalue %76, %133[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %135 = llvm.insertvalue %115, %134[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          llvm.br ^bb5(%7 : i64)
        ^bb5(%136: i64):  // 2 preds: ^bb4, ^bb8
          %137 = llvm.icmp "slt" %136, %76 : i64
          llvm.cond_br %137, ^bb6(%7 : i64), ^bb9(%7 : i64)
        ^bb6(%138: i64):  // 2 preds: ^bb5, ^bb7
          %139 = llvm.icmp "slt" %138, %5 : i64
          llvm.cond_br %139, ^bb7, ^bb8
        ^bb7:  // pred: ^bb6
          %140 = llvm.extractvalue %135[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %141 = llvm.extractvalue %135[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %142 = llvm.mul %136, %1  : i64
          %143 = llvm.add %141, %142  : i64
          %144 = llvm.add %143, %138  : i64
          %145 = llvm.getelementptr %140[%144] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
          llvm.store %0, %145 : !llvm.ptr<f32>
          %146 = llvm.add %138, %8  : i64
          llvm.br ^bb6(%146 : i64)
        ^bb8:  // pred: ^bb6
          %147 = llvm.add %136, %8  : i64
          llvm.br ^bb5(%147 : i64)
        ^bb9(%148: i64):  // 2 preds: ^bb5, ^bb28
          %149 = llvm.icmp "slt" %148, %76 : i64
          llvm.cond_br %149, ^bb10(%7 : i64), ^bb29
        ^bb10(%150: i64):  // 2 preds: ^bb9, ^bb27
          %151 = llvm.icmp "slt" %150, %5 : i64
          llvm.cond_br %151, ^bb11(%7 : i64), ^bb28
        ^bb11(%152: i64):  // 2 preds: ^bb10, ^bb26
          %153 = llvm.icmp "slt" %152, %2 : i64
          llvm.cond_br %153, ^bb12, ^bb27
        ^bb12:  // pred: ^bb11
          %154 = llvm.mul %148, %72  : i64
          %155 = llvm.add %76, %154  : i64
          %156 = llvm.icmp "slt" %6, %155 : i64
          %157 = llvm.select %156, %6, %155 : i1, i64
          %158 = llvm.extractvalue %97[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %159 = llvm.bitcast %158 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %160 = llvm.insertvalue %159, %15[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %161 = llvm.extractvalue %97[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %162 = llvm.bitcast %161 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %163 = llvm.insertvalue %162, %160[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %164 = llvm.extractvalue %97[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %165 = llvm.extractvalue %97[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %166 = llvm.extractvalue %97[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %167 = llvm.mul %148, %164  : i64
          %168 = llvm.add %166, %167  : i64
          %169 = llvm.mul %152, %165  : i64
          %170 = llvm.add %168, %169  : i64
          %171 = llvm.insertvalue %170, %163[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %172 = llvm.mlir.constant(28 : i64) : i64
          %173 = llvm.insertvalue %172, %171[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %174 = llvm.insertvalue %93, %173[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %175 = llvm.insertvalue %157, %174[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %176 = llvm.insertvalue %92, %175[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %177 = llvm.extractvalue %117[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %178 = llvm.bitcast %177 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %179 = llvm.insertvalue %178, %15[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %180 = llvm.extractvalue %117[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %181 = llvm.bitcast %180 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %182 = llvm.insertvalue %181, %179[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %183 = llvm.extractvalue %117[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %184 = llvm.extractvalue %117[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %185 = llvm.extractvalue %117[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %186 = llvm.mul %152, %183  : i64
          %187 = llvm.add %185, %186  : i64
          %188 = llvm.mul %150, %184  : i64
          %189 = llvm.add %187, %188  : i64
          %190 = llvm.insertvalue %189, %182[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %191 = llvm.mlir.constant(32 : i64) : i64
          %192 = llvm.insertvalue %191, %190[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %193 = llvm.insertvalue %93, %192[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %194 = llvm.insertvalue %172, %193[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %195 = llvm.insertvalue %115, %194[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %196 = llvm.extractvalue %135[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %197 = llvm.bitcast %196 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %198 = llvm.insertvalue %197, %15[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %199 = llvm.extractvalue %135[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %200 = llvm.bitcast %199 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %201 = llvm.insertvalue %200, %198[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %202 = llvm.extractvalue %135[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %203 = llvm.extractvalue %135[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %204 = llvm.extractvalue %135[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %205 = llvm.mul %148, %202  : i64
          %206 = llvm.add %204, %205  : i64
          %207 = llvm.mul %150, %203  : i64
          %208 = llvm.add %206, %207  : i64
          %209 = llvm.insertvalue %208, %201[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %210 = llvm.insertvalue %191, %209[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %211 = llvm.insertvalue %93, %210[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %212 = llvm.insertvalue %157, %211[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %213 = llvm.insertvalue %115, %212[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          llvm.br ^bb13(%7 : i64)
        ^bb13(%214: i64):  // 2 preds: ^bb12, ^bb25
          %215 = llvm.icmp "slt" %214, %157 : i64
          llvm.cond_br %215, ^bb14(%7 : i64), ^bb26
        ^bb14(%216: i64):  // 2 preds: ^bb13, ^bb24
          %217 = llvm.icmp "slt" %216, %4 : i64
          llvm.cond_br %217, ^bb15(%7 : i64), ^bb25
        ^bb15(%218: i64):  // 2 preds: ^bb14, ^bb23
          %219 = llvm.icmp "slt" %218, %3 : i64
          llvm.cond_br %219, ^bb16, ^bb24
        ^bb16:  // pred: ^bb15
          %220 = llvm.mul %214, %72  : i64
          %221 = llvm.add %157, %220  : i64
          %222 = llvm.icmp "slt" %6, %221 : i64
          %223 = llvm.select %222, %6, %221 : i1, i64
          %224 = llvm.extractvalue %176[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %225 = llvm.bitcast %224 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %226 = llvm.insertvalue %225, %15[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %227 = llvm.extractvalue %176[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %228 = llvm.bitcast %227 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %229 = llvm.insertvalue %228, %226[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %230 = llvm.extractvalue %176[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %231 = llvm.extractvalue %176[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %232 = llvm.extractvalue %176[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %233 = llvm.mul %214, %230  : i64
          %234 = llvm.add %232, %233  : i64
          %235 = llvm.mul %218, %231  : i64
          %236 = llvm.add %234, %235  : i64
          %237 = llvm.insertvalue %236, %229[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %238 = llvm.mlir.constant(4 : i64) : i64
          %239 = llvm.insertvalue %238, %237[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %240 = llvm.insertvalue %93, %239[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %241 = llvm.insertvalue %223, %240[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %242 = llvm.insertvalue %92, %241[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %243 = llvm.extractvalue %195[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %244 = llvm.bitcast %243 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %245 = llvm.insertvalue %244, %15[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %246 = llvm.extractvalue %195[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %247 = llvm.bitcast %246 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %248 = llvm.insertvalue %247, %245[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %249 = llvm.extractvalue %195[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %250 = llvm.extractvalue %195[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %251 = llvm.extractvalue %195[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %252 = llvm.mul %218, %249  : i64
          %253 = llvm.add %251, %252  : i64
          %254 = llvm.mul %216, %250  : i64
          %255 = llvm.add %253, %254  : i64
          %256 = llvm.insertvalue %255, %248[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %257 = llvm.insertvalue %238, %256[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %258 = llvm.insertvalue %93, %257[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %259 = llvm.insertvalue %238, %258[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %260 = llvm.insertvalue %115, %259[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %261 = llvm.extractvalue %213[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %262 = llvm.bitcast %261 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %263 = llvm.insertvalue %262, %15[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %264 = llvm.extractvalue %213[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %265 = llvm.bitcast %264 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %266 = llvm.insertvalue %265, %263[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %267 = llvm.extractvalue %213[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %268 = llvm.extractvalue %213[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %269 = llvm.extractvalue %213[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %270 = llvm.mul %214, %267  : i64
          %271 = llvm.add %269, %270  : i64
          %272 = llvm.mul %216, %268  : i64
          %273 = llvm.add %271, %272  : i64
          %274 = llvm.insertvalue %273, %266[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %275 = llvm.insertvalue %238, %274[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %276 = llvm.insertvalue %93, %275[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %277 = llvm.insertvalue %223, %276[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %278 = llvm.insertvalue %115, %277[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          llvm.br ^bb17(%7 : i64)
        ^bb17(%279: i64):  // 2 preds: ^bb16, ^bb22
          %280 = llvm.icmp "slt" %279, %223 : i64
          llvm.cond_br %280, ^bb18(%7 : i64), ^bb23
        ^bb18(%281: i64):  // 2 preds: ^bb17, ^bb21
          %282 = llvm.icmp "slt" %281, %6 : i64
          llvm.cond_br %282, ^bb19(%7 : i64), ^bb22
        ^bb19(%283: i64):  // 2 preds: ^bb18, ^bb20
          %284 = llvm.icmp "slt" %283, %6 : i64
          llvm.cond_br %284, ^bb20, ^bb21
        ^bb20:  // pred: ^bb19
          %285 = llvm.extractvalue %242[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %286 = llvm.extractvalue %242[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %287 = llvm.mul %279, %2  : i64
          %288 = llvm.add %286, %287  : i64
          %289 = llvm.add %288, %283  : i64
          %290 = llvm.getelementptr %285[%289] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
          %291 = llvm.load %290 : !llvm.ptr<f32>
          %292 = llvm.extractvalue %260[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %293 = llvm.extractvalue %260[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %294 = llvm.mul %283, %1  : i64
          %295 = llvm.add %293, %294  : i64
          %296 = llvm.add %295, %281  : i64
          %297 = llvm.getelementptr %292[%296] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
          %298 = llvm.load %297 : !llvm.ptr<f32>
          %299 = llvm.extractvalue %278[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %300 = llvm.extractvalue %278[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %301 = llvm.mul %279, %1  : i64
          %302 = llvm.add %300, %301  : i64
          %303 = llvm.add %302, %281  : i64
          %304 = llvm.getelementptr %299[%303] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
          %305 = llvm.load %304 : !llvm.ptr<f32>
          %306 = llvm.fmul %291, %298  : f32
          %307 = llvm.fadd %305, %306  : f32
          llvm.store %307, %304 : !llvm.ptr<f32>
          %308 = llvm.add %283, %8  : i64
          llvm.br ^bb19(%308 : i64)
        ^bb21:  // pred: ^bb19
          %309 = llvm.add %281, %8  : i64
          llvm.br ^bb18(%309 : i64)
        ^bb22:  // pred: ^bb18
          %310 = llvm.add %279, %8  : i64
          llvm.br ^bb17(%310 : i64)
        ^bb23:  // pred: ^bb17
          %311 = llvm.add %218, %6  : i64
          llvm.br ^bb15(%311 : i64)
        ^bb24:  // pred: ^bb15
          %312 = llvm.add %216, %6  : i64
          llvm.br ^bb14(%312 : i64)
        ^bb25:  // pred: ^bb14
          %313 = llvm.add %214, %6  : i64
          llvm.br ^bb13(%313 : i64)
        ^bb26:  // pred: ^bb13
          %314 = llvm.add %152, %3  : i64
          llvm.br ^bb11(%314 : i64)
        ^bb27:  // pred: ^bb11
          %315 = llvm.add %150, %4  : i64
          llvm.br ^bb10(%315 : i64)
        ^bb28:  // pred: ^bb10
          %316 = llvm.add %148, %6  : i64
          llvm.br ^bb9(%316 : i64)
        ^bb29:  // pred: ^bb9
          %317 = llvm.add %70, %69  : i64
          llvm.br ^bb3(%317 : i64)
        ^bb30:  // pred: ^bb3
          %318 = llvm.add %66, %65  : i64
          llvm.br ^bb1(%318 : i64)
        ^bb31:  // pred: ^bb1
          %319 = llvm.mlir.constant(0 : i32) : i32
          llvm.return %319 : i32
        }
        llvm.func internal @predict_dispatch_1(%arg0: !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>, %arg1: !llvm.ptr<array<3 x i32>>) -> i32 {
          %0 = llvm.mlir.constant(0x7FC00000 : f32) : f32
          %1 = llvm.mlir.constant(0.000000e+00 : f32) : f32
          %2 = llvm.mlir.constant(128 : index) : i64
          %3 = llvm.mlir.constant(0 : index) : i64
          %4 = llvm.mlir.constant(1 : index) : i64
          %5 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %6 = llvm.extractvalue %5[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %7 = llvm.getelementptr %6[%4] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
          %8 = llvm.load %7 : !llvm.ptr<ptr<i8>>
          %9 = llvm.getelementptr %8[%3] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
          %10 = llvm.bitcast %9 : !llvm.ptr<i8> to !llvm.ptr<f32>
          %11 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %12 = llvm.insertvalue %10, %11[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %13 = llvm.insertvalue %10, %12[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %14 = llvm.insertvalue %3, %13[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %15 = llvm.insertvalue %4, %14[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %16 = llvm.insertvalue %2, %15[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %17 = llvm.insertvalue %2, %16[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %18 = llvm.insertvalue %4, %17[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %19 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %20 = llvm.extractvalue %19[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %21 = llvm.getelementptr %20[%3] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
          %22 = llvm.load %21 : !llvm.ptr<ptr<i8>>
          %23 = llvm.getelementptr %22[%3] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
          %24 = llvm.bitcast %23 : !llvm.ptr<i8> to !llvm.ptr<f32>
          %25 = llvm.insertvalue %24, %11[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %26 = llvm.insertvalue %24, %25[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %27 = llvm.insertvalue %3, %26[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %28 = llvm.insertvalue %4, %27[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %29 = llvm.insertvalue %2, %28[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %30 = llvm.insertvalue %2, %29[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %31 = llvm.insertvalue %4, %30[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %32 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %33 = llvm.extractvalue %32[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %34 = llvm.mlir.constant(2 : index) : i64
          %35 = llvm.getelementptr %33[%34] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
          %36 = llvm.load %35 : !llvm.ptr<ptr<i8>>
          %37 = llvm.getelementptr %36[%3] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
          %38 = llvm.bitcast %37 : !llvm.ptr<i8> to !llvm.ptr<f32>
          %39 = llvm.insertvalue %38, %11[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %40 = llvm.insertvalue %38, %39[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %41 = llvm.insertvalue %3, %40[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %42 = llvm.insertvalue %4, %41[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %43 = llvm.insertvalue %2, %42[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %44 = llvm.insertvalue %2, %43[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %45 = llvm.insertvalue %4, %44[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %46 = llvm.load %arg1 : !llvm.ptr<array<3 x i32>>
          %47 = llvm.extractvalue %46[0] : !llvm.array<3 x i32>
          %48 = llvm.zext %47 : i32 to i64
          %49 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %50 = llvm.extractvalue %49[0] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %51 = llvm.extractvalue %50[0] : !llvm.array<3 x i32>
          %52 = llvm.zext %51 : i32 to i64
          %53 = llvm.load %arg1 : !llvm.ptr<array<3 x i32>>
          %54 = llvm.extractvalue %53[1] : !llvm.array<3 x i32>
          %55 = llvm.zext %54 : i32 to i64
          %56 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %57 = llvm.extractvalue %56[0] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %58 = llvm.extractvalue %57[1] : !llvm.array<3 x i32>
          %59 = llvm.zext %58 : i32 to i64
          %60 = llvm.mul %55, %2  : i64
          %61 = llvm.mul %59, %2  : i64
          llvm.br ^bb1(%60 : i64)
        ^bb1(%62: i64):  // 2 preds: ^bb0, ^bb10
          %63 = llvm.icmp "slt" %62, %4 : i64
          llvm.cond_br %63, ^bb2, ^bb11
        ^bb2:  // pred: ^bb1
          %64 = llvm.mul %48, %2  : i64
          %65 = llvm.mul %52, %2  : i64
          llvm.br ^bb3(%64 : i64)
        ^bb3(%66: i64):  // 2 preds: ^bb2, ^bb9
          %67 = llvm.icmp "slt" %66, %2 : i64
          llvm.cond_br %67, ^bb4, ^bb10
        ^bb4:  // pred: ^bb3
          %68 = llvm.mlir.constant(-1 : index) : i64
          %69 = llvm.mul %62, %68  : i64
          %70 = llvm.add %69, %4  : i64
          %71 = llvm.icmp "slt" %2, %70 : i64
          %72 = llvm.select %71, %2, %70 : i1, i64
          %73 = llvm.extractvalue %18[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %74 = llvm.bitcast %73 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %75 = llvm.insertvalue %74, %11[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %76 = llvm.extractvalue %18[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %77 = llvm.bitcast %76 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %78 = llvm.insertvalue %77, %75[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %79 = llvm.extractvalue %18[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %80 = llvm.extractvalue %18[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %81 = llvm.extractvalue %18[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %82 = llvm.mul %62, %79  : i64
          %83 = llvm.add %81, %82  : i64
          %84 = llvm.mul %66, %80  : i64
          %85 = llvm.add %83, %84  : i64
          %86 = llvm.insertvalue %85, %78[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %87 = llvm.mlir.constant(128 : i64) : i64
          %88 = llvm.mlir.constant(1 : i64) : i64
          %89 = llvm.insertvalue %87, %86[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %90 = llvm.insertvalue %88, %89[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %91 = llvm.insertvalue %72, %90[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %92 = llvm.insertvalue %87, %91[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %93 = llvm.extractvalue %31[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %94 = llvm.bitcast %93 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %95 = llvm.insertvalue %94, %11[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %96 = llvm.extractvalue %31[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %97 = llvm.bitcast %96 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %98 = llvm.insertvalue %97, %95[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %99 = llvm.extractvalue %31[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %100 = llvm.extractvalue %31[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %101 = llvm.extractvalue %31[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %102 = llvm.mul %62, %99  : i64
          %103 = llvm.add %101, %102  : i64
          %104 = llvm.mul %66, %100  : i64
          %105 = llvm.add %103, %104  : i64
          %106 = llvm.insertvalue %105, %98[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %107 = llvm.insertvalue %87, %106[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %108 = llvm.insertvalue %88, %107[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %109 = llvm.insertvalue %72, %108[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %110 = llvm.insertvalue %87, %109[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %111 = llvm.extractvalue %45[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %112 = llvm.bitcast %111 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %113 = llvm.insertvalue %112, %11[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %114 = llvm.extractvalue %45[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %115 = llvm.bitcast %114 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %116 = llvm.insertvalue %115, %113[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %117 = llvm.extractvalue %45[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %118 = llvm.extractvalue %45[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %119 = llvm.extractvalue %45[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %120 = llvm.mul %62, %117  : i64
          %121 = llvm.add %119, %120  : i64
          %122 = llvm.mul %66, %118  : i64
          %123 = llvm.add %121, %122  : i64
          %124 = llvm.insertvalue %123, %116[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %125 = llvm.insertvalue %87, %124[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %126 = llvm.insertvalue %88, %125[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %127 = llvm.insertvalue %72, %126[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %128 = llvm.insertvalue %87, %127[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          llvm.br ^bb5(%3 : i64)
        ^bb5(%129: i64):  // 2 preds: ^bb4, ^bb8
          %130 = llvm.icmp "slt" %129, %72 : i64
          llvm.cond_br %130, ^bb6(%3 : i64), ^bb9
        ^bb6(%131: i64):  // 2 preds: ^bb5, ^bb7
          %132 = llvm.icmp "slt" %131, %2 : i64
          llvm.cond_br %132, ^bb7, ^bb8
        ^bb7:  // pred: ^bb6
          %133 = llvm.extractvalue %92[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %134 = llvm.extractvalue %92[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %135 = llvm.mul %129, %2  : i64
          %136 = llvm.add %134, %135  : i64
          %137 = llvm.add %136, %131  : i64
          %138 = llvm.getelementptr %133[%137] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
          %139 = llvm.load %138 : !llvm.ptr<f32>
          %140 = llvm.extractvalue %110[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %141 = llvm.extractvalue %110[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %142 = llvm.add %141, %135  : i64
          %143 = llvm.add %142, %131  : i64
          %144 = llvm.getelementptr %140[%143] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
          %145 = llvm.load %144 : !llvm.ptr<f32>
          %146 = llvm.fadd %139, %145  : f32
          %147 = llvm.fcmp "ogt" %146, %1 : f32
          %148 = llvm.select %147, %146, %1 : i1, f32
          %149 = llvm.fcmp "uno" %146, %1 : f32
          %150 = llvm.select %149, %0, %148 : i1, f32
          %151 = llvm.extractvalue %128[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %152 = llvm.extractvalue %128[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %153 = llvm.add %152, %135  : i64
          %154 = llvm.add %153, %131  : i64
          %155 = llvm.getelementptr %151[%154] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
          llvm.store %150, %155 : !llvm.ptr<f32>
          %156 = llvm.add %131, %4  : i64
          llvm.br ^bb6(%156 : i64)
        ^bb8:  // pred: ^bb6
          %157 = llvm.add %129, %4  : i64
          llvm.br ^bb5(%157 : i64)
        ^bb9:  // pred: ^bb5
          %158 = llvm.add %66, %65  : i64
          llvm.br ^bb3(%158 : i64)
        ^bb10:  // pred: ^bb3
          %159 = llvm.add %62, %61  : i64
          llvm.br ^bb1(%159 : i64)
        ^bb11:  // pred: ^bb1
          %160 = llvm.mlir.constant(0 : i32) : i32
          llvm.return %160 : i32
        }
        llvm.func internal @predict_dispatch_2(%arg0: !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>, %arg1: !llvm.ptr<array<3 x i32>>) -> i32 {
          %0 = llvm.mlir.constant(0.000000e+00 : f32) : f32
          %1 = llvm.mlir.constant(10 : index) : i64
          %2 = llvm.mlir.constant(128 : index) : i64
          %3 = llvm.mlir.constant(32 : index) : i64
          %4 = llvm.mlir.constant(4 : index) : i64
          %5 = llvm.mlir.constant(0 : index) : i64
          %6 = llvm.mlir.constant(1 : index) : i64
          %7 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %8 = llvm.extractvalue %7[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %9 = llvm.getelementptr %8[%6] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
          %10 = llvm.load %9 : !llvm.ptr<ptr<i8>>
          %11 = llvm.getelementptr %10[%5] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
          %12 = llvm.bitcast %11 : !llvm.ptr<i8> to !llvm.ptr<f32>
          %13 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %14 = llvm.insertvalue %12, %13[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %15 = llvm.insertvalue %12, %14[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %16 = llvm.insertvalue %5, %15[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %17 = llvm.insertvalue %6, %16[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %18 = llvm.insertvalue %2, %17[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %19 = llvm.insertvalue %2, %18[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %20 = llvm.insertvalue %6, %19[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %21 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %22 = llvm.extractvalue %21[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %23 = llvm.getelementptr %22[%5] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
          %24 = llvm.load %23 : !llvm.ptr<ptr<i8>>
          %25 = llvm.getelementptr %24[%5] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
          %26 = llvm.bitcast %25 : !llvm.ptr<i8> to !llvm.ptr<f32>
          %27 = llvm.insertvalue %26, %13[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %28 = llvm.insertvalue %26, %27[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %29 = llvm.insertvalue %5, %28[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %30 = llvm.insertvalue %2, %29[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %31 = llvm.insertvalue %1, %30[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %32 = llvm.insertvalue %1, %31[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %33 = llvm.insertvalue %6, %32[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %34 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %35 = llvm.extractvalue %34[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %36 = llvm.mlir.constant(2 : index) : i64
          %37 = llvm.getelementptr %35[%36] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
          %38 = llvm.load %37 : !llvm.ptr<ptr<i8>>
          %39 = llvm.getelementptr %38[%5] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
          %40 = llvm.bitcast %39 : !llvm.ptr<i8> to !llvm.ptr<f32>
          %41 = llvm.insertvalue %40, %13[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %42 = llvm.insertvalue %40, %41[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %43 = llvm.insertvalue %5, %42[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %44 = llvm.insertvalue %6, %43[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %45 = llvm.insertvalue %1, %44[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %46 = llvm.insertvalue %1, %45[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %47 = llvm.insertvalue %6, %46[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %48 = llvm.load %arg1 : !llvm.ptr<array<3 x i32>>
          %49 = llvm.extractvalue %48[0] : !llvm.array<3 x i32>
          %50 = llvm.zext %49 : i32 to i64
          %51 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %52 = llvm.extractvalue %51[0] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %53 = llvm.extractvalue %52[0] : !llvm.array<3 x i32>
          %54 = llvm.zext %53 : i32 to i64
          %55 = llvm.load %arg1 : !llvm.ptr<array<3 x i32>>
          %56 = llvm.extractvalue %55[1] : !llvm.array<3 x i32>
          %57 = llvm.zext %56 : i32 to i64
          %58 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %59 = llvm.extractvalue %58[0] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %60 = llvm.extractvalue %59[1] : !llvm.array<3 x i32>
          %61 = llvm.zext %60 : i32 to i64
          %62 = llvm.mul %57, %4  : i64
          %63 = llvm.mul %61, %4  : i64
          llvm.br ^bb1(%62 : i64)
        ^bb1(%64: i64):  // 2 preds: ^bb0, ^bb30
          %65 = llvm.icmp "slt" %64, %6 : i64
          llvm.cond_br %65, ^bb2, ^bb31
        ^bb2:  // pred: ^bb1
          %66 = llvm.mlir.constant(64 : index) : i64
          %67 = llvm.mul %50, %66  : i64
          %68 = llvm.mul %54, %66  : i64
          llvm.br ^bb3(%67 : i64)
        ^bb3(%69: i64):  // 2 preds: ^bb2, ^bb29
          %70 = llvm.icmp "slt" %69, %1 : i64
          llvm.cond_br %70, ^bb4, ^bb30
        ^bb4:  // pred: ^bb3
          %71 = llvm.mlir.constant(-1 : index) : i64
          %72 = llvm.mul %64, %71  : i64
          %73 = llvm.add %72, %6  : i64
          %74 = llvm.icmp "slt" %4, %73 : i64
          %75 = llvm.select %74, %4, %73 : i1, i64
          %76 = llvm.extractvalue %20[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %77 = llvm.bitcast %76 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %78 = llvm.insertvalue %77, %13[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %79 = llvm.extractvalue %20[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %80 = llvm.bitcast %79 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %81 = llvm.insertvalue %80, %78[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %82 = llvm.extractvalue %20[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %83 = llvm.extractvalue %20[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %84 = llvm.extractvalue %20[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %85 = llvm.mul %64, %82  : i64
          %86 = llvm.add %84, %85  : i64
          %87 = llvm.mlir.constant(0 : i64) : i64
          %88 = llvm.mul %87, %83  : i64
          %89 = llvm.add %86, %88  : i64
          %90 = llvm.insertvalue %89, %81[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %91 = llvm.mlir.constant(128 : i64) : i64
          %92 = llvm.mlir.constant(1 : i64) : i64
          %93 = llvm.insertvalue %91, %90[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %94 = llvm.insertvalue %92, %93[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %95 = llvm.insertvalue %75, %94[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %96 = llvm.insertvalue %91, %95[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %97 = llvm.mul %69, %71  : i64
          %98 = llvm.add %97, %1  : i64
          %99 = llvm.icmp "slt" %66, %98 : i64
          %100 = llvm.select %99, %66, %98 : i1, i64
          %101 = llvm.extractvalue %33[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %102 = llvm.bitcast %101 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %103 = llvm.insertvalue %102, %13[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %104 = llvm.extractvalue %33[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %105 = llvm.bitcast %104 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %106 = llvm.insertvalue %105, %103[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %107 = llvm.extractvalue %33[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %108 = llvm.extractvalue %33[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %109 = llvm.extractvalue %33[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %110 = llvm.mul %87, %107  : i64
          %111 = llvm.add %109, %110  : i64
          %112 = llvm.mul %69, %108  : i64
          %113 = llvm.add %111, %112  : i64
          %114 = llvm.insertvalue %113, %106[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %115 = llvm.insertvalue %100, %114[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %116 = llvm.insertvalue %92, %115[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %117 = llvm.mlir.constant(10 : i64) : i64
          %118 = llvm.insertvalue %91, %116[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %119 = llvm.insertvalue %117, %118[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %120 = llvm.extractvalue %47[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %121 = llvm.bitcast %120 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %122 = llvm.insertvalue %121, %13[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %123 = llvm.extractvalue %47[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %124 = llvm.bitcast %123 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %125 = llvm.insertvalue %124, %122[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %126 = llvm.extractvalue %47[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %127 = llvm.extractvalue %47[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %128 = llvm.extractvalue %47[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %129 = llvm.mul %64, %126  : i64
          %130 = llvm.add %128, %129  : i64
          %131 = llvm.mul %69, %127  : i64
          %132 = llvm.add %130, %131  : i64
          %133 = llvm.insertvalue %132, %125[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %134 = llvm.insertvalue %100, %133[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %135 = llvm.insertvalue %92, %134[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %136 = llvm.insertvalue %75, %135[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %137 = llvm.insertvalue %117, %136[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          llvm.br ^bb5(%5 : i64)
        ^bb5(%138: i64):  // 2 preds: ^bb4, ^bb8
          %139 = llvm.icmp "slt" %138, %75 : i64
          llvm.cond_br %139, ^bb6(%5 : i64), ^bb9(%5 : i64)
        ^bb6(%140: i64):  // 2 preds: ^bb5, ^bb7
          %141 = llvm.icmp "slt" %140, %100 : i64
          llvm.cond_br %141, ^bb7, ^bb8
        ^bb7:  // pred: ^bb6
          %142 = llvm.extractvalue %137[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %143 = llvm.extractvalue %137[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %144 = llvm.mul %138, %1  : i64
          %145 = llvm.add %143, %144  : i64
          %146 = llvm.add %145, %140  : i64
          %147 = llvm.getelementptr %142[%146] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
          llvm.store %0, %147 : !llvm.ptr<f32>
          %148 = llvm.add %140, %6  : i64
          llvm.br ^bb6(%148 : i64)
        ^bb8:  // pred: ^bb6
          %149 = llvm.add %138, %6  : i64
          llvm.br ^bb5(%149 : i64)
        ^bb9(%150: i64):  // 2 preds: ^bb5, ^bb28
          %151 = llvm.icmp "slt" %150, %75 : i64
          llvm.cond_br %151, ^bb10(%5 : i64), ^bb29
        ^bb10(%152: i64):  // 2 preds: ^bb9, ^bb27
          %153 = llvm.icmp "slt" %152, %100 : i64
          llvm.cond_br %153, ^bb11(%5 : i64), ^bb28
        ^bb11(%154: i64):  // 2 preds: ^bb10, ^bb26
          %155 = llvm.icmp "slt" %154, %2 : i64
          llvm.cond_br %155, ^bb12, ^bb27
        ^bb12:  // pred: ^bb11
          %156 = llvm.mul %150, %71  : i64
          %157 = llvm.add %75, %156  : i64
          %158 = llvm.icmp "slt" %4, %157 : i64
          %159 = llvm.select %158, %4, %157 : i1, i64
          %160 = llvm.extractvalue %96[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %161 = llvm.bitcast %160 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %162 = llvm.insertvalue %161, %13[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %163 = llvm.extractvalue %96[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %164 = llvm.bitcast %163 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %165 = llvm.insertvalue %164, %162[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %166 = llvm.extractvalue %96[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %167 = llvm.extractvalue %96[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %168 = llvm.extractvalue %96[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %169 = llvm.mul %150, %166  : i64
          %170 = llvm.add %168, %169  : i64
          %171 = llvm.mul %154, %167  : i64
          %172 = llvm.add %170, %171  : i64
          %173 = llvm.insertvalue %172, %165[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %174 = llvm.mlir.constant(32 : i64) : i64
          %175 = llvm.insertvalue %174, %173[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %176 = llvm.insertvalue %92, %175[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %177 = llvm.insertvalue %159, %176[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %178 = llvm.insertvalue %91, %177[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %179 = llvm.mul %152, %71  : i64
          %180 = llvm.add %100, %179  : i64
          %181 = llvm.icmp "slt" %3, %180 : i64
          %182 = llvm.select %181, %3, %180 : i1, i64
          %183 = llvm.extractvalue %119[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %184 = llvm.bitcast %183 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %185 = llvm.insertvalue %184, %13[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %186 = llvm.extractvalue %119[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %187 = llvm.bitcast %186 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %188 = llvm.insertvalue %187, %185[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %189 = llvm.extractvalue %119[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %190 = llvm.extractvalue %119[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %191 = llvm.extractvalue %119[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %192 = llvm.mul %154, %189  : i64
          %193 = llvm.add %191, %192  : i64
          %194 = llvm.mul %152, %190  : i64
          %195 = llvm.add %193, %194  : i64
          %196 = llvm.insertvalue %195, %188[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %197 = llvm.insertvalue %182, %196[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %198 = llvm.insertvalue %92, %197[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %199 = llvm.insertvalue %174, %198[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %200 = llvm.insertvalue %117, %199[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %201 = llvm.extractvalue %137[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %202 = llvm.bitcast %201 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %203 = llvm.insertvalue %202, %13[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %204 = llvm.extractvalue %137[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %205 = llvm.bitcast %204 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %206 = llvm.insertvalue %205, %203[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %207 = llvm.extractvalue %137[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %208 = llvm.extractvalue %137[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %209 = llvm.extractvalue %137[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %210 = llvm.mul %150, %207  : i64
          %211 = llvm.add %209, %210  : i64
          %212 = llvm.mul %152, %208  : i64
          %213 = llvm.add %211, %212  : i64
          %214 = llvm.insertvalue %213, %206[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %215 = llvm.insertvalue %182, %214[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %216 = llvm.insertvalue %92, %215[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %217 = llvm.insertvalue %159, %216[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %218 = llvm.insertvalue %117, %217[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          llvm.br ^bb13(%5 : i64)
        ^bb13(%219: i64):  // 2 preds: ^bb12, ^bb25
          %220 = llvm.icmp "slt" %219, %159 : i64
          llvm.cond_br %220, ^bb14(%5 : i64), ^bb26
        ^bb14(%221: i64):  // 2 preds: ^bb13, ^bb24
          %222 = llvm.icmp "slt" %221, %182 : i64
          llvm.cond_br %222, ^bb15(%5 : i64), ^bb25
        ^bb15(%223: i64):  // 2 preds: ^bb14, ^bb23
          %224 = llvm.icmp "slt" %223, %3 : i64
          llvm.cond_br %224, ^bb16, ^bb24
        ^bb16:  // pred: ^bb15
          %225 = llvm.mul %219, %71  : i64
          %226 = llvm.add %159, %225  : i64
          %227 = llvm.icmp "slt" %4, %226 : i64
          %228 = llvm.select %227, %4, %226 : i1, i64
          %229 = llvm.extractvalue %178[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %230 = llvm.bitcast %229 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %231 = llvm.insertvalue %230, %13[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %232 = llvm.extractvalue %178[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %233 = llvm.bitcast %232 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %234 = llvm.insertvalue %233, %231[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %235 = llvm.extractvalue %178[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %236 = llvm.extractvalue %178[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %237 = llvm.extractvalue %178[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %238 = llvm.mul %219, %235  : i64
          %239 = llvm.add %237, %238  : i64
          %240 = llvm.mul %223, %236  : i64
          %241 = llvm.add %239, %240  : i64
          %242 = llvm.insertvalue %241, %234[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %243 = llvm.mlir.constant(4 : i64) : i64
          %244 = llvm.insertvalue %243, %242[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %245 = llvm.insertvalue %92, %244[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %246 = llvm.insertvalue %228, %245[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %247 = llvm.insertvalue %91, %246[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %248 = llvm.mul %221, %71  : i64
          %249 = llvm.add %182, %248  : i64
          %250 = llvm.icmp "slt" %4, %249 : i64
          %251 = llvm.select %250, %4, %249 : i1, i64
          %252 = llvm.extractvalue %200[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %253 = llvm.bitcast %252 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %254 = llvm.insertvalue %253, %13[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %255 = llvm.extractvalue %200[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %256 = llvm.bitcast %255 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %257 = llvm.insertvalue %256, %254[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %258 = llvm.extractvalue %200[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %259 = llvm.extractvalue %200[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %260 = llvm.extractvalue %200[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %261 = llvm.mul %223, %258  : i64
          %262 = llvm.add %260, %261  : i64
          %263 = llvm.mul %221, %259  : i64
          %264 = llvm.add %262, %263  : i64
          %265 = llvm.insertvalue %264, %257[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %266 = llvm.insertvalue %251, %265[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %267 = llvm.insertvalue %92, %266[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %268 = llvm.insertvalue %243, %267[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %269 = llvm.insertvalue %117, %268[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %270 = llvm.extractvalue %218[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %271 = llvm.bitcast %270 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %272 = llvm.insertvalue %271, %13[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %273 = llvm.extractvalue %218[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %274 = llvm.bitcast %273 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %275 = llvm.insertvalue %274, %272[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %276 = llvm.extractvalue %218[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %277 = llvm.extractvalue %218[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %278 = llvm.extractvalue %218[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %279 = llvm.mul %219, %276  : i64
          %280 = llvm.add %278, %279  : i64
          %281 = llvm.mul %221, %277  : i64
          %282 = llvm.add %280, %281  : i64
          %283 = llvm.insertvalue %282, %275[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %284 = llvm.insertvalue %251, %283[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %285 = llvm.insertvalue %92, %284[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %286 = llvm.insertvalue %228, %285[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %287 = llvm.insertvalue %117, %286[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          llvm.br ^bb17(%5 : i64)
        ^bb17(%288: i64):  // 2 preds: ^bb16, ^bb22
          %289 = llvm.icmp "slt" %288, %228 : i64
          llvm.cond_br %289, ^bb18(%5 : i64), ^bb23
        ^bb18(%290: i64):  // 2 preds: ^bb17, ^bb21
          %291 = llvm.icmp "slt" %290, %251 : i64
          llvm.cond_br %291, ^bb19(%5 : i64), ^bb22
        ^bb19(%292: i64):  // 2 preds: ^bb18, ^bb20
          %293 = llvm.icmp "slt" %292, %4 : i64
          llvm.cond_br %293, ^bb20, ^bb21
        ^bb20:  // pred: ^bb19
          %294 = llvm.extractvalue %247[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %295 = llvm.extractvalue %247[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %296 = llvm.mul %288, %2  : i64
          %297 = llvm.add %295, %296  : i64
          %298 = llvm.add %297, %292  : i64
          %299 = llvm.getelementptr %294[%298] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
          %300 = llvm.load %299 : !llvm.ptr<f32>
          %301 = llvm.extractvalue %269[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %302 = llvm.extractvalue %269[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %303 = llvm.mul %292, %1  : i64
          %304 = llvm.add %302, %303  : i64
          %305 = llvm.add %304, %290  : i64
          %306 = llvm.getelementptr %301[%305] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
          %307 = llvm.load %306 : !llvm.ptr<f32>
          %308 = llvm.extractvalue %287[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %309 = llvm.extractvalue %287[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %310 = llvm.mul %288, %1  : i64
          %311 = llvm.add %309, %310  : i64
          %312 = llvm.add %311, %290  : i64
          %313 = llvm.getelementptr %308[%312] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
          %314 = llvm.load %313 : !llvm.ptr<f32>
          %315 = llvm.fmul %300, %307  : f32
          %316 = llvm.fadd %314, %315  : f32
          llvm.store %316, %313 : !llvm.ptr<f32>
          %317 = llvm.add %292, %6  : i64
          llvm.br ^bb19(%317 : i64)
        ^bb21:  // pred: ^bb19
          %318 = llvm.add %290, %6  : i64
          llvm.br ^bb18(%318 : i64)
        ^bb22:  // pred: ^bb18
          %319 = llvm.add %288, %6  : i64
          llvm.br ^bb17(%319 : i64)
        ^bb23:  // pred: ^bb17
          %320 = llvm.add %223, %4  : i64
          llvm.br ^bb15(%320 : i64)
        ^bb24:  // pred: ^bb15
          %321 = llvm.add %221, %4  : i64
          llvm.br ^bb14(%321 : i64)
        ^bb25:  // pred: ^bb14
          %322 = llvm.add %219, %4  : i64
          llvm.br ^bb13(%322 : i64)
        ^bb26:  // pred: ^bb13
          %323 = llvm.add %154, %3  : i64
          llvm.br ^bb11(%323 : i64)
        ^bb27:  // pred: ^bb11
          %324 = llvm.add %152, %3  : i64
          llvm.br ^bb10(%324 : i64)
        ^bb28:  // pred: ^bb10
          %325 = llvm.add %150, %4  : i64
          llvm.br ^bb9(%325 : i64)
        ^bb29:  // pred: ^bb9
          %326 = llvm.add %69, %68  : i64
          llvm.br ^bb3(%326 : i64)
        ^bb30:  // pred: ^bb3
          %327 = llvm.add %64, %63  : i64
          llvm.br ^bb1(%327 : i64)
        ^bb31:  // pred: ^bb1
          %328 = llvm.mlir.constant(0 : i32) : i32
          llvm.return %328 : i32
        }
        llvm.mlir.global private constant @__constant_1x10xf32_3(opaque<"_", "0xDEADBEEF"> : tensor<1x10xf32>) : !llvm.array<1 x array<10 x f32>>
        llvm.func internal @predict_dispatch_3(%arg0: !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>, %arg1: !llvm.ptr<array<3 x i32>>) -> i32 {
          %0 = llvm.mlir.constant(10 : index) : i64
          %1 = llvm.mlir.constant(0 : index) : i64
          %2 = llvm.mlir.constant(1 : index) : i64
          %3 = llvm.mlir.addressof @__constant_1x10xf32_3 : !llvm.ptr<array<1 x array<10 x f32>>>
          %4 = llvm.getelementptr %3[%1, %1, %1] : (!llvm.ptr<array<1 x array<10 x f32>>>, i64, i64, i64) -> !llvm.ptr<f32>
          %5 = llvm.mlir.constant(3735928559 : index) : i64
          %6 = llvm.inttoptr %5 : i64 to !llvm.ptr<f32>
          %7 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %8 = llvm.insertvalue %6, %7[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %9 = llvm.insertvalue %4, %8[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %10 = llvm.insertvalue %1, %9[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %11 = llvm.insertvalue %2, %10[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %12 = llvm.insertvalue %0, %11[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %13 = llvm.insertvalue %0, %12[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %14 = llvm.insertvalue %2, %13[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %15 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %16 = llvm.extractvalue %15[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %17 = llvm.getelementptr %16[%1] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
          %18 = llvm.load %17 : !llvm.ptr<ptr<i8>>
          %19 = llvm.getelementptr %18[%1] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
          %20 = llvm.bitcast %19 : !llvm.ptr<i8> to !llvm.ptr<f32>
          %21 = llvm.insertvalue %20, %7[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %22 = llvm.insertvalue %20, %21[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %23 = llvm.insertvalue %1, %22[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %24 = llvm.insertvalue %2, %23[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %25 = llvm.insertvalue %0, %24[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %26 = llvm.insertvalue %0, %25[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %27 = llvm.insertvalue %2, %26[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %28 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %29 = llvm.extractvalue %28[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %30 = llvm.getelementptr %29[%2] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
          %31 = llvm.load %30 : !llvm.ptr<ptr<i8>>
          %32 = llvm.getelementptr %31[%1] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
          %33 = llvm.bitcast %32 : !llvm.ptr<i8> to !llvm.ptr<f32>
          %34 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %35 = llvm.insertvalue %33, %34[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %36 = llvm.insertvalue %33, %35[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %37 = llvm.insertvalue %1, %36[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %38 = llvm.insertvalue %0, %37[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %39 = llvm.insertvalue %2, %38[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %40 = llvm.load %arg1 : !llvm.ptr<array<3 x i32>>
          %41 = llvm.extractvalue %40[0] : !llvm.array<3 x i32>
          %42 = llvm.zext %41 : i32 to i64
          %43 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %44 = llvm.extractvalue %43[0] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %45 = llvm.extractvalue %44[0] : !llvm.array<3 x i32>
          %46 = llvm.zext %45 : i32 to i64
          %47 = llvm.load %arg1 : !llvm.ptr<array<3 x i32>>
          %48 = llvm.extractvalue %47[1] : !llvm.array<3 x i32>
          %49 = llvm.zext %48 : i32 to i64
          %50 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %51 = llvm.extractvalue %50[0] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %52 = llvm.extractvalue %51[1] : !llvm.array<3 x i32>
          %53 = llvm.zext %52 : i32 to i64
          %54 = llvm.mlir.constant(128 : index) : i64
          %55 = llvm.mul %49, %54  : i64
          %56 = llvm.mul %53, %54  : i64
          llvm.br ^bb1(%55 : i64)
        ^bb1(%57: i64):  // 2 preds: ^bb0, ^bb10
          %58 = llvm.icmp "slt" %57, %2 : i64
          llvm.cond_br %58, ^bb2, ^bb11
        ^bb2:  // pred: ^bb1
          %59 = llvm.mul %42, %54  : i64
          %60 = llvm.mul %46, %54  : i64
          llvm.br ^bb3(%59 : i64)
        ^bb3(%61: i64):  // 2 preds: ^bb2, ^bb9
          %62 = llvm.icmp "slt" %61, %0 : i64
          llvm.cond_br %62, ^bb4, ^bb10
        ^bb4:  // pred: ^bb3
          %63 = llvm.mlir.constant(-1 : index) : i64
          %64 = llvm.mul %57, %63  : i64
          %65 = llvm.add %64, %2  : i64
          %66 = llvm.icmp "slt" %54, %65 : i64
          %67 = llvm.select %66, %54, %65 : i1, i64
          %68 = llvm.mul %61, %63  : i64
          %69 = llvm.add %68, %0  : i64
          %70 = llvm.icmp "slt" %54, %69 : i64
          %71 = llvm.select %70, %54, %69 : i1, i64
          %72 = llvm.extractvalue %27[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %73 = llvm.bitcast %72 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %74 = llvm.insertvalue %73, %7[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %75 = llvm.extractvalue %27[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %76 = llvm.bitcast %75 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %77 = llvm.insertvalue %76, %74[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %78 = llvm.extractvalue %27[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %79 = llvm.extractvalue %27[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %80 = llvm.extractvalue %27[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %81 = llvm.mul %57, %78  : i64
          %82 = llvm.add %80, %81  : i64
          %83 = llvm.mul %61, %79  : i64
          %84 = llvm.add %82, %83  : i64
          %85 = llvm.insertvalue %84, %77[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %86 = llvm.mlir.constant(1 : i64) : i64
          %87 = llvm.insertvalue %71, %85[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %88 = llvm.insertvalue %86, %87[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %89 = llvm.mlir.constant(10 : i64) : i64
          %90 = llvm.insertvalue %67, %88[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %91 = llvm.insertvalue %89, %90[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %92 = llvm.extractvalue %14[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %93 = llvm.bitcast %92 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %94 = llvm.insertvalue %93, %7[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %95 = llvm.extractvalue %14[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %96 = llvm.bitcast %95 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %97 = llvm.insertvalue %96, %94[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %98 = llvm.extractvalue %14[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %99 = llvm.extractvalue %14[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %100 = llvm.extractvalue %14[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %101 = llvm.mul %57, %98  : i64
          %102 = llvm.add %100, %101  : i64
          %103 = llvm.mul %61, %99  : i64
          %104 = llvm.add %102, %103  : i64
          %105 = llvm.insertvalue %104, %97[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %106 = llvm.insertvalue %71, %105[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %107 = llvm.insertvalue %86, %106[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %108 = llvm.insertvalue %67, %107[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %109 = llvm.insertvalue %89, %108[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %110 = llvm.extractvalue %39[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %111 = llvm.bitcast %110 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %112 = llvm.insertvalue %111, %34[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %113 = llvm.extractvalue %39[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %114 = llvm.bitcast %113 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %115 = llvm.insertvalue %114, %112[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %116 = llvm.extractvalue %39[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %117 = llvm.extractvalue %39[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %118 = llvm.mul %61, %116  : i64
          %119 = llvm.add %117, %118  : i64
          %120 = llvm.insertvalue %119, %115[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %121 = llvm.insertvalue %71, %120[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %122 = llvm.insertvalue %86, %121[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          llvm.br ^bb5(%1 : i64)
        ^bb5(%123: i64):  // 2 preds: ^bb4, ^bb8
          %124 = llvm.icmp "slt" %123, %67 : i64
          llvm.cond_br %124, ^bb6(%1 : i64), ^bb9
        ^bb6(%125: i64):  // 2 preds: ^bb5, ^bb7
          %126 = llvm.icmp "slt" %125, %71 : i64
          llvm.cond_br %126, ^bb7, ^bb8
        ^bb7:  // pred: ^bb6
          %127 = llvm.extractvalue %91[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %128 = llvm.extractvalue %91[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %129 = llvm.mul %123, %0  : i64
          %130 = llvm.add %128, %129  : i64
          %131 = llvm.add %130, %125  : i64
          %132 = llvm.getelementptr %127[%131] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
          %133 = llvm.load %132 : !llvm.ptr<f32>
          %134 = llvm.extractvalue %109[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %135 = llvm.extractvalue %109[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %136 = llvm.add %135, %129  : i64
          %137 = llvm.add %136, %125  : i64
          %138 = llvm.getelementptr %134[%137] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
          %139 = llvm.load %138 : !llvm.ptr<f32>
          %140 = llvm.fadd %133, %139  : f32
          %141 = llvm.extractvalue %122[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %142 = llvm.extractvalue %122[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %143 = llvm.add %142, %125  : i64
          %144 = llvm.getelementptr %141[%143] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
          llvm.store %140, %144 : !llvm.ptr<f32>
          %145 = llvm.add %125, %2  : i64
          llvm.br ^bb6(%145 : i64)
        ^bb8:  // pred: ^bb6
          %146 = llvm.add %123, %2  : i64
          llvm.br ^bb5(%146 : i64)
        ^bb9:  // pred: ^bb5
          %147 = llvm.add %61, %60  : i64
          llvm.br ^bb3(%147 : i64)
        ^bb10:  // pred: ^bb3
          %148 = llvm.add %57, %56  : i64
          llvm.br ^bb1(%148 : i64)
        ^bb11:  // pred: ^bb1
          %149 = llvm.mlir.constant(0 : i32) : i32
          llvm.return %149 : i32
        }
        llvm.func internal @predict_dispatch_4(%arg0: !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>, %arg1: !llvm.ptr<array<3 x i32>>) -> i32 {
          %0 = llvm.mlir.constant(0x7FC00000 : f32) : f32
          %1 = llvm.mlir.constant(0xFF800000 : f32) : f32
          %2 = llvm.mlir.constant(10 : index) : i64
          %3 = llvm.mlir.constant(0 : index) : i64
          %4 = llvm.mlir.constant(1 : index) : i64
          %5 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %6 = llvm.extractvalue %5[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %7 = llvm.getelementptr %6[%3] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
          %8 = llvm.load %7 : !llvm.ptr<ptr<i8>>
          %9 = llvm.getelementptr %8[%3] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
          %10 = llvm.bitcast %9 : !llvm.ptr<i8> to !llvm.ptr<f32>
          %11 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %12 = llvm.insertvalue %10, %11[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %13 = llvm.insertvalue %10, %12[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %14 = llvm.insertvalue %3, %13[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %15 = llvm.insertvalue %2, %14[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %16 = llvm.insertvalue %4, %15[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %17 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %18 = llvm.extractvalue %17[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %19 = llvm.getelementptr %18[%4] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
          %20 = llvm.load %19 : !llvm.ptr<ptr<i8>>
          %21 = llvm.getelementptr %20[%3] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
          %22 = llvm.bitcast %21 : !llvm.ptr<i8> to !llvm.ptr<f32>
          %23 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
          %24 = llvm.insertvalue %22, %23[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
          %25 = llvm.insertvalue %22, %24[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
          %26 = llvm.insertvalue %3, %25[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
          %27 = llvm.extractvalue %26[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
          llvm.store %1, %27 : !llvm.ptr<f32>
          llvm.br ^bb1(%3 : i64)
        ^bb1(%28: i64):  // 2 preds: ^bb0, ^bb2
          %29 = llvm.icmp "slt" %28, %2 : i64
          llvm.cond_br %29, ^bb2, ^bb3
        ^bb2:  // pred: ^bb1
          %30 = llvm.extractvalue %16[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %31 = llvm.getelementptr %30[%28] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
          %32 = llvm.load %31 : !llvm.ptr<f32>
          %33 = llvm.load %27 : !llvm.ptr<f32>
          %34 = llvm.fcmp "ogt" %32, %33 : f32
          %35 = llvm.select %34, %32, %33 : i1, f32
          %36 = llvm.fcmp "uno" %32, %33 : f32
          %37 = llvm.select %36, %0, %35 : i1, f32
          llvm.store %37, %27 : !llvm.ptr<f32>
          %38 = llvm.add %28, %4  : i64
          llvm.br ^bb1(%38 : i64)
        ^bb3:  // pred: ^bb1
          %39 = llvm.mlir.constant(0 : i32) : i32
          llvm.return %39 : i32
        }
        llvm.mlir.global private constant @__constant_1x10xf32_5(opaque<"_", "0xDEADBEEF"> : tensor<1x10xf32>) : !llvm.array<1 x array<10 x f32>>
        llvm.func internal @predict_dispatch_5(%arg0: !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>, %arg1: !llvm.ptr<array<3 x i32>>) -> i32 {
          %0 = llvm.mlir.constant(10 : index) : i64
          %1 = llvm.mlir.constant(0 : index) : i64
          %2 = llvm.mlir.constant(1 : index) : i64
          %3 = llvm.mlir.constant(0.693147182 : f32) : f32
          %4 = llvm.mlir.constant(1.44269502 : f32) : f32
          %5 = llvm.mlir.constant(1.000000e+00 : f32) : f32
          %6 = llvm.mlir.constant(0.499705136 : f32) : f32
          %7 = llvm.mlir.constant(0.168738902 : f32) : f32
          %8 = llvm.mlir.constant(0.0366896503 : f32) : f32
          %9 = llvm.mlir.constant(1.314350e-02 : f32) : f32
          %10 = llvm.mlir.constant(23 : i32) : i32
          %11 = llvm.mlir.constant(0.000000e+00 : f32) : f32
          %12 = llvm.mlir.constant(0x7F800000 : f32) : f32
          %13 = llvm.mlir.constant(0xFF800000 : f32) : f32
          %14 = llvm.mlir.constant(1.17549435E-38 : f32) : f32
          %15 = llvm.mlir.constant(127 : i32) : i32
          %16 = llvm.mlir.constant(-127 : i32) : i32
          %17 = llvm.mlir.addressof @__constant_1x10xf32_5 : !llvm.ptr<array<1 x array<10 x f32>>>
          %18 = llvm.getelementptr %17[%1, %1, %1] : (!llvm.ptr<array<1 x array<10 x f32>>>, i64, i64, i64) -> !llvm.ptr<f32>
          %19 = llvm.mlir.constant(3735928559 : index) : i64
          %20 = llvm.inttoptr %19 : i64 to !llvm.ptr<f32>
          %21 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %22 = llvm.insertvalue %20, %21[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %23 = llvm.insertvalue %18, %22[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %24 = llvm.insertvalue %1, %23[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %25 = llvm.insertvalue %2, %24[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %26 = llvm.insertvalue %0, %25[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %27 = llvm.insertvalue %0, %26[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %28 = llvm.insertvalue %2, %27[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %29 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %30 = llvm.extractvalue %29[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %31 = llvm.getelementptr %30[%1] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
          %32 = llvm.load %31 : !llvm.ptr<ptr<i8>>
          %33 = llvm.getelementptr %32[%1] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
          %34 = llvm.bitcast %33 : !llvm.ptr<i8> to !llvm.ptr<f32>
          %35 = llvm.insertvalue %34, %21[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %36 = llvm.insertvalue %34, %35[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %37 = llvm.insertvalue %1, %36[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %38 = llvm.insertvalue %2, %37[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %39 = llvm.insertvalue %0, %38[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %40 = llvm.insertvalue %0, %39[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %41 = llvm.insertvalue %2, %40[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %42 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %43 = llvm.extractvalue %42[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %44 = llvm.getelementptr %43[%2] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
          %45 = llvm.load %44 : !llvm.ptr<ptr<i8>>
          %46 = llvm.getelementptr %45[%1] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
          %47 = llvm.bitcast %46 : !llvm.ptr<i8> to !llvm.ptr<f32>
          %48 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
          %49 = llvm.insertvalue %47, %48[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
          %50 = llvm.insertvalue %47, %49[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
          %51 = llvm.insertvalue %1, %50[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
          %52 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %53 = llvm.extractvalue %52[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %54 = llvm.mlir.constant(2 : index) : i64
          %55 = llvm.getelementptr %53[%54] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
          %56 = llvm.load %55 : !llvm.ptr<ptr<i8>>
          %57 = llvm.getelementptr %56[%1] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
          %58 = llvm.bitcast %57 : !llvm.ptr<i8> to !llvm.ptr<f32>
          %59 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %60 = llvm.insertvalue %58, %59[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %61 = llvm.insertvalue %58, %60[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %62 = llvm.insertvalue %1, %61[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %63 = llvm.insertvalue %0, %62[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %64 = llvm.insertvalue %2, %63[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %65 = llvm.load %arg1 : !llvm.ptr<array<3 x i32>>
          %66 = llvm.extractvalue %65[0] : !llvm.array<3 x i32>
          %67 = llvm.zext %66 : i32 to i64
          %68 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %69 = llvm.extractvalue %68[0] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %70 = llvm.extractvalue %69[0] : !llvm.array<3 x i32>
          %71 = llvm.zext %70 : i32 to i64
          %72 = llvm.load %arg1 : !llvm.ptr<array<3 x i32>>
          %73 = llvm.extractvalue %72[1] : !llvm.array<3 x i32>
          %74 = llvm.zext %73 : i32 to i64
          %75 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %76 = llvm.extractvalue %75[0] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %77 = llvm.extractvalue %76[1] : !llvm.array<3 x i32>
          %78 = llvm.zext %77 : i32 to i64
          %79 = llvm.mlir.constant(128 : index) : i64
          %80 = llvm.mul %74, %79  : i64
          %81 = llvm.mul %78, %79  : i64
          llvm.br ^bb1(%80 : i64)
        ^bb1(%82: i64):  // 2 preds: ^bb0, ^bb10
          %83 = llvm.icmp "slt" %82, %2 : i64
          llvm.cond_br %83, ^bb2, ^bb11
        ^bb2:  // pred: ^bb1
          %84 = llvm.mul %67, %79  : i64
          %85 = llvm.mul %71, %79  : i64
          llvm.br ^bb3(%84 : i64)
        ^bb3(%86: i64):  // 2 preds: ^bb2, ^bb9
          %87 = llvm.icmp "slt" %86, %0 : i64
          llvm.cond_br %87, ^bb4, ^bb10
        ^bb4:  // pred: ^bb3
          %88 = llvm.mlir.constant(-1 : index) : i64
          %89 = llvm.mul %82, %88  : i64
          %90 = llvm.add %89, %2  : i64
          %91 = llvm.icmp "slt" %79, %90 : i64
          %92 = llvm.select %91, %79, %90 : i1, i64
          %93 = llvm.mul %86, %88  : i64
          %94 = llvm.add %93, %0  : i64
          %95 = llvm.icmp "slt" %79, %94 : i64
          %96 = llvm.select %95, %79, %94 : i1, i64
          %97 = llvm.extractvalue %41[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %98 = llvm.bitcast %97 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %99 = llvm.insertvalue %98, %21[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %100 = llvm.extractvalue %41[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %101 = llvm.bitcast %100 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %102 = llvm.insertvalue %101, %99[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %103 = llvm.extractvalue %41[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %104 = llvm.extractvalue %41[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %105 = llvm.extractvalue %41[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %106 = llvm.mul %82, %103  : i64
          %107 = llvm.add %105, %106  : i64
          %108 = llvm.mul %86, %104  : i64
          %109 = llvm.add %107, %108  : i64
          %110 = llvm.insertvalue %109, %102[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %111 = llvm.mlir.constant(1 : i64) : i64
          %112 = llvm.insertvalue %96, %110[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %113 = llvm.insertvalue %111, %112[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %114 = llvm.mlir.constant(10 : i64) : i64
          %115 = llvm.insertvalue %92, %113[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %116 = llvm.insertvalue %114, %115[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %117 = llvm.extractvalue %28[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %118 = llvm.bitcast %117 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %119 = llvm.insertvalue %118, %21[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %120 = llvm.extractvalue %28[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %121 = llvm.bitcast %120 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %122 = llvm.insertvalue %121, %119[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %123 = llvm.extractvalue %28[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %124 = llvm.extractvalue %28[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %125 = llvm.extractvalue %28[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %126 = llvm.mul %82, %123  : i64
          %127 = llvm.add %125, %126  : i64
          %128 = llvm.mul %86, %124  : i64
          %129 = llvm.add %127, %128  : i64
          %130 = llvm.insertvalue %129, %122[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %131 = llvm.insertvalue %96, %130[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %132 = llvm.insertvalue %111, %131[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %133 = llvm.insertvalue %92, %132[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %134 = llvm.insertvalue %114, %133[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %135 = llvm.extractvalue %64[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %136 = llvm.bitcast %135 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %137 = llvm.insertvalue %136, %59[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %138 = llvm.extractvalue %64[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %139 = llvm.bitcast %138 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %140 = llvm.insertvalue %139, %137[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %141 = llvm.extractvalue %64[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %142 = llvm.extractvalue %64[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %143 = llvm.mul %86, %141  : i64
          %144 = llvm.add %142, %143  : i64
          %145 = llvm.insertvalue %144, %140[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %146 = llvm.insertvalue %96, %145[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %147 = llvm.insertvalue %111, %146[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          llvm.br ^bb5(%1 : i64)
        ^bb5(%148: i64):  // 2 preds: ^bb4, ^bb8
          %149 = llvm.icmp "slt" %148, %92 : i64
          llvm.cond_br %149, ^bb6(%1 : i64), ^bb9
        ^bb6(%150: i64):  // 2 preds: ^bb5, ^bb7
          %151 = llvm.icmp "slt" %150, %96 : i64
          llvm.cond_br %151, ^bb7, ^bb8
        ^bb7:  // pred: ^bb6
          %152 = llvm.extractvalue %116[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %153 = llvm.extractvalue %116[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %154 = llvm.mul %148, %0  : i64
          %155 = llvm.add %153, %154  : i64
          %156 = llvm.add %155, %150  : i64
          %157 = llvm.getelementptr %152[%156] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
          %158 = llvm.load %157 : !llvm.ptr<f32>
          %159 = llvm.extractvalue %134[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %160 = llvm.extractvalue %134[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %161 = llvm.add %160, %154  : i64
          %162 = llvm.add %161, %150  : i64
          %163 = llvm.getelementptr %159[%162] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
          %164 = llvm.load %163 : !llvm.ptr<f32>
          %165 = llvm.extractvalue %51[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
          %166 = llvm.load %165 : !llvm.ptr<f32>
          %167 = llvm.fadd %158, %164  : f32
          %168 = llvm.fsub %167, %166  : f32
          %169 = llvm.fmul %168, %4  : f32
          %170 = "llvm.intr.floor"(%169) : (f32) -> f32
          %171 = llvm.fmul %170, %3  : f32
          %172 = llvm.fsub %168, %171  : f32
          %173 = llvm.fmul %172, %172  : f32
          %174 = llvm.fmul %173, %173  : f32
          %175 = "llvm.intr.fma"(%5, %172, %5) : (f32, f32, f32) -> f32
          %176 = "llvm.intr.fma"(%7, %172, %6) : (f32, f32, f32) -> f32
          %177 = "llvm.intr.fma"(%9, %172, %8) : (f32, f32, f32) -> f32
          %178 = "llvm.intr.fma"(%176, %173, %175) : (f32, f32, f32) -> f32
          %179 = "llvm.intr.fma"(%177, %174, %178) : (f32, f32, f32) -> f32
          %180 = llvm.fptosi %170 : f32 to i32
          %181 = llvm.add %180, %15  : i32
          %182 = llvm.shl %181, %10  : i32
          %183 = llvm.bitcast %182 : i32 to f32
          %184 = llvm.fmul %179, %183  : f32
          %185 = llvm.icmp "sle" %180, %15 : i32
          %186 = llvm.icmp "sge" %180, %16 : i32
          %187 = llvm.fcmp "oeq" %168, %13 : f32
          %188 = llvm.fcmp "ogt" %168, %11 : f32
          %189 = llvm.and %185, %186  : i1
          %190 = llvm.select %187, %11, %14 : i1, f32
          %191 = llvm.select %188, %12, %190 : i1, f32
          %192 = llvm.select %189, %184, %191 : i1, f32
          %193 = llvm.extractvalue %147[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %194 = llvm.extractvalue %147[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %195 = llvm.add %194, %150  : i64
          %196 = llvm.getelementptr %193[%195] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
          llvm.store %192, %196 : !llvm.ptr<f32>
          %197 = llvm.add %150, %2  : i64
          llvm.br ^bb6(%197 : i64)
        ^bb8:  // pred: ^bb6
          %198 = llvm.add %148, %2  : i64
          llvm.br ^bb5(%198 : i64)
        ^bb9:  // pred: ^bb5
          %199 = llvm.add %86, %85  : i64
          llvm.br ^bb3(%199 : i64)
        ^bb10:  // pred: ^bb3
          %200 = llvm.add %82, %81  : i64
          llvm.br ^bb1(%200 : i64)
        ^bb11:  // pred: ^bb1
          %201 = llvm.mlir.constant(0 : i32) : i32
          llvm.return %201 : i32
        }
        llvm.func internal @predict_dispatch_6(%arg0: !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>, %arg1: !llvm.ptr<array<3 x i32>>) -> i32 {
          %0 = llvm.mlir.constant(0.000000e+00 : f32) : f32
          %1 = llvm.mlir.constant(10 : index) : i64
          %2 = llvm.mlir.constant(0 : index) : i64
          %3 = llvm.mlir.constant(1 : index) : i64
          %4 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %5 = llvm.extractvalue %4[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %6 = llvm.getelementptr %5[%2] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
          %7 = llvm.load %6 : !llvm.ptr<ptr<i8>>
          %8 = llvm.getelementptr %7[%2] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
          %9 = llvm.bitcast %8 : !llvm.ptr<i8> to !llvm.ptr<f32>
          %10 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %11 = llvm.insertvalue %9, %10[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %12 = llvm.insertvalue %9, %11[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %13 = llvm.insertvalue %2, %12[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %14 = llvm.insertvalue %1, %13[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %15 = llvm.insertvalue %3, %14[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %16 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %17 = llvm.extractvalue %16[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %18 = llvm.getelementptr %17[%3] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
          %19 = llvm.load %18 : !llvm.ptr<ptr<i8>>
          %20 = llvm.getelementptr %19[%2] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
          %21 = llvm.bitcast %20 : !llvm.ptr<i8> to !llvm.ptr<f32>
          %22 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
          %23 = llvm.insertvalue %21, %22[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
          %24 = llvm.insertvalue %21, %23[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
          %25 = llvm.insertvalue %2, %24[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
          %26 = llvm.extractvalue %25[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
          llvm.store %0, %26 : !llvm.ptr<f32>
          llvm.br ^bb1(%2 : i64)
        ^bb1(%27: i64):  // 2 preds: ^bb0, ^bb2
          %28 = llvm.icmp "slt" %27, %1 : i64
          llvm.cond_br %28, ^bb2, ^bb3
        ^bb2:  // pred: ^bb1
          %29 = llvm.extractvalue %15[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %30 = llvm.getelementptr %29[%27] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
          %31 = llvm.load %30 : !llvm.ptr<f32>
          %32 = llvm.load %26 : !llvm.ptr<f32>
          %33 = llvm.fadd %31, %32  : f32
          llvm.store %33, %26 : !llvm.ptr<f32>
          %34 = llvm.add %27, %3  : i64
          llvm.br ^bb1(%34 : i64)
        ^bb3:  // pred: ^bb1
          %35 = llvm.mlir.constant(0 : i32) : i32
          llvm.return %35 : i32
        }
        llvm.mlir.global private constant @__constant_1x10xf32_7(opaque<"_", "0xDEADBEEF"> : tensor<1x10xf32>) : !llvm.array<1 x array<10 x f32>>
        llvm.func internal @predict_dispatch_7(%arg0: !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>, %arg1: !llvm.ptr<array<3 x i32>>) -> i32 {
          %0 = llvm.mlir.constant(10 : index) : i64
          %1 = llvm.mlir.constant(0 : index) : i64
          %2 = llvm.mlir.constant(1 : index) : i64
          %3 = llvm.mlir.constant(0.693147182 : f32) : f32
          %4 = llvm.mlir.constant(1.44269502 : f32) : f32
          %5 = llvm.mlir.constant(1.000000e+00 : f32) : f32
          %6 = llvm.mlir.constant(0.499705136 : f32) : f32
          %7 = llvm.mlir.constant(0.168738902 : f32) : f32
          %8 = llvm.mlir.constant(0.0366896503 : f32) : f32
          %9 = llvm.mlir.constant(1.314350e-02 : f32) : f32
          %10 = llvm.mlir.constant(23 : i32) : i32
          %11 = llvm.mlir.constant(0.000000e+00 : f32) : f32
          %12 = llvm.mlir.constant(0x7F800000 : f32) : f32
          %13 = llvm.mlir.constant(0xFF800000 : f32) : f32
          %14 = llvm.mlir.constant(1.17549435E-38 : f32) : f32
          %15 = llvm.mlir.constant(127 : i32) : i32
          %16 = llvm.mlir.constant(-127 : i32) : i32
          %17 = llvm.mlir.addressof @__constant_1x10xf32_7 : !llvm.ptr<array<1 x array<10 x f32>>>
          %18 = llvm.getelementptr %17[%1, %1, %1] : (!llvm.ptr<array<1 x array<10 x f32>>>, i64, i64, i64) -> !llvm.ptr<f32>
          %19 = llvm.mlir.constant(3735928559 : index) : i64
          %20 = llvm.inttoptr %19 : i64 to !llvm.ptr<f32>
          %21 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %22 = llvm.insertvalue %20, %21[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %23 = llvm.insertvalue %18, %22[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %24 = llvm.insertvalue %1, %23[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %25 = llvm.insertvalue %2, %24[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %26 = llvm.insertvalue %0, %25[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %27 = llvm.insertvalue %0, %26[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %28 = llvm.insertvalue %2, %27[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %29 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %30 = llvm.extractvalue %29[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %31 = llvm.getelementptr %30[%1] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
          %32 = llvm.load %31 : !llvm.ptr<ptr<i8>>
          %33 = llvm.getelementptr %32[%1] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
          %34 = llvm.bitcast %33 : !llvm.ptr<i8> to !llvm.ptr<f32>
          %35 = llvm.insertvalue %34, %21[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %36 = llvm.insertvalue %34, %35[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %37 = llvm.insertvalue %1, %36[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %38 = llvm.insertvalue %2, %37[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %39 = llvm.insertvalue %0, %38[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %40 = llvm.insertvalue %0, %39[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %41 = llvm.insertvalue %2, %40[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %42 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %43 = llvm.extractvalue %42[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %44 = llvm.getelementptr %43[%2] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
          %45 = llvm.load %44 : !llvm.ptr<ptr<i8>>
          %46 = llvm.getelementptr %45[%1] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
          %47 = llvm.bitcast %46 : !llvm.ptr<i8> to !llvm.ptr<f32>
          %48 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
          %49 = llvm.insertvalue %47, %48[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
          %50 = llvm.insertvalue %47, %49[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
          %51 = llvm.insertvalue %1, %50[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
          %52 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %53 = llvm.extractvalue %52[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %54 = llvm.mlir.constant(2 : index) : i64
          %55 = llvm.getelementptr %53[%54] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
          %56 = llvm.load %55 : !llvm.ptr<ptr<i8>>
          %57 = llvm.getelementptr %56[%1] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
          %58 = llvm.bitcast %57 : !llvm.ptr<i8> to !llvm.ptr<f32>
          %59 = llvm.insertvalue %58, %48[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
          %60 = llvm.insertvalue %58, %59[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
          %61 = llvm.insertvalue %1, %60[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
          %62 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %63 = llvm.extractvalue %62[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %64 = llvm.mlir.constant(3 : index) : i64
          %65 = llvm.getelementptr %63[%64] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
          %66 = llvm.load %65 : !llvm.ptr<ptr<i8>>
          %67 = llvm.getelementptr %66[%1] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
          %68 = llvm.bitcast %67 : !llvm.ptr<i8> to !llvm.ptr<f32>
          %69 = llvm.insertvalue %68, %21[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %70 = llvm.insertvalue %68, %69[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %71 = llvm.insertvalue %1, %70[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %72 = llvm.insertvalue %2, %71[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %73 = llvm.insertvalue %0, %72[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %74 = llvm.insertvalue %0, %73[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %75 = llvm.insertvalue %2, %74[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %76 = llvm.load %arg1 : !llvm.ptr<array<3 x i32>>
          %77 = llvm.extractvalue %76[0] : !llvm.array<3 x i32>
          %78 = llvm.zext %77 : i32 to i64
          %79 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %80 = llvm.extractvalue %79[0] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %81 = llvm.extractvalue %80[0] : !llvm.array<3 x i32>
          %82 = llvm.zext %81 : i32 to i64
          %83 = llvm.load %arg1 : !llvm.ptr<array<3 x i32>>
          %84 = llvm.extractvalue %83[1] : !llvm.array<3 x i32>
          %85 = llvm.zext %84 : i32 to i64
          %86 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %87 = llvm.extractvalue %86[0] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %88 = llvm.extractvalue %87[1] : !llvm.array<3 x i32>
          %89 = llvm.zext %88 : i32 to i64
          %90 = llvm.mlir.constant(128 : index) : i64
          %91 = llvm.mul %85, %90  : i64
          %92 = llvm.mul %89, %90  : i64
          llvm.br ^bb1(%91 : i64)
        ^bb1(%93: i64):  // 2 preds: ^bb0, ^bb10
          %94 = llvm.icmp "slt" %93, %2 : i64
          llvm.cond_br %94, ^bb2, ^bb11
        ^bb2:  // pred: ^bb1
          %95 = llvm.mul %78, %90  : i64
          %96 = llvm.mul %82, %90  : i64
          llvm.br ^bb3(%95 : i64)
        ^bb3(%97: i64):  // 2 preds: ^bb2, ^bb9
          %98 = llvm.icmp "slt" %97, %0 : i64
          llvm.cond_br %98, ^bb4, ^bb10
        ^bb4:  // pred: ^bb3
          %99 = llvm.mlir.constant(-1 : index) : i64
          %100 = llvm.mul %93, %99  : i64
          %101 = llvm.add %100, %2  : i64
          %102 = llvm.icmp "slt" %90, %101 : i64
          %103 = llvm.select %102, %90, %101 : i1, i64
          %104 = llvm.mul %97, %99  : i64
          %105 = llvm.add %104, %0  : i64
          %106 = llvm.icmp "slt" %90, %105 : i64
          %107 = llvm.select %106, %90, %105 : i1, i64
          %108 = llvm.extractvalue %41[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %109 = llvm.bitcast %108 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %110 = llvm.insertvalue %109, %21[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %111 = llvm.extractvalue %41[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %112 = llvm.bitcast %111 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %113 = llvm.insertvalue %112, %110[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %114 = llvm.extractvalue %41[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %115 = llvm.extractvalue %41[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %116 = llvm.extractvalue %41[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %117 = llvm.mul %93, %114  : i64
          %118 = llvm.add %116, %117  : i64
          %119 = llvm.mul %97, %115  : i64
          %120 = llvm.add %118, %119  : i64
          %121 = llvm.insertvalue %120, %113[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %122 = llvm.mlir.constant(1 : i64) : i64
          %123 = llvm.insertvalue %107, %121[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %124 = llvm.insertvalue %122, %123[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %125 = llvm.mlir.constant(10 : i64) : i64
          %126 = llvm.insertvalue %103, %124[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %127 = llvm.insertvalue %125, %126[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %128 = llvm.extractvalue %28[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %129 = llvm.bitcast %128 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %130 = llvm.insertvalue %129, %21[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %131 = llvm.extractvalue %28[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %132 = llvm.bitcast %131 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %133 = llvm.insertvalue %132, %130[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %134 = llvm.extractvalue %28[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %135 = llvm.extractvalue %28[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %136 = llvm.extractvalue %28[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %137 = llvm.mul %93, %134  : i64
          %138 = llvm.add %136, %137  : i64
          %139 = llvm.mul %97, %135  : i64
          %140 = llvm.add %138, %139  : i64
          %141 = llvm.insertvalue %140, %133[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %142 = llvm.insertvalue %107, %141[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %143 = llvm.insertvalue %122, %142[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %144 = llvm.insertvalue %103, %143[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %145 = llvm.insertvalue %125, %144[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %146 = llvm.extractvalue %75[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %147 = llvm.bitcast %146 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %148 = llvm.insertvalue %147, %21[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %149 = llvm.extractvalue %75[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %150 = llvm.bitcast %149 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %151 = llvm.insertvalue %150, %148[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %152 = llvm.extractvalue %75[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %153 = llvm.extractvalue %75[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %154 = llvm.extractvalue %75[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %155 = llvm.mul %93, %152  : i64
          %156 = llvm.add %154, %155  : i64
          %157 = llvm.mul %97, %153  : i64
          %158 = llvm.add %156, %157  : i64
          %159 = llvm.insertvalue %158, %151[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %160 = llvm.insertvalue %107, %159[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %161 = llvm.insertvalue %122, %160[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %162 = llvm.insertvalue %103, %161[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %163 = llvm.insertvalue %125, %162[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          llvm.br ^bb5(%1 : i64)
        ^bb5(%164: i64):  // 2 preds: ^bb4, ^bb8
          %165 = llvm.icmp "slt" %164, %103 : i64
          llvm.cond_br %165, ^bb6(%1 : i64), ^bb9
        ^bb6(%166: i64):  // 2 preds: ^bb5, ^bb7
          %167 = llvm.icmp "slt" %166, %107 : i64
          llvm.cond_br %167, ^bb7, ^bb8
        ^bb7:  // pred: ^bb6
          %168 = llvm.extractvalue %127[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %169 = llvm.extractvalue %127[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %170 = llvm.mul %164, %0  : i64
          %171 = llvm.add %169, %170  : i64
          %172 = llvm.add %171, %166  : i64
          %173 = llvm.getelementptr %168[%172] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
          %174 = llvm.load %173 : !llvm.ptr<f32>
          %175 = llvm.extractvalue %145[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %176 = llvm.extractvalue %145[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %177 = llvm.add %176, %170  : i64
          %178 = llvm.add %177, %166  : i64
          %179 = llvm.getelementptr %175[%178] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
          %180 = llvm.load %179 : !llvm.ptr<f32>
          %181 = llvm.extractvalue %51[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
          %182 = llvm.load %181 : !llvm.ptr<f32>
          %183 = llvm.extractvalue %61[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
          %184 = llvm.load %183 : !llvm.ptr<f32>
          %185 = llvm.fadd %174, %180  : f32
          %186 = llvm.fsub %185, %182  : f32
          %187 = llvm.fmul %186, %4  : f32
          %188 = "llvm.intr.floor"(%187) : (f32) -> f32
          %189 = llvm.fmul %188, %3  : f32
          %190 = llvm.fsub %186, %189  : f32
          %191 = llvm.fmul %190, %190  : f32
          %192 = llvm.fmul %191, %191  : f32
          %193 = "llvm.intr.fma"(%5, %190, %5) : (f32, f32, f32) -> f32
          %194 = "llvm.intr.fma"(%7, %190, %6) : (f32, f32, f32) -> f32
          %195 = "llvm.intr.fma"(%9, %190, %8) : (f32, f32, f32) -> f32
          %196 = "llvm.intr.fma"(%194, %191, %193) : (f32, f32, f32) -> f32
          %197 = "llvm.intr.fma"(%195, %192, %196) : (f32, f32, f32) -> f32
          %198 = llvm.fptosi %188 : f32 to i32
          %199 = llvm.add %198, %15  : i32
          %200 = llvm.shl %199, %10  : i32
          %201 = llvm.bitcast %200 : i32 to f32
          %202 = llvm.fmul %197, %201  : f32
          %203 = llvm.icmp "sle" %198, %15 : i32
          %204 = llvm.icmp "sge" %198, %16 : i32
          %205 = llvm.fcmp "oeq" %186, %13 : f32
          %206 = llvm.fcmp "ogt" %186, %11 : f32
          %207 = llvm.and %203, %204  : i1
          %208 = llvm.select %205, %11, %14 : i1, f32
          %209 = llvm.select %206, %12, %208 : i1, f32
          %210 = llvm.select %207, %202, %209 : i1, f32
          %211 = llvm.fdiv %210, %184  : f32
          %212 = llvm.extractvalue %163[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %213 = llvm.extractvalue %163[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %214 = llvm.add %213, %170  : i64
          %215 = llvm.add %214, %166  : i64
          %216 = llvm.getelementptr %212[%215] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
          llvm.store %211, %216 : !llvm.ptr<f32>
          %217 = llvm.add %166, %2  : i64
          llvm.br ^bb6(%217 : i64)
        ^bb8:  // pred: ^bb6
          %218 = llvm.add %164, %2  : i64
          llvm.br ^bb5(%218 : i64)
        ^bb9:  // pred: ^bb5
          %219 = llvm.add %97, %96  : i64
          llvm.br ^bb3(%219 : i64)
        ^bb10:  // pred: ^bb3
          %220 = llvm.add %93, %92  : i64
          llvm.br ^bb1(%220 : i64)
        ^bb11:  // pred: ^bb1
          %221 = llvm.mlir.constant(0 : i32) : i32
          llvm.return %221 : i32
        }
      }
    }
  }
  hal.constant_pool @_const_pool attributes {buffer_constraints = #hal.buffer_constraints<max_allocation_size = 1073741824, min_buffer_offset_alignment = 16, max_buffer_range = 1073741824, min_buffer_range_alignment = 16>, sym_visibility = "private"} {
    hal.constant_storage @_storage = opaque<"_", "0xDEADBEEF"> : vector<407040xi8> attributes {sym_visibility = "nested"}
  }
  hal.variable @_const_pool_storage_buffer init(@_const_pool_storage_buffer_initializer) : !hal.buffer attributes {sym_visibility = "private"}
  func private @_const_pool_storage_buffer_initializer() -> !hal.buffer {
    %c0 = constant 0 : index
    %c407040 = constant 407040 : index
    %device = hal.ex.shared_device : !hal.device
    %allocator = hal.device.allocator<%device : !hal.device> : !hal.allocator
    %storage = hal.constant_storage.lookup @_const_pool::@_storage : !iree.byte_buffer
    %mapped = hal.allocator.map<%allocator : !hal.allocator> source(%storage : !iree.byte_buffer)[%c0, %c407040] type("HostVisible|DeviceVisible|DeviceLocal") usage("Constant|Transfer|Mapping|Dispatch") : !hal.buffer
    return %mapped : !hal.buffer
  }
  func @predict(%arg0: !hal.buffer) -> !hal.buffer attributes {noinline} {
    %c3136 = constant 3136 : index
    %c401408 = constant 401408 : index
    %c401920 = constant 401920 : index
    %c5120 = constant 5120 : index
    %c40 = constant 40 : index
    %c4 = constant 4 : index
    %c128 = constant 128 : index
    %c1 = constant 1 : index
    %c10 = constant 10 : index
    %c2 = constant 2 : index
    %c3 = constant 3 : index
    %c0 = constant 0 : index
    %c512 = constant 512 : index
    %c96 = constant 96 : index
    %c48 = constant 48 : index
    %c112 = constant 112 : index
    %c1024 = constant 1024 : index
    %device = hal.ex.shared_device : !hal.device
    %allocator = hal.device.allocator<%device : !hal.device> : !hal.allocator
    %buffer = hal.allocator.allocate<%allocator : !hal.allocator> type("HostVisible|DeviceVisible|DeviceLocal") usage("Transfer|Mapping|Dispatch") : !hal.buffer{%c40}
    %0 = hal.variable.load @_const_pool_storage_buffer : !hal.buffer
    %buffer_0 = hal.allocator.allocate<%allocator : !hal.allocator> type("DeviceVisible|DeviceLocal") usage("Transfer|Dispatch") : !hal.buffer{%c1024}
    %cmd = hal.command_buffer.create device(%device : !hal.device) mode("OneShot|AllowInlineExecution") categories("Transfer|Dispatch") : !hal.command_buffer
    hal.command_buffer.begin<%cmd : !hal.command_buffer>
    %1 = hal.variable.load @_executable_layout_0 : !hal.executable_layout
    hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%1 : !hal.executable_layout)[%c0] bindings([
      %c0 = (%0 : !hal.buffer)[%c512, %c401408], 
      %c1 = (%arg0 : !hal.buffer)[%c0, %c3136], 
      %c2 = (%buffer_0 : !hal.buffer)[%c0, %c512]
    ])
    hal.device.switch<%device : !hal.device>
    #hal.device.match.id<"dylib*">(%arg1 = %cmd : !hal.command_buffer, %arg2 = %c128 : index, %arg3 = %c1 : index, %arg4 = %c1 : index) {
      %c1_1 = constant 1 : index
      %4 = affine.apply #map0()[%arg2]
      %5 = affine.apply #map1()[%arg3]
      %6 = hal.command_buffer.device<%arg1 : !hal.command_buffer> : !hal.device
      %7 = hal.variable.load @_executable_mnist_linked_llvm_aot : !hal.executable
      hal.command_buffer.dispatch<%arg1 : !hal.command_buffer> target(%7 : !hal.executable)[0] workgroups([%4, %5, %c1_1])
      hal.return
    }
    hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
    hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%1 : !hal.executable_layout)[%c0] bindings([
      %c0 = (%0 : !hal.buffer)[%c0, %c512], 
      %c1 = (%buffer_0 : !hal.buffer)[%c0, %c512], 
      %c2 = (%buffer_0 : !hal.buffer)[%c512, %c512]
    ])
    hal.device.switch<%device : !hal.device>
    #hal.device.match.id<"dylib*">(%arg1 = %cmd : !hal.command_buffer, %arg2 = %c128 : index, %arg3 = %c1 : index, %arg4 = %c1 : index) {
      %c1_1 = constant 1 : index
      %4 = affine.apply #map2()[%arg2]
      %5 = affine.apply #map2()[%arg3]
      %6 = hal.command_buffer.device<%arg1 : !hal.command_buffer> : !hal.device
      %7 = hal.variable.load @_executable_mnist_linked_llvm_aot : !hal.executable
      hal.command_buffer.dispatch<%arg1 : !hal.command_buffer> target(%7 : !hal.executable)[1] workgroups([%4, %5, %c1_1])
      hal.return
    }
    hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
    hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%1 : !hal.executable_layout)[%c0] bindings([
      %c0 = (%0 : !hal.buffer)[%c401920, %c5120], 
      %c1 = (%buffer_0 : !hal.buffer)[%c512, %c512], 
      %c2 = (%buffer_0 : !hal.buffer)[%c0, %c40]
    ])
    hal.device.switch<%device : !hal.device>
    #hal.device.match.id<"dylib*">(%arg1 = %cmd : !hal.command_buffer, %arg2 = %c10 : index, %arg3 = %c1 : index, %arg4 = %c1 : index) {
      %c1_1 = constant 1 : index
      %4 = affine.apply #map0()[%arg2]
      %5 = affine.apply #map1()[%arg3]
      %6 = hal.command_buffer.device<%arg1 : !hal.command_buffer> : !hal.device
      %7 = hal.variable.load @_executable_mnist_linked_llvm_aot : !hal.executable
      hal.command_buffer.dispatch<%arg1 : !hal.command_buffer> target(%7 : !hal.executable)[2] workgroups([%4, %5, %c1_1])
      hal.return
    }
    hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
    %2 = hal.variable.load @_executable_layout_1 : !hal.executable_layout
    hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%2 : !hal.executable_layout)[%c0] bindings([
      %c0 = (%buffer_0 : !hal.buffer)[%c0, %c40], 
      %c1 = (%buffer_0 : !hal.buffer)[%c48, %c40]
    ])
    hal.device.switch<%device : !hal.device>
    #hal.device.match.id<"dylib*">(%arg1 = %cmd : !hal.command_buffer, %arg2 = %c10 : index, %arg3 = %c1 : index, %arg4 = %c1 : index) {
      %c1_1 = constant 1 : index
      %4 = affine.apply #map2()[%arg2]
      %5 = affine.apply #map2()[%arg3]
      %6 = hal.command_buffer.device<%arg1 : !hal.command_buffer> : !hal.device
      %7 = hal.variable.load @_executable_mnist_linked_llvm_aot : !hal.executable
      hal.command_buffer.dispatch<%arg1 : !hal.command_buffer> target(%7 : !hal.executable)[3] workgroups([%4, %5, %c1_1])
      hal.return
    }
    hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
    hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%2 : !hal.executable_layout)[%c0] bindings([
      %c0 = (%buffer_0 : !hal.buffer)[%c48, %c40], 
      %c1 = (%buffer_0 : !hal.buffer)[%c96, %c4]
    ])
    hal.device.switch<%device : !hal.device>
    #hal.device.match.id<"dylib*">(%arg1 = %cmd : !hal.command_buffer, %arg2 = %c1 : index, %arg3 = %c1 : index, %arg4 = %c1 : index) {
      %c1_1 = constant 1 : index
      %4 = hal.command_buffer.device<%arg1 : !hal.command_buffer> : !hal.device
      %5 = hal.variable.load @_executable_mnist_linked_llvm_aot : !hal.executable
      hal.command_buffer.dispatch<%arg1 : !hal.command_buffer> target(%5 : !hal.executable)[4] workgroups([%c1_1, %c1_1, %c1_1])
      hal.return
    }
    hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
    hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%1 : !hal.executable_layout)[%c0] bindings([
      %c0 = (%buffer_0 : !hal.buffer)[%c0, %c40], 
      %c1 = (%buffer_0 : !hal.buffer)[%c96, %c4], 
      %c2 = (%buffer_0 : !hal.buffer)[%c48, %c40]
    ])
    hal.device.switch<%device : !hal.device>
    #hal.device.match.id<"dylib*">(%arg1 = %cmd : !hal.command_buffer, %arg2 = %c10 : index, %arg3 = %c1 : index, %arg4 = %c1 : index) {
      %c1_1 = constant 1 : index
      %4 = affine.apply #map2()[%arg2]
      %5 = affine.apply #map2()[%arg3]
      %6 = hal.command_buffer.device<%arg1 : !hal.command_buffer> : !hal.device
      %7 = hal.variable.load @_executable_mnist_linked_llvm_aot : !hal.executable
      hal.command_buffer.dispatch<%arg1 : !hal.command_buffer> target(%7 : !hal.executable)[5] workgroups([%4, %5, %c1_1])
      hal.return
    }
    hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
    hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%2 : !hal.executable_layout)[%c0] bindings([
      %c0 = (%buffer_0 : !hal.buffer)[%c48, %c40], 
      %c1 = (%buffer_0 : !hal.buffer)[%c112, %c4]
    ])
    hal.device.switch<%device : !hal.device>
    #hal.device.match.id<"dylib*">(%arg1 = %cmd : !hal.command_buffer, %arg2 = %c1 : index, %arg3 = %c1 : index, %arg4 = %c1 : index) {
      %c1_1 = constant 1 : index
      %4 = hal.command_buffer.device<%arg1 : !hal.command_buffer> : !hal.device
      %5 = hal.variable.load @_executable_mnist_linked_llvm_aot : !hal.executable
      hal.command_buffer.dispatch<%arg1 : !hal.command_buffer> target(%5 : !hal.executable)[6] workgroups([%c1_1, %c1_1, %c1_1])
      hal.return
    }
    hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
    %3 = hal.variable.load @_executable_layout_2 : !hal.executable_layout
    hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%3 : !hal.executable_layout)[%c0] bindings([
      %c0 = (%buffer_0 : !hal.buffer)[%c0, %c40], 
      %c1 = (%buffer_0 : !hal.buffer)[%c96, %c4], 
      %c2 = (%buffer_0 : !hal.buffer)[%c112, %c4], 
      %c3 = (%buffer : !hal.buffer)[%c0, %c40]
    ])
    hal.device.switch<%device : !hal.device>
    #hal.device.match.id<"dylib*">(%arg1 = %cmd : !hal.command_buffer, %arg2 = %c10 : index, %arg3 = %c1 : index, %arg4 = %c1 : index) {
      %c1_1 = constant 1 : index
      %4 = affine.apply #map2()[%arg2]
      %5 = affine.apply #map2()[%arg3]
      %6 = hal.command_buffer.device<%arg1 : !hal.command_buffer> : !hal.device
      %7 = hal.variable.load @_executable_mnist_linked_llvm_aot : !hal.executable
      hal.command_buffer.dispatch<%arg1 : !hal.command_buffer> target(%7 : !hal.executable)[7] workgroups([%4, %5, %c1_1])
      hal.return
    }
    hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
    hal.command_buffer.end<%cmd : !hal.command_buffer>
    hal.ex.submit_and_wait %device, %cmd
    return %buffer : !hal.buffer
  }
  func @predict$async(%arg0: !hal.semaphore, %arg1: index, %arg2: !hal.buffer_view, %arg3: !hal.semaphore, %arg4: index) -> !hal.buffer_view attributes {iree.module.export = "predict$async"} {
    %c1 = constant 1 : index
    %c10 = constant 10 : index
    %c50331680_i32 = constant 50331680 : i32
    %0 = hal.semaphore.await<%arg0 : !hal.semaphore> until(%arg1) : i32
    hal.check_success %0, "semaphore wait failed"
    %buffer = hal.buffer_view.buffer %arg2 : !hal.buffer
    %1 = call @predict(%buffer) : (!hal.buffer) -> !hal.buffer
    %view = hal.buffer_view.create %1, element_type = %c50331680_i32, shape = [%c1, %c10] : !hal.buffer -> !hal.buffer_view
    hal.semaphore.signal<%arg3 : !hal.semaphore> value(%arg4)
    return %view : !hal.buffer_view
  }
  func @predict$sync(%arg0: !hal.buffer_view) -> !hal.buffer_view attributes {iree.abi.stub, iree.module.export = "predict", iree.reflection = {abi = "sip", abiv = 1 : i32, f = "I15!B11!d1d28d28d1R9!B6!d1d10", fv = "1", sip = "I8!S5!k0_0R3!_0"}} {
    %c0 = constant 0 : index
    %c1 = constant 1 : index
    %device = hal.ex.shared_device : !hal.device
    %semaphore = hal.semaphore.create device(%device : !hal.device) initial(%c0) : !hal.semaphore
    %0 = call @predict$async(%semaphore, %c0, %arg0, %semaphore, %c1) : (!hal.semaphore, index, !hal.buffer_view, !hal.semaphore, index) -> !hal.buffer_view
    %1 = hal.semaphore.await<%semaphore : !hal.semaphore> until(%c1) : i32
    hal.check_success %1, "semaphore wait failed"
    return %0 : !hal.buffer_view
  }
}


// *** IR Dump After mlir::iree_compiler::IREE::HAL::InlineDeviceSwitchesPass ***
func private @_descriptor_set_layout_0_initializer() -> !hal.descriptor_set_layout {
  %device = hal.ex.shared_device : !hal.device
  %descriptor_set_layout = hal.descriptor_set_layout.create device(%device : !hal.device) usage(PushOnly) bindings([#hal.descriptor_set_layout_binding<0, "StorageBuffer", R>, #hal.descriptor_set_layout_binding<1, "StorageBuffer", R>, #hal.descriptor_set_layout_binding<2, "StorageBuffer", DW>]) : !hal.descriptor_set_layout
  return %descriptor_set_layout : !hal.descriptor_set_layout
}

// *** IR Dump After mlir::iree_compiler::IREE::HAL::InlineDeviceSwitchesPass ***
func private @_executable_layout_0_initializer() -> !hal.executable_layout {
  %0 = hal.variable.load @_descriptor_set_layout_0 : !hal.descriptor_set_layout
  %device = hal.ex.shared_device : !hal.device
  %executable_layout = hal.executable_layout.create device(%device : !hal.device) push_constants(0) layouts([%0]) : !hal.executable_layout
  return %executable_layout : !hal.executable_layout
}

// *** IR Dump After mlir::iree_compiler::IREE::HAL::InlineDeviceSwitchesPass ***
func private @_descriptor_set_layout_1_initializer() -> !hal.descriptor_set_layout {
  %device = hal.ex.shared_device : !hal.device
  %descriptor_set_layout = hal.descriptor_set_layout.create device(%device : !hal.device) usage(PushOnly) bindings([#hal.descriptor_set_layout_binding<0, "StorageBuffer", R>, #hal.descriptor_set_layout_binding<1, "StorageBuffer", DW>]) : !hal.descriptor_set_layout
  return %descriptor_set_layout : !hal.descriptor_set_layout
}

// *** IR Dump After mlir::iree_compiler::IREE::HAL::InlineDeviceSwitchesPass ***
func private @_executable_layout_1_initializer() -> !hal.executable_layout {
  %0 = hal.variable.load @_descriptor_set_layout_1 : !hal.descriptor_set_layout
  %device = hal.ex.shared_device : !hal.device
  %executable_layout = hal.executable_layout.create device(%device : !hal.device) push_constants(0) layouts([%0]) : !hal.executable_layout
  return %executable_layout : !hal.executable_layout
}

// *** IR Dump After mlir::iree_compiler::IREE::HAL::InlineDeviceSwitchesPass ***
func private @_descriptor_set_layout_2_initializer() -> !hal.descriptor_set_layout {
  %device = hal.ex.shared_device : !hal.device
  %descriptor_set_layout = hal.descriptor_set_layout.create device(%device : !hal.device) usage(PushOnly) bindings([#hal.descriptor_set_layout_binding<0, "StorageBuffer", R>, #hal.descriptor_set_layout_binding<1, "StorageBuffer", R>, #hal.descriptor_set_layout_binding<2, "StorageBuffer", R>, #hal.descriptor_set_layout_binding<3, "StorageBuffer", DW>]) : !hal.descriptor_set_layout
  return %descriptor_set_layout : !hal.descriptor_set_layout
}

// *** IR Dump After mlir::iree_compiler::IREE::HAL::InlineDeviceSwitchesPass ***
func private @_executable_layout_2_initializer() -> !hal.executable_layout {
  %0 = hal.variable.load @_descriptor_set_layout_2 : !hal.descriptor_set_layout
  %device = hal.ex.shared_device : !hal.device
  %executable_layout = hal.executable_layout.create device(%device : !hal.device) push_constants(0) layouts([%0]) : !hal.executable_layout
  return %executable_layout : !hal.executable_layout
}

// *** IR Dump After mlir::iree_compiler::IREE::HAL::InlineDeviceSwitchesPass ***
func private @_executable_mnist_linked_llvm_aot_initializer() -> !hal.executable {
  %device = hal.ex.shared_device : !hal.device
  %0 = hal.device.match.id<%device : !hal.device> pattern("dylib*") : i1
  cond_br %0, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %1 = hal.variable.load @_executable_layout_0 : !hal.executable_layout
  %2 = hal.variable.load @_executable_layout_0 : !hal.executable_layout
  %3 = hal.variable.load @_executable_layout_0 : !hal.executable_layout
  %4 = hal.variable.load @_executable_layout_1 : !hal.executable_layout
  %5 = hal.variable.load @_executable_layout_1 : !hal.executable_layout
  %6 = hal.variable.load @_executable_layout_0 : !hal.executable_layout
  %7 = hal.variable.load @_executable_layout_1 : !hal.executable_layout
  %8 = hal.variable.load @_executable_layout_2 : !hal.executable_layout
  %exe = hal.executable.create device(%device : !hal.device) target(@mnist_linked_llvm_aot::@llvm_aot) layouts([%1, %2, %3, %4, %5, %6, %7, %8]) : !hal.executable
  br ^bb5(%exe : !hal.executable)
^bb2:  // pred: ^bb0
  %true = constant true
  cond_br %true, ^bb3, ^bb4
^bb3:  // pred: ^bb2
  %9 = iree.null : !hal.executable
  br ^bb5(%9 : !hal.executable)
^bb4:  // pred: ^bb2
  iree.unreachable "device not supported in the compiled configuration"
^bb5(%10: !hal.executable):  // 2 preds: ^bb1, ^bb3
  return %10 : !hal.executable
}

// *** IR Dump After mlir::iree_compiler::IREE::HAL::InlineDeviceSwitchesPass ***
func private @_const_pool_storage_buffer_initializer() -> !hal.buffer {
  %c0 = constant 0 : index
  %c407040 = constant 407040 : index
  %device = hal.ex.shared_device : !hal.device
  %allocator = hal.device.allocator<%device : !hal.device> : !hal.allocator
  %storage = hal.constant_storage.lookup @_const_pool::@_storage : !iree.byte_buffer
  %mapped = hal.allocator.map<%allocator : !hal.allocator> source(%storage : !iree.byte_buffer)[%c0, %c407040] type("HostVisible|DeviceVisible|DeviceLocal") usage("Constant|Transfer|Mapping|Dispatch") : !hal.buffer
  return %mapped : !hal.buffer
}

// *** IR Dump After mlir::iree_compiler::IREE::HAL::InlineDeviceSwitchesPass ***
func @predict(%arg0: !hal.buffer) -> !hal.buffer attributes {noinline} {
  %c3136 = constant 3136 : index
  %c401408 = constant 401408 : index
  %c401920 = constant 401920 : index
  %c5120 = constant 5120 : index
  %c40 = constant 40 : index
  %c4 = constant 4 : index
  %c128 = constant 128 : index
  %c1 = constant 1 : index
  %c10 = constant 10 : index
  %c2 = constant 2 : index
  %c3 = constant 3 : index
  %c0 = constant 0 : index
  %c512 = constant 512 : index
  %c96 = constant 96 : index
  %c48 = constant 48 : index
  %c112 = constant 112 : index
  %c1024 = constant 1024 : index
  %device = hal.ex.shared_device : !hal.device
  %allocator = hal.device.allocator<%device : !hal.device> : !hal.allocator
  %buffer = hal.allocator.allocate<%allocator : !hal.allocator> type("HostVisible|DeviceVisible|DeviceLocal") usage("Transfer|Mapping|Dispatch") : !hal.buffer{%c40}
  %0 = hal.variable.load @_const_pool_storage_buffer : !hal.buffer
  %buffer_0 = hal.allocator.allocate<%allocator : !hal.allocator> type("DeviceVisible|DeviceLocal") usage("Transfer|Dispatch") : !hal.buffer{%c1024}
  %cmd = hal.command_buffer.create device(%device : !hal.device) mode("OneShot|AllowInlineExecution") categories("Transfer|Dispatch") : !hal.command_buffer
  hal.command_buffer.begin<%cmd : !hal.command_buffer>
  %1 = hal.variable.load @_executable_layout_0 : !hal.executable_layout
  hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%1 : !hal.executable_layout)[%c0] bindings([
    %c0 = (%0 : !hal.buffer)[%c512, %c401408], 
    %c1 = (%arg0 : !hal.buffer)[%c0, %c3136], 
    %c2 = (%buffer_0 : !hal.buffer)[%c0, %c512]
  ])
  %2 = hal.device.match.id<%device : !hal.device> pattern("dylib*") : i1
  cond_br %2, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %c1_1 = constant 1 : index
  %3 = affine.apply affine_map<()[s0] -> (s0 ceildiv 64)>()[%c128]
  %4 = affine.apply affine_map<()[s0] -> (s0 ceildiv 4)>()[%c1]
  %5 = hal.command_buffer.device<%cmd : !hal.command_buffer> : !hal.device
  %6 = hal.variable.load @_executable_mnist_linked_llvm_aot : !hal.executable
  hal.command_buffer.dispatch<%cmd : !hal.command_buffer> target(%6 : !hal.executable)[0] workgroups([%3, %4, %c1_1])
  br ^bb3
^bb2:  // pred: ^bb0
  iree.unreachable "device not supported in the compiled configuration"
^bb3:  // pred: ^bb1
  hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
  hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%1 : !hal.executable_layout)[%c0] bindings([
    %c0 = (%0 : !hal.buffer)[%c0, %c512], 
    %c1 = (%buffer_0 : !hal.buffer)[%c0, %c512], 
    %c2 = (%buffer_0 : !hal.buffer)[%c512, %c512]
  ])
  %7 = hal.device.match.id<%device : !hal.device> pattern("dylib*") : i1
  cond_br %7, ^bb4, ^bb5
^bb4:  // pred: ^bb3
  %c1_2 = constant 1 : index
  %8 = affine.apply affine_map<()[s0] -> (s0 ceildiv 128)>()[%c128]
  %9 = affine.apply affine_map<()[s0] -> (s0 ceildiv 128)>()[%c1]
  %10 = hal.command_buffer.device<%cmd : !hal.command_buffer> : !hal.device
  %11 = hal.variable.load @_executable_mnist_linked_llvm_aot : !hal.executable
  hal.command_buffer.dispatch<%cmd : !hal.command_buffer> target(%11 : !hal.executable)[1] workgroups([%8, %9, %c1_2])
  br ^bb6
^bb5:  // pred: ^bb3
  iree.unreachable "device not supported in the compiled configuration"
^bb6:  // pred: ^bb4
  hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
  hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%1 : !hal.executable_layout)[%c0] bindings([
    %c0 = (%0 : !hal.buffer)[%c401920, %c5120], 
    %c1 = (%buffer_0 : !hal.buffer)[%c512, %c512], 
    %c2 = (%buffer_0 : !hal.buffer)[%c0, %c40]
  ])
  %12 = hal.device.match.id<%device : !hal.device> pattern("dylib*") : i1
  cond_br %12, ^bb7, ^bb8
^bb7:  // pred: ^bb6
  %c1_3 = constant 1 : index
  %13 = affine.apply affine_map<()[s0] -> (s0 ceildiv 64)>()[%c10]
  %14 = affine.apply affine_map<()[s0] -> (s0 ceildiv 4)>()[%c1]
  %15 = hal.command_buffer.device<%cmd : !hal.command_buffer> : !hal.device
  %16 = hal.variable.load @_executable_mnist_linked_llvm_aot : !hal.executable
  hal.command_buffer.dispatch<%cmd : !hal.command_buffer> target(%16 : !hal.executable)[2] workgroups([%13, %14, %c1_3])
  br ^bb9
^bb8:  // pred: ^bb6
  iree.unreachable "device not supported in the compiled configuration"
^bb9:  // pred: ^bb7
  hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
  %17 = hal.variable.load @_executable_layout_1 : !hal.executable_layout
  hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%17 : !hal.executable_layout)[%c0] bindings([
    %c0 = (%buffer_0 : !hal.buffer)[%c0, %c40], 
    %c1 = (%buffer_0 : !hal.buffer)[%c48, %c40]
  ])
  %18 = hal.device.match.id<%device : !hal.device> pattern("dylib*") : i1
  cond_br %18, ^bb10, ^bb11
^bb10:  // pred: ^bb9
  %c1_4 = constant 1 : index
  %19 = affine.apply affine_map<()[s0] -> (s0 ceildiv 128)>()[%c10]
  %20 = affine.apply affine_map<()[s0] -> (s0 ceildiv 128)>()[%c1]
  %21 = hal.command_buffer.device<%cmd : !hal.command_buffer> : !hal.device
  %22 = hal.variable.load @_executable_mnist_linked_llvm_aot : !hal.executable
  hal.command_buffer.dispatch<%cmd : !hal.command_buffer> target(%22 : !hal.executable)[3] workgroups([%19, %20, %c1_4])
  br ^bb12
^bb11:  // pred: ^bb9
  iree.unreachable "device not supported in the compiled configuration"
^bb12:  // pred: ^bb10
  hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
  hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%17 : !hal.executable_layout)[%c0] bindings([
    %c0 = (%buffer_0 : !hal.buffer)[%c48, %c40], 
    %c1 = (%buffer_0 : !hal.buffer)[%c96, %c4]
  ])
  %23 = hal.device.match.id<%device : !hal.device> pattern("dylib*") : i1
  cond_br %23, ^bb13, ^bb14
^bb13:  // pred: ^bb12
  %c1_5 = constant 1 : index
  %24 = hal.command_buffer.device<%cmd : !hal.command_buffer> : !hal.device
  %25 = hal.variable.load @_executable_mnist_linked_llvm_aot : !hal.executable
  hal.command_buffer.dispatch<%cmd : !hal.command_buffer> target(%25 : !hal.executable)[4] workgroups([%c1_5, %c1_5, %c1_5])
  br ^bb15
^bb14:  // pred: ^bb12
  iree.unreachable "device not supported in the compiled configuration"
^bb15:  // pred: ^bb13
  hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
  hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%1 : !hal.executable_layout)[%c0] bindings([
    %c0 = (%buffer_0 : !hal.buffer)[%c0, %c40], 
    %c1 = (%buffer_0 : !hal.buffer)[%c96, %c4], 
    %c2 = (%buffer_0 : !hal.buffer)[%c48, %c40]
  ])
  %26 = hal.device.match.id<%device : !hal.device> pattern("dylib*") : i1
  cond_br %26, ^bb16, ^bb17
^bb16:  // pred: ^bb15
  %c1_6 = constant 1 : index
  %27 = affine.apply affine_map<()[s0] -> (s0 ceildiv 128)>()[%c10]
  %28 = affine.apply affine_map<()[s0] -> (s0 ceildiv 128)>()[%c1]
  %29 = hal.command_buffer.device<%cmd : !hal.command_buffer> : !hal.device
  %30 = hal.variable.load @_executable_mnist_linked_llvm_aot : !hal.executable
  hal.command_buffer.dispatch<%cmd : !hal.command_buffer> target(%30 : !hal.executable)[5] workgroups([%27, %28, %c1_6])
  br ^bb18
^bb17:  // pred: ^bb15
  iree.unreachable "device not supported in the compiled configuration"
^bb18:  // pred: ^bb16
  hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
  hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%17 : !hal.executable_layout)[%c0] bindings([
    %c0 = (%buffer_0 : !hal.buffer)[%c48, %c40], 
    %c1 = (%buffer_0 : !hal.buffer)[%c112, %c4]
  ])
  %31 = hal.device.match.id<%device : !hal.device> pattern("dylib*") : i1
  cond_br %31, ^bb19, ^bb20
^bb19:  // pred: ^bb18
  %c1_7 = constant 1 : index
  %32 = hal.command_buffer.device<%cmd : !hal.command_buffer> : !hal.device
  %33 = hal.variable.load @_executable_mnist_linked_llvm_aot : !hal.executable
  hal.command_buffer.dispatch<%cmd : !hal.command_buffer> target(%33 : !hal.executable)[6] workgroups([%c1_7, %c1_7, %c1_7])
  br ^bb21
^bb20:  // pred: ^bb18
  iree.unreachable "device not supported in the compiled configuration"
^bb21:  // pred: ^bb19
  hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
  %34 = hal.variable.load @_executable_layout_2 : !hal.executable_layout
  hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%34 : !hal.executable_layout)[%c0] bindings([
    %c0 = (%buffer_0 : !hal.buffer)[%c0, %c40], 
    %c1 = (%buffer_0 : !hal.buffer)[%c96, %c4], 
    %c2 = (%buffer_0 : !hal.buffer)[%c112, %c4], 
    %c3 = (%buffer : !hal.buffer)[%c0, %c40]
  ])
  %35 = hal.device.match.id<%device : !hal.device> pattern("dylib*") : i1
  cond_br %35, ^bb22, ^bb23
^bb22:  // pred: ^bb21
  %c1_8 = constant 1 : index
  %36 = affine.apply affine_map<()[s0] -> (s0 ceildiv 128)>()[%c10]
  %37 = affine.apply affine_map<()[s0] -> (s0 ceildiv 128)>()[%c1]
  %38 = hal.command_buffer.device<%cmd : !hal.command_buffer> : !hal.device
  %39 = hal.variable.load @_executable_mnist_linked_llvm_aot : !hal.executable
  hal.command_buffer.dispatch<%cmd : !hal.command_buffer> target(%39 : !hal.executable)[7] workgroups([%36, %37, %c1_8])
  br ^bb24
^bb23:  // pred: ^bb21
  iree.unreachable "device not supported in the compiled configuration"
^bb24:  // pred: ^bb22
  hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
  hal.command_buffer.end<%cmd : !hal.command_buffer>
  hal.ex.submit_and_wait %device, %cmd
  return %buffer : !hal.buffer
}

// *** IR Dump After mlir::iree_compiler::IREE::HAL::InlineDeviceSwitchesPass ***
func @predict$async(%arg0: !hal.semaphore, %arg1: index, %arg2: !hal.buffer_view, %arg3: !hal.semaphore, %arg4: index) -> !hal.buffer_view attributes {iree.module.export = "predict$async"} {
  %c1 = constant 1 : index
  %c10 = constant 10 : index
  %c50331680_i32 = constant 50331680 : i32
  %0 = hal.semaphore.await<%arg0 : !hal.semaphore> until(%arg1) : i32
  hal.check_success %0, "semaphore wait failed"
  %buffer = hal.buffer_view.buffer %arg2 : !hal.buffer
  %1 = call @predict(%buffer) : (!hal.buffer) -> !hal.buffer
  %view = hal.buffer_view.create %1, element_type = %c50331680_i32, shape = [%c1, %c10] : !hal.buffer -> !hal.buffer_view
  hal.semaphore.signal<%arg3 : !hal.semaphore> value(%arg4)
  return %view : !hal.buffer_view
}

// *** IR Dump After mlir::iree_compiler::IREE::HAL::InlineDeviceSwitchesPass ***
func @predict$sync(%arg0: !hal.buffer_view) -> !hal.buffer_view attributes {iree.abi.stub, iree.module.export = "predict", iree.reflection = {abi = "sip", abiv = 1 : i32, f = "I15!B11!d1d28d28d1R9!B6!d1d10", fv = "1", sip = "I8!S5!k0_0R3!_0"}} {
  %c0 = constant 0 : index
  %c1 = constant 1 : index
  %device = hal.ex.shared_device : !hal.device
  %semaphore = hal.semaphore.create device(%device : !hal.device) initial(%c0) : !hal.semaphore
  %0 = call @predict$async(%semaphore, %c0, %arg0, %semaphore, %c1) : (!hal.semaphore, index, !hal.buffer_view, !hal.semaphore, index) -> !hal.buffer_view
  %1 = hal.semaphore.await<%semaphore : !hal.semaphore> until(%c1) : i32
  hal.check_success %1, "semaphore wait failed"
  return %0 : !hal.buffer_view
}

// *** IR Dump After ConvertAffineToStandard ***
module  {
  hal.variable @_descriptor_set_layout_0 init(@_descriptor_set_layout_0_initializer) : !hal.descriptor_set_layout attributes {sym_visibility = "private"}
  func private @_descriptor_set_layout_0_initializer() -> !hal.descriptor_set_layout {
    %device = hal.ex.shared_device : !hal.device
    %descriptor_set_layout = hal.descriptor_set_layout.create device(%device : !hal.device) usage(PushOnly) bindings([#hal.descriptor_set_layout_binding<0, "StorageBuffer", R>, #hal.descriptor_set_layout_binding<1, "StorageBuffer", R>, #hal.descriptor_set_layout_binding<2, "StorageBuffer", DW>]) : !hal.descriptor_set_layout
    return %descriptor_set_layout : !hal.descriptor_set_layout
  }
  hal.variable @_executable_layout_0 init(@_executable_layout_0_initializer) : !hal.executable_layout attributes {sym_visibility = "private"}
  func private @_executable_layout_0_initializer() -> !hal.executable_layout {
    %0 = hal.variable.load @_descriptor_set_layout_0 : !hal.descriptor_set_layout
    %device = hal.ex.shared_device : !hal.device
    %executable_layout = hal.executable_layout.create device(%device : !hal.device) push_constants(0) layouts([%0]) : !hal.executable_layout
    return %executable_layout : !hal.executable_layout
  }
  hal.variable @_descriptor_set_layout_1 init(@_descriptor_set_layout_1_initializer) : !hal.descriptor_set_layout attributes {sym_visibility = "private"}
  func private @_descriptor_set_layout_1_initializer() -> !hal.descriptor_set_layout {
    %device = hal.ex.shared_device : !hal.device
    %descriptor_set_layout = hal.descriptor_set_layout.create device(%device : !hal.device) usage(PushOnly) bindings([#hal.descriptor_set_layout_binding<0, "StorageBuffer", R>, #hal.descriptor_set_layout_binding<1, "StorageBuffer", DW>]) : !hal.descriptor_set_layout
    return %descriptor_set_layout : !hal.descriptor_set_layout
  }
  hal.variable @_executable_layout_1 init(@_executable_layout_1_initializer) : !hal.executable_layout attributes {sym_visibility = "private"}
  func private @_executable_layout_1_initializer() -> !hal.executable_layout {
    %0 = hal.variable.load @_descriptor_set_layout_1 : !hal.descriptor_set_layout
    %device = hal.ex.shared_device : !hal.device
    %executable_layout = hal.executable_layout.create device(%device : !hal.device) push_constants(0) layouts([%0]) : !hal.executable_layout
    return %executable_layout : !hal.executable_layout
  }
  hal.variable @_descriptor_set_layout_2 init(@_descriptor_set_layout_2_initializer) : !hal.descriptor_set_layout attributes {sym_visibility = "private"}
  func private @_descriptor_set_layout_2_initializer() -> !hal.descriptor_set_layout {
    %device = hal.ex.shared_device : !hal.device
    %descriptor_set_layout = hal.descriptor_set_layout.create device(%device : !hal.device) usage(PushOnly) bindings([#hal.descriptor_set_layout_binding<0, "StorageBuffer", R>, #hal.descriptor_set_layout_binding<1, "StorageBuffer", R>, #hal.descriptor_set_layout_binding<2, "StorageBuffer", R>, #hal.descriptor_set_layout_binding<3, "StorageBuffer", DW>]) : !hal.descriptor_set_layout
    return %descriptor_set_layout : !hal.descriptor_set_layout
  }
  hal.variable @_executable_layout_2 init(@_executable_layout_2_initializer) : !hal.executable_layout attributes {sym_visibility = "private"}
  func private @_executable_layout_2_initializer() -> !hal.executable_layout {
    %0 = hal.variable.load @_descriptor_set_layout_2 : !hal.descriptor_set_layout
    %device = hal.ex.shared_device : !hal.device
    %executable_layout = hal.executable_layout.create device(%device : !hal.device) push_constants(0) layouts([%0]) : !hal.executable_layout
    return %executable_layout : !hal.executable_layout
  }
  hal.variable @_executable_mnist_linked_llvm_aot init(@_executable_mnist_linked_llvm_aot_initializer) : !hal.executable attributes {sym_visibility = "private"}
  func private @_executable_mnist_linked_llvm_aot_initializer() -> !hal.executable {
    %device = hal.ex.shared_device : !hal.device
    %0 = hal.device.match.id<%device : !hal.device> pattern("dylib*") : i1
    cond_br %0, ^bb1, ^bb2
  ^bb1:  // pred: ^bb0
    %1 = hal.variable.load @_executable_layout_0 : !hal.executable_layout
    %2 = hal.variable.load @_executable_layout_0 : !hal.executable_layout
    %3 = hal.variable.load @_executable_layout_0 : !hal.executable_layout
    %4 = hal.variable.load @_executable_layout_1 : !hal.executable_layout
    %5 = hal.variable.load @_executable_layout_1 : !hal.executable_layout
    %6 = hal.variable.load @_executable_layout_0 : !hal.executable_layout
    %7 = hal.variable.load @_executable_layout_1 : !hal.executable_layout
    %8 = hal.variable.load @_executable_layout_2 : !hal.executable_layout
    %exe = hal.executable.create device(%device : !hal.device) target(@mnist_linked_llvm_aot::@llvm_aot) layouts([%1, %2, %3, %4, %5, %6, %7, %8]) : !hal.executable
    br ^bb5(%exe : !hal.executable)
  ^bb2:  // pred: ^bb0
    %true = constant true
    cond_br %true, ^bb3, ^bb4
  ^bb3:  // pred: ^bb2
    %9 = iree.null : !hal.executable
    br ^bb5(%9 : !hal.executable)
  ^bb4:  // pred: ^bb2
    iree.unreachable "device not supported in the compiled configuration"
  ^bb5(%10: !hal.executable):  // 2 preds: ^bb1, ^bb3
    return %10 : !hal.executable
  }
  hal.executable @mnist_linked_llvm_aot attributes {sym_visibility = "private"} {
    hal.interface @io_0 {
      hal.interface.binding @s0b0_ro_constant, set=0, binding=0, type="StorageBuffer", access="Read"
      hal.interface.binding @s0b1_ro_external, set=0, binding=1, type="StorageBuffer", access="Read"
      hal.interface.binding @s0b2_xw_external, set=0, binding=2, type="StorageBuffer", access="Write|Discard"
    }
    hal.interface @io_1 {
      hal.interface.binding @s0b0_ro_external, set=0, binding=0, type="StorageBuffer", access="Read"
      hal.interface.binding @s0b1_xw_external, set=0, binding=1, type="StorageBuffer", access="Write|Discard"
    }
    hal.interface @io_2 {
      hal.interface.binding @s0b0_ro_external, set=0, binding=0, type="StorageBuffer", access="Read"
      hal.interface.binding @s0b1_ro_external, set=0, binding=1, type="StorageBuffer", access="Read"
      hal.interface.binding @s0b2_xw_external, set=0, binding=2, type="StorageBuffer", access="Write|Discard"
    }
    hal.interface @io_3 {
      hal.interface.binding @s0b0_ro_external, set=0, binding=0, type="StorageBuffer", access="Read"
      hal.interface.binding @s0b1_ro_external, set=0, binding=1, type="StorageBuffer", access="Read"
      hal.interface.binding @s0b2_ro_external, set=0, binding=2, type="StorageBuffer", access="Read"
      hal.interface.binding @s0b3_xw_external, set=0, binding=3, type="StorageBuffer", access="Write|Discard"
    }
    hal.executable.target @llvm_aot, filter="dylib*" {
      hal.executable.entry_point @predict_dispatch_0 attributes {interface = @io_0, ordinal = 0 : index}
      hal.executable.entry_point @predict_dispatch_1 attributes {interface = @io_0, ordinal = 1 : index}
      hal.executable.entry_point @predict_dispatch_2 attributes {interface = @io_0, ordinal = 2 : index}
      hal.executable.entry_point @predict_dispatch_3 attributes {interface = @io_1, ordinal = 3 : index}
      hal.executable.entry_point @predict_dispatch_4 attributes {interface = @io_1, ordinal = 4 : index}
      hal.executable.entry_point @predict_dispatch_5 attributes {interface = @io_2, ordinal = 5 : index}
      hal.executable.entry_point @predict_dispatch_6 attributes {interface = @io_1, ordinal = 6 : index}
      hal.executable.entry_point @predict_dispatch_7 attributes {interface = @io_3, ordinal = 7 : index}
      module  {
        llvm.func internal @predict_dispatch_0(%arg0: !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>, %arg1: !llvm.ptr<array<3 x i32>>) -> i32 {
          %0 = llvm.mlir.constant(0.000000e+00 : f32) : f32
          %1 = llvm.mlir.constant(128 : index) : i64
          %2 = llvm.mlir.constant(784 : index) : i64
          %3 = llvm.mlir.constant(28 : index) : i64
          %4 = llvm.mlir.constant(32 : index) : i64
          %5 = llvm.mlir.constant(64 : index) : i64
          %6 = llvm.mlir.constant(4 : index) : i64
          %7 = llvm.mlir.constant(0 : index) : i64
          %8 = llvm.mlir.constant(1 : index) : i64
          %9 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %10 = llvm.extractvalue %9[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %11 = llvm.getelementptr %10[%8] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
          %12 = llvm.load %11 : !llvm.ptr<ptr<i8>>
          %13 = llvm.getelementptr %12[%7] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
          %14 = llvm.bitcast %13 : !llvm.ptr<i8> to !llvm.ptr<f32>
          %15 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %16 = llvm.insertvalue %14, %15[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %17 = llvm.insertvalue %14, %16[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %18 = llvm.insertvalue %7, %17[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %19 = llvm.insertvalue %8, %18[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %20 = llvm.insertvalue %2, %19[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %21 = llvm.insertvalue %2, %20[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %22 = llvm.insertvalue %8, %21[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %23 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %24 = llvm.extractvalue %23[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %25 = llvm.getelementptr %24[%7] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
          %26 = llvm.load %25 : !llvm.ptr<ptr<i8>>
          %27 = llvm.getelementptr %26[%7] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
          %28 = llvm.bitcast %27 : !llvm.ptr<i8> to !llvm.ptr<f32>
          %29 = llvm.insertvalue %28, %15[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %30 = llvm.insertvalue %28, %29[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %31 = llvm.insertvalue %7, %30[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %32 = llvm.insertvalue %2, %31[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %33 = llvm.insertvalue %1, %32[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %34 = llvm.insertvalue %1, %33[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %35 = llvm.insertvalue %8, %34[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %36 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %37 = llvm.extractvalue %36[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %38 = llvm.mlir.constant(2 : index) : i64
          %39 = llvm.getelementptr %37[%38] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
          %40 = llvm.load %39 : !llvm.ptr<ptr<i8>>
          %41 = llvm.getelementptr %40[%7] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
          %42 = llvm.bitcast %41 : !llvm.ptr<i8> to !llvm.ptr<f32>
          %43 = llvm.insertvalue %42, %15[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %44 = llvm.insertvalue %42, %43[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %45 = llvm.insertvalue %7, %44[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %46 = llvm.insertvalue %8, %45[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %47 = llvm.insertvalue %1, %46[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %48 = llvm.insertvalue %1, %47[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %49 = llvm.insertvalue %8, %48[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %50 = llvm.load %arg1 : !llvm.ptr<array<3 x i32>>
          %51 = llvm.extractvalue %50[0] : !llvm.array<3 x i32>
          %52 = llvm.zext %51 : i32 to i64
          %53 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %54 = llvm.extractvalue %53[0] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %55 = llvm.extractvalue %54[0] : !llvm.array<3 x i32>
          %56 = llvm.zext %55 : i32 to i64
          %57 = llvm.load %arg1 : !llvm.ptr<array<3 x i32>>
          %58 = llvm.extractvalue %57[1] : !llvm.array<3 x i32>
          %59 = llvm.zext %58 : i32 to i64
          %60 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %61 = llvm.extractvalue %60[0] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %62 = llvm.extractvalue %61[1] : !llvm.array<3 x i32>
          %63 = llvm.zext %62 : i32 to i64
          %64 = llvm.mul %59, %6  : i64
          %65 = llvm.mul %63, %6  : i64
          llvm.br ^bb1(%64 : i64)
        ^bb1(%66: i64):  // 2 preds: ^bb0, ^bb30
          %67 = llvm.icmp "slt" %66, %8 : i64
          llvm.cond_br %67, ^bb2, ^bb31
        ^bb2:  // pred: ^bb1
          %68 = llvm.mul %52, %5  : i64
          %69 = llvm.mul %56, %5  : i64
          llvm.br ^bb3(%68 : i64)
        ^bb3(%70: i64):  // 2 preds: ^bb2, ^bb29
          %71 = llvm.icmp "slt" %70, %1 : i64
          llvm.cond_br %71, ^bb4, ^bb30
        ^bb4:  // pred: ^bb3
          %72 = llvm.mlir.constant(-1 : index) : i64
          %73 = llvm.mul %66, %72  : i64
          %74 = llvm.add %73, %8  : i64
          %75 = llvm.icmp "slt" %6, %74 : i64
          %76 = llvm.select %75, %6, %74 : i1, i64
          %77 = llvm.extractvalue %22[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %78 = llvm.bitcast %77 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %79 = llvm.insertvalue %78, %15[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %80 = llvm.extractvalue %22[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %81 = llvm.bitcast %80 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %82 = llvm.insertvalue %81, %79[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %83 = llvm.extractvalue %22[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %84 = llvm.extractvalue %22[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %85 = llvm.extractvalue %22[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %86 = llvm.mul %66, %83  : i64
          %87 = llvm.add %85, %86  : i64
          %88 = llvm.mlir.constant(0 : i64) : i64
          %89 = llvm.mul %88, %84  : i64
          %90 = llvm.add %87, %89  : i64
          %91 = llvm.insertvalue %90, %82[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %92 = llvm.mlir.constant(784 : i64) : i64
          %93 = llvm.mlir.constant(1 : i64) : i64
          %94 = llvm.insertvalue %92, %91[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %95 = llvm.insertvalue %93, %94[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %96 = llvm.insertvalue %76, %95[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %97 = llvm.insertvalue %92, %96[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %98 = llvm.extractvalue %35[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %99 = llvm.bitcast %98 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %100 = llvm.insertvalue %99, %15[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %101 = llvm.extractvalue %35[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %102 = llvm.bitcast %101 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %103 = llvm.insertvalue %102, %100[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %104 = llvm.extractvalue %35[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %105 = llvm.extractvalue %35[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %106 = llvm.extractvalue %35[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %107 = llvm.mul %88, %104  : i64
          %108 = llvm.add %106, %107  : i64
          %109 = llvm.mul %70, %105  : i64
          %110 = llvm.add %108, %109  : i64
          %111 = llvm.insertvalue %110, %103[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %112 = llvm.mlir.constant(64 : i64) : i64
          %113 = llvm.insertvalue %112, %111[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %114 = llvm.insertvalue %93, %113[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %115 = llvm.mlir.constant(128 : i64) : i64
          %116 = llvm.insertvalue %92, %114[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %117 = llvm.insertvalue %115, %116[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %118 = llvm.extractvalue %49[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %119 = llvm.bitcast %118 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %120 = llvm.insertvalue %119, %15[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %121 = llvm.extractvalue %49[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %122 = llvm.bitcast %121 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %123 = llvm.insertvalue %122, %120[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %124 = llvm.extractvalue %49[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %125 = llvm.extractvalue %49[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %126 = llvm.extractvalue %49[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %127 = llvm.mul %66, %124  : i64
          %128 = llvm.add %126, %127  : i64
          %129 = llvm.mul %70, %125  : i64
          %130 = llvm.add %128, %129  : i64
          %131 = llvm.insertvalue %130, %123[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %132 = llvm.insertvalue %112, %131[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %133 = llvm.insertvalue %93, %132[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %134 = llvm.insertvalue %76, %133[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %135 = llvm.insertvalue %115, %134[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          llvm.br ^bb5(%7 : i64)
        ^bb5(%136: i64):  // 2 preds: ^bb4, ^bb8
          %137 = llvm.icmp "slt" %136, %76 : i64
          llvm.cond_br %137, ^bb6(%7 : i64), ^bb9(%7 : i64)
        ^bb6(%138: i64):  // 2 preds: ^bb5, ^bb7
          %139 = llvm.icmp "slt" %138, %5 : i64
          llvm.cond_br %139, ^bb7, ^bb8
        ^bb7:  // pred: ^bb6
          %140 = llvm.extractvalue %135[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %141 = llvm.extractvalue %135[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %142 = llvm.mul %136, %1  : i64
          %143 = llvm.add %141, %142  : i64
          %144 = llvm.add %143, %138  : i64
          %145 = llvm.getelementptr %140[%144] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
          llvm.store %0, %145 : !llvm.ptr<f32>
          %146 = llvm.add %138, %8  : i64
          llvm.br ^bb6(%146 : i64)
        ^bb8:  // pred: ^bb6
          %147 = llvm.add %136, %8  : i64
          llvm.br ^bb5(%147 : i64)
        ^bb9(%148: i64):  // 2 preds: ^bb5, ^bb28
          %149 = llvm.icmp "slt" %148, %76 : i64
          llvm.cond_br %149, ^bb10(%7 : i64), ^bb29
        ^bb10(%150: i64):  // 2 preds: ^bb9, ^bb27
          %151 = llvm.icmp "slt" %150, %5 : i64
          llvm.cond_br %151, ^bb11(%7 : i64), ^bb28
        ^bb11(%152: i64):  // 2 preds: ^bb10, ^bb26
          %153 = llvm.icmp "slt" %152, %2 : i64
          llvm.cond_br %153, ^bb12, ^bb27
        ^bb12:  // pred: ^bb11
          %154 = llvm.mul %148, %72  : i64
          %155 = llvm.add %76, %154  : i64
          %156 = llvm.icmp "slt" %6, %155 : i64
          %157 = llvm.select %156, %6, %155 : i1, i64
          %158 = llvm.extractvalue %97[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %159 = llvm.bitcast %158 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %160 = llvm.insertvalue %159, %15[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %161 = llvm.extractvalue %97[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %162 = llvm.bitcast %161 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %163 = llvm.insertvalue %162, %160[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %164 = llvm.extractvalue %97[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %165 = llvm.extractvalue %97[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %166 = llvm.extractvalue %97[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %167 = llvm.mul %148, %164  : i64
          %168 = llvm.add %166, %167  : i64
          %169 = llvm.mul %152, %165  : i64
          %170 = llvm.add %168, %169  : i64
          %171 = llvm.insertvalue %170, %163[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %172 = llvm.mlir.constant(28 : i64) : i64
          %173 = llvm.insertvalue %172, %171[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %174 = llvm.insertvalue %93, %173[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %175 = llvm.insertvalue %157, %174[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %176 = llvm.insertvalue %92, %175[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %177 = llvm.extractvalue %117[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %178 = llvm.bitcast %177 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %179 = llvm.insertvalue %178, %15[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %180 = llvm.extractvalue %117[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %181 = llvm.bitcast %180 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %182 = llvm.insertvalue %181, %179[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %183 = llvm.extractvalue %117[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %184 = llvm.extractvalue %117[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %185 = llvm.extractvalue %117[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %186 = llvm.mul %152, %183  : i64
          %187 = llvm.add %185, %186  : i64
          %188 = llvm.mul %150, %184  : i64
          %189 = llvm.add %187, %188  : i64
          %190 = llvm.insertvalue %189, %182[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %191 = llvm.mlir.constant(32 : i64) : i64
          %192 = llvm.insertvalue %191, %190[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %193 = llvm.insertvalue %93, %192[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %194 = llvm.insertvalue %172, %193[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %195 = llvm.insertvalue %115, %194[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %196 = llvm.extractvalue %135[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %197 = llvm.bitcast %196 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %198 = llvm.insertvalue %197, %15[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %199 = llvm.extractvalue %135[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %200 = llvm.bitcast %199 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %201 = llvm.insertvalue %200, %198[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %202 = llvm.extractvalue %135[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %203 = llvm.extractvalue %135[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %204 = llvm.extractvalue %135[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %205 = llvm.mul %148, %202  : i64
          %206 = llvm.add %204, %205  : i64
          %207 = llvm.mul %150, %203  : i64
          %208 = llvm.add %206, %207  : i64
          %209 = llvm.insertvalue %208, %201[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %210 = llvm.insertvalue %191, %209[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %211 = llvm.insertvalue %93, %210[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %212 = llvm.insertvalue %157, %211[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %213 = llvm.insertvalue %115, %212[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          llvm.br ^bb13(%7 : i64)
        ^bb13(%214: i64):  // 2 preds: ^bb12, ^bb25
          %215 = llvm.icmp "slt" %214, %157 : i64
          llvm.cond_br %215, ^bb14(%7 : i64), ^bb26
        ^bb14(%216: i64):  // 2 preds: ^bb13, ^bb24
          %217 = llvm.icmp "slt" %216, %4 : i64
          llvm.cond_br %217, ^bb15(%7 : i64), ^bb25
        ^bb15(%218: i64):  // 2 preds: ^bb14, ^bb23
          %219 = llvm.icmp "slt" %218, %3 : i64
          llvm.cond_br %219, ^bb16, ^bb24
        ^bb16:  // pred: ^bb15
          %220 = llvm.mul %214, %72  : i64
          %221 = llvm.add %157, %220  : i64
          %222 = llvm.icmp "slt" %6, %221 : i64
          %223 = llvm.select %222, %6, %221 : i1, i64
          %224 = llvm.extractvalue %176[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %225 = llvm.bitcast %224 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %226 = llvm.insertvalue %225, %15[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %227 = llvm.extractvalue %176[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %228 = llvm.bitcast %227 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %229 = llvm.insertvalue %228, %226[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %230 = llvm.extractvalue %176[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %231 = llvm.extractvalue %176[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %232 = llvm.extractvalue %176[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %233 = llvm.mul %214, %230  : i64
          %234 = llvm.add %232, %233  : i64
          %235 = llvm.mul %218, %231  : i64
          %236 = llvm.add %234, %235  : i64
          %237 = llvm.insertvalue %236, %229[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %238 = llvm.mlir.constant(4 : i64) : i64
          %239 = llvm.insertvalue %238, %237[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %240 = llvm.insertvalue %93, %239[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %241 = llvm.insertvalue %223, %240[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %242 = llvm.insertvalue %92, %241[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %243 = llvm.extractvalue %195[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %244 = llvm.bitcast %243 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %245 = llvm.insertvalue %244, %15[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %246 = llvm.extractvalue %195[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %247 = llvm.bitcast %246 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %248 = llvm.insertvalue %247, %245[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %249 = llvm.extractvalue %195[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %250 = llvm.extractvalue %195[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %251 = llvm.extractvalue %195[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %252 = llvm.mul %218, %249  : i64
          %253 = llvm.add %251, %252  : i64
          %254 = llvm.mul %216, %250  : i64
          %255 = llvm.add %253, %254  : i64
          %256 = llvm.insertvalue %255, %248[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %257 = llvm.insertvalue %238, %256[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %258 = llvm.insertvalue %93, %257[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %259 = llvm.insertvalue %238, %258[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %260 = llvm.insertvalue %115, %259[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %261 = llvm.extractvalue %213[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %262 = llvm.bitcast %261 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %263 = llvm.insertvalue %262, %15[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %264 = llvm.extractvalue %213[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %265 = llvm.bitcast %264 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %266 = llvm.insertvalue %265, %263[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %267 = llvm.extractvalue %213[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %268 = llvm.extractvalue %213[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %269 = llvm.extractvalue %213[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %270 = llvm.mul %214, %267  : i64
          %271 = llvm.add %269, %270  : i64
          %272 = llvm.mul %216, %268  : i64
          %273 = llvm.add %271, %272  : i64
          %274 = llvm.insertvalue %273, %266[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %275 = llvm.insertvalue %238, %274[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %276 = llvm.insertvalue %93, %275[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %277 = llvm.insertvalue %223, %276[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %278 = llvm.insertvalue %115, %277[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          llvm.br ^bb17(%7 : i64)
        ^bb17(%279: i64):  // 2 preds: ^bb16, ^bb22
          %280 = llvm.icmp "slt" %279, %223 : i64
          llvm.cond_br %280, ^bb18(%7 : i64), ^bb23
        ^bb18(%281: i64):  // 2 preds: ^bb17, ^bb21
          %282 = llvm.icmp "slt" %281, %6 : i64
          llvm.cond_br %282, ^bb19(%7 : i64), ^bb22
        ^bb19(%283: i64):  // 2 preds: ^bb18, ^bb20
          %284 = llvm.icmp "slt" %283, %6 : i64
          llvm.cond_br %284, ^bb20, ^bb21
        ^bb20:  // pred: ^bb19
          %285 = llvm.extractvalue %242[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %286 = llvm.extractvalue %242[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %287 = llvm.mul %279, %2  : i64
          %288 = llvm.add %286, %287  : i64
          %289 = llvm.add %288, %283  : i64
          %290 = llvm.getelementptr %285[%289] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
          %291 = llvm.load %290 : !llvm.ptr<f32>
          %292 = llvm.extractvalue %260[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %293 = llvm.extractvalue %260[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %294 = llvm.mul %283, %1  : i64
          %295 = llvm.add %293, %294  : i64
          %296 = llvm.add %295, %281  : i64
          %297 = llvm.getelementptr %292[%296] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
          %298 = llvm.load %297 : !llvm.ptr<f32>
          %299 = llvm.extractvalue %278[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %300 = llvm.extractvalue %278[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %301 = llvm.mul %279, %1  : i64
          %302 = llvm.add %300, %301  : i64
          %303 = llvm.add %302, %281  : i64
          %304 = llvm.getelementptr %299[%303] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
          %305 = llvm.load %304 : !llvm.ptr<f32>
          %306 = llvm.fmul %291, %298  : f32
          %307 = llvm.fadd %305, %306  : f32
          llvm.store %307, %304 : !llvm.ptr<f32>
          %308 = llvm.add %283, %8  : i64
          llvm.br ^bb19(%308 : i64)
        ^bb21:  // pred: ^bb19
          %309 = llvm.add %281, %8  : i64
          llvm.br ^bb18(%309 : i64)
        ^bb22:  // pred: ^bb18
          %310 = llvm.add %279, %8  : i64
          llvm.br ^bb17(%310 : i64)
        ^bb23:  // pred: ^bb17
          %311 = llvm.add %218, %6  : i64
          llvm.br ^bb15(%311 : i64)
        ^bb24:  // pred: ^bb15
          %312 = llvm.add %216, %6  : i64
          llvm.br ^bb14(%312 : i64)
        ^bb25:  // pred: ^bb14
          %313 = llvm.add %214, %6  : i64
          llvm.br ^bb13(%313 : i64)
        ^bb26:  // pred: ^bb13
          %314 = llvm.add %152, %3  : i64
          llvm.br ^bb11(%314 : i64)
        ^bb27:  // pred: ^bb11
          %315 = llvm.add %150, %4  : i64
          llvm.br ^bb10(%315 : i64)
        ^bb28:  // pred: ^bb10
          %316 = llvm.add %148, %6  : i64
          llvm.br ^bb9(%316 : i64)
        ^bb29:  // pred: ^bb9
          %317 = llvm.add %70, %69  : i64
          llvm.br ^bb3(%317 : i64)
        ^bb30:  // pred: ^bb3
          %318 = llvm.add %66, %65  : i64
          llvm.br ^bb1(%318 : i64)
        ^bb31:  // pred: ^bb1
          %319 = llvm.mlir.constant(0 : i32) : i32
          llvm.return %319 : i32
        }
        llvm.func internal @predict_dispatch_1(%arg0: !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>, %arg1: !llvm.ptr<array<3 x i32>>) -> i32 {
          %0 = llvm.mlir.constant(0x7FC00000 : f32) : f32
          %1 = llvm.mlir.constant(0.000000e+00 : f32) : f32
          %2 = llvm.mlir.constant(128 : index) : i64
          %3 = llvm.mlir.constant(0 : index) : i64
          %4 = llvm.mlir.constant(1 : index) : i64
          %5 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %6 = llvm.extractvalue %5[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %7 = llvm.getelementptr %6[%4] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
          %8 = llvm.load %7 : !llvm.ptr<ptr<i8>>
          %9 = llvm.getelementptr %8[%3] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
          %10 = llvm.bitcast %9 : !llvm.ptr<i8> to !llvm.ptr<f32>
          %11 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %12 = llvm.insertvalue %10, %11[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %13 = llvm.insertvalue %10, %12[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %14 = llvm.insertvalue %3, %13[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %15 = llvm.insertvalue %4, %14[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %16 = llvm.insertvalue %2, %15[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %17 = llvm.insertvalue %2, %16[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %18 = llvm.insertvalue %4, %17[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %19 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %20 = llvm.extractvalue %19[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %21 = llvm.getelementptr %20[%3] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
          %22 = llvm.load %21 : !llvm.ptr<ptr<i8>>
          %23 = llvm.getelementptr %22[%3] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
          %24 = llvm.bitcast %23 : !llvm.ptr<i8> to !llvm.ptr<f32>
          %25 = llvm.insertvalue %24, %11[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %26 = llvm.insertvalue %24, %25[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %27 = llvm.insertvalue %3, %26[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %28 = llvm.insertvalue %4, %27[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %29 = llvm.insertvalue %2, %28[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %30 = llvm.insertvalue %2, %29[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %31 = llvm.insertvalue %4, %30[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %32 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %33 = llvm.extractvalue %32[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %34 = llvm.mlir.constant(2 : index) : i64
          %35 = llvm.getelementptr %33[%34] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
          %36 = llvm.load %35 : !llvm.ptr<ptr<i8>>
          %37 = llvm.getelementptr %36[%3] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
          %38 = llvm.bitcast %37 : !llvm.ptr<i8> to !llvm.ptr<f32>
          %39 = llvm.insertvalue %38, %11[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %40 = llvm.insertvalue %38, %39[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %41 = llvm.insertvalue %3, %40[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %42 = llvm.insertvalue %4, %41[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %43 = llvm.insertvalue %2, %42[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %44 = llvm.insertvalue %2, %43[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %45 = llvm.insertvalue %4, %44[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %46 = llvm.load %arg1 : !llvm.ptr<array<3 x i32>>
          %47 = llvm.extractvalue %46[0] : !llvm.array<3 x i32>
          %48 = llvm.zext %47 : i32 to i64
          %49 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %50 = llvm.extractvalue %49[0] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %51 = llvm.extractvalue %50[0] : !llvm.array<3 x i32>
          %52 = llvm.zext %51 : i32 to i64
          %53 = llvm.load %arg1 : !llvm.ptr<array<3 x i32>>
          %54 = llvm.extractvalue %53[1] : !llvm.array<3 x i32>
          %55 = llvm.zext %54 : i32 to i64
          %56 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %57 = llvm.extractvalue %56[0] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %58 = llvm.extractvalue %57[1] : !llvm.array<3 x i32>
          %59 = llvm.zext %58 : i32 to i64
          %60 = llvm.mul %55, %2  : i64
          %61 = llvm.mul %59, %2  : i64
          llvm.br ^bb1(%60 : i64)
        ^bb1(%62: i64):  // 2 preds: ^bb0, ^bb10
          %63 = llvm.icmp "slt" %62, %4 : i64
          llvm.cond_br %63, ^bb2, ^bb11
        ^bb2:  // pred: ^bb1
          %64 = llvm.mul %48, %2  : i64
          %65 = llvm.mul %52, %2  : i64
          llvm.br ^bb3(%64 : i64)
        ^bb3(%66: i64):  // 2 preds: ^bb2, ^bb9
          %67 = llvm.icmp "slt" %66, %2 : i64
          llvm.cond_br %67, ^bb4, ^bb10
        ^bb4:  // pred: ^bb3
          %68 = llvm.mlir.constant(-1 : index) : i64
          %69 = llvm.mul %62, %68  : i64
          %70 = llvm.add %69, %4  : i64
          %71 = llvm.icmp "slt" %2, %70 : i64
          %72 = llvm.select %71, %2, %70 : i1, i64
          %73 = llvm.extractvalue %18[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %74 = llvm.bitcast %73 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %75 = llvm.insertvalue %74, %11[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %76 = llvm.extractvalue %18[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %77 = llvm.bitcast %76 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %78 = llvm.insertvalue %77, %75[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %79 = llvm.extractvalue %18[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %80 = llvm.extractvalue %18[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %81 = llvm.extractvalue %18[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %82 = llvm.mul %62, %79  : i64
          %83 = llvm.add %81, %82  : i64
          %84 = llvm.mul %66, %80  : i64
          %85 = llvm.add %83, %84  : i64
          %86 = llvm.insertvalue %85, %78[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %87 = llvm.mlir.constant(128 : i64) : i64
          %88 = llvm.mlir.constant(1 : i64) : i64
          %89 = llvm.insertvalue %87, %86[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %90 = llvm.insertvalue %88, %89[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %91 = llvm.insertvalue %72, %90[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %92 = llvm.insertvalue %87, %91[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %93 = llvm.extractvalue %31[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %94 = llvm.bitcast %93 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %95 = llvm.insertvalue %94, %11[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %96 = llvm.extractvalue %31[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %97 = llvm.bitcast %96 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %98 = llvm.insertvalue %97, %95[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %99 = llvm.extractvalue %31[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %100 = llvm.extractvalue %31[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %101 = llvm.extractvalue %31[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %102 = llvm.mul %62, %99  : i64
          %103 = llvm.add %101, %102  : i64
          %104 = llvm.mul %66, %100  : i64
          %105 = llvm.add %103, %104  : i64
          %106 = llvm.insertvalue %105, %98[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %107 = llvm.insertvalue %87, %106[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %108 = llvm.insertvalue %88, %107[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %109 = llvm.insertvalue %72, %108[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %110 = llvm.insertvalue %87, %109[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %111 = llvm.extractvalue %45[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %112 = llvm.bitcast %111 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %113 = llvm.insertvalue %112, %11[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %114 = llvm.extractvalue %45[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %115 = llvm.bitcast %114 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %116 = llvm.insertvalue %115, %113[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %117 = llvm.extractvalue %45[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %118 = llvm.extractvalue %45[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %119 = llvm.extractvalue %45[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %120 = llvm.mul %62, %117  : i64
          %121 = llvm.add %119, %120  : i64
          %122 = llvm.mul %66, %118  : i64
          %123 = llvm.add %121, %122  : i64
          %124 = llvm.insertvalue %123, %116[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %125 = llvm.insertvalue %87, %124[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %126 = llvm.insertvalue %88, %125[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %127 = llvm.insertvalue %72, %126[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %128 = llvm.insertvalue %87, %127[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          llvm.br ^bb5(%3 : i64)
        ^bb5(%129: i64):  // 2 preds: ^bb4, ^bb8
          %130 = llvm.icmp "slt" %129, %72 : i64
          llvm.cond_br %130, ^bb6(%3 : i64), ^bb9
        ^bb6(%131: i64):  // 2 preds: ^bb5, ^bb7
          %132 = llvm.icmp "slt" %131, %2 : i64
          llvm.cond_br %132, ^bb7, ^bb8
        ^bb7:  // pred: ^bb6
          %133 = llvm.extractvalue %92[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %134 = llvm.extractvalue %92[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %135 = llvm.mul %129, %2  : i64
          %136 = llvm.add %134, %135  : i64
          %137 = llvm.add %136, %131  : i64
          %138 = llvm.getelementptr %133[%137] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
          %139 = llvm.load %138 : !llvm.ptr<f32>
          %140 = llvm.extractvalue %110[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %141 = llvm.extractvalue %110[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %142 = llvm.add %141, %135  : i64
          %143 = llvm.add %142, %131  : i64
          %144 = llvm.getelementptr %140[%143] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
          %145 = llvm.load %144 : !llvm.ptr<f32>
          %146 = llvm.fadd %139, %145  : f32
          %147 = llvm.fcmp "ogt" %146, %1 : f32
          %148 = llvm.select %147, %146, %1 : i1, f32
          %149 = llvm.fcmp "uno" %146, %1 : f32
          %150 = llvm.select %149, %0, %148 : i1, f32
          %151 = llvm.extractvalue %128[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %152 = llvm.extractvalue %128[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %153 = llvm.add %152, %135  : i64
          %154 = llvm.add %153, %131  : i64
          %155 = llvm.getelementptr %151[%154] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
          llvm.store %150, %155 : !llvm.ptr<f32>
          %156 = llvm.add %131, %4  : i64
          llvm.br ^bb6(%156 : i64)
        ^bb8:  // pred: ^bb6
          %157 = llvm.add %129, %4  : i64
          llvm.br ^bb5(%157 : i64)
        ^bb9:  // pred: ^bb5
          %158 = llvm.add %66, %65  : i64
          llvm.br ^bb3(%158 : i64)
        ^bb10:  // pred: ^bb3
          %159 = llvm.add %62, %61  : i64
          llvm.br ^bb1(%159 : i64)
        ^bb11:  // pred: ^bb1
          %160 = llvm.mlir.constant(0 : i32) : i32
          llvm.return %160 : i32
        }
        llvm.func internal @predict_dispatch_2(%arg0: !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>, %arg1: !llvm.ptr<array<3 x i32>>) -> i32 {
          %0 = llvm.mlir.constant(0.000000e+00 : f32) : f32
          %1 = llvm.mlir.constant(10 : index) : i64
          %2 = llvm.mlir.constant(128 : index) : i64
          %3 = llvm.mlir.constant(32 : index) : i64
          %4 = llvm.mlir.constant(4 : index) : i64
          %5 = llvm.mlir.constant(0 : index) : i64
          %6 = llvm.mlir.constant(1 : index) : i64
          %7 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %8 = llvm.extractvalue %7[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %9 = llvm.getelementptr %8[%6] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
          %10 = llvm.load %9 : !llvm.ptr<ptr<i8>>
          %11 = llvm.getelementptr %10[%5] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
          %12 = llvm.bitcast %11 : !llvm.ptr<i8> to !llvm.ptr<f32>
          %13 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %14 = llvm.insertvalue %12, %13[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %15 = llvm.insertvalue %12, %14[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %16 = llvm.insertvalue %5, %15[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %17 = llvm.insertvalue %6, %16[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %18 = llvm.insertvalue %2, %17[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %19 = llvm.insertvalue %2, %18[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %20 = llvm.insertvalue %6, %19[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %21 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %22 = llvm.extractvalue %21[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %23 = llvm.getelementptr %22[%5] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
          %24 = llvm.load %23 : !llvm.ptr<ptr<i8>>
          %25 = llvm.getelementptr %24[%5] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
          %26 = llvm.bitcast %25 : !llvm.ptr<i8> to !llvm.ptr<f32>
          %27 = llvm.insertvalue %26, %13[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %28 = llvm.insertvalue %26, %27[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %29 = llvm.insertvalue %5, %28[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %30 = llvm.insertvalue %2, %29[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %31 = llvm.insertvalue %1, %30[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %32 = llvm.insertvalue %1, %31[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %33 = llvm.insertvalue %6, %32[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %34 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %35 = llvm.extractvalue %34[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %36 = llvm.mlir.constant(2 : index) : i64
          %37 = llvm.getelementptr %35[%36] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
          %38 = llvm.load %37 : !llvm.ptr<ptr<i8>>
          %39 = llvm.getelementptr %38[%5] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
          %40 = llvm.bitcast %39 : !llvm.ptr<i8> to !llvm.ptr<f32>
          %41 = llvm.insertvalue %40, %13[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %42 = llvm.insertvalue %40, %41[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %43 = llvm.insertvalue %5, %42[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %44 = llvm.insertvalue %6, %43[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %45 = llvm.insertvalue %1, %44[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %46 = llvm.insertvalue %1, %45[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %47 = llvm.insertvalue %6, %46[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %48 = llvm.load %arg1 : !llvm.ptr<array<3 x i32>>
          %49 = llvm.extractvalue %48[0] : !llvm.array<3 x i32>
          %50 = llvm.zext %49 : i32 to i64
          %51 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %52 = llvm.extractvalue %51[0] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %53 = llvm.extractvalue %52[0] : !llvm.array<3 x i32>
          %54 = llvm.zext %53 : i32 to i64
          %55 = llvm.load %arg1 : !llvm.ptr<array<3 x i32>>
          %56 = llvm.extractvalue %55[1] : !llvm.array<3 x i32>
          %57 = llvm.zext %56 : i32 to i64
          %58 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %59 = llvm.extractvalue %58[0] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %60 = llvm.extractvalue %59[1] : !llvm.array<3 x i32>
          %61 = llvm.zext %60 : i32 to i64
          %62 = llvm.mul %57, %4  : i64
          %63 = llvm.mul %61, %4  : i64
          llvm.br ^bb1(%62 : i64)
        ^bb1(%64: i64):  // 2 preds: ^bb0, ^bb30
          %65 = llvm.icmp "slt" %64, %6 : i64
          llvm.cond_br %65, ^bb2, ^bb31
        ^bb2:  // pred: ^bb1
          %66 = llvm.mlir.constant(64 : index) : i64
          %67 = llvm.mul %50, %66  : i64
          %68 = llvm.mul %54, %66  : i64
          llvm.br ^bb3(%67 : i64)
        ^bb3(%69: i64):  // 2 preds: ^bb2, ^bb29
          %70 = llvm.icmp "slt" %69, %1 : i64
          llvm.cond_br %70, ^bb4, ^bb30
        ^bb4:  // pred: ^bb3
          %71 = llvm.mlir.constant(-1 : index) : i64
          %72 = llvm.mul %64, %71  : i64
          %73 = llvm.add %72, %6  : i64
          %74 = llvm.icmp "slt" %4, %73 : i64
          %75 = llvm.select %74, %4, %73 : i1, i64
          %76 = llvm.extractvalue %20[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %77 = llvm.bitcast %76 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %78 = llvm.insertvalue %77, %13[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %79 = llvm.extractvalue %20[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %80 = llvm.bitcast %79 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %81 = llvm.insertvalue %80, %78[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %82 = llvm.extractvalue %20[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %83 = llvm.extractvalue %20[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %84 = llvm.extractvalue %20[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %85 = llvm.mul %64, %82  : i64
          %86 = llvm.add %84, %85  : i64
          %87 = llvm.mlir.constant(0 : i64) : i64
          %88 = llvm.mul %87, %83  : i64
          %89 = llvm.add %86, %88  : i64
          %90 = llvm.insertvalue %89, %81[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %91 = llvm.mlir.constant(128 : i64) : i64
          %92 = llvm.mlir.constant(1 : i64) : i64
          %93 = llvm.insertvalue %91, %90[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %94 = llvm.insertvalue %92, %93[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %95 = llvm.insertvalue %75, %94[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %96 = llvm.insertvalue %91, %95[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %97 = llvm.mul %69, %71  : i64
          %98 = llvm.add %97, %1  : i64
          %99 = llvm.icmp "slt" %66, %98 : i64
          %100 = llvm.select %99, %66, %98 : i1, i64
          %101 = llvm.extractvalue %33[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %102 = llvm.bitcast %101 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %103 = llvm.insertvalue %102, %13[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %104 = llvm.extractvalue %33[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %105 = llvm.bitcast %104 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %106 = llvm.insertvalue %105, %103[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %107 = llvm.extractvalue %33[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %108 = llvm.extractvalue %33[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %109 = llvm.extractvalue %33[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %110 = llvm.mul %87, %107  : i64
          %111 = llvm.add %109, %110  : i64
          %112 = llvm.mul %69, %108  : i64
          %113 = llvm.add %111, %112  : i64
          %114 = llvm.insertvalue %113, %106[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %115 = llvm.insertvalue %100, %114[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %116 = llvm.insertvalue %92, %115[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %117 = llvm.mlir.constant(10 : i64) : i64
          %118 = llvm.insertvalue %91, %116[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %119 = llvm.insertvalue %117, %118[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %120 = llvm.extractvalue %47[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %121 = llvm.bitcast %120 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %122 = llvm.insertvalue %121, %13[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %123 = llvm.extractvalue %47[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %124 = llvm.bitcast %123 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %125 = llvm.insertvalue %124, %122[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %126 = llvm.extractvalue %47[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %127 = llvm.extractvalue %47[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %128 = llvm.extractvalue %47[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %129 = llvm.mul %64, %126  : i64
          %130 = llvm.add %128, %129  : i64
          %131 = llvm.mul %69, %127  : i64
          %132 = llvm.add %130, %131  : i64
          %133 = llvm.insertvalue %132, %125[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %134 = llvm.insertvalue %100, %133[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %135 = llvm.insertvalue %92, %134[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %136 = llvm.insertvalue %75, %135[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %137 = llvm.insertvalue %117, %136[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          llvm.br ^bb5(%5 : i64)
        ^bb5(%138: i64):  // 2 preds: ^bb4, ^bb8
          %139 = llvm.icmp "slt" %138, %75 : i64
          llvm.cond_br %139, ^bb6(%5 : i64), ^bb9(%5 : i64)
        ^bb6(%140: i64):  // 2 preds: ^bb5, ^bb7
          %141 = llvm.icmp "slt" %140, %100 : i64
          llvm.cond_br %141, ^bb7, ^bb8
        ^bb7:  // pred: ^bb6
          %142 = llvm.extractvalue %137[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %143 = llvm.extractvalue %137[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %144 = llvm.mul %138, %1  : i64
          %145 = llvm.add %143, %144  : i64
          %146 = llvm.add %145, %140  : i64
          %147 = llvm.getelementptr %142[%146] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
          llvm.store %0, %147 : !llvm.ptr<f32>
          %148 = llvm.add %140, %6  : i64
          llvm.br ^bb6(%148 : i64)
        ^bb8:  // pred: ^bb6
          %149 = llvm.add %138, %6  : i64
          llvm.br ^bb5(%149 : i64)
        ^bb9(%150: i64):  // 2 preds: ^bb5, ^bb28
          %151 = llvm.icmp "slt" %150, %75 : i64
          llvm.cond_br %151, ^bb10(%5 : i64), ^bb29
        ^bb10(%152: i64):  // 2 preds: ^bb9, ^bb27
          %153 = llvm.icmp "slt" %152, %100 : i64
          llvm.cond_br %153, ^bb11(%5 : i64), ^bb28
        ^bb11(%154: i64):  // 2 preds: ^bb10, ^bb26
          %155 = llvm.icmp "slt" %154, %2 : i64
          llvm.cond_br %155, ^bb12, ^bb27
        ^bb12:  // pred: ^bb11
          %156 = llvm.mul %150, %71  : i64
          %157 = llvm.add %75, %156  : i64
          %158 = llvm.icmp "slt" %4, %157 : i64
          %159 = llvm.select %158, %4, %157 : i1, i64
          %160 = llvm.extractvalue %96[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %161 = llvm.bitcast %160 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %162 = llvm.insertvalue %161, %13[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %163 = llvm.extractvalue %96[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %164 = llvm.bitcast %163 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %165 = llvm.insertvalue %164, %162[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %166 = llvm.extractvalue %96[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %167 = llvm.extractvalue %96[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %168 = llvm.extractvalue %96[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %169 = llvm.mul %150, %166  : i64
          %170 = llvm.add %168, %169  : i64
          %171 = llvm.mul %154, %167  : i64
          %172 = llvm.add %170, %171  : i64
          %173 = llvm.insertvalue %172, %165[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %174 = llvm.mlir.constant(32 : i64) : i64
          %175 = llvm.insertvalue %174, %173[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %176 = llvm.insertvalue %92, %175[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %177 = llvm.insertvalue %159, %176[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %178 = llvm.insertvalue %91, %177[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %179 = llvm.mul %152, %71  : i64
          %180 = llvm.add %100, %179  : i64
          %181 = llvm.icmp "slt" %3, %180 : i64
          %182 = llvm.select %181, %3, %180 : i1, i64
          %183 = llvm.extractvalue %119[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %184 = llvm.bitcast %183 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %185 = llvm.insertvalue %184, %13[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %186 = llvm.extractvalue %119[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %187 = llvm.bitcast %186 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %188 = llvm.insertvalue %187, %185[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %189 = llvm.extractvalue %119[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %190 = llvm.extractvalue %119[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %191 = llvm.extractvalue %119[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %192 = llvm.mul %154, %189  : i64
          %193 = llvm.add %191, %192  : i64
          %194 = llvm.mul %152, %190  : i64
          %195 = llvm.add %193, %194  : i64
          %196 = llvm.insertvalue %195, %188[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %197 = llvm.insertvalue %182, %196[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %198 = llvm.insertvalue %92, %197[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %199 = llvm.insertvalue %174, %198[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %200 = llvm.insertvalue %117, %199[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %201 = llvm.extractvalue %137[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %202 = llvm.bitcast %201 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %203 = llvm.insertvalue %202, %13[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %204 = llvm.extractvalue %137[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %205 = llvm.bitcast %204 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %206 = llvm.insertvalue %205, %203[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %207 = llvm.extractvalue %137[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %208 = llvm.extractvalue %137[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %209 = llvm.extractvalue %137[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %210 = llvm.mul %150, %207  : i64
          %211 = llvm.add %209, %210  : i64
          %212 = llvm.mul %152, %208  : i64
          %213 = llvm.add %211, %212  : i64
          %214 = llvm.insertvalue %213, %206[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %215 = llvm.insertvalue %182, %214[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %216 = llvm.insertvalue %92, %215[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %217 = llvm.insertvalue %159, %216[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %218 = llvm.insertvalue %117, %217[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          llvm.br ^bb13(%5 : i64)
        ^bb13(%219: i64):  // 2 preds: ^bb12, ^bb25
          %220 = llvm.icmp "slt" %219, %159 : i64
          llvm.cond_br %220, ^bb14(%5 : i64), ^bb26
        ^bb14(%221: i64):  // 2 preds: ^bb13, ^bb24
          %222 = llvm.icmp "slt" %221, %182 : i64
          llvm.cond_br %222, ^bb15(%5 : i64), ^bb25
        ^bb15(%223: i64):  // 2 preds: ^bb14, ^bb23
          %224 = llvm.icmp "slt" %223, %3 : i64
          llvm.cond_br %224, ^bb16, ^bb24
        ^bb16:  // pred: ^bb15
          %225 = llvm.mul %219, %71  : i64
          %226 = llvm.add %159, %225  : i64
          %227 = llvm.icmp "slt" %4, %226 : i64
          %228 = llvm.select %227, %4, %226 : i1, i64
          %229 = llvm.extractvalue %178[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %230 = llvm.bitcast %229 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %231 = llvm.insertvalue %230, %13[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %232 = llvm.extractvalue %178[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %233 = llvm.bitcast %232 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %234 = llvm.insertvalue %233, %231[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %235 = llvm.extractvalue %178[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %236 = llvm.extractvalue %178[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %237 = llvm.extractvalue %178[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %238 = llvm.mul %219, %235  : i64
          %239 = llvm.add %237, %238  : i64
          %240 = llvm.mul %223, %236  : i64
          %241 = llvm.add %239, %240  : i64
          %242 = llvm.insertvalue %241, %234[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %243 = llvm.mlir.constant(4 : i64) : i64
          %244 = llvm.insertvalue %243, %242[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %245 = llvm.insertvalue %92, %244[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %246 = llvm.insertvalue %228, %245[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %247 = llvm.insertvalue %91, %246[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %248 = llvm.mul %221, %71  : i64
          %249 = llvm.add %182, %248  : i64
          %250 = llvm.icmp "slt" %4, %249 : i64
          %251 = llvm.select %250, %4, %249 : i1, i64
          %252 = llvm.extractvalue %200[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %253 = llvm.bitcast %252 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %254 = llvm.insertvalue %253, %13[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %255 = llvm.extractvalue %200[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %256 = llvm.bitcast %255 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %257 = llvm.insertvalue %256, %254[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %258 = llvm.extractvalue %200[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %259 = llvm.extractvalue %200[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %260 = llvm.extractvalue %200[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %261 = llvm.mul %223, %258  : i64
          %262 = llvm.add %260, %261  : i64
          %263 = llvm.mul %221, %259  : i64
          %264 = llvm.add %262, %263  : i64
          %265 = llvm.insertvalue %264, %257[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %266 = llvm.insertvalue %251, %265[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %267 = llvm.insertvalue %92, %266[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %268 = llvm.insertvalue %243, %267[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %269 = llvm.insertvalue %117, %268[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %270 = llvm.extractvalue %218[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %271 = llvm.bitcast %270 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %272 = llvm.insertvalue %271, %13[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %273 = llvm.extractvalue %218[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %274 = llvm.bitcast %273 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %275 = llvm.insertvalue %274, %272[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %276 = llvm.extractvalue %218[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %277 = llvm.extractvalue %218[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %278 = llvm.extractvalue %218[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %279 = llvm.mul %219, %276  : i64
          %280 = llvm.add %278, %279  : i64
          %281 = llvm.mul %221, %277  : i64
          %282 = llvm.add %280, %281  : i64
          %283 = llvm.insertvalue %282, %275[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %284 = llvm.insertvalue %251, %283[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %285 = llvm.insertvalue %92, %284[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %286 = llvm.insertvalue %228, %285[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %287 = llvm.insertvalue %117, %286[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          llvm.br ^bb17(%5 : i64)
        ^bb17(%288: i64):  // 2 preds: ^bb16, ^bb22
          %289 = llvm.icmp "slt" %288, %228 : i64
          llvm.cond_br %289, ^bb18(%5 : i64), ^bb23
        ^bb18(%290: i64):  // 2 preds: ^bb17, ^bb21
          %291 = llvm.icmp "slt" %290, %251 : i64
          llvm.cond_br %291, ^bb19(%5 : i64), ^bb22
        ^bb19(%292: i64):  // 2 preds: ^bb18, ^bb20
          %293 = llvm.icmp "slt" %292, %4 : i64
          llvm.cond_br %293, ^bb20, ^bb21
        ^bb20:  // pred: ^bb19
          %294 = llvm.extractvalue %247[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %295 = llvm.extractvalue %247[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %296 = llvm.mul %288, %2  : i64
          %297 = llvm.add %295, %296  : i64
          %298 = llvm.add %297, %292  : i64
          %299 = llvm.getelementptr %294[%298] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
          %300 = llvm.load %299 : !llvm.ptr<f32>
          %301 = llvm.extractvalue %269[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %302 = llvm.extractvalue %269[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %303 = llvm.mul %292, %1  : i64
          %304 = llvm.add %302, %303  : i64
          %305 = llvm.add %304, %290  : i64
          %306 = llvm.getelementptr %301[%305] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
          %307 = llvm.load %306 : !llvm.ptr<f32>
          %308 = llvm.extractvalue %287[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %309 = llvm.extractvalue %287[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %310 = llvm.mul %288, %1  : i64
          %311 = llvm.add %309, %310  : i64
          %312 = llvm.add %311, %290  : i64
          %313 = llvm.getelementptr %308[%312] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
          %314 = llvm.load %313 : !llvm.ptr<f32>
          %315 = llvm.fmul %300, %307  : f32
          %316 = llvm.fadd %314, %315  : f32
          llvm.store %316, %313 : !llvm.ptr<f32>
          %317 = llvm.add %292, %6  : i64
          llvm.br ^bb19(%317 : i64)
        ^bb21:  // pred: ^bb19
          %318 = llvm.add %290, %6  : i64
          llvm.br ^bb18(%318 : i64)
        ^bb22:  // pred: ^bb18
          %319 = llvm.add %288, %6  : i64
          llvm.br ^bb17(%319 : i64)
        ^bb23:  // pred: ^bb17
          %320 = llvm.add %223, %4  : i64
          llvm.br ^bb15(%320 : i64)
        ^bb24:  // pred: ^bb15
          %321 = llvm.add %221, %4  : i64
          llvm.br ^bb14(%321 : i64)
        ^bb25:  // pred: ^bb14
          %322 = llvm.add %219, %4  : i64
          llvm.br ^bb13(%322 : i64)
        ^bb26:  // pred: ^bb13
          %323 = llvm.add %154, %3  : i64
          llvm.br ^bb11(%323 : i64)
        ^bb27:  // pred: ^bb11
          %324 = llvm.add %152, %3  : i64
          llvm.br ^bb10(%324 : i64)
        ^bb28:  // pred: ^bb10
          %325 = llvm.add %150, %4  : i64
          llvm.br ^bb9(%325 : i64)
        ^bb29:  // pred: ^bb9
          %326 = llvm.add %69, %68  : i64
          llvm.br ^bb3(%326 : i64)
        ^bb30:  // pred: ^bb3
          %327 = llvm.add %64, %63  : i64
          llvm.br ^bb1(%327 : i64)
        ^bb31:  // pred: ^bb1
          %328 = llvm.mlir.constant(0 : i32) : i32
          llvm.return %328 : i32
        }
        llvm.mlir.global private constant @__constant_1x10xf32_3(opaque<"_", "0xDEADBEEF"> : tensor<1x10xf32>) : !llvm.array<1 x array<10 x f32>>
        llvm.func internal @predict_dispatch_3(%arg0: !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>, %arg1: !llvm.ptr<array<3 x i32>>) -> i32 {
          %0 = llvm.mlir.constant(10 : index) : i64
          %1 = llvm.mlir.constant(0 : index) : i64
          %2 = llvm.mlir.constant(1 : index) : i64
          %3 = llvm.mlir.addressof @__constant_1x10xf32_3 : !llvm.ptr<array<1 x array<10 x f32>>>
          %4 = llvm.getelementptr %3[%1, %1, %1] : (!llvm.ptr<array<1 x array<10 x f32>>>, i64, i64, i64) -> !llvm.ptr<f32>
          %5 = llvm.mlir.constant(3735928559 : index) : i64
          %6 = llvm.inttoptr %5 : i64 to !llvm.ptr<f32>
          %7 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %8 = llvm.insertvalue %6, %7[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %9 = llvm.insertvalue %4, %8[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %10 = llvm.insertvalue %1, %9[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %11 = llvm.insertvalue %2, %10[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %12 = llvm.insertvalue %0, %11[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %13 = llvm.insertvalue %0, %12[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %14 = llvm.insertvalue %2, %13[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %15 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %16 = llvm.extractvalue %15[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %17 = llvm.getelementptr %16[%1] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
          %18 = llvm.load %17 : !llvm.ptr<ptr<i8>>
          %19 = llvm.getelementptr %18[%1] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
          %20 = llvm.bitcast %19 : !llvm.ptr<i8> to !llvm.ptr<f32>
          %21 = llvm.insertvalue %20, %7[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %22 = llvm.insertvalue %20, %21[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %23 = llvm.insertvalue %1, %22[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %24 = llvm.insertvalue %2, %23[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %25 = llvm.insertvalue %0, %24[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %26 = llvm.insertvalue %0, %25[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %27 = llvm.insertvalue %2, %26[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %28 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %29 = llvm.extractvalue %28[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %30 = llvm.getelementptr %29[%2] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
          %31 = llvm.load %30 : !llvm.ptr<ptr<i8>>
          %32 = llvm.getelementptr %31[%1] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
          %33 = llvm.bitcast %32 : !llvm.ptr<i8> to !llvm.ptr<f32>
          %34 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %35 = llvm.insertvalue %33, %34[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %36 = llvm.insertvalue %33, %35[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %37 = llvm.insertvalue %1, %36[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %38 = llvm.insertvalue %0, %37[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %39 = llvm.insertvalue %2, %38[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %40 = llvm.load %arg1 : !llvm.ptr<array<3 x i32>>
          %41 = llvm.extractvalue %40[0] : !llvm.array<3 x i32>
          %42 = llvm.zext %41 : i32 to i64
          %43 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %44 = llvm.extractvalue %43[0] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %45 = llvm.extractvalue %44[0] : !llvm.array<3 x i32>
          %46 = llvm.zext %45 : i32 to i64
          %47 = llvm.load %arg1 : !llvm.ptr<array<3 x i32>>
          %48 = llvm.extractvalue %47[1] : !llvm.array<3 x i32>
          %49 = llvm.zext %48 : i32 to i64
          %50 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %51 = llvm.extractvalue %50[0] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %52 = llvm.extractvalue %51[1] : !llvm.array<3 x i32>
          %53 = llvm.zext %52 : i32 to i64
          %54 = llvm.mlir.constant(128 : index) : i64
          %55 = llvm.mul %49, %54  : i64
          %56 = llvm.mul %53, %54  : i64
          llvm.br ^bb1(%55 : i64)
        ^bb1(%57: i64):  // 2 preds: ^bb0, ^bb10
          %58 = llvm.icmp "slt" %57, %2 : i64
          llvm.cond_br %58, ^bb2, ^bb11
        ^bb2:  // pred: ^bb1
          %59 = llvm.mul %42, %54  : i64
          %60 = llvm.mul %46, %54  : i64
          llvm.br ^bb3(%59 : i64)
        ^bb3(%61: i64):  // 2 preds: ^bb2, ^bb9
          %62 = llvm.icmp "slt" %61, %0 : i64
          llvm.cond_br %62, ^bb4, ^bb10
        ^bb4:  // pred: ^bb3
          %63 = llvm.mlir.constant(-1 : index) : i64
          %64 = llvm.mul %57, %63  : i64
          %65 = llvm.add %64, %2  : i64
          %66 = llvm.icmp "slt" %54, %65 : i64
          %67 = llvm.select %66, %54, %65 : i1, i64
          %68 = llvm.mul %61, %63  : i64
          %69 = llvm.add %68, %0  : i64
          %70 = llvm.icmp "slt" %54, %69 : i64
          %71 = llvm.select %70, %54, %69 : i1, i64
          %72 = llvm.extractvalue %27[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %73 = llvm.bitcast %72 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %74 = llvm.insertvalue %73, %7[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %75 = llvm.extractvalue %27[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %76 = llvm.bitcast %75 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %77 = llvm.insertvalue %76, %74[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %78 = llvm.extractvalue %27[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %79 = llvm.extractvalue %27[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %80 = llvm.extractvalue %27[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %81 = llvm.mul %57, %78  : i64
          %82 = llvm.add %80, %81  : i64
          %83 = llvm.mul %61, %79  : i64
          %84 = llvm.add %82, %83  : i64
          %85 = llvm.insertvalue %84, %77[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %86 = llvm.mlir.constant(1 : i64) : i64
          %87 = llvm.insertvalue %71, %85[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %88 = llvm.insertvalue %86, %87[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %89 = llvm.mlir.constant(10 : i64) : i64
          %90 = llvm.insertvalue %67, %88[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %91 = llvm.insertvalue %89, %90[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %92 = llvm.extractvalue %14[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %93 = llvm.bitcast %92 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %94 = llvm.insertvalue %93, %7[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %95 = llvm.extractvalue %14[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %96 = llvm.bitcast %95 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %97 = llvm.insertvalue %96, %94[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %98 = llvm.extractvalue %14[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %99 = llvm.extractvalue %14[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %100 = llvm.extractvalue %14[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %101 = llvm.mul %57, %98  : i64
          %102 = llvm.add %100, %101  : i64
          %103 = llvm.mul %61, %99  : i64
          %104 = llvm.add %102, %103  : i64
          %105 = llvm.insertvalue %104, %97[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %106 = llvm.insertvalue %71, %105[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %107 = llvm.insertvalue %86, %106[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %108 = llvm.insertvalue %67, %107[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %109 = llvm.insertvalue %89, %108[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %110 = llvm.extractvalue %39[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %111 = llvm.bitcast %110 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %112 = llvm.insertvalue %111, %34[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %113 = llvm.extractvalue %39[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %114 = llvm.bitcast %113 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %115 = llvm.insertvalue %114, %112[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %116 = llvm.extractvalue %39[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %117 = llvm.extractvalue %39[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %118 = llvm.mul %61, %116  : i64
          %119 = llvm.add %117, %118  : i64
          %120 = llvm.insertvalue %119, %115[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %121 = llvm.insertvalue %71, %120[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %122 = llvm.insertvalue %86, %121[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          llvm.br ^bb5(%1 : i64)
        ^bb5(%123: i64):  // 2 preds: ^bb4, ^bb8
          %124 = llvm.icmp "slt" %123, %67 : i64
          llvm.cond_br %124, ^bb6(%1 : i64), ^bb9
        ^bb6(%125: i64):  // 2 preds: ^bb5, ^bb7
          %126 = llvm.icmp "slt" %125, %71 : i64
          llvm.cond_br %126, ^bb7, ^bb8
        ^bb7:  // pred: ^bb6
          %127 = llvm.extractvalue %91[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %128 = llvm.extractvalue %91[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %129 = llvm.mul %123, %0  : i64
          %130 = llvm.add %128, %129  : i64
          %131 = llvm.add %130, %125  : i64
          %132 = llvm.getelementptr %127[%131] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
          %133 = llvm.load %132 : !llvm.ptr<f32>
          %134 = llvm.extractvalue %109[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %135 = llvm.extractvalue %109[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %136 = llvm.add %135, %129  : i64
          %137 = llvm.add %136, %125  : i64
          %138 = llvm.getelementptr %134[%137] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
          %139 = llvm.load %138 : !llvm.ptr<f32>
          %140 = llvm.fadd %133, %139  : f32
          %141 = llvm.extractvalue %122[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %142 = llvm.extractvalue %122[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %143 = llvm.add %142, %125  : i64
          %144 = llvm.getelementptr %141[%143] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
          llvm.store %140, %144 : !llvm.ptr<f32>
          %145 = llvm.add %125, %2  : i64
          llvm.br ^bb6(%145 : i64)
        ^bb8:  // pred: ^bb6
          %146 = llvm.add %123, %2  : i64
          llvm.br ^bb5(%146 : i64)
        ^bb9:  // pred: ^bb5
          %147 = llvm.add %61, %60  : i64
          llvm.br ^bb3(%147 : i64)
        ^bb10:  // pred: ^bb3
          %148 = llvm.add %57, %56  : i64
          llvm.br ^bb1(%148 : i64)
        ^bb11:  // pred: ^bb1
          %149 = llvm.mlir.constant(0 : i32) : i32
          llvm.return %149 : i32
        }
        llvm.func internal @predict_dispatch_4(%arg0: !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>, %arg1: !llvm.ptr<array<3 x i32>>) -> i32 {
          %0 = llvm.mlir.constant(0x7FC00000 : f32) : f32
          %1 = llvm.mlir.constant(0xFF800000 : f32) : f32
          %2 = llvm.mlir.constant(10 : index) : i64
          %3 = llvm.mlir.constant(0 : index) : i64
          %4 = llvm.mlir.constant(1 : index) : i64
          %5 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %6 = llvm.extractvalue %5[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %7 = llvm.getelementptr %6[%3] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
          %8 = llvm.load %7 : !llvm.ptr<ptr<i8>>
          %9 = llvm.getelementptr %8[%3] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
          %10 = llvm.bitcast %9 : !llvm.ptr<i8> to !llvm.ptr<f32>
          %11 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %12 = llvm.insertvalue %10, %11[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %13 = llvm.insertvalue %10, %12[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %14 = llvm.insertvalue %3, %13[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %15 = llvm.insertvalue %2, %14[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %16 = llvm.insertvalue %4, %15[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %17 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %18 = llvm.extractvalue %17[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %19 = llvm.getelementptr %18[%4] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
          %20 = llvm.load %19 : !llvm.ptr<ptr<i8>>
          %21 = llvm.getelementptr %20[%3] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
          %22 = llvm.bitcast %21 : !llvm.ptr<i8> to !llvm.ptr<f32>
          %23 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
          %24 = llvm.insertvalue %22, %23[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
          %25 = llvm.insertvalue %22, %24[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
          %26 = llvm.insertvalue %3, %25[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
          %27 = llvm.extractvalue %26[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
          llvm.store %1, %27 : !llvm.ptr<f32>
          llvm.br ^bb1(%3 : i64)
        ^bb1(%28: i64):  // 2 preds: ^bb0, ^bb2
          %29 = llvm.icmp "slt" %28, %2 : i64
          llvm.cond_br %29, ^bb2, ^bb3
        ^bb2:  // pred: ^bb1
          %30 = llvm.extractvalue %16[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %31 = llvm.getelementptr %30[%28] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
          %32 = llvm.load %31 : !llvm.ptr<f32>
          %33 = llvm.load %27 : !llvm.ptr<f32>
          %34 = llvm.fcmp "ogt" %32, %33 : f32
          %35 = llvm.select %34, %32, %33 : i1, f32
          %36 = llvm.fcmp "uno" %32, %33 : f32
          %37 = llvm.select %36, %0, %35 : i1, f32
          llvm.store %37, %27 : !llvm.ptr<f32>
          %38 = llvm.add %28, %4  : i64
          llvm.br ^bb1(%38 : i64)
        ^bb3:  // pred: ^bb1
          %39 = llvm.mlir.constant(0 : i32) : i32
          llvm.return %39 : i32
        }
        llvm.mlir.global private constant @__constant_1x10xf32_5(opaque<"_", "0xDEADBEEF"> : tensor<1x10xf32>) : !llvm.array<1 x array<10 x f32>>
        llvm.func internal @predict_dispatch_5(%arg0: !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>, %arg1: !llvm.ptr<array<3 x i32>>) -> i32 {
          %0 = llvm.mlir.constant(10 : index) : i64
          %1 = llvm.mlir.constant(0 : index) : i64
          %2 = llvm.mlir.constant(1 : index) : i64
          %3 = llvm.mlir.constant(0.693147182 : f32) : f32
          %4 = llvm.mlir.constant(1.44269502 : f32) : f32
          %5 = llvm.mlir.constant(1.000000e+00 : f32) : f32
          %6 = llvm.mlir.constant(0.499705136 : f32) : f32
          %7 = llvm.mlir.constant(0.168738902 : f32) : f32
          %8 = llvm.mlir.constant(0.0366896503 : f32) : f32
          %9 = llvm.mlir.constant(1.314350e-02 : f32) : f32
          %10 = llvm.mlir.constant(23 : i32) : i32
          %11 = llvm.mlir.constant(0.000000e+00 : f32) : f32
          %12 = llvm.mlir.constant(0x7F800000 : f32) : f32
          %13 = llvm.mlir.constant(0xFF800000 : f32) : f32
          %14 = llvm.mlir.constant(1.17549435E-38 : f32) : f32
          %15 = llvm.mlir.constant(127 : i32) : i32
          %16 = llvm.mlir.constant(-127 : i32) : i32
          %17 = llvm.mlir.addressof @__constant_1x10xf32_5 : !llvm.ptr<array<1 x array<10 x f32>>>
          %18 = llvm.getelementptr %17[%1, %1, %1] : (!llvm.ptr<array<1 x array<10 x f32>>>, i64, i64, i64) -> !llvm.ptr<f32>
          %19 = llvm.mlir.constant(3735928559 : index) : i64
          %20 = llvm.inttoptr %19 : i64 to !llvm.ptr<f32>
          %21 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %22 = llvm.insertvalue %20, %21[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %23 = llvm.insertvalue %18, %22[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %24 = llvm.insertvalue %1, %23[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %25 = llvm.insertvalue %2, %24[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %26 = llvm.insertvalue %0, %25[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %27 = llvm.insertvalue %0, %26[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %28 = llvm.insertvalue %2, %27[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %29 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %30 = llvm.extractvalue %29[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %31 = llvm.getelementptr %30[%1] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
          %32 = llvm.load %31 : !llvm.ptr<ptr<i8>>
          %33 = llvm.getelementptr %32[%1] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
          %34 = llvm.bitcast %33 : !llvm.ptr<i8> to !llvm.ptr<f32>
          %35 = llvm.insertvalue %34, %21[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %36 = llvm.insertvalue %34, %35[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %37 = llvm.insertvalue %1, %36[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %38 = llvm.insertvalue %2, %37[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %39 = llvm.insertvalue %0, %38[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %40 = llvm.insertvalue %0, %39[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %41 = llvm.insertvalue %2, %40[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %42 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %43 = llvm.extractvalue %42[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %44 = llvm.getelementptr %43[%2] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
          %45 = llvm.load %44 : !llvm.ptr<ptr<i8>>
          %46 = llvm.getelementptr %45[%1] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
          %47 = llvm.bitcast %46 : !llvm.ptr<i8> to !llvm.ptr<f32>
          %48 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
          %49 = llvm.insertvalue %47, %48[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
          %50 = llvm.insertvalue %47, %49[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
          %51 = llvm.insertvalue %1, %50[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
          %52 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %53 = llvm.extractvalue %52[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %54 = llvm.mlir.constant(2 : index) : i64
          %55 = llvm.getelementptr %53[%54] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
          %56 = llvm.load %55 : !llvm.ptr<ptr<i8>>
          %57 = llvm.getelementptr %56[%1] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
          %58 = llvm.bitcast %57 : !llvm.ptr<i8> to !llvm.ptr<f32>
          %59 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %60 = llvm.insertvalue %58, %59[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %61 = llvm.insertvalue %58, %60[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %62 = llvm.insertvalue %1, %61[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %63 = llvm.insertvalue %0, %62[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %64 = llvm.insertvalue %2, %63[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %65 = llvm.load %arg1 : !llvm.ptr<array<3 x i32>>
          %66 = llvm.extractvalue %65[0] : !llvm.array<3 x i32>
          %67 = llvm.zext %66 : i32 to i64
          %68 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %69 = llvm.extractvalue %68[0] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %70 = llvm.extractvalue %69[0] : !llvm.array<3 x i32>
          %71 = llvm.zext %70 : i32 to i64
          %72 = llvm.load %arg1 : !llvm.ptr<array<3 x i32>>
          %73 = llvm.extractvalue %72[1] : !llvm.array<3 x i32>
          %74 = llvm.zext %73 : i32 to i64
          %75 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %76 = llvm.extractvalue %75[0] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %77 = llvm.extractvalue %76[1] : !llvm.array<3 x i32>
          %78 = llvm.zext %77 : i32 to i64
          %79 = llvm.mlir.constant(128 : index) : i64
          %80 = llvm.mul %74, %79  : i64
          %81 = llvm.mul %78, %79  : i64
          llvm.br ^bb1(%80 : i64)
        ^bb1(%82: i64):  // 2 preds: ^bb0, ^bb10
          %83 = llvm.icmp "slt" %82, %2 : i64
          llvm.cond_br %83, ^bb2, ^bb11
        ^bb2:  // pred: ^bb1
          %84 = llvm.mul %67, %79  : i64
          %85 = llvm.mul %71, %79  : i64
          llvm.br ^bb3(%84 : i64)
        ^bb3(%86: i64):  // 2 preds: ^bb2, ^bb9
          %87 = llvm.icmp "slt" %86, %0 : i64
          llvm.cond_br %87, ^bb4, ^bb10
        ^bb4:  // pred: ^bb3
          %88 = llvm.mlir.constant(-1 : index) : i64
          %89 = llvm.mul %82, %88  : i64
          %90 = llvm.add %89, %2  : i64
          %91 = llvm.icmp "slt" %79, %90 : i64
          %92 = llvm.select %91, %79, %90 : i1, i64
          %93 = llvm.mul %86, %88  : i64
          %94 = llvm.add %93, %0  : i64
          %95 = llvm.icmp "slt" %79, %94 : i64
          %96 = llvm.select %95, %79, %94 : i1, i64
          %97 = llvm.extractvalue %41[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %98 = llvm.bitcast %97 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %99 = llvm.insertvalue %98, %21[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %100 = llvm.extractvalue %41[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %101 = llvm.bitcast %100 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %102 = llvm.insertvalue %101, %99[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %103 = llvm.extractvalue %41[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %104 = llvm.extractvalue %41[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %105 = llvm.extractvalue %41[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %106 = llvm.mul %82, %103  : i64
          %107 = llvm.add %105, %106  : i64
          %108 = llvm.mul %86, %104  : i64
          %109 = llvm.add %107, %108  : i64
          %110 = llvm.insertvalue %109, %102[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %111 = llvm.mlir.constant(1 : i64) : i64
          %112 = llvm.insertvalue %96, %110[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %113 = llvm.insertvalue %111, %112[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %114 = llvm.mlir.constant(10 : i64) : i64
          %115 = llvm.insertvalue %92, %113[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %116 = llvm.insertvalue %114, %115[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %117 = llvm.extractvalue %28[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %118 = llvm.bitcast %117 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %119 = llvm.insertvalue %118, %21[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %120 = llvm.extractvalue %28[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %121 = llvm.bitcast %120 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %122 = llvm.insertvalue %121, %119[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %123 = llvm.extractvalue %28[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %124 = llvm.extractvalue %28[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %125 = llvm.extractvalue %28[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %126 = llvm.mul %82, %123  : i64
          %127 = llvm.add %125, %126  : i64
          %128 = llvm.mul %86, %124  : i64
          %129 = llvm.add %127, %128  : i64
          %130 = llvm.insertvalue %129, %122[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %131 = llvm.insertvalue %96, %130[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %132 = llvm.insertvalue %111, %131[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %133 = llvm.insertvalue %92, %132[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %134 = llvm.insertvalue %114, %133[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %135 = llvm.extractvalue %64[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %136 = llvm.bitcast %135 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %137 = llvm.insertvalue %136, %59[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %138 = llvm.extractvalue %64[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %139 = llvm.bitcast %138 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %140 = llvm.insertvalue %139, %137[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %141 = llvm.extractvalue %64[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %142 = llvm.extractvalue %64[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %143 = llvm.mul %86, %141  : i64
          %144 = llvm.add %142, %143  : i64
          %145 = llvm.insertvalue %144, %140[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %146 = llvm.insertvalue %96, %145[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %147 = llvm.insertvalue %111, %146[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          llvm.br ^bb5(%1 : i64)
        ^bb5(%148: i64):  // 2 preds: ^bb4, ^bb8
          %149 = llvm.icmp "slt" %148, %92 : i64
          llvm.cond_br %149, ^bb6(%1 : i64), ^bb9
        ^bb6(%150: i64):  // 2 preds: ^bb5, ^bb7
          %151 = llvm.icmp "slt" %150, %96 : i64
          llvm.cond_br %151, ^bb7, ^bb8
        ^bb7:  // pred: ^bb6
          %152 = llvm.extractvalue %116[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %153 = llvm.extractvalue %116[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %154 = llvm.mul %148, %0  : i64
          %155 = llvm.add %153, %154  : i64
          %156 = llvm.add %155, %150  : i64
          %157 = llvm.getelementptr %152[%156] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
          %158 = llvm.load %157 : !llvm.ptr<f32>
          %159 = llvm.extractvalue %134[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %160 = llvm.extractvalue %134[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %161 = llvm.add %160, %154  : i64
          %162 = llvm.add %161, %150  : i64
          %163 = llvm.getelementptr %159[%162] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
          %164 = llvm.load %163 : !llvm.ptr<f32>
          %165 = llvm.extractvalue %51[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
          %166 = llvm.load %165 : !llvm.ptr<f32>
          %167 = llvm.fadd %158, %164  : f32
          %168 = llvm.fsub %167, %166  : f32
          %169 = llvm.fmul %168, %4  : f32
          %170 = "llvm.intr.floor"(%169) : (f32) -> f32
          %171 = llvm.fmul %170, %3  : f32
          %172 = llvm.fsub %168, %171  : f32
          %173 = llvm.fmul %172, %172  : f32
          %174 = llvm.fmul %173, %173  : f32
          %175 = "llvm.intr.fma"(%5, %172, %5) : (f32, f32, f32) -> f32
          %176 = "llvm.intr.fma"(%7, %172, %6) : (f32, f32, f32) -> f32
          %177 = "llvm.intr.fma"(%9, %172, %8) : (f32, f32, f32) -> f32
          %178 = "llvm.intr.fma"(%176, %173, %175) : (f32, f32, f32) -> f32
          %179 = "llvm.intr.fma"(%177, %174, %178) : (f32, f32, f32) -> f32
          %180 = llvm.fptosi %170 : f32 to i32
          %181 = llvm.add %180, %15  : i32
          %182 = llvm.shl %181, %10  : i32
          %183 = llvm.bitcast %182 : i32 to f32
          %184 = llvm.fmul %179, %183  : f32
          %185 = llvm.icmp "sle" %180, %15 : i32
          %186 = llvm.icmp "sge" %180, %16 : i32
          %187 = llvm.fcmp "oeq" %168, %13 : f32
          %188 = llvm.fcmp "ogt" %168, %11 : f32
          %189 = llvm.and %185, %186  : i1
          %190 = llvm.select %187, %11, %14 : i1, f32
          %191 = llvm.select %188, %12, %190 : i1, f32
          %192 = llvm.select %189, %184, %191 : i1, f32
          %193 = llvm.extractvalue %147[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %194 = llvm.extractvalue %147[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %195 = llvm.add %194, %150  : i64
          %196 = llvm.getelementptr %193[%195] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
          llvm.store %192, %196 : !llvm.ptr<f32>
          %197 = llvm.add %150, %2  : i64
          llvm.br ^bb6(%197 : i64)
        ^bb8:  // pred: ^bb6
          %198 = llvm.add %148, %2  : i64
          llvm.br ^bb5(%198 : i64)
        ^bb9:  // pred: ^bb5
          %199 = llvm.add %86, %85  : i64
          llvm.br ^bb3(%199 : i64)
        ^bb10:  // pred: ^bb3
          %200 = llvm.add %82, %81  : i64
          llvm.br ^bb1(%200 : i64)
        ^bb11:  // pred: ^bb1
          %201 = llvm.mlir.constant(0 : i32) : i32
          llvm.return %201 : i32
        }
        llvm.func internal @predict_dispatch_6(%arg0: !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>, %arg1: !llvm.ptr<array<3 x i32>>) -> i32 {
          %0 = llvm.mlir.constant(0.000000e+00 : f32) : f32
          %1 = llvm.mlir.constant(10 : index) : i64
          %2 = llvm.mlir.constant(0 : index) : i64
          %3 = llvm.mlir.constant(1 : index) : i64
          %4 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %5 = llvm.extractvalue %4[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %6 = llvm.getelementptr %5[%2] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
          %7 = llvm.load %6 : !llvm.ptr<ptr<i8>>
          %8 = llvm.getelementptr %7[%2] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
          %9 = llvm.bitcast %8 : !llvm.ptr<i8> to !llvm.ptr<f32>
          %10 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %11 = llvm.insertvalue %9, %10[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %12 = llvm.insertvalue %9, %11[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %13 = llvm.insertvalue %2, %12[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %14 = llvm.insertvalue %1, %13[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %15 = llvm.insertvalue %3, %14[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %16 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %17 = llvm.extractvalue %16[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %18 = llvm.getelementptr %17[%3] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
          %19 = llvm.load %18 : !llvm.ptr<ptr<i8>>
          %20 = llvm.getelementptr %19[%2] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
          %21 = llvm.bitcast %20 : !llvm.ptr<i8> to !llvm.ptr<f32>
          %22 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
          %23 = llvm.insertvalue %21, %22[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
          %24 = llvm.insertvalue %21, %23[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
          %25 = llvm.insertvalue %2, %24[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
          %26 = llvm.extractvalue %25[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
          llvm.store %0, %26 : !llvm.ptr<f32>
          llvm.br ^bb1(%2 : i64)
        ^bb1(%27: i64):  // 2 preds: ^bb0, ^bb2
          %28 = llvm.icmp "slt" %27, %1 : i64
          llvm.cond_br %28, ^bb2, ^bb3
        ^bb2:  // pred: ^bb1
          %29 = llvm.extractvalue %15[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %30 = llvm.getelementptr %29[%27] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
          %31 = llvm.load %30 : !llvm.ptr<f32>
          %32 = llvm.load %26 : !llvm.ptr<f32>
          %33 = llvm.fadd %31, %32  : f32
          llvm.store %33, %26 : !llvm.ptr<f32>
          %34 = llvm.add %27, %3  : i64
          llvm.br ^bb1(%34 : i64)
        ^bb3:  // pred: ^bb1
          %35 = llvm.mlir.constant(0 : i32) : i32
          llvm.return %35 : i32
        }
        llvm.mlir.global private constant @__constant_1x10xf32_7(opaque<"_", "0xDEADBEEF"> : tensor<1x10xf32>) : !llvm.array<1 x array<10 x f32>>
        llvm.func internal @predict_dispatch_7(%arg0: !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>, %arg1: !llvm.ptr<array<3 x i32>>) -> i32 {
          %0 = llvm.mlir.constant(10 : index) : i64
          %1 = llvm.mlir.constant(0 : index) : i64
          %2 = llvm.mlir.constant(1 : index) : i64
          %3 = llvm.mlir.constant(0.693147182 : f32) : f32
          %4 = llvm.mlir.constant(1.44269502 : f32) : f32
          %5 = llvm.mlir.constant(1.000000e+00 : f32) : f32
          %6 = llvm.mlir.constant(0.499705136 : f32) : f32
          %7 = llvm.mlir.constant(0.168738902 : f32) : f32
          %8 = llvm.mlir.constant(0.0366896503 : f32) : f32
          %9 = llvm.mlir.constant(1.314350e-02 : f32) : f32
          %10 = llvm.mlir.constant(23 : i32) : i32
          %11 = llvm.mlir.constant(0.000000e+00 : f32) : f32
          %12 = llvm.mlir.constant(0x7F800000 : f32) : f32
          %13 = llvm.mlir.constant(0xFF800000 : f32) : f32
          %14 = llvm.mlir.constant(1.17549435E-38 : f32) : f32
          %15 = llvm.mlir.constant(127 : i32) : i32
          %16 = llvm.mlir.constant(-127 : i32) : i32
          %17 = llvm.mlir.addressof @__constant_1x10xf32_7 : !llvm.ptr<array<1 x array<10 x f32>>>
          %18 = llvm.getelementptr %17[%1, %1, %1] : (!llvm.ptr<array<1 x array<10 x f32>>>, i64, i64, i64) -> !llvm.ptr<f32>
          %19 = llvm.mlir.constant(3735928559 : index) : i64
          %20 = llvm.inttoptr %19 : i64 to !llvm.ptr<f32>
          %21 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %22 = llvm.insertvalue %20, %21[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %23 = llvm.insertvalue %18, %22[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %24 = llvm.insertvalue %1, %23[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %25 = llvm.insertvalue %2, %24[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %26 = llvm.insertvalue %0, %25[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %27 = llvm.insertvalue %0, %26[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %28 = llvm.insertvalue %2, %27[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %29 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %30 = llvm.extractvalue %29[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %31 = llvm.getelementptr %30[%1] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
          %32 = llvm.load %31 : !llvm.ptr<ptr<i8>>
          %33 = llvm.getelementptr %32[%1] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
          %34 = llvm.bitcast %33 : !llvm.ptr<i8> to !llvm.ptr<f32>
          %35 = llvm.insertvalue %34, %21[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %36 = llvm.insertvalue %34, %35[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %37 = llvm.insertvalue %1, %36[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %38 = llvm.insertvalue %2, %37[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %39 = llvm.insertvalue %0, %38[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %40 = llvm.insertvalue %0, %39[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %41 = llvm.insertvalue %2, %40[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %42 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %43 = llvm.extractvalue %42[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %44 = llvm.getelementptr %43[%2] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
          %45 = llvm.load %44 : !llvm.ptr<ptr<i8>>
          %46 = llvm.getelementptr %45[%1] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
          %47 = llvm.bitcast %46 : !llvm.ptr<i8> to !llvm.ptr<f32>
          %48 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
          %49 = llvm.insertvalue %47, %48[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
          %50 = llvm.insertvalue %47, %49[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
          %51 = llvm.insertvalue %1, %50[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
          %52 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %53 = llvm.extractvalue %52[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %54 = llvm.mlir.constant(2 : index) : i64
          %55 = llvm.getelementptr %53[%54] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
          %56 = llvm.load %55 : !llvm.ptr<ptr<i8>>
          %57 = llvm.getelementptr %56[%1] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
          %58 = llvm.bitcast %57 : !llvm.ptr<i8> to !llvm.ptr<f32>
          %59 = llvm.insertvalue %58, %48[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
          %60 = llvm.insertvalue %58, %59[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
          %61 = llvm.insertvalue %1, %60[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
          %62 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %63 = llvm.extractvalue %62[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %64 = llvm.mlir.constant(3 : index) : i64
          %65 = llvm.getelementptr %63[%64] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
          %66 = llvm.load %65 : !llvm.ptr<ptr<i8>>
          %67 = llvm.getelementptr %66[%1] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
          %68 = llvm.bitcast %67 : !llvm.ptr<i8> to !llvm.ptr<f32>
          %69 = llvm.insertvalue %68, %21[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %70 = llvm.insertvalue %68, %69[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %71 = llvm.insertvalue %1, %70[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %72 = llvm.insertvalue %2, %71[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %73 = llvm.insertvalue %0, %72[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %74 = llvm.insertvalue %0, %73[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %75 = llvm.insertvalue %2, %74[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %76 = llvm.load %arg1 : !llvm.ptr<array<3 x i32>>
          %77 = llvm.extractvalue %76[0] : !llvm.array<3 x i32>
          %78 = llvm.zext %77 : i32 to i64
          %79 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %80 = llvm.extractvalue %79[0] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %81 = llvm.extractvalue %80[0] : !llvm.array<3 x i32>
          %82 = llvm.zext %81 : i32 to i64
          %83 = llvm.load %arg1 : !llvm.ptr<array<3 x i32>>
          %84 = llvm.extractvalue %83[1] : !llvm.array<3 x i32>
          %85 = llvm.zext %84 : i32 to i64
          %86 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %87 = llvm.extractvalue %86[0] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %88 = llvm.extractvalue %87[1] : !llvm.array<3 x i32>
          %89 = llvm.zext %88 : i32 to i64
          %90 = llvm.mlir.constant(128 : index) : i64
          %91 = llvm.mul %85, %90  : i64
          %92 = llvm.mul %89, %90  : i64
          llvm.br ^bb1(%91 : i64)
        ^bb1(%93: i64):  // 2 preds: ^bb0, ^bb10
          %94 = llvm.icmp "slt" %93, %2 : i64
          llvm.cond_br %94, ^bb2, ^bb11
        ^bb2:  // pred: ^bb1
          %95 = llvm.mul %78, %90  : i64
          %96 = llvm.mul %82, %90  : i64
          llvm.br ^bb3(%95 : i64)
        ^bb3(%97: i64):  // 2 preds: ^bb2, ^bb9
          %98 = llvm.icmp "slt" %97, %0 : i64
          llvm.cond_br %98, ^bb4, ^bb10
        ^bb4:  // pred: ^bb3
          %99 = llvm.mlir.constant(-1 : index) : i64
          %100 = llvm.mul %93, %99  : i64
          %101 = llvm.add %100, %2  : i64
          %102 = llvm.icmp "slt" %90, %101 : i64
          %103 = llvm.select %102, %90, %101 : i1, i64
          %104 = llvm.mul %97, %99  : i64
          %105 = llvm.add %104, %0  : i64
          %106 = llvm.icmp "slt" %90, %105 : i64
          %107 = llvm.select %106, %90, %105 : i1, i64
          %108 = llvm.extractvalue %41[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %109 = llvm.bitcast %108 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %110 = llvm.insertvalue %109, %21[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %111 = llvm.extractvalue %41[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %112 = llvm.bitcast %111 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %113 = llvm.insertvalue %112, %110[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %114 = llvm.extractvalue %41[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %115 = llvm.extractvalue %41[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %116 = llvm.extractvalue %41[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %117 = llvm.mul %93, %114  : i64
          %118 = llvm.add %116, %117  : i64
          %119 = llvm.mul %97, %115  : i64
          %120 = llvm.add %118, %119  : i64
          %121 = llvm.insertvalue %120, %113[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %122 = llvm.mlir.constant(1 : i64) : i64
          %123 = llvm.insertvalue %107, %121[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %124 = llvm.insertvalue %122, %123[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %125 = llvm.mlir.constant(10 : i64) : i64
          %126 = llvm.insertvalue %103, %124[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %127 = llvm.insertvalue %125, %126[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %128 = llvm.extractvalue %28[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %129 = llvm.bitcast %128 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %130 = llvm.insertvalue %129, %21[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %131 = llvm.extractvalue %28[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %132 = llvm.bitcast %131 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %133 = llvm.insertvalue %132, %130[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %134 = llvm.extractvalue %28[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %135 = llvm.extractvalue %28[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %136 = llvm.extractvalue %28[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %137 = llvm.mul %93, %134  : i64
          %138 = llvm.add %136, %137  : i64
          %139 = llvm.mul %97, %135  : i64
          %140 = llvm.add %138, %139  : i64
          %141 = llvm.insertvalue %140, %133[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %142 = llvm.insertvalue %107, %141[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %143 = llvm.insertvalue %122, %142[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %144 = llvm.insertvalue %103, %143[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %145 = llvm.insertvalue %125, %144[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %146 = llvm.extractvalue %75[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %147 = llvm.bitcast %146 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %148 = llvm.insertvalue %147, %21[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %149 = llvm.extractvalue %75[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %150 = llvm.bitcast %149 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %151 = llvm.insertvalue %150, %148[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %152 = llvm.extractvalue %75[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %153 = llvm.extractvalue %75[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %154 = llvm.extractvalue %75[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %155 = llvm.mul %93, %152  : i64
          %156 = llvm.add %154, %155  : i64
          %157 = llvm.mul %97, %153  : i64
          %158 = llvm.add %156, %157  : i64
          %159 = llvm.insertvalue %158, %151[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %160 = llvm.insertvalue %107, %159[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %161 = llvm.insertvalue %122, %160[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %162 = llvm.insertvalue %103, %161[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %163 = llvm.insertvalue %125, %162[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          llvm.br ^bb5(%1 : i64)
        ^bb5(%164: i64):  // 2 preds: ^bb4, ^bb8
          %165 = llvm.icmp "slt" %164, %103 : i64
          llvm.cond_br %165, ^bb6(%1 : i64), ^bb9
        ^bb6(%166: i64):  // 2 preds: ^bb5, ^bb7
          %167 = llvm.icmp "slt" %166, %107 : i64
          llvm.cond_br %167, ^bb7, ^bb8
        ^bb7:  // pred: ^bb6
          %168 = llvm.extractvalue %127[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %169 = llvm.extractvalue %127[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %170 = llvm.mul %164, %0  : i64
          %171 = llvm.add %169, %170  : i64
          %172 = llvm.add %171, %166  : i64
          %173 = llvm.getelementptr %168[%172] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
          %174 = llvm.load %173 : !llvm.ptr<f32>
          %175 = llvm.extractvalue %145[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %176 = llvm.extractvalue %145[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %177 = llvm.add %176, %170  : i64
          %178 = llvm.add %177, %166  : i64
          %179 = llvm.getelementptr %175[%178] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
          %180 = llvm.load %179 : !llvm.ptr<f32>
          %181 = llvm.extractvalue %51[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
          %182 = llvm.load %181 : !llvm.ptr<f32>
          %183 = llvm.extractvalue %61[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
          %184 = llvm.load %183 : !llvm.ptr<f32>
          %185 = llvm.fadd %174, %180  : f32
          %186 = llvm.fsub %185, %182  : f32
          %187 = llvm.fmul %186, %4  : f32
          %188 = "llvm.intr.floor"(%187) : (f32) -> f32
          %189 = llvm.fmul %188, %3  : f32
          %190 = llvm.fsub %186, %189  : f32
          %191 = llvm.fmul %190, %190  : f32
          %192 = llvm.fmul %191, %191  : f32
          %193 = "llvm.intr.fma"(%5, %190, %5) : (f32, f32, f32) -> f32
          %194 = "llvm.intr.fma"(%7, %190, %6) : (f32, f32, f32) -> f32
          %195 = "llvm.intr.fma"(%9, %190, %8) : (f32, f32, f32) -> f32
          %196 = "llvm.intr.fma"(%194, %191, %193) : (f32, f32, f32) -> f32
          %197 = "llvm.intr.fma"(%195, %192, %196) : (f32, f32, f32) -> f32
          %198 = llvm.fptosi %188 : f32 to i32
          %199 = llvm.add %198, %15  : i32
          %200 = llvm.shl %199, %10  : i32
          %201 = llvm.bitcast %200 : i32 to f32
          %202 = llvm.fmul %197, %201  : f32
          %203 = llvm.icmp "sle" %198, %15 : i32
          %204 = llvm.icmp "sge" %198, %16 : i32
          %205 = llvm.fcmp "oeq" %186, %13 : f32
          %206 = llvm.fcmp "ogt" %186, %11 : f32
          %207 = llvm.and %203, %204  : i1
          %208 = llvm.select %205, %11, %14 : i1, f32
          %209 = llvm.select %206, %12, %208 : i1, f32
          %210 = llvm.select %207, %202, %209 : i1, f32
          %211 = llvm.fdiv %210, %184  : f32
          %212 = llvm.extractvalue %163[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %213 = llvm.extractvalue %163[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %214 = llvm.add %213, %170  : i64
          %215 = llvm.add %214, %166  : i64
          %216 = llvm.getelementptr %212[%215] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
          llvm.store %211, %216 : !llvm.ptr<f32>
          %217 = llvm.add %166, %2  : i64
          llvm.br ^bb6(%217 : i64)
        ^bb8:  // pred: ^bb6
          %218 = llvm.add %164, %2  : i64
          llvm.br ^bb5(%218 : i64)
        ^bb9:  // pred: ^bb5
          %219 = llvm.add %97, %96  : i64
          llvm.br ^bb3(%219 : i64)
        ^bb10:  // pred: ^bb3
          %220 = llvm.add %93, %92  : i64
          llvm.br ^bb1(%220 : i64)
        ^bb11:  // pred: ^bb1
          %221 = llvm.mlir.constant(0 : i32) : i32
          llvm.return %221 : i32
        }
      }
    }
  }
  hal.constant_pool @_const_pool attributes {buffer_constraints = #hal.buffer_constraints<max_allocation_size = 1073741824, min_buffer_offset_alignment = 16, max_buffer_range = 1073741824, min_buffer_range_alignment = 16>, sym_visibility = "private"} {
    hal.constant_storage @_storage = opaque<"_", "0xDEADBEEF"> : vector<407040xi8> attributes {sym_visibility = "nested"}
  }
  hal.variable @_const_pool_storage_buffer init(@_const_pool_storage_buffer_initializer) : !hal.buffer attributes {sym_visibility = "private"}
  func private @_const_pool_storage_buffer_initializer() -> !hal.buffer {
    %c0 = constant 0 : index
    %c407040 = constant 407040 : index
    %device = hal.ex.shared_device : !hal.device
    %allocator = hal.device.allocator<%device : !hal.device> : !hal.allocator
    %storage = hal.constant_storage.lookup @_const_pool::@_storage : !iree.byte_buffer
    %mapped = hal.allocator.map<%allocator : !hal.allocator> source(%storage : !iree.byte_buffer)[%c0, %c407040] type("HostVisible|DeviceVisible|DeviceLocal") usage("Constant|Transfer|Mapping|Dispatch") : !hal.buffer
    return %mapped : !hal.buffer
  }
  func @predict(%arg0: !hal.buffer) -> !hal.buffer attributes {noinline} {
    %c3136 = constant 3136 : index
    %c401408 = constant 401408 : index
    %c401920 = constant 401920 : index
    %c5120 = constant 5120 : index
    %c40 = constant 40 : index
    %c4 = constant 4 : index
    %c128 = constant 128 : index
    %c1 = constant 1 : index
    %c10 = constant 10 : index
    %c2 = constant 2 : index
    %c3 = constant 3 : index
    %c0 = constant 0 : index
    %c512 = constant 512 : index
    %c96 = constant 96 : index
    %c48 = constant 48 : index
    %c112 = constant 112 : index
    %c1024 = constant 1024 : index
    %device = hal.ex.shared_device : !hal.device
    %allocator = hal.device.allocator<%device : !hal.device> : !hal.allocator
    %buffer = hal.allocator.allocate<%allocator : !hal.allocator> type("HostVisible|DeviceVisible|DeviceLocal") usage("Transfer|Mapping|Dispatch") : !hal.buffer{%c40}
    %0 = hal.variable.load @_const_pool_storage_buffer : !hal.buffer
    %buffer_0 = hal.allocator.allocate<%allocator : !hal.allocator> type("DeviceVisible|DeviceLocal") usage("Transfer|Dispatch") : !hal.buffer{%c1024}
    %cmd = hal.command_buffer.create device(%device : !hal.device) mode("OneShot|AllowInlineExecution") categories("Transfer|Dispatch") : !hal.command_buffer
    hal.command_buffer.begin<%cmd : !hal.command_buffer>
    %1 = hal.variable.load @_executable_layout_0 : !hal.executable_layout
    hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%1 : !hal.executable_layout)[%c0] bindings([
      %c0 = (%0 : !hal.buffer)[%c512, %c401408], 
      %c1 = (%arg0 : !hal.buffer)[%c0, %c3136], 
      %c2 = (%buffer_0 : !hal.buffer)[%c0, %c512]
    ])
    %2 = hal.device.match.id<%device : !hal.device> pattern("dylib*") : i1
    cond_br %2, ^bb1, ^bb2
  ^bb1:  // pred: ^bb0
    %c1_1 = constant 1 : index
    %c2_2 = constant 2 : index
    %c1_3 = constant 1 : index
    %3 = hal.command_buffer.device<%cmd : !hal.command_buffer> : !hal.device
    %4 = hal.variable.load @_executable_mnist_linked_llvm_aot : !hal.executable
    hal.command_buffer.dispatch<%cmd : !hal.command_buffer> target(%4 : !hal.executable)[0] workgroups([%c2_2, %c1_3, %c1_1])
    br ^bb3
  ^bb2:  // pred: ^bb0
    iree.unreachable "device not supported in the compiled configuration"
  ^bb3:  // pred: ^bb1
    hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
    hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%1 : !hal.executable_layout)[%c0] bindings([
      %c0 = (%0 : !hal.buffer)[%c0, %c512], 
      %c1 = (%buffer_0 : !hal.buffer)[%c0, %c512], 
      %c2 = (%buffer_0 : !hal.buffer)[%c512, %c512]
    ])
    %5 = hal.device.match.id<%device : !hal.device> pattern("dylib*") : i1
    cond_br %5, ^bb4, ^bb5
  ^bb4:  // pred: ^bb3
    %c1_4 = constant 1 : index
    %c1_5 = constant 1 : index
    %c1_6 = constant 1 : index
    %6 = hal.command_buffer.device<%cmd : !hal.command_buffer> : !hal.device
    %7 = hal.variable.load @_executable_mnist_linked_llvm_aot : !hal.executable
    hal.command_buffer.dispatch<%cmd : !hal.command_buffer> target(%7 : !hal.executable)[1] workgroups([%c1_5, %c1_6, %c1_4])
    br ^bb6
  ^bb5:  // pred: ^bb3
    iree.unreachable "device not supported in the compiled configuration"
  ^bb6:  // pred: ^bb4
    hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
    hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%1 : !hal.executable_layout)[%c0] bindings([
      %c0 = (%0 : !hal.buffer)[%c401920, %c5120], 
      %c1 = (%buffer_0 : !hal.buffer)[%c512, %c512], 
      %c2 = (%buffer_0 : !hal.buffer)[%c0, %c40]
    ])
    %8 = hal.device.match.id<%device : !hal.device> pattern("dylib*") : i1
    cond_br %8, ^bb7, ^bb8
  ^bb7:  // pred: ^bb6
    %c1_7 = constant 1 : index
    %c1_8 = constant 1 : index
    %c1_9 = constant 1 : index
    %9 = hal.command_buffer.device<%cmd : !hal.command_buffer> : !hal.device
    %10 = hal.variable.load @_executable_mnist_linked_llvm_aot : !hal.executable
    hal.command_buffer.dispatch<%cmd : !hal.command_buffer> target(%10 : !hal.executable)[2] workgroups([%c1_8, %c1_9, %c1_7])
    br ^bb9
  ^bb8:  // pred: ^bb6
    iree.unreachable "device not supported in the compiled configuration"
  ^bb9:  // pred: ^bb7
    hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
    %11 = hal.variable.load @_executable_layout_1 : !hal.executable_layout
    hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%11 : !hal.executable_layout)[%c0] bindings([
      %c0 = (%buffer_0 : !hal.buffer)[%c0, %c40], 
      %c1 = (%buffer_0 : !hal.buffer)[%c48, %c40]
    ])
    %12 = hal.device.match.id<%device : !hal.device> pattern("dylib*") : i1
    cond_br %12, ^bb10, ^bb11
  ^bb10:  // pred: ^bb9
    %c1_10 = constant 1 : index
    %c1_11 = constant 1 : index
    %c1_12 = constant 1 : index
    %13 = hal.command_buffer.device<%cmd : !hal.command_buffer> : !hal.device
    %14 = hal.variable.load @_executable_mnist_linked_llvm_aot : !hal.executable
    hal.command_buffer.dispatch<%cmd : !hal.command_buffer> target(%14 : !hal.executable)[3] workgroups([%c1_11, %c1_12, %c1_10])
    br ^bb12
  ^bb11:  // pred: ^bb9
    iree.unreachable "device not supported in the compiled configuration"
  ^bb12:  // pred: ^bb10
    hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
    hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%11 : !hal.executable_layout)[%c0] bindings([
      %c0 = (%buffer_0 : !hal.buffer)[%c48, %c40], 
      %c1 = (%buffer_0 : !hal.buffer)[%c96, %c4]
    ])
    %15 = hal.device.match.id<%device : !hal.device> pattern("dylib*") : i1
    cond_br %15, ^bb13, ^bb14
  ^bb13:  // pred: ^bb12
    %c1_13 = constant 1 : index
    %16 = hal.command_buffer.device<%cmd : !hal.command_buffer> : !hal.device
    %17 = hal.variable.load @_executable_mnist_linked_llvm_aot : !hal.executable
    hal.command_buffer.dispatch<%cmd : !hal.command_buffer> target(%17 : !hal.executable)[4] workgroups([%c1_13, %c1_13, %c1_13])
    br ^bb15
  ^bb14:  // pred: ^bb12
    iree.unreachable "device not supported in the compiled configuration"
  ^bb15:  // pred: ^bb13
    hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
    hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%1 : !hal.executable_layout)[%c0] bindings([
      %c0 = (%buffer_0 : !hal.buffer)[%c0, %c40], 
      %c1 = (%buffer_0 : !hal.buffer)[%c96, %c4], 
      %c2 = (%buffer_0 : !hal.buffer)[%c48, %c40]
    ])
    %18 = hal.device.match.id<%device : !hal.device> pattern("dylib*") : i1
    cond_br %18, ^bb16, ^bb17
  ^bb16:  // pred: ^bb15
    %c1_14 = constant 1 : index
    %c1_15 = constant 1 : index
    %c1_16 = constant 1 : index
    %19 = hal.command_buffer.device<%cmd : !hal.command_buffer> : !hal.device
    %20 = hal.variable.load @_executable_mnist_linked_llvm_aot : !hal.executable
    hal.command_buffer.dispatch<%cmd : !hal.command_buffer> target(%20 : !hal.executable)[5] workgroups([%c1_15, %c1_16, %c1_14])
    br ^bb18
  ^bb17:  // pred: ^bb15
    iree.unreachable "device not supported in the compiled configuration"
  ^bb18:  // pred: ^bb16
    hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
    hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%11 : !hal.executable_layout)[%c0] bindings([
      %c0 = (%buffer_0 : !hal.buffer)[%c48, %c40], 
      %c1 = (%buffer_0 : !hal.buffer)[%c112, %c4]
    ])
    %21 = hal.device.match.id<%device : !hal.device> pattern("dylib*") : i1
    cond_br %21, ^bb19, ^bb20
  ^bb19:  // pred: ^bb18
    %c1_17 = constant 1 : index
    %22 = hal.command_buffer.device<%cmd : !hal.command_buffer> : !hal.device
    %23 = hal.variable.load @_executable_mnist_linked_llvm_aot : !hal.executable
    hal.command_buffer.dispatch<%cmd : !hal.command_buffer> target(%23 : !hal.executable)[6] workgroups([%c1_17, %c1_17, %c1_17])
    br ^bb21
  ^bb20:  // pred: ^bb18
    iree.unreachable "device not supported in the compiled configuration"
  ^bb21:  // pred: ^bb19
    hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
    %24 = hal.variable.load @_executable_layout_2 : !hal.executable_layout
    hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%24 : !hal.executable_layout)[%c0] bindings([
      %c0 = (%buffer_0 : !hal.buffer)[%c0, %c40], 
      %c1 = (%buffer_0 : !hal.buffer)[%c96, %c4], 
      %c2 = (%buffer_0 : !hal.buffer)[%c112, %c4], 
      %c3 = (%buffer : !hal.buffer)[%c0, %c40]
    ])
    %25 = hal.device.match.id<%device : !hal.device> pattern("dylib*") : i1
    cond_br %25, ^bb22, ^bb23
  ^bb22:  // pred: ^bb21
    %c1_18 = constant 1 : index
    %c1_19 = constant 1 : index
    %c1_20 = constant 1 : index
    %26 = hal.command_buffer.device<%cmd : !hal.command_buffer> : !hal.device
    %27 = hal.variable.load @_executable_mnist_linked_llvm_aot : !hal.executable
    hal.command_buffer.dispatch<%cmd : !hal.command_buffer> target(%27 : !hal.executable)[7] workgroups([%c1_19, %c1_20, %c1_18])
    br ^bb24
  ^bb23:  // pred: ^bb21
    iree.unreachable "device not supported in the compiled configuration"
  ^bb24:  // pred: ^bb22
    hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
    hal.command_buffer.end<%cmd : !hal.command_buffer>
    hal.ex.submit_and_wait %device, %cmd
    return %buffer : !hal.buffer
  }
  func @predict$async(%arg0: !hal.semaphore, %arg1: index, %arg2: !hal.buffer_view, %arg3: !hal.semaphore, %arg4: index) -> !hal.buffer_view attributes {iree.module.export = "predict$async"} {
    %c1 = constant 1 : index
    %c10 = constant 10 : index
    %c50331680_i32 = constant 50331680 : i32
    %0 = hal.semaphore.await<%arg0 : !hal.semaphore> until(%arg1) : i32
    hal.check_success %0, "semaphore wait failed"
    %buffer = hal.buffer_view.buffer %arg2 : !hal.buffer
    %1 = call @predict(%buffer) : (!hal.buffer) -> !hal.buffer
    %view = hal.buffer_view.create %1, element_type = %c50331680_i32, shape = [%c1, %c10] : !hal.buffer -> !hal.buffer_view
    hal.semaphore.signal<%arg3 : !hal.semaphore> value(%arg4)
    return %view : !hal.buffer_view
  }
  func @predict$sync(%arg0: !hal.buffer_view) -> !hal.buffer_view attributes {iree.abi.stub, iree.module.export = "predict", iree.reflection = {abi = "sip", abiv = 1 : i32, f = "I15!B11!d1d28d28d1R9!B6!d1d10", fv = "1", sip = "I8!S5!k0_0R3!_0"}} {
    %c0 = constant 0 : index
    %c1 = constant 1 : index
    %device = hal.ex.shared_device : !hal.device
    %semaphore = hal.semaphore.create device(%device : !hal.device) initial(%c0) : !hal.semaphore
    %0 = call @predict$async(%semaphore, %c0, %arg0, %semaphore, %c1) : (!hal.semaphore, index, !hal.buffer_view, !hal.semaphore, index) -> !hal.buffer_view
    %1 = hal.semaphore.await<%semaphore : !hal.semaphore> until(%c1) : i32
    hal.check_success %1, "semaphore wait failed"
    return %0 : !hal.buffer_view
  }
}


// *** IR Dump After mlir::iree_compiler::IREE::HAL::MemoizeDeviceQueriesPass ***
module  {
  hal.variable @_device_match_id_0 init(@_device_match_id_0_initializer) : i1 attributes {sym_visibility = "private"}
  func private @_device_match_id_0_initializer() -> i1 {
    %device = hal.ex.shared_device : !hal.device
    %0 = hal.device.match.id<%device : !hal.device> pattern("dylib*") : i1
    return %0 : i1
  }
  hal.variable @_descriptor_set_layout_0 init(@_descriptor_set_layout_0_initializer) : !hal.descriptor_set_layout attributes {sym_visibility = "private"}
  func private @_descriptor_set_layout_0_initializer() -> !hal.descriptor_set_layout {
    %device = hal.ex.shared_device : !hal.device
    %descriptor_set_layout = hal.descriptor_set_layout.create device(%device : !hal.device) usage(PushOnly) bindings([#hal.descriptor_set_layout_binding<0, "StorageBuffer", R>, #hal.descriptor_set_layout_binding<1, "StorageBuffer", R>, #hal.descriptor_set_layout_binding<2, "StorageBuffer", DW>]) : !hal.descriptor_set_layout
    return %descriptor_set_layout : !hal.descriptor_set_layout
  }
  hal.variable @_executable_layout_0 init(@_executable_layout_0_initializer) : !hal.executable_layout attributes {sym_visibility = "private"}
  func private @_executable_layout_0_initializer() -> !hal.executable_layout {
    %0 = hal.variable.load @_descriptor_set_layout_0 : !hal.descriptor_set_layout
    %device = hal.ex.shared_device : !hal.device
    %executable_layout = hal.executable_layout.create device(%device : !hal.device) push_constants(0) layouts([%0]) : !hal.executable_layout
    return %executable_layout : !hal.executable_layout
  }
  hal.variable @_descriptor_set_layout_1 init(@_descriptor_set_layout_1_initializer) : !hal.descriptor_set_layout attributes {sym_visibility = "private"}
  func private @_descriptor_set_layout_1_initializer() -> !hal.descriptor_set_layout {
    %device = hal.ex.shared_device : !hal.device
    %descriptor_set_layout = hal.descriptor_set_layout.create device(%device : !hal.device) usage(PushOnly) bindings([#hal.descriptor_set_layout_binding<0, "StorageBuffer", R>, #hal.descriptor_set_layout_binding<1, "StorageBuffer", DW>]) : !hal.descriptor_set_layout
    return %descriptor_set_layout : !hal.descriptor_set_layout
  }
  hal.variable @_executable_layout_1 init(@_executable_layout_1_initializer) : !hal.executable_layout attributes {sym_visibility = "private"}
  func private @_executable_layout_1_initializer() -> !hal.executable_layout {
    %0 = hal.variable.load @_descriptor_set_layout_1 : !hal.descriptor_set_layout
    %device = hal.ex.shared_device : !hal.device
    %executable_layout = hal.executable_layout.create device(%device : !hal.device) push_constants(0) layouts([%0]) : !hal.executable_layout
    return %executable_layout : !hal.executable_layout
  }
  hal.variable @_descriptor_set_layout_2 init(@_descriptor_set_layout_2_initializer) : !hal.descriptor_set_layout attributes {sym_visibility = "private"}
  func private @_descriptor_set_layout_2_initializer() -> !hal.descriptor_set_layout {
    %device = hal.ex.shared_device : !hal.device
    %descriptor_set_layout = hal.descriptor_set_layout.create device(%device : !hal.device) usage(PushOnly) bindings([#hal.descriptor_set_layout_binding<0, "StorageBuffer", R>, #hal.descriptor_set_layout_binding<1, "StorageBuffer", R>, #hal.descriptor_set_layout_binding<2, "StorageBuffer", R>, #hal.descriptor_set_layout_binding<3, "StorageBuffer", DW>]) : !hal.descriptor_set_layout
    return %descriptor_set_layout : !hal.descriptor_set_layout
  }
  hal.variable @_executable_layout_2 init(@_executable_layout_2_initializer) : !hal.executable_layout attributes {sym_visibility = "private"}
  func private @_executable_layout_2_initializer() -> !hal.executable_layout {
    %0 = hal.variable.load @_descriptor_set_layout_2 : !hal.descriptor_set_layout
    %device = hal.ex.shared_device : !hal.device
    %executable_layout = hal.executable_layout.create device(%device : !hal.device) push_constants(0) layouts([%0]) : !hal.executable_layout
    return %executable_layout : !hal.executable_layout
  }
  hal.variable @_executable_mnist_linked_llvm_aot init(@_executable_mnist_linked_llvm_aot_initializer) : !hal.executable attributes {sym_visibility = "private"}
  func private @_executable_mnist_linked_llvm_aot_initializer() -> !hal.executable {
    %device = hal.ex.shared_device : !hal.device
    %0 = hal.variable.load @_device_match_id_0 : i1
    cond_br %0, ^bb1, ^bb2
  ^bb1:  // pred: ^bb0
    %1 = hal.variable.load @_executable_layout_0 : !hal.executable_layout
    %2 = hal.variable.load @_executable_layout_0 : !hal.executable_layout
    %3 = hal.variable.load @_executable_layout_0 : !hal.executable_layout
    %4 = hal.variable.load @_executable_layout_1 : !hal.executable_layout
    %5 = hal.variable.load @_executable_layout_1 : !hal.executable_layout
    %6 = hal.variable.load @_executable_layout_0 : !hal.executable_layout
    %7 = hal.variable.load @_executable_layout_1 : !hal.executable_layout
    %8 = hal.variable.load @_executable_layout_2 : !hal.executable_layout
    %exe = hal.executable.create device(%device : !hal.device) target(@mnist_linked_llvm_aot::@llvm_aot) layouts([%1, %2, %3, %4, %5, %6, %7, %8]) : !hal.executable
    br ^bb5(%exe : !hal.executable)
  ^bb2:  // pred: ^bb0
    %true = constant true
    cond_br %true, ^bb3, ^bb4
  ^bb3:  // pred: ^bb2
    %9 = iree.null : !hal.executable
    br ^bb5(%9 : !hal.executable)
  ^bb4:  // pred: ^bb2
    iree.unreachable "device not supported in the compiled configuration"
  ^bb5(%10: !hal.executable):  // 2 preds: ^bb1, ^bb3
    return %10 : !hal.executable
  }
  hal.executable @mnist_linked_llvm_aot attributes {sym_visibility = "private"} {
    hal.interface @io_0 {
      hal.interface.binding @s0b0_ro_constant, set=0, binding=0, type="StorageBuffer", access="Read"
      hal.interface.binding @s0b1_ro_external, set=0, binding=1, type="StorageBuffer", access="Read"
      hal.interface.binding @s0b2_xw_external, set=0, binding=2, type="StorageBuffer", access="Write|Discard"
    }
    hal.interface @io_1 {
      hal.interface.binding @s0b0_ro_external, set=0, binding=0, type="StorageBuffer", access="Read"
      hal.interface.binding @s0b1_xw_external, set=0, binding=1, type="StorageBuffer", access="Write|Discard"
    }
    hal.interface @io_2 {
      hal.interface.binding @s0b0_ro_external, set=0, binding=0, type="StorageBuffer", access="Read"
      hal.interface.binding @s0b1_ro_external, set=0, binding=1, type="StorageBuffer", access="Read"
      hal.interface.binding @s0b2_xw_external, set=0, binding=2, type="StorageBuffer", access="Write|Discard"
    }
    hal.interface @io_3 {
      hal.interface.binding @s0b0_ro_external, set=0, binding=0, type="StorageBuffer", access="Read"
      hal.interface.binding @s0b1_ro_external, set=0, binding=1, type="StorageBuffer", access="Read"
      hal.interface.binding @s0b2_ro_external, set=0, binding=2, type="StorageBuffer", access="Read"
      hal.interface.binding @s0b3_xw_external, set=0, binding=3, type="StorageBuffer", access="Write|Discard"
    }
    hal.executable.target @llvm_aot, filter="dylib*" {
      hal.executable.entry_point @predict_dispatch_0 attributes {interface = @io_0, ordinal = 0 : index}
      hal.executable.entry_point @predict_dispatch_1 attributes {interface = @io_0, ordinal = 1 : index}
      hal.executable.entry_point @predict_dispatch_2 attributes {interface = @io_0, ordinal = 2 : index}
      hal.executable.entry_point @predict_dispatch_3 attributes {interface = @io_1, ordinal = 3 : index}
      hal.executable.entry_point @predict_dispatch_4 attributes {interface = @io_1, ordinal = 4 : index}
      hal.executable.entry_point @predict_dispatch_5 attributes {interface = @io_2, ordinal = 5 : index}
      hal.executable.entry_point @predict_dispatch_6 attributes {interface = @io_1, ordinal = 6 : index}
      hal.executable.entry_point @predict_dispatch_7 attributes {interface = @io_3, ordinal = 7 : index}
      module  {
        llvm.func internal @predict_dispatch_0(%arg0: !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>, %arg1: !llvm.ptr<array<3 x i32>>) -> i32 {
          %0 = llvm.mlir.constant(0.000000e+00 : f32) : f32
          %1 = llvm.mlir.constant(128 : index) : i64
          %2 = llvm.mlir.constant(784 : index) : i64
          %3 = llvm.mlir.constant(28 : index) : i64
          %4 = llvm.mlir.constant(32 : index) : i64
          %5 = llvm.mlir.constant(64 : index) : i64
          %6 = llvm.mlir.constant(4 : index) : i64
          %7 = llvm.mlir.constant(0 : index) : i64
          %8 = llvm.mlir.constant(1 : index) : i64
          %9 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %10 = llvm.extractvalue %9[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %11 = llvm.getelementptr %10[%8] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
          %12 = llvm.load %11 : !llvm.ptr<ptr<i8>>
          %13 = llvm.getelementptr %12[%7] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
          %14 = llvm.bitcast %13 : !llvm.ptr<i8> to !llvm.ptr<f32>
          %15 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %16 = llvm.insertvalue %14, %15[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %17 = llvm.insertvalue %14, %16[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %18 = llvm.insertvalue %7, %17[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %19 = llvm.insertvalue %8, %18[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %20 = llvm.insertvalue %2, %19[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %21 = llvm.insertvalue %2, %20[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %22 = llvm.insertvalue %8, %21[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %23 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %24 = llvm.extractvalue %23[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %25 = llvm.getelementptr %24[%7] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
          %26 = llvm.load %25 : !llvm.ptr<ptr<i8>>
          %27 = llvm.getelementptr %26[%7] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
          %28 = llvm.bitcast %27 : !llvm.ptr<i8> to !llvm.ptr<f32>
          %29 = llvm.insertvalue %28, %15[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %30 = llvm.insertvalue %28, %29[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %31 = llvm.insertvalue %7, %30[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %32 = llvm.insertvalue %2, %31[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %33 = llvm.insertvalue %1, %32[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %34 = llvm.insertvalue %1, %33[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %35 = llvm.insertvalue %8, %34[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %36 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %37 = llvm.extractvalue %36[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %38 = llvm.mlir.constant(2 : index) : i64
          %39 = llvm.getelementptr %37[%38] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
          %40 = llvm.load %39 : !llvm.ptr<ptr<i8>>
          %41 = llvm.getelementptr %40[%7] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
          %42 = llvm.bitcast %41 : !llvm.ptr<i8> to !llvm.ptr<f32>
          %43 = llvm.insertvalue %42, %15[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %44 = llvm.insertvalue %42, %43[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %45 = llvm.insertvalue %7, %44[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %46 = llvm.insertvalue %8, %45[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %47 = llvm.insertvalue %1, %46[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %48 = llvm.insertvalue %1, %47[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %49 = llvm.insertvalue %8, %48[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %50 = llvm.load %arg1 : !llvm.ptr<array<3 x i32>>
          %51 = llvm.extractvalue %50[0] : !llvm.array<3 x i32>
          %52 = llvm.zext %51 : i32 to i64
          %53 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %54 = llvm.extractvalue %53[0] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %55 = llvm.extractvalue %54[0] : !llvm.array<3 x i32>
          %56 = llvm.zext %55 : i32 to i64
          %57 = llvm.load %arg1 : !llvm.ptr<array<3 x i32>>
          %58 = llvm.extractvalue %57[1] : !llvm.array<3 x i32>
          %59 = llvm.zext %58 : i32 to i64
          %60 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %61 = llvm.extractvalue %60[0] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %62 = llvm.extractvalue %61[1] : !llvm.array<3 x i32>
          %63 = llvm.zext %62 : i32 to i64
          %64 = llvm.mul %59, %6  : i64
          %65 = llvm.mul %63, %6  : i64
          llvm.br ^bb1(%64 : i64)
        ^bb1(%66: i64):  // 2 preds: ^bb0, ^bb30
          %67 = llvm.icmp "slt" %66, %8 : i64
          llvm.cond_br %67, ^bb2, ^bb31
        ^bb2:  // pred: ^bb1
          %68 = llvm.mul %52, %5  : i64
          %69 = llvm.mul %56, %5  : i64
          llvm.br ^bb3(%68 : i64)
        ^bb3(%70: i64):  // 2 preds: ^bb2, ^bb29
          %71 = llvm.icmp "slt" %70, %1 : i64
          llvm.cond_br %71, ^bb4, ^bb30
        ^bb4:  // pred: ^bb3
          %72 = llvm.mlir.constant(-1 : index) : i64
          %73 = llvm.mul %66, %72  : i64
          %74 = llvm.add %73, %8  : i64
          %75 = llvm.icmp "slt" %6, %74 : i64
          %76 = llvm.select %75, %6, %74 : i1, i64
          %77 = llvm.extractvalue %22[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %78 = llvm.bitcast %77 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %79 = llvm.insertvalue %78, %15[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %80 = llvm.extractvalue %22[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %81 = llvm.bitcast %80 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %82 = llvm.insertvalue %81, %79[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %83 = llvm.extractvalue %22[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %84 = llvm.extractvalue %22[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %85 = llvm.extractvalue %22[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %86 = llvm.mul %66, %83  : i64
          %87 = llvm.add %85, %86  : i64
          %88 = llvm.mlir.constant(0 : i64) : i64
          %89 = llvm.mul %88, %84  : i64
          %90 = llvm.add %87, %89  : i64
          %91 = llvm.insertvalue %90, %82[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %92 = llvm.mlir.constant(784 : i64) : i64
          %93 = llvm.mlir.constant(1 : i64) : i64
          %94 = llvm.insertvalue %92, %91[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %95 = llvm.insertvalue %93, %94[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %96 = llvm.insertvalue %76, %95[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %97 = llvm.insertvalue %92, %96[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %98 = llvm.extractvalue %35[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %99 = llvm.bitcast %98 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %100 = llvm.insertvalue %99, %15[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %101 = llvm.extractvalue %35[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %102 = llvm.bitcast %101 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %103 = llvm.insertvalue %102, %100[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %104 = llvm.extractvalue %35[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %105 = llvm.extractvalue %35[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %106 = llvm.extractvalue %35[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %107 = llvm.mul %88, %104  : i64
          %108 = llvm.add %106, %107  : i64
          %109 = llvm.mul %70, %105  : i64
          %110 = llvm.add %108, %109  : i64
          %111 = llvm.insertvalue %110, %103[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %112 = llvm.mlir.constant(64 : i64) : i64
          %113 = llvm.insertvalue %112, %111[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %114 = llvm.insertvalue %93, %113[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %115 = llvm.mlir.constant(128 : i64) : i64
          %116 = llvm.insertvalue %92, %114[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %117 = llvm.insertvalue %115, %116[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %118 = llvm.extractvalue %49[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %119 = llvm.bitcast %118 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %120 = llvm.insertvalue %119, %15[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %121 = llvm.extractvalue %49[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %122 = llvm.bitcast %121 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %123 = llvm.insertvalue %122, %120[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %124 = llvm.extractvalue %49[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %125 = llvm.extractvalue %49[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %126 = llvm.extractvalue %49[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %127 = llvm.mul %66, %124  : i64
          %128 = llvm.add %126, %127  : i64
          %129 = llvm.mul %70, %125  : i64
          %130 = llvm.add %128, %129  : i64
          %131 = llvm.insertvalue %130, %123[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %132 = llvm.insertvalue %112, %131[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %133 = llvm.insertvalue %93, %132[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %134 = llvm.insertvalue %76, %133[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %135 = llvm.insertvalue %115, %134[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          llvm.br ^bb5(%7 : i64)
        ^bb5(%136: i64):  // 2 preds: ^bb4, ^bb8
          %137 = llvm.icmp "slt" %136, %76 : i64
          llvm.cond_br %137, ^bb6(%7 : i64), ^bb9(%7 : i64)
        ^bb6(%138: i64):  // 2 preds: ^bb5, ^bb7
          %139 = llvm.icmp "slt" %138, %5 : i64
          llvm.cond_br %139, ^bb7, ^bb8
        ^bb7:  // pred: ^bb6
          %140 = llvm.extractvalue %135[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %141 = llvm.extractvalue %135[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %142 = llvm.mul %136, %1  : i64
          %143 = llvm.add %141, %142  : i64
          %144 = llvm.add %143, %138  : i64
          %145 = llvm.getelementptr %140[%144] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
          llvm.store %0, %145 : !llvm.ptr<f32>
          %146 = llvm.add %138, %8  : i64
          llvm.br ^bb6(%146 : i64)
        ^bb8:  // pred: ^bb6
          %147 = llvm.add %136, %8  : i64
          llvm.br ^bb5(%147 : i64)
        ^bb9(%148: i64):  // 2 preds: ^bb5, ^bb28
          %149 = llvm.icmp "slt" %148, %76 : i64
          llvm.cond_br %149, ^bb10(%7 : i64), ^bb29
        ^bb10(%150: i64):  // 2 preds: ^bb9, ^bb27
          %151 = llvm.icmp "slt" %150, %5 : i64
          llvm.cond_br %151, ^bb11(%7 : i64), ^bb28
        ^bb11(%152: i64):  // 2 preds: ^bb10, ^bb26
          %153 = llvm.icmp "slt" %152, %2 : i64
          llvm.cond_br %153, ^bb12, ^bb27
        ^bb12:  // pred: ^bb11
          %154 = llvm.mul %148, %72  : i64
          %155 = llvm.add %76, %154  : i64
          %156 = llvm.icmp "slt" %6, %155 : i64
          %157 = llvm.select %156, %6, %155 : i1, i64
          %158 = llvm.extractvalue %97[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %159 = llvm.bitcast %158 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %160 = llvm.insertvalue %159, %15[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %161 = llvm.extractvalue %97[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %162 = llvm.bitcast %161 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %163 = llvm.insertvalue %162, %160[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %164 = llvm.extractvalue %97[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %165 = llvm.extractvalue %97[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %166 = llvm.extractvalue %97[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %167 = llvm.mul %148, %164  : i64
          %168 = llvm.add %166, %167  : i64
          %169 = llvm.mul %152, %165  : i64
          %170 = llvm.add %168, %169  : i64
          %171 = llvm.insertvalue %170, %163[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %172 = llvm.mlir.constant(28 : i64) : i64
          %173 = llvm.insertvalue %172, %171[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %174 = llvm.insertvalue %93, %173[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %175 = llvm.insertvalue %157, %174[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %176 = llvm.insertvalue %92, %175[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %177 = llvm.extractvalue %117[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %178 = llvm.bitcast %177 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %179 = llvm.insertvalue %178, %15[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %180 = llvm.extractvalue %117[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %181 = llvm.bitcast %180 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %182 = llvm.insertvalue %181, %179[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %183 = llvm.extractvalue %117[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %184 = llvm.extractvalue %117[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %185 = llvm.extractvalue %117[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %186 = llvm.mul %152, %183  : i64
          %187 = llvm.add %185, %186  : i64
          %188 = llvm.mul %150, %184  : i64
          %189 = llvm.add %187, %188  : i64
          %190 = llvm.insertvalue %189, %182[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %191 = llvm.mlir.constant(32 : i64) : i64
          %192 = llvm.insertvalue %191, %190[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %193 = llvm.insertvalue %93, %192[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %194 = llvm.insertvalue %172, %193[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %195 = llvm.insertvalue %115, %194[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %196 = llvm.extractvalue %135[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %197 = llvm.bitcast %196 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %198 = llvm.insertvalue %197, %15[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %199 = llvm.extractvalue %135[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %200 = llvm.bitcast %199 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %201 = llvm.insertvalue %200, %198[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %202 = llvm.extractvalue %135[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %203 = llvm.extractvalue %135[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %204 = llvm.extractvalue %135[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %205 = llvm.mul %148, %202  : i64
          %206 = llvm.add %204, %205  : i64
          %207 = llvm.mul %150, %203  : i64
          %208 = llvm.add %206, %207  : i64
          %209 = llvm.insertvalue %208, %201[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %210 = llvm.insertvalue %191, %209[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %211 = llvm.insertvalue %93, %210[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %212 = llvm.insertvalue %157, %211[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %213 = llvm.insertvalue %115, %212[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          llvm.br ^bb13(%7 : i64)
        ^bb13(%214: i64):  // 2 preds: ^bb12, ^bb25
          %215 = llvm.icmp "slt" %214, %157 : i64
          llvm.cond_br %215, ^bb14(%7 : i64), ^bb26
        ^bb14(%216: i64):  // 2 preds: ^bb13, ^bb24
          %217 = llvm.icmp "slt" %216, %4 : i64
          llvm.cond_br %217, ^bb15(%7 : i64), ^bb25
        ^bb15(%218: i64):  // 2 preds: ^bb14, ^bb23
          %219 = llvm.icmp "slt" %218, %3 : i64
          llvm.cond_br %219, ^bb16, ^bb24
        ^bb16:  // pred: ^bb15
          %220 = llvm.mul %214, %72  : i64
          %221 = llvm.add %157, %220  : i64
          %222 = llvm.icmp "slt" %6, %221 : i64
          %223 = llvm.select %222, %6, %221 : i1, i64
          %224 = llvm.extractvalue %176[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %225 = llvm.bitcast %224 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %226 = llvm.insertvalue %225, %15[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %227 = llvm.extractvalue %176[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %228 = llvm.bitcast %227 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %229 = llvm.insertvalue %228, %226[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %230 = llvm.extractvalue %176[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %231 = llvm.extractvalue %176[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %232 = llvm.extractvalue %176[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %233 = llvm.mul %214, %230  : i64
          %234 = llvm.add %232, %233  : i64
          %235 = llvm.mul %218, %231  : i64
          %236 = llvm.add %234, %235  : i64
          %237 = llvm.insertvalue %236, %229[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %238 = llvm.mlir.constant(4 : i64) : i64
          %239 = llvm.insertvalue %238, %237[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %240 = llvm.insertvalue %93, %239[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %241 = llvm.insertvalue %223, %240[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %242 = llvm.insertvalue %92, %241[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %243 = llvm.extractvalue %195[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %244 = llvm.bitcast %243 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %245 = llvm.insertvalue %244, %15[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %246 = llvm.extractvalue %195[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %247 = llvm.bitcast %246 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %248 = llvm.insertvalue %247, %245[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %249 = llvm.extractvalue %195[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %250 = llvm.extractvalue %195[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %251 = llvm.extractvalue %195[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %252 = llvm.mul %218, %249  : i64
          %253 = llvm.add %251, %252  : i64
          %254 = llvm.mul %216, %250  : i64
          %255 = llvm.add %253, %254  : i64
          %256 = llvm.insertvalue %255, %248[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %257 = llvm.insertvalue %238, %256[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %258 = llvm.insertvalue %93, %257[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %259 = llvm.insertvalue %238, %258[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %260 = llvm.insertvalue %115, %259[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %261 = llvm.extractvalue %213[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %262 = llvm.bitcast %261 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %263 = llvm.insertvalue %262, %15[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %264 = llvm.extractvalue %213[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %265 = llvm.bitcast %264 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %266 = llvm.insertvalue %265, %263[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %267 = llvm.extractvalue %213[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %268 = llvm.extractvalue %213[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %269 = llvm.extractvalue %213[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %270 = llvm.mul %214, %267  : i64
          %271 = llvm.add %269, %270  : i64
          %272 = llvm.mul %216, %268  : i64
          %273 = llvm.add %271, %272  : i64
          %274 = llvm.insertvalue %273, %266[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %275 = llvm.insertvalue %238, %274[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %276 = llvm.insertvalue %93, %275[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %277 = llvm.insertvalue %223, %276[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %278 = llvm.insertvalue %115, %277[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          llvm.br ^bb17(%7 : i64)
        ^bb17(%279: i64):  // 2 preds: ^bb16, ^bb22
          %280 = llvm.icmp "slt" %279, %223 : i64
          llvm.cond_br %280, ^bb18(%7 : i64), ^bb23
        ^bb18(%281: i64):  // 2 preds: ^bb17, ^bb21
          %282 = llvm.icmp "slt" %281, %6 : i64
          llvm.cond_br %282, ^bb19(%7 : i64), ^bb22
        ^bb19(%283: i64):  // 2 preds: ^bb18, ^bb20
          %284 = llvm.icmp "slt" %283, %6 : i64
          llvm.cond_br %284, ^bb20, ^bb21
        ^bb20:  // pred: ^bb19
          %285 = llvm.extractvalue %242[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %286 = llvm.extractvalue %242[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %287 = llvm.mul %279, %2  : i64
          %288 = llvm.add %286, %287  : i64
          %289 = llvm.add %288, %283  : i64
          %290 = llvm.getelementptr %285[%289] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
          %291 = llvm.load %290 : !llvm.ptr<f32>
          %292 = llvm.extractvalue %260[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %293 = llvm.extractvalue %260[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %294 = llvm.mul %283, %1  : i64
          %295 = llvm.add %293, %294  : i64
          %296 = llvm.add %295, %281  : i64
          %297 = llvm.getelementptr %292[%296] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
          %298 = llvm.load %297 : !llvm.ptr<f32>
          %299 = llvm.extractvalue %278[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %300 = llvm.extractvalue %278[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %301 = llvm.mul %279, %1  : i64
          %302 = llvm.add %300, %301  : i64
          %303 = llvm.add %302, %281  : i64
          %304 = llvm.getelementptr %299[%303] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
          %305 = llvm.load %304 : !llvm.ptr<f32>
          %306 = llvm.fmul %291, %298  : f32
          %307 = llvm.fadd %305, %306  : f32
          llvm.store %307, %304 : !llvm.ptr<f32>
          %308 = llvm.add %283, %8  : i64
          llvm.br ^bb19(%308 : i64)
        ^bb21:  // pred: ^bb19
          %309 = llvm.add %281, %8  : i64
          llvm.br ^bb18(%309 : i64)
        ^bb22:  // pred: ^bb18
          %310 = llvm.add %279, %8  : i64
          llvm.br ^bb17(%310 : i64)
        ^bb23:  // pred: ^bb17
          %311 = llvm.add %218, %6  : i64
          llvm.br ^bb15(%311 : i64)
        ^bb24:  // pred: ^bb15
          %312 = llvm.add %216, %6  : i64
          llvm.br ^bb14(%312 : i64)
        ^bb25:  // pred: ^bb14
          %313 = llvm.add %214, %6  : i64
          llvm.br ^bb13(%313 : i64)
        ^bb26:  // pred: ^bb13
          %314 = llvm.add %152, %3  : i64
          llvm.br ^bb11(%314 : i64)
        ^bb27:  // pred: ^bb11
          %315 = llvm.add %150, %4  : i64
          llvm.br ^bb10(%315 : i64)
        ^bb28:  // pred: ^bb10
          %316 = llvm.add %148, %6  : i64
          llvm.br ^bb9(%316 : i64)
        ^bb29:  // pred: ^bb9
          %317 = llvm.add %70, %69  : i64
          llvm.br ^bb3(%317 : i64)
        ^bb30:  // pred: ^bb3
          %318 = llvm.add %66, %65  : i64
          llvm.br ^bb1(%318 : i64)
        ^bb31:  // pred: ^bb1
          %319 = llvm.mlir.constant(0 : i32) : i32
          llvm.return %319 : i32
        }
        llvm.func internal @predict_dispatch_1(%arg0: !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>, %arg1: !llvm.ptr<array<3 x i32>>) -> i32 {
          %0 = llvm.mlir.constant(0x7FC00000 : f32) : f32
          %1 = llvm.mlir.constant(0.000000e+00 : f32) : f32
          %2 = llvm.mlir.constant(128 : index) : i64
          %3 = llvm.mlir.constant(0 : index) : i64
          %4 = llvm.mlir.constant(1 : index) : i64
          %5 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %6 = llvm.extractvalue %5[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %7 = llvm.getelementptr %6[%4] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
          %8 = llvm.load %7 : !llvm.ptr<ptr<i8>>
          %9 = llvm.getelementptr %8[%3] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
          %10 = llvm.bitcast %9 : !llvm.ptr<i8> to !llvm.ptr<f32>
          %11 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %12 = llvm.insertvalue %10, %11[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %13 = llvm.insertvalue %10, %12[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %14 = llvm.insertvalue %3, %13[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %15 = llvm.insertvalue %4, %14[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %16 = llvm.insertvalue %2, %15[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %17 = llvm.insertvalue %2, %16[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %18 = llvm.insertvalue %4, %17[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %19 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %20 = llvm.extractvalue %19[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %21 = llvm.getelementptr %20[%3] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
          %22 = llvm.load %21 : !llvm.ptr<ptr<i8>>
          %23 = llvm.getelementptr %22[%3] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
          %24 = llvm.bitcast %23 : !llvm.ptr<i8> to !llvm.ptr<f32>
          %25 = llvm.insertvalue %24, %11[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %26 = llvm.insertvalue %24, %25[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %27 = llvm.insertvalue %3, %26[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %28 = llvm.insertvalue %4, %27[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %29 = llvm.insertvalue %2, %28[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %30 = llvm.insertvalue %2, %29[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %31 = llvm.insertvalue %4, %30[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %32 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %33 = llvm.extractvalue %32[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %34 = llvm.mlir.constant(2 : index) : i64
          %35 = llvm.getelementptr %33[%34] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
          %36 = llvm.load %35 : !llvm.ptr<ptr<i8>>
          %37 = llvm.getelementptr %36[%3] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
          %38 = llvm.bitcast %37 : !llvm.ptr<i8> to !llvm.ptr<f32>
          %39 = llvm.insertvalue %38, %11[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %40 = llvm.insertvalue %38, %39[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %41 = llvm.insertvalue %3, %40[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %42 = llvm.insertvalue %4, %41[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %43 = llvm.insertvalue %2, %42[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %44 = llvm.insertvalue %2, %43[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %45 = llvm.insertvalue %4, %44[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %46 = llvm.load %arg1 : !llvm.ptr<array<3 x i32>>
          %47 = llvm.extractvalue %46[0] : !llvm.array<3 x i32>
          %48 = llvm.zext %47 : i32 to i64
          %49 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %50 = llvm.extractvalue %49[0] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %51 = llvm.extractvalue %50[0] : !llvm.array<3 x i32>
          %52 = llvm.zext %51 : i32 to i64
          %53 = llvm.load %arg1 : !llvm.ptr<array<3 x i32>>
          %54 = llvm.extractvalue %53[1] : !llvm.array<3 x i32>
          %55 = llvm.zext %54 : i32 to i64
          %56 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %57 = llvm.extractvalue %56[0] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %58 = llvm.extractvalue %57[1] : !llvm.array<3 x i32>
          %59 = llvm.zext %58 : i32 to i64
          %60 = llvm.mul %55, %2  : i64
          %61 = llvm.mul %59, %2  : i64
          llvm.br ^bb1(%60 : i64)
        ^bb1(%62: i64):  // 2 preds: ^bb0, ^bb10
          %63 = llvm.icmp "slt" %62, %4 : i64
          llvm.cond_br %63, ^bb2, ^bb11
        ^bb2:  // pred: ^bb1
          %64 = llvm.mul %48, %2  : i64
          %65 = llvm.mul %52, %2  : i64
          llvm.br ^bb3(%64 : i64)
        ^bb3(%66: i64):  // 2 preds: ^bb2, ^bb9
          %67 = llvm.icmp "slt" %66, %2 : i64
          llvm.cond_br %67, ^bb4, ^bb10
        ^bb4:  // pred: ^bb3
          %68 = llvm.mlir.constant(-1 : index) : i64
          %69 = llvm.mul %62, %68  : i64
          %70 = llvm.add %69, %4  : i64
          %71 = llvm.icmp "slt" %2, %70 : i64
          %72 = llvm.select %71, %2, %70 : i1, i64
          %73 = llvm.extractvalue %18[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %74 = llvm.bitcast %73 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %75 = llvm.insertvalue %74, %11[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %76 = llvm.extractvalue %18[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %77 = llvm.bitcast %76 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %78 = llvm.insertvalue %77, %75[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %79 = llvm.extractvalue %18[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %80 = llvm.extractvalue %18[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %81 = llvm.extractvalue %18[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %82 = llvm.mul %62, %79  : i64
          %83 = llvm.add %81, %82  : i64
          %84 = llvm.mul %66, %80  : i64
          %85 = llvm.add %83, %84  : i64
          %86 = llvm.insertvalue %85, %78[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %87 = llvm.mlir.constant(128 : i64) : i64
          %88 = llvm.mlir.constant(1 : i64) : i64
          %89 = llvm.insertvalue %87, %86[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %90 = llvm.insertvalue %88, %89[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %91 = llvm.insertvalue %72, %90[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %92 = llvm.insertvalue %87, %91[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %93 = llvm.extractvalue %31[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %94 = llvm.bitcast %93 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %95 = llvm.insertvalue %94, %11[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %96 = llvm.extractvalue %31[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %97 = llvm.bitcast %96 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %98 = llvm.insertvalue %97, %95[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %99 = llvm.extractvalue %31[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %100 = llvm.extractvalue %31[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %101 = llvm.extractvalue %31[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %102 = llvm.mul %62, %99  : i64
          %103 = llvm.add %101, %102  : i64
          %104 = llvm.mul %66, %100  : i64
          %105 = llvm.add %103, %104  : i64
          %106 = llvm.insertvalue %105, %98[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %107 = llvm.insertvalue %87, %106[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %108 = llvm.insertvalue %88, %107[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %109 = llvm.insertvalue %72, %108[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %110 = llvm.insertvalue %87, %109[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %111 = llvm.extractvalue %45[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %112 = llvm.bitcast %111 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %113 = llvm.insertvalue %112, %11[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %114 = llvm.extractvalue %45[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %115 = llvm.bitcast %114 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %116 = llvm.insertvalue %115, %113[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %117 = llvm.extractvalue %45[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %118 = llvm.extractvalue %45[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %119 = llvm.extractvalue %45[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %120 = llvm.mul %62, %117  : i64
          %121 = llvm.add %119, %120  : i64
          %122 = llvm.mul %66, %118  : i64
          %123 = llvm.add %121, %122  : i64
          %124 = llvm.insertvalue %123, %116[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %125 = llvm.insertvalue %87, %124[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %126 = llvm.insertvalue %88, %125[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %127 = llvm.insertvalue %72, %126[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %128 = llvm.insertvalue %87, %127[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          llvm.br ^bb5(%3 : i64)
        ^bb5(%129: i64):  // 2 preds: ^bb4, ^bb8
          %130 = llvm.icmp "slt" %129, %72 : i64
          llvm.cond_br %130, ^bb6(%3 : i64), ^bb9
        ^bb6(%131: i64):  // 2 preds: ^bb5, ^bb7
          %132 = llvm.icmp "slt" %131, %2 : i64
          llvm.cond_br %132, ^bb7, ^bb8
        ^bb7:  // pred: ^bb6
          %133 = llvm.extractvalue %92[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %134 = llvm.extractvalue %92[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %135 = llvm.mul %129, %2  : i64
          %136 = llvm.add %134, %135  : i64
          %137 = llvm.add %136, %131  : i64
          %138 = llvm.getelementptr %133[%137] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
          %139 = llvm.load %138 : !llvm.ptr<f32>
          %140 = llvm.extractvalue %110[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %141 = llvm.extractvalue %110[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %142 = llvm.add %141, %135  : i64
          %143 = llvm.add %142, %131  : i64
          %144 = llvm.getelementptr %140[%143] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
          %145 = llvm.load %144 : !llvm.ptr<f32>
          %146 = llvm.fadd %139, %145  : f32
          %147 = llvm.fcmp "ogt" %146, %1 : f32
          %148 = llvm.select %147, %146, %1 : i1, f32
          %149 = llvm.fcmp "uno" %146, %1 : f32
          %150 = llvm.select %149, %0, %148 : i1, f32
          %151 = llvm.extractvalue %128[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %152 = llvm.extractvalue %128[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %153 = llvm.add %152, %135  : i64
          %154 = llvm.add %153, %131  : i64
          %155 = llvm.getelementptr %151[%154] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
          llvm.store %150, %155 : !llvm.ptr<f32>
          %156 = llvm.add %131, %4  : i64
          llvm.br ^bb6(%156 : i64)
        ^bb8:  // pred: ^bb6
          %157 = llvm.add %129, %4  : i64
          llvm.br ^bb5(%157 : i64)
        ^bb9:  // pred: ^bb5
          %158 = llvm.add %66, %65  : i64
          llvm.br ^bb3(%158 : i64)
        ^bb10:  // pred: ^bb3
          %159 = llvm.add %62, %61  : i64
          llvm.br ^bb1(%159 : i64)
        ^bb11:  // pred: ^bb1
          %160 = llvm.mlir.constant(0 : i32) : i32
          llvm.return %160 : i32
        }
        llvm.func internal @predict_dispatch_2(%arg0: !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>, %arg1: !llvm.ptr<array<3 x i32>>) -> i32 {
          %0 = llvm.mlir.constant(0.000000e+00 : f32) : f32
          %1 = llvm.mlir.constant(10 : index) : i64
          %2 = llvm.mlir.constant(128 : index) : i64
          %3 = llvm.mlir.constant(32 : index) : i64
          %4 = llvm.mlir.constant(4 : index) : i64
          %5 = llvm.mlir.constant(0 : index) : i64
          %6 = llvm.mlir.constant(1 : index) : i64
          %7 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %8 = llvm.extractvalue %7[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %9 = llvm.getelementptr %8[%6] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
          %10 = llvm.load %9 : !llvm.ptr<ptr<i8>>
          %11 = llvm.getelementptr %10[%5] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
          %12 = llvm.bitcast %11 : !llvm.ptr<i8> to !llvm.ptr<f32>
          %13 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %14 = llvm.insertvalue %12, %13[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %15 = llvm.insertvalue %12, %14[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %16 = llvm.insertvalue %5, %15[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %17 = llvm.insertvalue %6, %16[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %18 = llvm.insertvalue %2, %17[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %19 = llvm.insertvalue %2, %18[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %20 = llvm.insertvalue %6, %19[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %21 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %22 = llvm.extractvalue %21[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %23 = llvm.getelementptr %22[%5] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
          %24 = llvm.load %23 : !llvm.ptr<ptr<i8>>
          %25 = llvm.getelementptr %24[%5] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
          %26 = llvm.bitcast %25 : !llvm.ptr<i8> to !llvm.ptr<f32>
          %27 = llvm.insertvalue %26, %13[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %28 = llvm.insertvalue %26, %27[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %29 = llvm.insertvalue %5, %28[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %30 = llvm.insertvalue %2, %29[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %31 = llvm.insertvalue %1, %30[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %32 = llvm.insertvalue %1, %31[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %33 = llvm.insertvalue %6, %32[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %34 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %35 = llvm.extractvalue %34[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %36 = llvm.mlir.constant(2 : index) : i64
          %37 = llvm.getelementptr %35[%36] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
          %38 = llvm.load %37 : !llvm.ptr<ptr<i8>>
          %39 = llvm.getelementptr %38[%5] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
          %40 = llvm.bitcast %39 : !llvm.ptr<i8> to !llvm.ptr<f32>
          %41 = llvm.insertvalue %40, %13[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %42 = llvm.insertvalue %40, %41[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %43 = llvm.insertvalue %5, %42[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %44 = llvm.insertvalue %6, %43[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %45 = llvm.insertvalue %1, %44[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %46 = llvm.insertvalue %1, %45[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %47 = llvm.insertvalue %6, %46[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %48 = llvm.load %arg1 : !llvm.ptr<array<3 x i32>>
          %49 = llvm.extractvalue %48[0] : !llvm.array<3 x i32>
          %50 = llvm.zext %49 : i32 to i64
          %51 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %52 = llvm.extractvalue %51[0] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %53 = llvm.extractvalue %52[0] : !llvm.array<3 x i32>
          %54 = llvm.zext %53 : i32 to i64
          %55 = llvm.load %arg1 : !llvm.ptr<array<3 x i32>>
          %56 = llvm.extractvalue %55[1] : !llvm.array<3 x i32>
          %57 = llvm.zext %56 : i32 to i64
          %58 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %59 = llvm.extractvalue %58[0] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %60 = llvm.extractvalue %59[1] : !llvm.array<3 x i32>
          %61 = llvm.zext %60 : i32 to i64
          %62 = llvm.mul %57, %4  : i64
          %63 = llvm.mul %61, %4  : i64
          llvm.br ^bb1(%62 : i64)
        ^bb1(%64: i64):  // 2 preds: ^bb0, ^bb30
          %65 = llvm.icmp "slt" %64, %6 : i64
          llvm.cond_br %65, ^bb2, ^bb31
        ^bb2:  // pred: ^bb1
          %66 = llvm.mlir.constant(64 : index) : i64
          %67 = llvm.mul %50, %66  : i64
          %68 = llvm.mul %54, %66  : i64
          llvm.br ^bb3(%67 : i64)
        ^bb3(%69: i64):  // 2 preds: ^bb2, ^bb29
          %70 = llvm.icmp "slt" %69, %1 : i64
          llvm.cond_br %70, ^bb4, ^bb30
        ^bb4:  // pred: ^bb3
          %71 = llvm.mlir.constant(-1 : index) : i64
          %72 = llvm.mul %64, %71  : i64
          %73 = llvm.add %72, %6  : i64
          %74 = llvm.icmp "slt" %4, %73 : i64
          %75 = llvm.select %74, %4, %73 : i1, i64
          %76 = llvm.extractvalue %20[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %77 = llvm.bitcast %76 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %78 = llvm.insertvalue %77, %13[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %79 = llvm.extractvalue %20[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %80 = llvm.bitcast %79 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %81 = llvm.insertvalue %80, %78[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %82 = llvm.extractvalue %20[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %83 = llvm.extractvalue %20[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %84 = llvm.extractvalue %20[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %85 = llvm.mul %64, %82  : i64
          %86 = llvm.add %84, %85  : i64
          %87 = llvm.mlir.constant(0 : i64) : i64
          %88 = llvm.mul %87, %83  : i64
          %89 = llvm.add %86, %88  : i64
          %90 = llvm.insertvalue %89, %81[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %91 = llvm.mlir.constant(128 : i64) : i64
          %92 = llvm.mlir.constant(1 : i64) : i64
          %93 = llvm.insertvalue %91, %90[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %94 = llvm.insertvalue %92, %93[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %95 = llvm.insertvalue %75, %94[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %96 = llvm.insertvalue %91, %95[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %97 = llvm.mul %69, %71  : i64
          %98 = llvm.add %97, %1  : i64
          %99 = llvm.icmp "slt" %66, %98 : i64
          %100 = llvm.select %99, %66, %98 : i1, i64
          %101 = llvm.extractvalue %33[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %102 = llvm.bitcast %101 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %103 = llvm.insertvalue %102, %13[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %104 = llvm.extractvalue %33[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %105 = llvm.bitcast %104 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %106 = llvm.insertvalue %105, %103[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %107 = llvm.extractvalue %33[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %108 = llvm.extractvalue %33[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %109 = llvm.extractvalue %33[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %110 = llvm.mul %87, %107  : i64
          %111 = llvm.add %109, %110  : i64
          %112 = llvm.mul %69, %108  : i64
          %113 = llvm.add %111, %112  : i64
          %114 = llvm.insertvalue %113, %106[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %115 = llvm.insertvalue %100, %114[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %116 = llvm.insertvalue %92, %115[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %117 = llvm.mlir.constant(10 : i64) : i64
          %118 = llvm.insertvalue %91, %116[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %119 = llvm.insertvalue %117, %118[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %120 = llvm.extractvalue %47[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %121 = llvm.bitcast %120 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %122 = llvm.insertvalue %121, %13[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %123 = llvm.extractvalue %47[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %124 = llvm.bitcast %123 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %125 = llvm.insertvalue %124, %122[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %126 = llvm.extractvalue %47[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %127 = llvm.extractvalue %47[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %128 = llvm.extractvalue %47[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %129 = llvm.mul %64, %126  : i64
          %130 = llvm.add %128, %129  : i64
          %131 = llvm.mul %69, %127  : i64
          %132 = llvm.add %130, %131  : i64
          %133 = llvm.insertvalue %132, %125[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %134 = llvm.insertvalue %100, %133[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %135 = llvm.insertvalue %92, %134[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %136 = llvm.insertvalue %75, %135[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %137 = llvm.insertvalue %117, %136[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          llvm.br ^bb5(%5 : i64)
        ^bb5(%138: i64):  // 2 preds: ^bb4, ^bb8
          %139 = llvm.icmp "slt" %138, %75 : i64
          llvm.cond_br %139, ^bb6(%5 : i64), ^bb9(%5 : i64)
        ^bb6(%140: i64):  // 2 preds: ^bb5, ^bb7
          %141 = llvm.icmp "slt" %140, %100 : i64
          llvm.cond_br %141, ^bb7, ^bb8
        ^bb7:  // pred: ^bb6
          %142 = llvm.extractvalue %137[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %143 = llvm.extractvalue %137[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %144 = llvm.mul %138, %1  : i64
          %145 = llvm.add %143, %144  : i64
          %146 = llvm.add %145, %140  : i64
          %147 = llvm.getelementptr %142[%146] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
          llvm.store %0, %147 : !llvm.ptr<f32>
          %148 = llvm.add %140, %6  : i64
          llvm.br ^bb6(%148 : i64)
        ^bb8:  // pred: ^bb6
          %149 = llvm.add %138, %6  : i64
          llvm.br ^bb5(%149 : i64)
        ^bb9(%150: i64):  // 2 preds: ^bb5, ^bb28
          %151 = llvm.icmp "slt" %150, %75 : i64
          llvm.cond_br %151, ^bb10(%5 : i64), ^bb29
        ^bb10(%152: i64):  // 2 preds: ^bb9, ^bb27
          %153 = llvm.icmp "slt" %152, %100 : i64
          llvm.cond_br %153, ^bb11(%5 : i64), ^bb28
        ^bb11(%154: i64):  // 2 preds: ^bb10, ^bb26
          %155 = llvm.icmp "slt" %154, %2 : i64
          llvm.cond_br %155, ^bb12, ^bb27
        ^bb12:  // pred: ^bb11
          %156 = llvm.mul %150, %71  : i64
          %157 = llvm.add %75, %156  : i64
          %158 = llvm.icmp "slt" %4, %157 : i64
          %159 = llvm.select %158, %4, %157 : i1, i64
          %160 = llvm.extractvalue %96[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %161 = llvm.bitcast %160 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %162 = llvm.insertvalue %161, %13[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %163 = llvm.extractvalue %96[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %164 = llvm.bitcast %163 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %165 = llvm.insertvalue %164, %162[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %166 = llvm.extractvalue %96[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %167 = llvm.extractvalue %96[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %168 = llvm.extractvalue %96[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %169 = llvm.mul %150, %166  : i64
          %170 = llvm.add %168, %169  : i64
          %171 = llvm.mul %154, %167  : i64
          %172 = llvm.add %170, %171  : i64
          %173 = llvm.insertvalue %172, %165[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %174 = llvm.mlir.constant(32 : i64) : i64
          %175 = llvm.insertvalue %174, %173[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %176 = llvm.insertvalue %92, %175[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %177 = llvm.insertvalue %159, %176[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %178 = llvm.insertvalue %91, %177[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %179 = llvm.mul %152, %71  : i64
          %180 = llvm.add %100, %179  : i64
          %181 = llvm.icmp "slt" %3, %180 : i64
          %182 = llvm.select %181, %3, %180 : i1, i64
          %183 = llvm.extractvalue %119[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %184 = llvm.bitcast %183 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %185 = llvm.insertvalue %184, %13[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %186 = llvm.extractvalue %119[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %187 = llvm.bitcast %186 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %188 = llvm.insertvalue %187, %185[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %189 = llvm.extractvalue %119[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %190 = llvm.extractvalue %119[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %191 = llvm.extractvalue %119[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %192 = llvm.mul %154, %189  : i64
          %193 = llvm.add %191, %192  : i64
          %194 = llvm.mul %152, %190  : i64
          %195 = llvm.add %193, %194  : i64
          %196 = llvm.insertvalue %195, %188[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %197 = llvm.insertvalue %182, %196[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %198 = llvm.insertvalue %92, %197[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %199 = llvm.insertvalue %174, %198[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %200 = llvm.insertvalue %117, %199[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %201 = llvm.extractvalue %137[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %202 = llvm.bitcast %201 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %203 = llvm.insertvalue %202, %13[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %204 = llvm.extractvalue %137[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %205 = llvm.bitcast %204 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %206 = llvm.insertvalue %205, %203[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %207 = llvm.extractvalue %137[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %208 = llvm.extractvalue %137[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %209 = llvm.extractvalue %137[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %210 = llvm.mul %150, %207  : i64
          %211 = llvm.add %209, %210  : i64
          %212 = llvm.mul %152, %208  : i64
          %213 = llvm.add %211, %212  : i64
          %214 = llvm.insertvalue %213, %206[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %215 = llvm.insertvalue %182, %214[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %216 = llvm.insertvalue %92, %215[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %217 = llvm.insertvalue %159, %216[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %218 = llvm.insertvalue %117, %217[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          llvm.br ^bb13(%5 : i64)
        ^bb13(%219: i64):  // 2 preds: ^bb12, ^bb25
          %220 = llvm.icmp "slt" %219, %159 : i64
          llvm.cond_br %220, ^bb14(%5 : i64), ^bb26
        ^bb14(%221: i64):  // 2 preds: ^bb13, ^bb24
          %222 = llvm.icmp "slt" %221, %182 : i64
          llvm.cond_br %222, ^bb15(%5 : i64), ^bb25
        ^bb15(%223: i64):  // 2 preds: ^bb14, ^bb23
          %224 = llvm.icmp "slt" %223, %3 : i64
          llvm.cond_br %224, ^bb16, ^bb24
        ^bb16:  // pred: ^bb15
          %225 = llvm.mul %219, %71  : i64
          %226 = llvm.add %159, %225  : i64
          %227 = llvm.icmp "slt" %4, %226 : i64
          %228 = llvm.select %227, %4, %226 : i1, i64
          %229 = llvm.extractvalue %178[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %230 = llvm.bitcast %229 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %231 = llvm.insertvalue %230, %13[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %232 = llvm.extractvalue %178[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %233 = llvm.bitcast %232 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %234 = llvm.insertvalue %233, %231[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %235 = llvm.extractvalue %178[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %236 = llvm.extractvalue %178[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %237 = llvm.extractvalue %178[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %238 = llvm.mul %219, %235  : i64
          %239 = llvm.add %237, %238  : i64
          %240 = llvm.mul %223, %236  : i64
          %241 = llvm.add %239, %240  : i64
          %242 = llvm.insertvalue %241, %234[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %243 = llvm.mlir.constant(4 : i64) : i64
          %244 = llvm.insertvalue %243, %242[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %245 = llvm.insertvalue %92, %244[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %246 = llvm.insertvalue %228, %245[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %247 = llvm.insertvalue %91, %246[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %248 = llvm.mul %221, %71  : i64
          %249 = llvm.add %182, %248  : i64
          %250 = llvm.icmp "slt" %4, %249 : i64
          %251 = llvm.select %250, %4, %249 : i1, i64
          %252 = llvm.extractvalue %200[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %253 = llvm.bitcast %252 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %254 = llvm.insertvalue %253, %13[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %255 = llvm.extractvalue %200[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %256 = llvm.bitcast %255 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %257 = llvm.insertvalue %256, %254[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %258 = llvm.extractvalue %200[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %259 = llvm.extractvalue %200[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %260 = llvm.extractvalue %200[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %261 = llvm.mul %223, %258  : i64
          %262 = llvm.add %260, %261  : i64
          %263 = llvm.mul %221, %259  : i64
          %264 = llvm.add %262, %263  : i64
          %265 = llvm.insertvalue %264, %257[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %266 = llvm.insertvalue %251, %265[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %267 = llvm.insertvalue %92, %266[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %268 = llvm.insertvalue %243, %267[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %269 = llvm.insertvalue %117, %268[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %270 = llvm.extractvalue %218[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %271 = llvm.bitcast %270 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %272 = llvm.insertvalue %271, %13[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %273 = llvm.extractvalue %218[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %274 = llvm.bitcast %273 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %275 = llvm.insertvalue %274, %272[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %276 = llvm.extractvalue %218[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %277 = llvm.extractvalue %218[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %278 = llvm.extractvalue %218[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %279 = llvm.mul %219, %276  : i64
          %280 = llvm.add %278, %279  : i64
          %281 = llvm.mul %221, %277  : i64
          %282 = llvm.add %280, %281  : i64
          %283 = llvm.insertvalue %282, %275[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %284 = llvm.insertvalue %251, %283[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %285 = llvm.insertvalue %92, %284[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %286 = llvm.insertvalue %228, %285[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %287 = llvm.insertvalue %117, %286[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          llvm.br ^bb17(%5 : i64)
        ^bb17(%288: i64):  // 2 preds: ^bb16, ^bb22
          %289 = llvm.icmp "slt" %288, %228 : i64
          llvm.cond_br %289, ^bb18(%5 : i64), ^bb23
        ^bb18(%290: i64):  // 2 preds: ^bb17, ^bb21
          %291 = llvm.icmp "slt" %290, %251 : i64
          llvm.cond_br %291, ^bb19(%5 : i64), ^bb22
        ^bb19(%292: i64):  // 2 preds: ^bb18, ^bb20
          %293 = llvm.icmp "slt" %292, %4 : i64
          llvm.cond_br %293, ^bb20, ^bb21
        ^bb20:  // pred: ^bb19
          %294 = llvm.extractvalue %247[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %295 = llvm.extractvalue %247[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %296 = llvm.mul %288, %2  : i64
          %297 = llvm.add %295, %296  : i64
          %298 = llvm.add %297, %292  : i64
          %299 = llvm.getelementptr %294[%298] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
          %300 = llvm.load %299 : !llvm.ptr<f32>
          %301 = llvm.extractvalue %269[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %302 = llvm.extractvalue %269[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %303 = llvm.mul %292, %1  : i64
          %304 = llvm.add %302, %303  : i64
          %305 = llvm.add %304, %290  : i64
          %306 = llvm.getelementptr %301[%305] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
          %307 = llvm.load %306 : !llvm.ptr<f32>
          %308 = llvm.extractvalue %287[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %309 = llvm.extractvalue %287[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %310 = llvm.mul %288, %1  : i64
          %311 = llvm.add %309, %310  : i64
          %312 = llvm.add %311, %290  : i64
          %313 = llvm.getelementptr %308[%312] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
          %314 = llvm.load %313 : !llvm.ptr<f32>
          %315 = llvm.fmul %300, %307  : f32
          %316 = llvm.fadd %314, %315  : f32
          llvm.store %316, %313 : !llvm.ptr<f32>
          %317 = llvm.add %292, %6  : i64
          llvm.br ^bb19(%317 : i64)
        ^bb21:  // pred: ^bb19
          %318 = llvm.add %290, %6  : i64
          llvm.br ^bb18(%318 : i64)
        ^bb22:  // pred: ^bb18
          %319 = llvm.add %288, %6  : i64
          llvm.br ^bb17(%319 : i64)
        ^bb23:  // pred: ^bb17
          %320 = llvm.add %223, %4  : i64
          llvm.br ^bb15(%320 : i64)
        ^bb24:  // pred: ^bb15
          %321 = llvm.add %221, %4  : i64
          llvm.br ^bb14(%321 : i64)
        ^bb25:  // pred: ^bb14
          %322 = llvm.add %219, %4  : i64
          llvm.br ^bb13(%322 : i64)
        ^bb26:  // pred: ^bb13
          %323 = llvm.add %154, %3  : i64
          llvm.br ^bb11(%323 : i64)
        ^bb27:  // pred: ^bb11
          %324 = llvm.add %152, %3  : i64
          llvm.br ^bb10(%324 : i64)
        ^bb28:  // pred: ^bb10
          %325 = llvm.add %150, %4  : i64
          llvm.br ^bb9(%325 : i64)
        ^bb29:  // pred: ^bb9
          %326 = llvm.add %69, %68  : i64
          llvm.br ^bb3(%326 : i64)
        ^bb30:  // pred: ^bb3
          %327 = llvm.add %64, %63  : i64
          llvm.br ^bb1(%327 : i64)
        ^bb31:  // pred: ^bb1
          %328 = llvm.mlir.constant(0 : i32) : i32
          llvm.return %328 : i32
        }
        llvm.mlir.global private constant @__constant_1x10xf32_3(opaque<"_", "0xDEADBEEF"> : tensor<1x10xf32>) : !llvm.array<1 x array<10 x f32>>
        llvm.func internal @predict_dispatch_3(%arg0: !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>, %arg1: !llvm.ptr<array<3 x i32>>) -> i32 {
          %0 = llvm.mlir.constant(10 : index) : i64
          %1 = llvm.mlir.constant(0 : index) : i64
          %2 = llvm.mlir.constant(1 : index) : i64
          %3 = llvm.mlir.addressof @__constant_1x10xf32_3 : !llvm.ptr<array<1 x array<10 x f32>>>
          %4 = llvm.getelementptr %3[%1, %1, %1] : (!llvm.ptr<array<1 x array<10 x f32>>>, i64, i64, i64) -> !llvm.ptr<f32>
          %5 = llvm.mlir.constant(3735928559 : index) : i64
          %6 = llvm.inttoptr %5 : i64 to !llvm.ptr<f32>
          %7 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %8 = llvm.insertvalue %6, %7[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %9 = llvm.insertvalue %4, %8[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %10 = llvm.insertvalue %1, %9[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %11 = llvm.insertvalue %2, %10[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %12 = llvm.insertvalue %0, %11[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %13 = llvm.insertvalue %0, %12[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %14 = llvm.insertvalue %2, %13[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %15 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %16 = llvm.extractvalue %15[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %17 = llvm.getelementptr %16[%1] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
          %18 = llvm.load %17 : !llvm.ptr<ptr<i8>>
          %19 = llvm.getelementptr %18[%1] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
          %20 = llvm.bitcast %19 : !llvm.ptr<i8> to !llvm.ptr<f32>
          %21 = llvm.insertvalue %20, %7[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %22 = llvm.insertvalue %20, %21[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %23 = llvm.insertvalue %1, %22[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %24 = llvm.insertvalue %2, %23[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %25 = llvm.insertvalue %0, %24[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %26 = llvm.insertvalue %0, %25[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %27 = llvm.insertvalue %2, %26[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %28 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %29 = llvm.extractvalue %28[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %30 = llvm.getelementptr %29[%2] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
          %31 = llvm.load %30 : !llvm.ptr<ptr<i8>>
          %32 = llvm.getelementptr %31[%1] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
          %33 = llvm.bitcast %32 : !llvm.ptr<i8> to !llvm.ptr<f32>
          %34 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %35 = llvm.insertvalue %33, %34[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %36 = llvm.insertvalue %33, %35[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %37 = llvm.insertvalue %1, %36[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %38 = llvm.insertvalue %0, %37[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %39 = llvm.insertvalue %2, %38[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %40 = llvm.load %arg1 : !llvm.ptr<array<3 x i32>>
          %41 = llvm.extractvalue %40[0] : !llvm.array<3 x i32>
          %42 = llvm.zext %41 : i32 to i64
          %43 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %44 = llvm.extractvalue %43[0] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %45 = llvm.extractvalue %44[0] : !llvm.array<3 x i32>
          %46 = llvm.zext %45 : i32 to i64
          %47 = llvm.load %arg1 : !llvm.ptr<array<3 x i32>>
          %48 = llvm.extractvalue %47[1] : !llvm.array<3 x i32>
          %49 = llvm.zext %48 : i32 to i64
          %50 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %51 = llvm.extractvalue %50[0] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %52 = llvm.extractvalue %51[1] : !llvm.array<3 x i32>
          %53 = llvm.zext %52 : i32 to i64
          %54 = llvm.mlir.constant(128 : index) : i64
          %55 = llvm.mul %49, %54  : i64
          %56 = llvm.mul %53, %54  : i64
          llvm.br ^bb1(%55 : i64)
        ^bb1(%57: i64):  // 2 preds: ^bb0, ^bb10
          %58 = llvm.icmp "slt" %57, %2 : i64
          llvm.cond_br %58, ^bb2, ^bb11
        ^bb2:  // pred: ^bb1
          %59 = llvm.mul %42, %54  : i64
          %60 = llvm.mul %46, %54  : i64
          llvm.br ^bb3(%59 : i64)
        ^bb3(%61: i64):  // 2 preds: ^bb2, ^bb9
          %62 = llvm.icmp "slt" %61, %0 : i64
          llvm.cond_br %62, ^bb4, ^bb10
        ^bb4:  // pred: ^bb3
          %63 = llvm.mlir.constant(-1 : index) : i64
          %64 = llvm.mul %57, %63  : i64
          %65 = llvm.add %64, %2  : i64
          %66 = llvm.icmp "slt" %54, %65 : i64
          %67 = llvm.select %66, %54, %65 : i1, i64
          %68 = llvm.mul %61, %63  : i64
          %69 = llvm.add %68, %0  : i64
          %70 = llvm.icmp "slt" %54, %69 : i64
          %71 = llvm.select %70, %54, %69 : i1, i64
          %72 = llvm.extractvalue %27[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %73 = llvm.bitcast %72 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %74 = llvm.insertvalue %73, %7[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %75 = llvm.extractvalue %27[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %76 = llvm.bitcast %75 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %77 = llvm.insertvalue %76, %74[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %78 = llvm.extractvalue %27[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %79 = llvm.extractvalue %27[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %80 = llvm.extractvalue %27[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %81 = llvm.mul %57, %78  : i64
          %82 = llvm.add %80, %81  : i64
          %83 = llvm.mul %61, %79  : i64
          %84 = llvm.add %82, %83  : i64
          %85 = llvm.insertvalue %84, %77[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %86 = llvm.mlir.constant(1 : i64) : i64
          %87 = llvm.insertvalue %71, %85[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %88 = llvm.insertvalue %86, %87[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %89 = llvm.mlir.constant(10 : i64) : i64
          %90 = llvm.insertvalue %67, %88[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %91 = llvm.insertvalue %89, %90[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %92 = llvm.extractvalue %14[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %93 = llvm.bitcast %92 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %94 = llvm.insertvalue %93, %7[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %95 = llvm.extractvalue %14[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %96 = llvm.bitcast %95 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %97 = llvm.insertvalue %96, %94[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %98 = llvm.extractvalue %14[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %99 = llvm.extractvalue %14[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %100 = llvm.extractvalue %14[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %101 = llvm.mul %57, %98  : i64
          %102 = llvm.add %100, %101  : i64
          %103 = llvm.mul %61, %99  : i64
          %104 = llvm.add %102, %103  : i64
          %105 = llvm.insertvalue %104, %97[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %106 = llvm.insertvalue %71, %105[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %107 = llvm.insertvalue %86, %106[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %108 = llvm.insertvalue %67, %107[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %109 = llvm.insertvalue %89, %108[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %110 = llvm.extractvalue %39[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %111 = llvm.bitcast %110 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %112 = llvm.insertvalue %111, %34[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %113 = llvm.extractvalue %39[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %114 = llvm.bitcast %113 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %115 = llvm.insertvalue %114, %112[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %116 = llvm.extractvalue %39[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %117 = llvm.extractvalue %39[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %118 = llvm.mul %61, %116  : i64
          %119 = llvm.add %117, %118  : i64
          %120 = llvm.insertvalue %119, %115[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %121 = llvm.insertvalue %71, %120[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %122 = llvm.insertvalue %86, %121[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          llvm.br ^bb5(%1 : i64)
        ^bb5(%123: i64):  // 2 preds: ^bb4, ^bb8
          %124 = llvm.icmp "slt" %123, %67 : i64
          llvm.cond_br %124, ^bb6(%1 : i64), ^bb9
        ^bb6(%125: i64):  // 2 preds: ^bb5, ^bb7
          %126 = llvm.icmp "slt" %125, %71 : i64
          llvm.cond_br %126, ^bb7, ^bb8
        ^bb7:  // pred: ^bb6
          %127 = llvm.extractvalue %91[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %128 = llvm.extractvalue %91[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %129 = llvm.mul %123, %0  : i64
          %130 = llvm.add %128, %129  : i64
          %131 = llvm.add %130, %125  : i64
          %132 = llvm.getelementptr %127[%131] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
          %133 = llvm.load %132 : !llvm.ptr<f32>
          %134 = llvm.extractvalue %109[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %135 = llvm.extractvalue %109[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %136 = llvm.add %135, %129  : i64
          %137 = llvm.add %136, %125  : i64
          %138 = llvm.getelementptr %134[%137] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
          %139 = llvm.load %138 : !llvm.ptr<f32>
          %140 = llvm.fadd %133, %139  : f32
          %141 = llvm.extractvalue %122[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %142 = llvm.extractvalue %122[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %143 = llvm.add %142, %125  : i64
          %144 = llvm.getelementptr %141[%143] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
          llvm.store %140, %144 : !llvm.ptr<f32>
          %145 = llvm.add %125, %2  : i64
          llvm.br ^bb6(%145 : i64)
        ^bb8:  // pred: ^bb6
          %146 = llvm.add %123, %2  : i64
          llvm.br ^bb5(%146 : i64)
        ^bb9:  // pred: ^bb5
          %147 = llvm.add %61, %60  : i64
          llvm.br ^bb3(%147 : i64)
        ^bb10:  // pred: ^bb3
          %148 = llvm.add %57, %56  : i64
          llvm.br ^bb1(%148 : i64)
        ^bb11:  // pred: ^bb1
          %149 = llvm.mlir.constant(0 : i32) : i32
          llvm.return %149 : i32
        }
        llvm.func internal @predict_dispatch_4(%arg0: !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>, %arg1: !llvm.ptr<array<3 x i32>>) -> i32 {
          %0 = llvm.mlir.constant(0x7FC00000 : f32) : f32
          %1 = llvm.mlir.constant(0xFF800000 : f32) : f32
          %2 = llvm.mlir.constant(10 : index) : i64
          %3 = llvm.mlir.constant(0 : index) : i64
          %4 = llvm.mlir.constant(1 : index) : i64
          %5 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %6 = llvm.extractvalue %5[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %7 = llvm.getelementptr %6[%3] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
          %8 = llvm.load %7 : !llvm.ptr<ptr<i8>>
          %9 = llvm.getelementptr %8[%3] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
          %10 = llvm.bitcast %9 : !llvm.ptr<i8> to !llvm.ptr<f32>
          %11 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %12 = llvm.insertvalue %10, %11[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %13 = llvm.insertvalue %10, %12[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %14 = llvm.insertvalue %3, %13[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %15 = llvm.insertvalue %2, %14[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %16 = llvm.insertvalue %4, %15[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %17 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %18 = llvm.extractvalue %17[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %19 = llvm.getelementptr %18[%4] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
          %20 = llvm.load %19 : !llvm.ptr<ptr<i8>>
          %21 = llvm.getelementptr %20[%3] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
          %22 = llvm.bitcast %21 : !llvm.ptr<i8> to !llvm.ptr<f32>
          %23 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
          %24 = llvm.insertvalue %22, %23[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
          %25 = llvm.insertvalue %22, %24[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
          %26 = llvm.insertvalue %3, %25[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
          %27 = llvm.extractvalue %26[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
          llvm.store %1, %27 : !llvm.ptr<f32>
          llvm.br ^bb1(%3 : i64)
        ^bb1(%28: i64):  // 2 preds: ^bb0, ^bb2
          %29 = llvm.icmp "slt" %28, %2 : i64
          llvm.cond_br %29, ^bb2, ^bb3
        ^bb2:  // pred: ^bb1
          %30 = llvm.extractvalue %16[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %31 = llvm.getelementptr %30[%28] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
          %32 = llvm.load %31 : !llvm.ptr<f32>
          %33 = llvm.load %27 : !llvm.ptr<f32>
          %34 = llvm.fcmp "ogt" %32, %33 : f32
          %35 = llvm.select %34, %32, %33 : i1, f32
          %36 = llvm.fcmp "uno" %32, %33 : f32
          %37 = llvm.select %36, %0, %35 : i1, f32
          llvm.store %37, %27 : !llvm.ptr<f32>
          %38 = llvm.add %28, %4  : i64
          llvm.br ^bb1(%38 : i64)
        ^bb3:  // pred: ^bb1
          %39 = llvm.mlir.constant(0 : i32) : i32
          llvm.return %39 : i32
        }
        llvm.mlir.global private constant @__constant_1x10xf32_5(opaque<"_", "0xDEADBEEF"> : tensor<1x10xf32>) : !llvm.array<1 x array<10 x f32>>
        llvm.func internal @predict_dispatch_5(%arg0: !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>, %arg1: !llvm.ptr<array<3 x i32>>) -> i32 {
          %0 = llvm.mlir.constant(10 : index) : i64
          %1 = llvm.mlir.constant(0 : index) : i64
          %2 = llvm.mlir.constant(1 : index) : i64
          %3 = llvm.mlir.constant(0.693147182 : f32) : f32
          %4 = llvm.mlir.constant(1.44269502 : f32) : f32
          %5 = llvm.mlir.constant(1.000000e+00 : f32) : f32
          %6 = llvm.mlir.constant(0.499705136 : f32) : f32
          %7 = llvm.mlir.constant(0.168738902 : f32) : f32
          %8 = llvm.mlir.constant(0.0366896503 : f32) : f32
          %9 = llvm.mlir.constant(1.314350e-02 : f32) : f32
          %10 = llvm.mlir.constant(23 : i32) : i32
          %11 = llvm.mlir.constant(0.000000e+00 : f32) : f32
          %12 = llvm.mlir.constant(0x7F800000 : f32) : f32
          %13 = llvm.mlir.constant(0xFF800000 : f32) : f32
          %14 = llvm.mlir.constant(1.17549435E-38 : f32) : f32
          %15 = llvm.mlir.constant(127 : i32) : i32
          %16 = llvm.mlir.constant(-127 : i32) : i32
          %17 = llvm.mlir.addressof @__constant_1x10xf32_5 : !llvm.ptr<array<1 x array<10 x f32>>>
          %18 = llvm.getelementptr %17[%1, %1, %1] : (!llvm.ptr<array<1 x array<10 x f32>>>, i64, i64, i64) -> !llvm.ptr<f32>
          %19 = llvm.mlir.constant(3735928559 : index) : i64
          %20 = llvm.inttoptr %19 : i64 to !llvm.ptr<f32>
          %21 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %22 = llvm.insertvalue %20, %21[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %23 = llvm.insertvalue %18, %22[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %24 = llvm.insertvalue %1, %23[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %25 = llvm.insertvalue %2, %24[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %26 = llvm.insertvalue %0, %25[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %27 = llvm.insertvalue %0, %26[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %28 = llvm.insertvalue %2, %27[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %29 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %30 = llvm.extractvalue %29[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %31 = llvm.getelementptr %30[%1] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
          %32 = llvm.load %31 : !llvm.ptr<ptr<i8>>
          %33 = llvm.getelementptr %32[%1] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
          %34 = llvm.bitcast %33 : !llvm.ptr<i8> to !llvm.ptr<f32>
          %35 = llvm.insertvalue %34, %21[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %36 = llvm.insertvalue %34, %35[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %37 = llvm.insertvalue %1, %36[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %38 = llvm.insertvalue %2, %37[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %39 = llvm.insertvalue %0, %38[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %40 = llvm.insertvalue %0, %39[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %41 = llvm.insertvalue %2, %40[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %42 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %43 = llvm.extractvalue %42[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %44 = llvm.getelementptr %43[%2] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
          %45 = llvm.load %44 : !llvm.ptr<ptr<i8>>
          %46 = llvm.getelementptr %45[%1] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
          %47 = llvm.bitcast %46 : !llvm.ptr<i8> to !llvm.ptr<f32>
          %48 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
          %49 = llvm.insertvalue %47, %48[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
          %50 = llvm.insertvalue %47, %49[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
          %51 = llvm.insertvalue %1, %50[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
          %52 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %53 = llvm.extractvalue %52[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %54 = llvm.mlir.constant(2 : index) : i64
          %55 = llvm.getelementptr %53[%54] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
          %56 = llvm.load %55 : !llvm.ptr<ptr<i8>>
          %57 = llvm.getelementptr %56[%1] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
          %58 = llvm.bitcast %57 : !llvm.ptr<i8> to !llvm.ptr<f32>
          %59 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %60 = llvm.insertvalue %58, %59[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %61 = llvm.insertvalue %58, %60[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %62 = llvm.insertvalue %1, %61[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %63 = llvm.insertvalue %0, %62[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %64 = llvm.insertvalue %2, %63[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %65 = llvm.load %arg1 : !llvm.ptr<array<3 x i32>>
          %66 = llvm.extractvalue %65[0] : !llvm.array<3 x i32>
          %67 = llvm.zext %66 : i32 to i64
          %68 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %69 = llvm.extractvalue %68[0] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %70 = llvm.extractvalue %69[0] : !llvm.array<3 x i32>
          %71 = llvm.zext %70 : i32 to i64
          %72 = llvm.load %arg1 : !llvm.ptr<array<3 x i32>>
          %73 = llvm.extractvalue %72[1] : !llvm.array<3 x i32>
          %74 = llvm.zext %73 : i32 to i64
          %75 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %76 = llvm.extractvalue %75[0] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %77 = llvm.extractvalue %76[1] : !llvm.array<3 x i32>
          %78 = llvm.zext %77 : i32 to i64
          %79 = llvm.mlir.constant(128 : index) : i64
          %80 = llvm.mul %74, %79  : i64
          %81 = llvm.mul %78, %79  : i64
          llvm.br ^bb1(%80 : i64)
        ^bb1(%82: i64):  // 2 preds: ^bb0, ^bb10
          %83 = llvm.icmp "slt" %82, %2 : i64
          llvm.cond_br %83, ^bb2, ^bb11
        ^bb2:  // pred: ^bb1
          %84 = llvm.mul %67, %79  : i64
          %85 = llvm.mul %71, %79  : i64
          llvm.br ^bb3(%84 : i64)
        ^bb3(%86: i64):  // 2 preds: ^bb2, ^bb9
          %87 = llvm.icmp "slt" %86, %0 : i64
          llvm.cond_br %87, ^bb4, ^bb10
        ^bb4:  // pred: ^bb3
          %88 = llvm.mlir.constant(-1 : index) : i64
          %89 = llvm.mul %82, %88  : i64
          %90 = llvm.add %89, %2  : i64
          %91 = llvm.icmp "slt" %79, %90 : i64
          %92 = llvm.select %91, %79, %90 : i1, i64
          %93 = llvm.mul %86, %88  : i64
          %94 = llvm.add %93, %0  : i64
          %95 = llvm.icmp "slt" %79, %94 : i64
          %96 = llvm.select %95, %79, %94 : i1, i64
          %97 = llvm.extractvalue %41[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %98 = llvm.bitcast %97 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %99 = llvm.insertvalue %98, %21[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %100 = llvm.extractvalue %41[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %101 = llvm.bitcast %100 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %102 = llvm.insertvalue %101, %99[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %103 = llvm.extractvalue %41[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %104 = llvm.extractvalue %41[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %105 = llvm.extractvalue %41[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %106 = llvm.mul %82, %103  : i64
          %107 = llvm.add %105, %106  : i64
          %108 = llvm.mul %86, %104  : i64
          %109 = llvm.add %107, %108  : i64
          %110 = llvm.insertvalue %109, %102[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %111 = llvm.mlir.constant(1 : i64) : i64
          %112 = llvm.insertvalue %96, %110[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %113 = llvm.insertvalue %111, %112[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %114 = llvm.mlir.constant(10 : i64) : i64
          %115 = llvm.insertvalue %92, %113[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %116 = llvm.insertvalue %114, %115[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %117 = llvm.extractvalue %28[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %118 = llvm.bitcast %117 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %119 = llvm.insertvalue %118, %21[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %120 = llvm.extractvalue %28[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %121 = llvm.bitcast %120 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %122 = llvm.insertvalue %121, %119[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %123 = llvm.extractvalue %28[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %124 = llvm.extractvalue %28[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %125 = llvm.extractvalue %28[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %126 = llvm.mul %82, %123  : i64
          %127 = llvm.add %125, %126  : i64
          %128 = llvm.mul %86, %124  : i64
          %129 = llvm.add %127, %128  : i64
          %130 = llvm.insertvalue %129, %122[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %131 = llvm.insertvalue %96, %130[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %132 = llvm.insertvalue %111, %131[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %133 = llvm.insertvalue %92, %132[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %134 = llvm.insertvalue %114, %133[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %135 = llvm.extractvalue %64[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %136 = llvm.bitcast %135 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %137 = llvm.insertvalue %136, %59[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %138 = llvm.extractvalue %64[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %139 = llvm.bitcast %138 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %140 = llvm.insertvalue %139, %137[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %141 = llvm.extractvalue %64[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %142 = llvm.extractvalue %64[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %143 = llvm.mul %86, %141  : i64
          %144 = llvm.add %142, %143  : i64
          %145 = llvm.insertvalue %144, %140[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %146 = llvm.insertvalue %96, %145[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %147 = llvm.insertvalue %111, %146[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          llvm.br ^bb5(%1 : i64)
        ^bb5(%148: i64):  // 2 preds: ^bb4, ^bb8
          %149 = llvm.icmp "slt" %148, %92 : i64
          llvm.cond_br %149, ^bb6(%1 : i64), ^bb9
        ^bb6(%150: i64):  // 2 preds: ^bb5, ^bb7
          %151 = llvm.icmp "slt" %150, %96 : i64
          llvm.cond_br %151, ^bb7, ^bb8
        ^bb7:  // pred: ^bb6
          %152 = llvm.extractvalue %116[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %153 = llvm.extractvalue %116[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %154 = llvm.mul %148, %0  : i64
          %155 = llvm.add %153, %154  : i64
          %156 = llvm.add %155, %150  : i64
          %157 = llvm.getelementptr %152[%156] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
          %158 = llvm.load %157 : !llvm.ptr<f32>
          %159 = llvm.extractvalue %134[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %160 = llvm.extractvalue %134[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %161 = llvm.add %160, %154  : i64
          %162 = llvm.add %161, %150  : i64
          %163 = llvm.getelementptr %159[%162] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
          %164 = llvm.load %163 : !llvm.ptr<f32>
          %165 = llvm.extractvalue %51[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
          %166 = llvm.load %165 : !llvm.ptr<f32>
          %167 = llvm.fadd %158, %164  : f32
          %168 = llvm.fsub %167, %166  : f32
          %169 = llvm.fmul %168, %4  : f32
          %170 = "llvm.intr.floor"(%169) : (f32) -> f32
          %171 = llvm.fmul %170, %3  : f32
          %172 = llvm.fsub %168, %171  : f32
          %173 = llvm.fmul %172, %172  : f32
          %174 = llvm.fmul %173, %173  : f32
          %175 = "llvm.intr.fma"(%5, %172, %5) : (f32, f32, f32) -> f32
          %176 = "llvm.intr.fma"(%7, %172, %6) : (f32, f32, f32) -> f32
          %177 = "llvm.intr.fma"(%9, %172, %8) : (f32, f32, f32) -> f32
          %178 = "llvm.intr.fma"(%176, %173, %175) : (f32, f32, f32) -> f32
          %179 = "llvm.intr.fma"(%177, %174, %178) : (f32, f32, f32) -> f32
          %180 = llvm.fptosi %170 : f32 to i32
          %181 = llvm.add %180, %15  : i32
          %182 = llvm.shl %181, %10  : i32
          %183 = llvm.bitcast %182 : i32 to f32
          %184 = llvm.fmul %179, %183  : f32
          %185 = llvm.icmp "sle" %180, %15 : i32
          %186 = llvm.icmp "sge" %180, %16 : i32
          %187 = llvm.fcmp "oeq" %168, %13 : f32
          %188 = llvm.fcmp "ogt" %168, %11 : f32
          %189 = llvm.and %185, %186  : i1
          %190 = llvm.select %187, %11, %14 : i1, f32
          %191 = llvm.select %188, %12, %190 : i1, f32
          %192 = llvm.select %189, %184, %191 : i1, f32
          %193 = llvm.extractvalue %147[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %194 = llvm.extractvalue %147[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %195 = llvm.add %194, %150  : i64
          %196 = llvm.getelementptr %193[%195] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
          llvm.store %192, %196 : !llvm.ptr<f32>
          %197 = llvm.add %150, %2  : i64
          llvm.br ^bb6(%197 : i64)
        ^bb8:  // pred: ^bb6
          %198 = llvm.add %148, %2  : i64
          llvm.br ^bb5(%198 : i64)
        ^bb9:  // pred: ^bb5
          %199 = llvm.add %86, %85  : i64
          llvm.br ^bb3(%199 : i64)
        ^bb10:  // pred: ^bb3
          %200 = llvm.add %82, %81  : i64
          llvm.br ^bb1(%200 : i64)
        ^bb11:  // pred: ^bb1
          %201 = llvm.mlir.constant(0 : i32) : i32
          llvm.return %201 : i32
        }
        llvm.func internal @predict_dispatch_6(%arg0: !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>, %arg1: !llvm.ptr<array<3 x i32>>) -> i32 {
          %0 = llvm.mlir.constant(0.000000e+00 : f32) : f32
          %1 = llvm.mlir.constant(10 : index) : i64
          %2 = llvm.mlir.constant(0 : index) : i64
          %3 = llvm.mlir.constant(1 : index) : i64
          %4 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %5 = llvm.extractvalue %4[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %6 = llvm.getelementptr %5[%2] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
          %7 = llvm.load %6 : !llvm.ptr<ptr<i8>>
          %8 = llvm.getelementptr %7[%2] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
          %9 = llvm.bitcast %8 : !llvm.ptr<i8> to !llvm.ptr<f32>
          %10 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %11 = llvm.insertvalue %9, %10[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %12 = llvm.insertvalue %9, %11[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %13 = llvm.insertvalue %2, %12[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %14 = llvm.insertvalue %1, %13[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %15 = llvm.insertvalue %3, %14[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %16 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %17 = llvm.extractvalue %16[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %18 = llvm.getelementptr %17[%3] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
          %19 = llvm.load %18 : !llvm.ptr<ptr<i8>>
          %20 = llvm.getelementptr %19[%2] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
          %21 = llvm.bitcast %20 : !llvm.ptr<i8> to !llvm.ptr<f32>
          %22 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
          %23 = llvm.insertvalue %21, %22[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
          %24 = llvm.insertvalue %21, %23[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
          %25 = llvm.insertvalue %2, %24[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
          %26 = llvm.extractvalue %25[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
          llvm.store %0, %26 : !llvm.ptr<f32>
          llvm.br ^bb1(%2 : i64)
        ^bb1(%27: i64):  // 2 preds: ^bb0, ^bb2
          %28 = llvm.icmp "slt" %27, %1 : i64
          llvm.cond_br %28, ^bb2, ^bb3
        ^bb2:  // pred: ^bb1
          %29 = llvm.extractvalue %15[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<1 x i64>, array<1 x i64>)>
          %30 = llvm.getelementptr %29[%27] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
          %31 = llvm.load %30 : !llvm.ptr<f32>
          %32 = llvm.load %26 : !llvm.ptr<f32>
          %33 = llvm.fadd %31, %32  : f32
          llvm.store %33, %26 : !llvm.ptr<f32>
          %34 = llvm.add %27, %3  : i64
          llvm.br ^bb1(%34 : i64)
        ^bb3:  // pred: ^bb1
          %35 = llvm.mlir.constant(0 : i32) : i32
          llvm.return %35 : i32
        }
        llvm.mlir.global private constant @__constant_1x10xf32_7(opaque<"_", "0xDEADBEEF"> : tensor<1x10xf32>) : !llvm.array<1 x array<10 x f32>>
        llvm.func internal @predict_dispatch_7(%arg0: !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>, %arg1: !llvm.ptr<array<3 x i32>>) -> i32 {
          %0 = llvm.mlir.constant(10 : index) : i64
          %1 = llvm.mlir.constant(0 : index) : i64
          %2 = llvm.mlir.constant(1 : index) : i64
          %3 = llvm.mlir.constant(0.693147182 : f32) : f32
          %4 = llvm.mlir.constant(1.44269502 : f32) : f32
          %5 = llvm.mlir.constant(1.000000e+00 : f32) : f32
          %6 = llvm.mlir.constant(0.499705136 : f32) : f32
          %7 = llvm.mlir.constant(0.168738902 : f32) : f32
          %8 = llvm.mlir.constant(0.0366896503 : f32) : f32
          %9 = llvm.mlir.constant(1.314350e-02 : f32) : f32
          %10 = llvm.mlir.constant(23 : i32) : i32
          %11 = llvm.mlir.constant(0.000000e+00 : f32) : f32
          %12 = llvm.mlir.constant(0x7F800000 : f32) : f32
          %13 = llvm.mlir.constant(0xFF800000 : f32) : f32
          %14 = llvm.mlir.constant(1.17549435E-38 : f32) : f32
          %15 = llvm.mlir.constant(127 : i32) : i32
          %16 = llvm.mlir.constant(-127 : i32) : i32
          %17 = llvm.mlir.addressof @__constant_1x10xf32_7 : !llvm.ptr<array<1 x array<10 x f32>>>
          %18 = llvm.getelementptr %17[%1, %1, %1] : (!llvm.ptr<array<1 x array<10 x f32>>>, i64, i64, i64) -> !llvm.ptr<f32>
          %19 = llvm.mlir.constant(3735928559 : index) : i64
          %20 = llvm.inttoptr %19 : i64 to !llvm.ptr<f32>
          %21 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %22 = llvm.insertvalue %20, %21[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %23 = llvm.insertvalue %18, %22[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %24 = llvm.insertvalue %1, %23[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %25 = llvm.insertvalue %2, %24[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %26 = llvm.insertvalue %0, %25[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %27 = llvm.insertvalue %0, %26[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %28 = llvm.insertvalue %2, %27[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %29 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %30 = llvm.extractvalue %29[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %31 = llvm.getelementptr %30[%1] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
          %32 = llvm.load %31 : !llvm.ptr<ptr<i8>>
          %33 = llvm.getelementptr %32[%1] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
          %34 = llvm.bitcast %33 : !llvm.ptr<i8> to !llvm.ptr<f32>
          %35 = llvm.insertvalue %34, %21[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %36 = llvm.insertvalue %34, %35[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %37 = llvm.insertvalue %1, %36[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %38 = llvm.insertvalue %2, %37[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %39 = llvm.insertvalue %0, %38[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %40 = llvm.insertvalue %0, %39[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %41 = llvm.insertvalue %2, %40[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %42 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %43 = llvm.extractvalue %42[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %44 = llvm.getelementptr %43[%2] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
          %45 = llvm.load %44 : !llvm.ptr<ptr<i8>>
          %46 = llvm.getelementptr %45[%1] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
          %47 = llvm.bitcast %46 : !llvm.ptr<i8> to !llvm.ptr<f32>
          %48 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
          %49 = llvm.insertvalue %47, %48[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
          %50 = llvm.insertvalue %47, %49[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
          %51 = llvm.insertvalue %1, %50[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
          %52 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %53 = llvm.extractvalue %52[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %54 = llvm.mlir.constant(2 : index) : i64
          %55 = llvm.getelementptr %53[%54] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
          %56 = llvm.load %55 : !llvm.ptr<ptr<i8>>
          %57 = llvm.getelementptr %56[%1] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
          %58 = llvm.bitcast %57 : !llvm.ptr<i8> to !llvm.ptr<f32>
          %59 = llvm.insertvalue %58, %48[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
          %60 = llvm.insertvalue %58, %59[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
          %61 = llvm.insertvalue %1, %60[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
          %62 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %63 = llvm.extractvalue %62[5] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %64 = llvm.mlir.constant(3 : index) : i64
          %65 = llvm.getelementptr %63[%64] : (!llvm.ptr<ptr<i8>>, i64) -> !llvm.ptr<ptr<i8>>
          %66 = llvm.load %65 : !llvm.ptr<ptr<i8>>
          %67 = llvm.getelementptr %66[%1] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
          %68 = llvm.bitcast %67 : !llvm.ptr<i8> to !llvm.ptr<f32>
          %69 = llvm.insertvalue %68, %21[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %70 = llvm.insertvalue %68, %69[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %71 = llvm.insertvalue %1, %70[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %72 = llvm.insertvalue %2, %71[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %73 = llvm.insertvalue %0, %72[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %74 = llvm.insertvalue %0, %73[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %75 = llvm.insertvalue %2, %74[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %76 = llvm.load %arg1 : !llvm.ptr<array<3 x i32>>
          %77 = llvm.extractvalue %76[0] : !llvm.array<3 x i32>
          %78 = llvm.zext %77 : i32 to i64
          %79 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %80 = llvm.extractvalue %79[0] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %81 = llvm.extractvalue %80[0] : !llvm.array<3 x i32>
          %82 = llvm.zext %81 : i32 to i64
          %83 = llvm.load %arg1 : !llvm.ptr<array<3 x i32>>
          %84 = llvm.extractvalue %83[1] : !llvm.array<3 x i32>
          %85 = llvm.zext %84 : i32 to i64
          %86 = llvm.load %arg0 : !llvm.ptr<struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>>
          %87 = llvm.extractvalue %86[0] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (array<3 x i32>, array<3 x i32>, i64, ptr<i32>, i64, ptr<ptr<i8>>, ptr<i64>)>
          %88 = llvm.extractvalue %87[1] : !llvm.array<3 x i32>
          %89 = llvm.zext %88 : i32 to i64
          %90 = llvm.mlir.constant(128 : index) : i64
          %91 = llvm.mul %85, %90  : i64
          %92 = llvm.mul %89, %90  : i64
          llvm.br ^bb1(%91 : i64)
        ^bb1(%93: i64):  // 2 preds: ^bb0, ^bb10
          %94 = llvm.icmp "slt" %93, %2 : i64
          llvm.cond_br %94, ^bb2, ^bb11
        ^bb2:  // pred: ^bb1
          %95 = llvm.mul %78, %90  : i64
          %96 = llvm.mul %82, %90  : i64
          llvm.br ^bb3(%95 : i64)
        ^bb3(%97: i64):  // 2 preds: ^bb2, ^bb9
          %98 = llvm.icmp "slt" %97, %0 : i64
          llvm.cond_br %98, ^bb4, ^bb10
        ^bb4:  // pred: ^bb3
          %99 = llvm.mlir.constant(-1 : index) : i64
          %100 = llvm.mul %93, %99  : i64
          %101 = llvm.add %100, %2  : i64
          %102 = llvm.icmp "slt" %90, %101 : i64
          %103 = llvm.select %102, %90, %101 : i1, i64
          %104 = llvm.mul %97, %99  : i64
          %105 = llvm.add %104, %0  : i64
          %106 = llvm.icmp "slt" %90, %105 : i64
          %107 = llvm.select %106, %90, %105 : i1, i64
          %108 = llvm.extractvalue %41[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %109 = llvm.bitcast %108 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %110 = llvm.insertvalue %109, %21[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %111 = llvm.extractvalue %41[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %112 = llvm.bitcast %111 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %113 = llvm.insertvalue %112, %110[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %114 = llvm.extractvalue %41[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %115 = llvm.extractvalue %41[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %116 = llvm.extractvalue %41[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %117 = llvm.mul %93, %114  : i64
          %118 = llvm.add %116, %117  : i64
          %119 = llvm.mul %97, %115  : i64
          %120 = llvm.add %118, %119  : i64
          %121 = llvm.insertvalue %120, %113[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %122 = llvm.mlir.constant(1 : i64) : i64
          %123 = llvm.insertvalue %107, %121[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %124 = llvm.insertvalue %122, %123[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %125 = llvm.mlir.constant(10 : i64) : i64
          %126 = llvm.insertvalue %103, %124[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %127 = llvm.insertvalue %125, %126[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %128 = llvm.extractvalue %28[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %129 = llvm.bitcast %128 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %130 = llvm.insertvalue %129, %21[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %131 = llvm.extractvalue %28[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %132 = llvm.bitcast %131 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %133 = llvm.insertvalue %132, %130[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %134 = llvm.extractvalue %28[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %135 = llvm.extractvalue %28[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %136 = llvm.extractvalue %28[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %137 = llvm.mul %93, %134  : i64
          %138 = llvm.add %136, %137  : i64
          %139 = llvm.mul %97, %135  : i64
          %140 = llvm.add %138, %139  : i64
          %141 = llvm.insertvalue %140, %133[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %142 = llvm.insertvalue %107, %141[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %143 = llvm.insertvalue %122, %142[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %144 = llvm.insertvalue %103, %143[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %145 = llvm.insertvalue %125, %144[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %146 = llvm.extractvalue %75[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %147 = llvm.bitcast %146 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %148 = llvm.insertvalue %147, %21[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %149 = llvm.extractvalue %75[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %150 = llvm.bitcast %149 : !llvm.ptr<f32> to !llvm.ptr<f32>
          %151 = llvm.insertvalue %150, %148[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %152 = llvm.extractvalue %75[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %153 = llvm.extractvalue %75[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %154 = llvm.extractvalue %75[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %155 = llvm.mul %93, %152  : i64
          %156 = llvm.add %154, %155  : i64
          %157 = llvm.mul %97, %153  : i64
          %158 = llvm.add %156, %157  : i64
          %159 = llvm.insertvalue %158, %151[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %160 = llvm.insertvalue %107, %159[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %161 = llvm.insertvalue %122, %160[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %162 = llvm.insertvalue %103, %161[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %163 = llvm.insertvalue %125, %162[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          llvm.br ^bb5(%1 : i64)
        ^bb5(%164: i64):  // 2 preds: ^bb4, ^bb8
          %165 = llvm.icmp "slt" %164, %103 : i64
          llvm.cond_br %165, ^bb6(%1 : i64), ^bb9
        ^bb6(%166: i64):  // 2 preds: ^bb5, ^bb7
          %167 = llvm.icmp "slt" %166, %107 : i64
          llvm.cond_br %167, ^bb7, ^bb8
        ^bb7:  // pred: ^bb6
          %168 = llvm.extractvalue %127[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %169 = llvm.extractvalue %127[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %170 = llvm.mul %164, %0  : i64
          %171 = llvm.add %169, %170  : i64
          %172 = llvm.add %171, %166  : i64
          %173 = llvm.getelementptr %168[%172] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
          %174 = llvm.load %173 : !llvm.ptr<f32>
          %175 = llvm.extractvalue %145[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %176 = llvm.extractvalue %145[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %177 = llvm.add %176, %170  : i64
          %178 = llvm.add %177, %166  : i64
          %179 = llvm.getelementptr %175[%178] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
          %180 = llvm.load %179 : !llvm.ptr<f32>
          %181 = llvm.extractvalue %51[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
          %182 = llvm.load %181 : !llvm.ptr<f32>
          %183 = llvm.extractvalue %61[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64)>
          %184 = llvm.load %183 : !llvm.ptr<f32>
          %185 = llvm.fadd %174, %180  : f32
          %186 = llvm.fsub %185, %182  : f32
          %187 = llvm.fmul %186, %4  : f32
          %188 = "llvm.intr.floor"(%187) : (f32) -> f32
          %189 = llvm.fmul %188, %3  : f32
          %190 = llvm.fsub %186, %189  : f32
          %191 = llvm.fmul %190, %190  : f32
          %192 = llvm.fmul %191, %191  : f32
          %193 = "llvm.intr.fma"(%5, %190, %5) : (f32, f32, f32) -> f32
          %194 = "llvm.intr.fma"(%7, %190, %6) : (f32, f32, f32) -> f32
          %195 = "llvm.intr.fma"(%9, %190, %8) : (f32, f32, f32) -> f32
          %196 = "llvm.intr.fma"(%194, %191, %193) : (f32, f32, f32) -> f32
          %197 = "llvm.intr.fma"(%195, %192, %196) : (f32, f32, f32) -> f32
          %198 = llvm.fptosi %188 : f32 to i32
          %199 = llvm.add %198, %15  : i32
          %200 = llvm.shl %199, %10  : i32
          %201 = llvm.bitcast %200 : i32 to f32
          %202 = llvm.fmul %197, %201  : f32
          %203 = llvm.icmp "sle" %198, %15 : i32
          %204 = llvm.icmp "sge" %198, %16 : i32
          %205 = llvm.fcmp "oeq" %186, %13 : f32
          %206 = llvm.fcmp "ogt" %186, %11 : f32
          %207 = llvm.and %203, %204  : i1
          %208 = llvm.select %205, %11, %14 : i1, f32
          %209 = llvm.select %206, %12, %208 : i1, f32
          %210 = llvm.select %207, %202, %209 : i1, f32
          %211 = llvm.fdiv %210, %184  : f32
          %212 = llvm.extractvalue %163[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %213 = llvm.extractvalue %163[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<2 x i64>, array<2 x i64>)>
          %214 = llvm.add %213, %170  : i64
          %215 = llvm.add %214, %166  : i64
          %216 = llvm.getelementptr %212[%215] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
          llvm.store %211, %216 : !llvm.ptr<f32>
          %217 = llvm.add %166, %2  : i64
          llvm.br ^bb6(%217 : i64)
        ^bb8:  // pred: ^bb6
          %218 = llvm.add %164, %2  : i64
          llvm.br ^bb5(%218 : i64)
        ^bb9:  // pred: ^bb5
          %219 = llvm.add %97, %96  : i64
          llvm.br ^bb3(%219 : i64)
        ^bb10:  // pred: ^bb3
          %220 = llvm.add %93, %92  : i64
          llvm.br ^bb1(%220 : i64)
        ^bb11:  // pred: ^bb1
          %221 = llvm.mlir.constant(0 : i32) : i32
          llvm.return %221 : i32
        }
      }
    }
  }
  hal.constant_pool @_const_pool attributes {buffer_constraints = #hal.buffer_constraints<max_allocation_size = 1073741824, min_buffer_offset_alignment = 16, max_buffer_range = 1073741824, min_buffer_range_alignment = 16>, sym_visibility = "private"} {
    hal.constant_storage @_storage = opaque<"_", "0xDEADBEEF"> : vector<407040xi8> attributes {sym_visibility = "nested"}
  }
  hal.variable @_const_pool_storage_buffer init(@_const_pool_storage_buffer_initializer) : !hal.buffer attributes {sym_visibility = "private"}
  func private @_const_pool_storage_buffer_initializer() -> !hal.buffer {
    %c0 = constant 0 : index
    %c407040 = constant 407040 : index
    %device = hal.ex.shared_device : !hal.device
    %allocator = hal.device.allocator<%device : !hal.device> : !hal.allocator
    %storage = hal.constant_storage.lookup @_const_pool::@_storage : !iree.byte_buffer
    %mapped = hal.allocator.map<%allocator : !hal.allocator> source(%storage : !iree.byte_buffer)[%c0, %c407040] type("HostVisible|DeviceVisible|DeviceLocal") usage("Constant|Transfer|Mapping|Dispatch") : !hal.buffer
    return %mapped : !hal.buffer
  }
  func @predict(%arg0: !hal.buffer) -> !hal.buffer attributes {noinline} {
    %c3136 = constant 3136 : index
    %c401408 = constant 401408 : index
    %c401920 = constant 401920 : index
    %c5120 = constant 5120 : index
    %c40 = constant 40 : index
    %c4 = constant 4 : index
    %c128 = constant 128 : index
    %c1 = constant 1 : index
    %c10 = constant 10 : index
    %c2 = constant 2 : index
    %c3 = constant 3 : index
    %c0 = constant 0 : index
    %c512 = constant 512 : index
    %c96 = constant 96 : index
    %c48 = constant 48 : index
    %c112 = constant 112 : index
    %c1024 = constant 1024 : index
    %device = hal.ex.shared_device : !hal.device
    %allocator = hal.device.allocator<%device : !hal.device> : !hal.allocator
    %buffer = hal.allocator.allocate<%allocator : !hal.allocator> type("HostVisible|DeviceVisible|DeviceLocal") usage("Transfer|Mapping|Dispatch") : !hal.buffer{%c40}
    %0 = hal.variable.load @_const_pool_storage_buffer : !hal.buffer
    %buffer_0 = hal.allocator.allocate<%allocator : !hal.allocator> type("DeviceVisible|DeviceLocal") usage("Transfer|Dispatch") : !hal.buffer{%c1024}
    %cmd = hal.command_buffer.create device(%device : !hal.device) mode("OneShot|AllowInlineExecution") categories("Transfer|Dispatch") : !hal.command_buffer
    hal.command_buffer.begin<%cmd : !hal.command_buffer>
    %1 = hal.variable.load @_executable_layout_0 : !hal.executable_layout
    hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%1 : !hal.executable_layout)[%c0] bindings([
      %c0 = (%0 : !hal.buffer)[%c512, %c401408], 
      %c1 = (%arg0 : !hal.buffer)[%c0, %c3136], 
      %c2 = (%buffer_0 : !hal.buffer)[%c0, %c512]
    ])
    %2 = hal.variable.load @_device_match_id_0 : i1
    cond_br %2, ^bb1, ^bb2
  ^bb1:  // pred: ^bb0
    %c1_1 = constant 1 : index
    %c2_2 = constant 2 : index
    %c1_3 = constant 1 : index
    %3 = hal.command_buffer.device<%cmd : !hal.command_buffer> : !hal.device
    %4 = hal.variable.load @_executable_mnist_linked_llvm_aot : !hal.executable
    hal.command_buffer.dispatch<%cmd : !hal.command_buffer> target(%4 : !hal.executable)[0] workgroups([%c2_2, %c1_3, %c1_1])
    br ^bb3
  ^bb2:  // pred: ^bb0
    iree.unreachable "device not supported in the compiled configuration"
  ^bb3:  // pred: ^bb1
    hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
    hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%1 : !hal.executable_layout)[%c0] bindings([
      %c0 = (%0 : !hal.buffer)[%c0, %c512], 
      %c1 = (%buffer_0 : !hal.buffer)[%c0, %c512], 
      %c2 = (%buffer_0 : !hal.buffer)[%c512, %c512]
    ])
    %5 = hal.variable.load @_device_match_id_0 : i1
    cond_br %5, ^bb4, ^bb5
  ^bb4:  // pred: ^bb3
    %c1_4 = constant 1 : index
    %c1_5 = constant 1 : index
    %c1_6 = constant 1 : index
    %6 = hal.command_buffer.device<%cmd : !hal.command_buffer> : !hal.device
    %7 = hal.variable.load @_executable_mnist_linked_llvm_aot : !hal.executable
    hal.command_buffer.dispatch<%cmd : !hal.command_buffer> target(%7 : !hal.executable)[1] workgroups([%c1_5, %c1_6, %c1_4])
    br ^bb6
  ^bb5:  // pred: ^bb3
    iree.unreachable "device not supported in the compiled configuration"
  ^bb6:  // pred: ^bb4
    hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
    hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%1 : !hal.executable_layout)[%c0] bindings([
      %c0 = (%0 : !hal.buffer)[%c401920, %c5120], 
      %c1 = (%buffer_0 : !hal.buffer)[%c512, %c512], 
      %c2 = (%buffer_0 : !hal.buffer)[%c0, %c40]
    ])
    %8 = hal.variable.load @_device_match_id_0 : i1
    cond_br %8, ^bb7, ^bb8
  ^bb7:  // pred: ^bb6
    %c1_7 = constant 1 : index
    %c1_8 = constant 1 : index
    %c1_9 = constant 1 : index
    %9 = hal.command_buffer.device<%cmd : !hal.command_buffer> : !hal.device
    %10 = hal.variable.load @_executable_mnist_linked_llvm_aot : !hal.executable
    hal.command_buffer.dispatch<%cmd : !hal.command_buffer> target(%10 : !hal.executable)[2] workgroups([%c1_8, %c1_9, %c1_7])
    br ^bb9
  ^bb8:  // pred: ^bb6
    iree.unreachable "device not supported in the compiled configuration"
  ^bb9:  // pred: ^bb7
    hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
    %11 = hal.variable.load @_executable_layout_1 : !hal.executable_layout
    hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%11 : !hal.executable_layout)[%c0] bindings([
      %c0 = (%buffer_0 : !hal.buffer)[%c0, %c40], 
      %c1 = (%buffer_0 : !hal.buffer)[%c48, %c40]
    ])
    %12 = hal.variable.load @_device_match_id_0 : i1
    cond_br %12, ^bb10, ^bb11
  ^bb10:  // pred: ^bb9
    %c1_10 = constant 1 : index
    %c1_11 = constant 1 : index
    %c1_12 = constant 1 : index
    %13 = hal.command_buffer.device<%cmd : !hal.command_buffer> : !hal.device
    %14 = hal.variable.load @_executable_mnist_linked_llvm_aot : !hal.executable
    hal.command_buffer.dispatch<%cmd : !hal.command_buffer> target(%14 : !hal.executable)[3] workgroups([%c1_11, %c1_12, %c1_10])
    br ^bb12
  ^bb11:  // pred: ^bb9
    iree.unreachable "device not supported in the compiled configuration"
  ^bb12:  // pred: ^bb10
    hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
    hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%11 : !hal.executable_layout)[%c0] bindings([
      %c0 = (%buffer_0 : !hal.buffer)[%c48, %c40], 
      %c1 = (%buffer_0 : !hal.buffer)[%c96, %c4]
    ])
    %15 = hal.variable.load @_device_match_id_0 : i1
    cond_br %15, ^bb13, ^bb14
  ^bb13:  // pred: ^bb12
    %c1_13 = constant 1 : index
    %16 = hal.command_buffer.device<%cmd : !hal.command_buffer> : !hal.device
    %17 = hal.variable.load @_executable_mnist_linked_llvm_aot : !hal.executable
    hal.command_buffer.dispatch<%cmd : !hal.command_buffer> target(%17 : !hal.executable)[4] workgroups([%c1_13, %c1_13, %c1_13])
    br ^bb15
  ^bb14:  // pred: ^bb12
    iree.unreachable "device not supported in the compiled configuration"
  ^bb15:  // pred: ^bb13
    hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
    hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%1 : !hal.executable_layout)[%c0] bindings([
      %c0 = (%buffer_0 : !hal.buffer)[%c0, %c40], 
      %c1 = (%buffer_0 : !hal.buffer)[%c96, %c4], 
      %c2 = (%buffer_0 : !hal.buffer)[%c48, %c40]
    ])
    %18 = hal.variable.load @_device_match_id_0 : i1
    cond_br %18, ^bb16, ^bb17
  ^bb16:  // pred: ^bb15
    %c1_14 = constant 1 : index
    %c1_15 = constant 1 : index
    %c1_16 = constant 1 : index
    %19 = hal.command_buffer.device<%cmd : !hal.command_buffer> : !hal.device
    %20 = hal.variable.load @_executable_mnist_linked_llvm_aot : !hal.executable
    hal.command_buffer.dispatch<%cmd : !hal.command_buffer> target(%20 : !hal.executable)[5] workgroups([%c1_15, %c1_16, %c1_14])
    br ^bb18
  ^bb17:  // pred: ^bb15
    iree.unreachable "device not supported in the compiled configuration"
  ^bb18:  // pred: ^bb16
    hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
    hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%11 : !hal.executable_layout)[%c0] bindings([
      %c0 = (%buffer_0 : !hal.buffer)[%c48, %c40], 
      %c1 = (%buffer_0 : !hal.buffer)[%c112, %c4]
    ])
    %21 = hal.variable.load @_device_match_id_0 : i1
    cond_br %21, ^bb19, ^bb20
  ^bb19:  // pred: ^bb18
    %c1_17 = constant 1 : index
    %22 = hal.command_buffer.device<%cmd : !hal.command_buffer> : !hal.device
    %23 = hal.variable.load @_executable_mnist_linked_llvm_aot : !hal.executable
    hal.command_buffer.dispatch<%cmd : !hal.command_buffer> target(%23 : !hal.executable)[6] workgroups([%c1_17, %c1_17, %c1_17])
    br ^bb21
  ^bb20:  // pred: ^bb18
    iree.unreachable "device not supported in the compiled configuration"
  ^bb21:  // pred: ^bb19
    hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
    %24 = hal.variable.load @_executable_layout_2 : !hal.executable_layout
    hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%24 : !hal.executable_layout)[%c0] bindings([
      %c0 = (%buffer_0 : !hal.buffer)[%c0, %c40], 
      %c1 = (%buffer_0 : !hal.buffer)[%c96, %c4], 
      %c2 = (%buffer_0 : !hal.buffer)[%c112, %c4], 
      %c3 = (%buffer : !hal.buffer)[%c0, %c40]
    ])
    %25 = hal.variable.load @_device_match_id_0 : i1
    cond_br %25, ^bb22, ^bb23
  ^bb22:  // pred: ^bb21
    %c1_18 = constant 1 : index
    %c1_19 = constant 1 : index
    %c1_20 = constant 1 : index
    %26 = hal.command_buffer.device<%cmd : !hal.command_buffer> : !hal.device
    %27 = hal.variable.load @_executable_mnist_linked_llvm_aot : !hal.executable
    hal.command_buffer.dispatch<%cmd : !hal.command_buffer> target(%27 : !hal.executable)[7] workgroups([%c1_19, %c1_20, %c1_18])
    br ^bb24
  ^bb23:  // pred: ^bb21
    iree.unreachable "device not supported in the compiled configuration"
  ^bb24:  // pred: ^bb22
    hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
    hal.command_buffer.end<%cmd : !hal.command_buffer>
    hal.ex.submit_and_wait %device, %cmd
    return %buffer : !hal.buffer
  }
  func @predict$async(%arg0: !hal.semaphore, %arg1: index, %arg2: !hal.buffer_view, %arg3: !hal.semaphore, %arg4: index) -> !hal.buffer_view attributes {iree.module.export = "predict$async"} {
    %c1 = constant 1 : index
    %c10 = constant 10 : index
    %c50331680_i32 = constant 50331680 : i32
    %0 = hal.semaphore.await<%arg0 : !hal.semaphore> until(%arg1) : i32
    hal.check_success %0, "semaphore wait failed"
    %buffer = hal.buffer_view.buffer %arg2 : !hal.buffer
    %1 = call @predict(%buffer) : (!hal.buffer) -> !hal.buffer
    %view = hal.buffer_view.create %1, element_type = %c50331680_i32, shape = [%c1, %c10] : !hal.buffer -> !hal.buffer_view
    hal.semaphore.signal<%arg3 : !hal.semaphore> value(%arg4)
    return %view : !hal.buffer_view
  }
  func @predict$sync(%arg0: !hal.buffer_view) -> !hal.buffer_view attributes {iree.abi.stub, iree.module.export = "predict", iree.reflection = {abi = "sip", abiv = 1 : i32, f = "I15!B11!d1d28d28d1R9!B6!d1d10", fv = "1", sip = "I8!S5!k0_0R3!_0"}} {
    %c0 = constant 0 : index
    %c1 = constant 1 : index
    %device = hal.ex.shared_device : !hal.device
    %semaphore = hal.semaphore.create device(%device : !hal.device) initial(%c0) : !hal.semaphore
    %0 = call @predict$async(%semaphore, %c0, %arg0, %semaphore, %c1) : (!hal.semaphore, index, !hal.buffer_view, !hal.semaphore, index) -> !hal.buffer_view
    %1 = hal.semaphore.await<%semaphore : !hal.semaphore> until(%c1) : i32
    hal.check_success %1, "semaphore wait failed"
    return %0 : !hal.buffer_view
  }
}


// *** IR Dump After Canonicalizer ***
func private @_device_match_id_0_initializer() -> i1 {
  %device = hal.ex.shared_device : !hal.device
  %0 = hal.device.match.id<%device : !hal.device> pattern("dylib*") : i1
  return %0 : i1
}

// *** IR Dump After CSE ***
func private @_device_match_id_0_initializer() -> i1 {
  %device = hal.ex.shared_device : !hal.device
  %0 = hal.device.match.id<%device : !hal.device> pattern("dylib*") : i1
  return %0 : i1
}

// *** IR Dump After mlir::iree_compiler::IREE::HAL::CSEVariableLoadsPass ***
func private @_device_match_id_0_initializer() -> i1 {
  %device = hal.ex.shared_device : !hal.device
  %0 = hal.device.match.id<%device : !hal.device> pattern("dylib*") : i1
  return %0 : i1
}

// *** IR Dump After Canonicalizer ***
func private @_descriptor_set_layout_0_initializer() -> !hal.descriptor_set_layout {
  %device = hal.ex.shared_device : !hal.device
  %descriptor_set_layout = hal.descriptor_set_layout.create device(%device : !hal.device) usage(PushOnly) bindings([#hal.descriptor_set_layout_binding<0, "StorageBuffer", R>, #hal.descriptor_set_layout_binding<1, "StorageBuffer", R>, #hal.descriptor_set_layout_binding<2, "StorageBuffer", DW>]) : !hal.descriptor_set_layout
  return %descriptor_set_layout : !hal.descriptor_set_layout
}

// *** IR Dump After CSE ***
func private @_descriptor_set_layout_0_initializer() -> !hal.descriptor_set_layout {
  %device = hal.ex.shared_device : !hal.device
  %descriptor_set_layout = hal.descriptor_set_layout.create device(%device : !hal.device) usage(PushOnly) bindings([#hal.descriptor_set_layout_binding<0, "StorageBuffer", R>, #hal.descriptor_set_layout_binding<1, "StorageBuffer", R>, #hal.descriptor_set_layout_binding<2, "StorageBuffer", DW>]) : !hal.descriptor_set_layout
  return %descriptor_set_layout : !hal.descriptor_set_layout
}

// *** IR Dump After mlir::iree_compiler::IREE::HAL::CSEVariableLoadsPass ***
func private @_descriptor_set_layout_0_initializer() -> !hal.descriptor_set_layout {
  %device = hal.ex.shared_device : !hal.device
  %descriptor_set_layout = hal.descriptor_set_layout.create device(%device : !hal.device) usage(PushOnly) bindings([#hal.descriptor_set_layout_binding<0, "StorageBuffer", R>, #hal.descriptor_set_layout_binding<1, "StorageBuffer", R>, #hal.descriptor_set_layout_binding<2, "StorageBuffer", DW>]) : !hal.descriptor_set_layout
  return %descriptor_set_layout : !hal.descriptor_set_layout
}

// *** IR Dump After Canonicalizer ***
func private @_executable_layout_0_initializer() -> !hal.executable_layout {
  %0 = hal.variable.load @_descriptor_set_layout_0 : !hal.descriptor_set_layout
  %device = hal.ex.shared_device : !hal.device
  %executable_layout = hal.executable_layout.create device(%device : !hal.device) push_constants(0) layouts([%0]) : !hal.executable_layout
  return %executable_layout : !hal.executable_layout
}

// *** IR Dump After CSE ***
func private @_executable_layout_0_initializer() -> !hal.executable_layout {
  %0 = hal.variable.load @_descriptor_set_layout_0 : !hal.descriptor_set_layout
  %device = hal.ex.shared_device : !hal.device
  %executable_layout = hal.executable_layout.create device(%device : !hal.device) push_constants(0) layouts([%0]) : !hal.executable_layout
  return %executable_layout : !hal.executable_layout
}

// *** IR Dump After mlir::iree_compiler::IREE::HAL::CSEVariableLoadsPass ***
func private @_executable_layout_0_initializer() -> !hal.executable_layout {
  %0 = hal.variable.load @_descriptor_set_layout_0 : !hal.descriptor_set_layout
  %device = hal.ex.shared_device : !hal.device
  %executable_layout = hal.executable_layout.create device(%device : !hal.device) push_constants(0) layouts([%0]) : !hal.executable_layout
  return %executable_layout : !hal.executable_layout
}

// *** IR Dump After Canonicalizer ***
func private @_descriptor_set_layout_1_initializer() -> !hal.descriptor_set_layout {
  %device = hal.ex.shared_device : !hal.device
  %descriptor_set_layout = hal.descriptor_set_layout.create device(%device : !hal.device) usage(PushOnly) bindings([#hal.descriptor_set_layout_binding<0, "StorageBuffer", R>, #hal.descriptor_set_layout_binding<1, "StorageBuffer", DW>]) : !hal.descriptor_set_layout
  return %descriptor_set_layout : !hal.descriptor_set_layout
}

// *** IR Dump After CSE ***
func private @_descriptor_set_layout_1_initializer() -> !hal.descriptor_set_layout {
  %device = hal.ex.shared_device : !hal.device
  %descriptor_set_layout = hal.descriptor_set_layout.create device(%device : !hal.device) usage(PushOnly) bindings([#hal.descriptor_set_layout_binding<0, "StorageBuffer", R>, #hal.descriptor_set_layout_binding<1, "StorageBuffer", DW>]) : !hal.descriptor_set_layout
  return %descriptor_set_layout : !hal.descriptor_set_layout
}

// *** IR Dump After mlir::iree_compiler::IREE::HAL::CSEVariableLoadsPass ***
func private @_descriptor_set_layout_1_initializer() -> !hal.descriptor_set_layout {
  %device = hal.ex.shared_device : !hal.device
  %descriptor_set_layout = hal.descriptor_set_layout.create device(%device : !hal.device) usage(PushOnly) bindings([#hal.descriptor_set_layout_binding<0, "StorageBuffer", R>, #hal.descriptor_set_layout_binding<1, "StorageBuffer", DW>]) : !hal.descriptor_set_layout
  return %descriptor_set_layout : !hal.descriptor_set_layout
}

// *** IR Dump After Canonicalizer ***
func private @_executable_layout_1_initializer() -> !hal.executable_layout {
  %0 = hal.variable.load @_descriptor_set_layout_1 : !hal.descriptor_set_layout
  %device = hal.ex.shared_device : !hal.device
  %executable_layout = hal.executable_layout.create device(%device : !hal.device) push_constants(0) layouts([%0]) : !hal.executable_layout
  return %executable_layout : !hal.executable_layout
}

// *** IR Dump After CSE ***
func private @_executable_layout_1_initializer() -> !hal.executable_layout {
  %0 = hal.variable.load @_descriptor_set_layout_1 : !hal.descriptor_set_layout
  %device = hal.ex.shared_device : !hal.device
  %executable_layout = hal.executable_layout.create device(%device : !hal.device) push_constants(0) layouts([%0]) : !hal.executable_layout
  return %executable_layout : !hal.executable_layout
}

// *** IR Dump After mlir::iree_compiler::IREE::HAL::CSEVariableLoadsPass ***
func private @_executable_layout_1_initializer() -> !hal.executable_layout {
  %0 = hal.variable.load @_descriptor_set_layout_1 : !hal.descriptor_set_layout
  %device = hal.ex.shared_device : !hal.device
  %executable_layout = hal.executable_layout.create device(%device : !hal.device) push_constants(0) layouts([%0]) : !hal.executable_layout
  return %executable_layout : !hal.executable_layout
}

// *** IR Dump After Canonicalizer ***
func private @_descriptor_set_layout_2_initializer() -> !hal.descriptor_set_layout {
  %device = hal.ex.shared_device : !hal.device
  %descriptor_set_layout = hal.descriptor_set_layout.create device(%device : !hal.device) usage(PushOnly) bindings([#hal.descriptor_set_layout_binding<0, "StorageBuffer", R>, #hal.descriptor_set_layout_binding<1, "StorageBuffer", R>, #hal.descriptor_set_layout_binding<2, "StorageBuffer", R>, #hal.descriptor_set_layout_binding<3, "StorageBuffer", DW>]) : !hal.descriptor_set_layout
  return %descriptor_set_layout : !hal.descriptor_set_layout
}

// *** IR Dump After CSE ***
func private @_descriptor_set_layout_2_initializer() -> !hal.descriptor_set_layout {
  %device = hal.ex.shared_device : !hal.device
  %descriptor_set_layout = hal.descriptor_set_layout.create device(%device : !hal.device) usage(PushOnly) bindings([#hal.descriptor_set_layout_binding<0, "StorageBuffer", R>, #hal.descriptor_set_layout_binding<1, "StorageBuffer", R>, #hal.descriptor_set_layout_binding<2, "StorageBuffer", R>, #hal.descriptor_set_layout_binding<3, "StorageBuffer", DW>]) : !hal.descriptor_set_layout
  return %descriptor_set_layout : !hal.descriptor_set_layout
}

// *** IR Dump After mlir::iree_compiler::IREE::HAL::CSEVariableLoadsPass ***
func private @_descriptor_set_layout_2_initializer() -> !hal.descriptor_set_layout {
  %device = hal.ex.shared_device : !hal.device
  %descriptor_set_layout = hal.descriptor_set_layout.create device(%device : !hal.device) usage(PushOnly) bindings([#hal.descriptor_set_layout_binding<0, "StorageBuffer", R>, #hal.descriptor_set_layout_binding<1, "StorageBuffer", R>, #hal.descriptor_set_layout_binding<2, "StorageBuffer", R>, #hal.descriptor_set_layout_binding<3, "StorageBuffer", DW>]) : !hal.descriptor_set_layout
  return %descriptor_set_layout : !hal.descriptor_set_layout
}

// *** IR Dump After Canonicalizer ***
func private @_executable_layout_2_initializer() -> !hal.executable_layout {
  %0 = hal.variable.load @_descriptor_set_layout_2 : !hal.descriptor_set_layout
  %device = hal.ex.shared_device : !hal.device
  %executable_layout = hal.executable_layout.create device(%device : !hal.device) push_constants(0) layouts([%0]) : !hal.executable_layout
  return %executable_layout : !hal.executable_layout
}

// *** IR Dump After CSE ***
func private @_executable_layout_2_initializer() -> !hal.executable_layout {
  %0 = hal.variable.load @_descriptor_set_layout_2 : !hal.descriptor_set_layout
  %device = hal.ex.shared_device : !hal.device
  %executable_layout = hal.executable_layout.create device(%device : !hal.device) push_constants(0) layouts([%0]) : !hal.executable_layout
  return %executable_layout : !hal.executable_layout
}

// *** IR Dump After mlir::iree_compiler::IREE::HAL::CSEVariableLoadsPass ***
func private @_executable_layout_2_initializer() -> !hal.executable_layout {
  %0 = hal.variable.load @_descriptor_set_layout_2 : !hal.descriptor_set_layout
  %device = hal.ex.shared_device : !hal.device
  %executable_layout = hal.executable_layout.create device(%device : !hal.device) push_constants(0) layouts([%0]) : !hal.executable_layout
  return %executable_layout : !hal.executable_layout
}

// *** IR Dump After Canonicalizer ***
func private @_executable_mnist_linked_llvm_aot_initializer() -> !hal.executable {
  %device = hal.ex.shared_device : !hal.device
  %0 = hal.variable.load @_device_match_id_0 : i1
  cond_br %0, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %1 = hal.variable.load @_executable_layout_0 : !hal.executable_layout
  %2 = hal.variable.load @_executable_layout_0 : !hal.executable_layout
  %3 = hal.variable.load @_executable_layout_0 : !hal.executable_layout
  %4 = hal.variable.load @_executable_layout_1 : !hal.executable_layout
  %5 = hal.variable.load @_executable_layout_1 : !hal.executable_layout
  %6 = hal.variable.load @_executable_layout_0 : !hal.executable_layout
  %7 = hal.variable.load @_executable_layout_1 : !hal.executable_layout
  %8 = hal.variable.load @_executable_layout_2 : !hal.executable_layout
  %exe = hal.executable.create device(%device : !hal.device) target(@mnist_linked_llvm_aot::@llvm_aot) layouts([%1, %2, %3, %4, %5, %6, %7, %8]) : !hal.executable
  br ^bb3(%exe : !hal.executable)
^bb2:  // pred: ^bb0
  %9 = iree.null : !hal.executable
  br ^bb3(%9 : !hal.executable)
^bb3(%10: !hal.executable):  // 2 preds: ^bb1, ^bb2
  return %10 : !hal.executable
}

// *** IR Dump After CSE ***
func private @_executable_mnist_linked_llvm_aot_initializer() -> !hal.executable {
  %device = hal.ex.shared_device : !hal.device
  %0 = hal.variable.load @_device_match_id_0 : i1
  cond_br %0, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %1 = hal.variable.load @_executable_layout_0 : !hal.executable_layout
  %2 = hal.variable.load @_executable_layout_1 : !hal.executable_layout
  %3 = hal.variable.load @_executable_layout_2 : !hal.executable_layout
  %exe = hal.executable.create device(%device : !hal.device) target(@mnist_linked_llvm_aot::@llvm_aot) layouts([%1, %1, %1, %2, %2, %1, %2, %3]) : !hal.executable
  br ^bb3(%exe : !hal.executable)
^bb2:  // pred: ^bb0
  %4 = iree.null : !hal.executable
  br ^bb3(%4 : !hal.executable)
^bb3(%5: !hal.executable):  // 2 preds: ^bb1, ^bb2
  return %5 : !hal.executable
}

// *** IR Dump After mlir::iree_compiler::IREE::HAL::CSEVariableLoadsPass ***
func private @_executable_mnist_linked_llvm_aot_initializer() -> !hal.executable {
  %device = hal.ex.shared_device : !hal.device
  %0 = hal.variable.load @_device_match_id_0 : i1
  cond_br %0, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %1 = hal.variable.load @_executable_layout_0 : !hal.executable_layout
  %2 = hal.variable.load @_executable_layout_1 : !hal.executable_layout
  %3 = hal.variable.load @_executable_layout_2 : !hal.executable_layout
  %exe = hal.executable.create device(%device : !hal.device) target(@mnist_linked_llvm_aot::@llvm_aot) layouts([%1, %1, %1, %2, %2, %1, %2, %3]) : !hal.executable
  br ^bb3(%exe : !hal.executable)
^bb2:  // pred: ^bb0
  %4 = iree.null : !hal.executable
  br ^bb3(%4 : !hal.executable)
^bb3(%5: !hal.executable):  // 2 preds: ^bb1, ^bb2
  return %5 : !hal.executable
}

// *** IR Dump After mlir::iree_compiler::IREE::HAL::SerializeExecutablesPass ***
hal.executable @mnist_linked_llvm_aot attributes {sym_visibility = "private"} {
  hal.interface @io_0 {
    hal.interface.binding @s0b0_ro_constant, set=0, binding=0, type="StorageBuffer", access="Read"
    hal.interface.binding @s0b1_ro_external, set=0, binding=1, type="StorageBuffer", access="Read"
    hal.interface.binding @s0b2_xw_external, set=0, binding=2, type="StorageBuffer", access="Write|Discard"
  }
  hal.interface @io_1 {
    hal.interface.binding @s0b0_ro_external, set=0, binding=0, type="StorageBuffer", access="Read"
    hal.interface.binding @s0b1_xw_external, set=0, binding=1, type="StorageBuffer", access="Write|Discard"
  }
  hal.interface @io_2 {
    hal.interface.binding @s0b0_ro_external, set=0, binding=0, type="StorageBuffer", access="Read"
    hal.interface.binding @s0b1_ro_external, set=0, binding=1, type="StorageBuffer", access="Read"
    hal.interface.binding @s0b2_xw_external, set=0, binding=2, type="StorageBuffer", access="Write|Discard"
  }
  hal.interface @io_3 {
    hal.interface.binding @s0b0_ro_external, set=0, binding=0, type="StorageBuffer", access="Read"
    hal.interface.binding @s0b1_ro_external, set=0, binding=1, type="StorageBuffer", access="Read"
    hal.interface.binding @s0b2_ro_external, set=0, binding=2, type="StorageBuffer", access="Read"
    hal.interface.binding @s0b3_xw_external, set=0, binding=3, type="StorageBuffer", access="Write|Discard"
  }
  hal.executable.binary @llvm_aot attributes {data = opaque<"_", "0xDEADBEEF"> : vector<136794xi8>, format = "DLIB", mime_type = "application/x-flatbuffers"} {
  }
}

// *** IR Dump After Canonicalizer ***
func private @_const_pool_storage_buffer_initializer() -> !hal.buffer {
  %c0 = constant 0 : index
  %c407040 = constant 407040 : index
  %device = hal.ex.shared_device : !hal.device
  %allocator = hal.device.allocator<%device : !hal.device> : !hal.allocator
  %storage = hal.constant_storage.lookup @_const_pool::@_storage : !iree.byte_buffer
  %mapped = hal.allocator.map<%allocator : !hal.allocator> source(%storage : !iree.byte_buffer)[%c0, %c407040] type("HostVisible|DeviceVisible|DeviceLocal") usage("Constant|Transfer|Mapping|Dispatch") : !hal.buffer
  return %mapped : !hal.buffer
}

// *** IR Dump After CSE ***
func private @_const_pool_storage_buffer_initializer() -> !hal.buffer {
  %c0 = constant 0 : index
  %c407040 = constant 407040 : index
  %device = hal.ex.shared_device : !hal.device
  %allocator = hal.device.allocator<%device : !hal.device> : !hal.allocator
  %storage = hal.constant_storage.lookup @_const_pool::@_storage : !iree.byte_buffer
  %mapped = hal.allocator.map<%allocator : !hal.allocator> source(%storage : !iree.byte_buffer)[%c0, %c407040] type("HostVisible|DeviceVisible|DeviceLocal") usage("Constant|Transfer|Mapping|Dispatch") : !hal.buffer
  return %mapped : !hal.buffer
}

// *** IR Dump After mlir::iree_compiler::IREE::HAL::CSEVariableLoadsPass ***
func private @_const_pool_storage_buffer_initializer() -> !hal.buffer {
  %c0 = constant 0 : index
  %c407040 = constant 407040 : index
  %device = hal.ex.shared_device : !hal.device
  %allocator = hal.device.allocator<%device : !hal.device> : !hal.allocator
  %storage = hal.constant_storage.lookup @_const_pool::@_storage : !iree.byte_buffer
  %mapped = hal.allocator.map<%allocator : !hal.allocator> source(%storage : !iree.byte_buffer)[%c0, %c407040] type("HostVisible|DeviceVisible|DeviceLocal") usage("Constant|Transfer|Mapping|Dispatch") : !hal.buffer
  return %mapped : !hal.buffer
}

// *** IR Dump After Canonicalizer ***
func @predict(%arg0: !hal.buffer) -> !hal.buffer attributes {noinline} {
  %c3136 = constant 3136 : index
  %c401408 = constant 401408 : index
  %c401920 = constant 401920 : index
  %c5120 = constant 5120 : index
  %c40 = constant 40 : index
  %c4 = constant 4 : index
  %c3 = constant 3 : index
  %c0 = constant 0 : index
  %c512 = constant 512 : index
  %c96 = constant 96 : index
  %c48 = constant 48 : index
  %c112 = constant 112 : index
  %c1024 = constant 1024 : index
  %c2 = constant 2 : index
  %c1 = constant 1 : index
  %device = hal.ex.shared_device : !hal.device
  %allocator = hal.device.allocator<%device : !hal.device> : !hal.allocator
  %buffer = hal.allocator.allocate<%allocator : !hal.allocator> type("HostVisible|DeviceVisible|DeviceLocal") usage("Transfer|Mapping|Dispatch") : !hal.buffer{%c40}
  %0 = hal.variable.load @_const_pool_storage_buffer : !hal.buffer
  %buffer_0 = hal.allocator.allocate<%allocator : !hal.allocator> type("DeviceVisible|DeviceLocal") usage("Transfer|Dispatch") : !hal.buffer{%c1024}
  %cmd = hal.command_buffer.create device(%device : !hal.device) mode("OneShot|AllowInlineExecution") categories("Transfer|Dispatch") : !hal.command_buffer
  hal.command_buffer.begin<%cmd : !hal.command_buffer>
  %1 = hal.variable.load @_executable_layout_0 : !hal.executable_layout
  hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%1 : !hal.executable_layout)[%c0] bindings([
    %c0 = (%0 : !hal.buffer)[%c512, %c401408], 
    %c1 = (%arg0 : !hal.buffer)[%c0, %c3136], 
    %c2 = (%buffer_0 : !hal.buffer)[%c0, %c512]
  ])
  %2 = hal.variable.load @_device_match_id_0 : i1
  cond_br %2, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %3 = hal.variable.load @_executable_mnist_linked_llvm_aot : !hal.executable
  hal.command_buffer.dispatch<%cmd : !hal.command_buffer> target(%3 : !hal.executable)[0] workgroups([%c2, %c1, %c1])
  hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
  hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%1 : !hal.executable_layout)[%c0] bindings([
    %c0 = (%0 : !hal.buffer)[%c0, %c512], 
    %c1 = (%buffer_0 : !hal.buffer)[%c0, %c512], 
    %c2 = (%buffer_0 : !hal.buffer)[%c512, %c512]
  ])
  %4 = hal.variable.load @_device_match_id_0 : i1
  cond_br %4, ^bb3, ^bb2
^bb2:  // 8 preds: ^bb0, ^bb1, ^bb3, ^bb4, ^bb5, ^bb6, ^bb7, ^bb8
  iree.unreachable "device not supported in the compiled configuration"
^bb3:  // pred: ^bb1
  %5 = hal.variable.load @_executable_mnist_linked_llvm_aot : !hal.executable
  hal.command_buffer.dispatch<%cmd : !hal.command_buffer> target(%5 : !hal.executable)[1] workgroups([%c1, %c1, %c1])
  hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
  hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%1 : !hal.executable_layout)[%c0] bindings([
    %c0 = (%0 : !hal.buffer)[%c401920, %c5120], 
    %c1 = (%buffer_0 : !hal.buffer)[%c512, %c512], 
    %c2 = (%buffer_0 : !hal.buffer)[%c0, %c40]
  ])
  %6 = hal.variable.load @_device_match_id_0 : i1
  cond_br %6, ^bb4, ^bb2
^bb4:  // pred: ^bb3
  %7 = hal.variable.load @_executable_mnist_linked_llvm_aot : !hal.executable
  hal.command_buffer.dispatch<%cmd : !hal.command_buffer> target(%7 : !hal.executable)[2] workgroups([%c1, %c1, %c1])
  hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
  %8 = hal.variable.load @_executable_layout_1 : !hal.executable_layout
  hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%8 : !hal.executable_layout)[%c0] bindings([
    %c0 = (%buffer_0 : !hal.buffer)[%c0, %c40], 
    %c1 = (%buffer_0 : !hal.buffer)[%c48, %c40]
  ])
  %9 = hal.variable.load @_device_match_id_0 : i1
  cond_br %9, ^bb5, ^bb2
^bb5:  // pred: ^bb4
  %10 = hal.variable.load @_executable_mnist_linked_llvm_aot : !hal.executable
  hal.command_buffer.dispatch<%cmd : !hal.command_buffer> target(%10 : !hal.executable)[3] workgroups([%c1, %c1, %c1])
  hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
  hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%8 : !hal.executable_layout)[%c0] bindings([
    %c0 = (%buffer_0 : !hal.buffer)[%c48, %c40], 
    %c1 = (%buffer_0 : !hal.buffer)[%c96, %c4]
  ])
  %11 = hal.variable.load @_device_match_id_0 : i1
  cond_br %11, ^bb6, ^bb2
^bb6:  // pred: ^bb5
  %12 = hal.variable.load @_executable_mnist_linked_llvm_aot : !hal.executable
  hal.command_buffer.dispatch<%cmd : !hal.command_buffer> target(%12 : !hal.executable)[4] workgroups([%c1, %c1, %c1])
  hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
  hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%1 : !hal.executable_layout)[%c0] bindings([
    %c0 = (%buffer_0 : !hal.buffer)[%c0, %c40], 
    %c1 = (%buffer_0 : !hal.buffer)[%c96, %c4], 
    %c2 = (%buffer_0 : !hal.buffer)[%c48, %c40]
  ])
  %13 = hal.variable.load @_device_match_id_0 : i1
  cond_br %13, ^bb7, ^bb2
^bb7:  // pred: ^bb6
  %14 = hal.variable.load @_executable_mnist_linked_llvm_aot : !hal.executable
  hal.command_buffer.dispatch<%cmd : !hal.command_buffer> target(%14 : !hal.executable)[5] workgroups([%c1, %c1, %c1])
  hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
  hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%8 : !hal.executable_layout)[%c0] bindings([
    %c0 = (%buffer_0 : !hal.buffer)[%c48, %c40], 
    %c1 = (%buffer_0 : !hal.buffer)[%c112, %c4]
  ])
  %15 = hal.variable.load @_device_match_id_0 : i1
  cond_br %15, ^bb8, ^bb2
^bb8:  // pred: ^bb7
  %16 = hal.variable.load @_executable_mnist_linked_llvm_aot : !hal.executable
  hal.command_buffer.dispatch<%cmd : !hal.command_buffer> target(%16 : !hal.executable)[6] workgroups([%c1, %c1, %c1])
  hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
  %17 = hal.variable.load @_executable_layout_2 : !hal.executable_layout
  hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%17 : !hal.executable_layout)[%c0] bindings([
    %c0 = (%buffer_0 : !hal.buffer)[%c0, %c40], 
    %c1 = (%buffer_0 : !hal.buffer)[%c96, %c4], 
    %c2 = (%buffer_0 : !hal.buffer)[%c112, %c4], 
    %c3 = (%buffer : !hal.buffer)[%c0, %c40]
  ])
  %18 = hal.variable.load @_device_match_id_0 : i1
  cond_br %18, ^bb9, ^bb2
^bb9:  // pred: ^bb8
  %19 = hal.variable.load @_executable_mnist_linked_llvm_aot : !hal.executable
  hal.command_buffer.dispatch<%cmd : !hal.command_buffer> target(%19 : !hal.executable)[7] workgroups([%c1, %c1, %c1])
  hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
  hal.command_buffer.end<%cmd : !hal.command_buffer>
  hal.ex.submit_and_wait %device, %cmd
  return %buffer : !hal.buffer
}

// *** IR Dump After CSE ***
func @predict(%arg0: !hal.buffer) -> !hal.buffer attributes {noinline} {
  %c3136 = constant 3136 : index
  %c401408 = constant 401408 : index
  %c401920 = constant 401920 : index
  %c5120 = constant 5120 : index
  %c40 = constant 40 : index
  %c4 = constant 4 : index
  %c3 = constant 3 : index
  %c0 = constant 0 : index
  %c512 = constant 512 : index
  %c96 = constant 96 : index
  %c48 = constant 48 : index
  %c112 = constant 112 : index
  %c1024 = constant 1024 : index
  %c2 = constant 2 : index
  %c1 = constant 1 : index
  %device = hal.ex.shared_device : !hal.device
  %allocator = hal.device.allocator<%device : !hal.device> : !hal.allocator
  %buffer = hal.allocator.allocate<%allocator : !hal.allocator> type("HostVisible|DeviceVisible|DeviceLocal") usage("Transfer|Mapping|Dispatch") : !hal.buffer{%c40}
  %0 = hal.variable.load @_const_pool_storage_buffer : !hal.buffer
  %buffer_0 = hal.allocator.allocate<%allocator : !hal.allocator> type("DeviceVisible|DeviceLocal") usage("Transfer|Dispatch") : !hal.buffer{%c1024}
  %cmd = hal.command_buffer.create device(%device : !hal.device) mode("OneShot|AllowInlineExecution") categories("Transfer|Dispatch") : !hal.command_buffer
  hal.command_buffer.begin<%cmd : !hal.command_buffer>
  %1 = hal.variable.load @_executable_layout_0 : !hal.executable_layout
  hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%1 : !hal.executable_layout)[%c0] bindings([
    %c0 = (%0 : !hal.buffer)[%c512, %c401408], 
    %c1 = (%arg0 : !hal.buffer)[%c0, %c3136], 
    %c2 = (%buffer_0 : !hal.buffer)[%c0, %c512]
  ])
  %2 = hal.variable.load @_device_match_id_0 : i1
  cond_br %2, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %3 = hal.variable.load @_executable_mnist_linked_llvm_aot : !hal.executable
  hal.command_buffer.dispatch<%cmd : !hal.command_buffer> target(%3 : !hal.executable)[0] workgroups([%c2, %c1, %c1])
  hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
  hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%1 : !hal.executable_layout)[%c0] bindings([
    %c0 = (%0 : !hal.buffer)[%c0, %c512], 
    %c1 = (%buffer_0 : !hal.buffer)[%c0, %c512], 
    %c2 = (%buffer_0 : !hal.buffer)[%c512, %c512]
  ])
  cond_br %2, ^bb3, ^bb2
^bb2:  // 8 preds: ^bb0, ^bb1, ^bb3, ^bb4, ^bb5, ^bb6, ^bb7, ^bb8
  iree.unreachable "device not supported in the compiled configuration"
^bb3:  // pred: ^bb1
  hal.command_buffer.dispatch<%cmd : !hal.command_buffer> target(%3 : !hal.executable)[1] workgroups([%c1, %c1, %c1])
  hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
  hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%1 : !hal.executable_layout)[%c0] bindings([
    %c0 = (%0 : !hal.buffer)[%c401920, %c5120], 
    %c1 = (%buffer_0 : !hal.buffer)[%c512, %c512], 
    %c2 = (%buffer_0 : !hal.buffer)[%c0, %c40]
  ])
  cond_br %2, ^bb4, ^bb2
^bb4:  // pred: ^bb3
  hal.command_buffer.dispatch<%cmd : !hal.command_buffer> target(%3 : !hal.executable)[2] workgroups([%c1, %c1, %c1])
  hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
  %4 = hal.variable.load @_executable_layout_1 : !hal.executable_layout
  hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%4 : !hal.executable_layout)[%c0] bindings([
    %c0 = (%buffer_0 : !hal.buffer)[%c0, %c40], 
    %c1 = (%buffer_0 : !hal.buffer)[%c48, %c40]
  ])
  cond_br %2, ^bb5, ^bb2
^bb5:  // pred: ^bb4
  hal.command_buffer.dispatch<%cmd : !hal.command_buffer> target(%3 : !hal.executable)[3] workgroups([%c1, %c1, %c1])
  hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
  hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%4 : !hal.executable_layout)[%c0] bindings([
    %c0 = (%buffer_0 : !hal.buffer)[%c48, %c40], 
    %c1 = (%buffer_0 : !hal.buffer)[%c96, %c4]
  ])
  cond_br %2, ^bb6, ^bb2
^bb6:  // pred: ^bb5
  hal.command_buffer.dispatch<%cmd : !hal.command_buffer> target(%3 : !hal.executable)[4] workgroups([%c1, %c1, %c1])
  hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
  hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%1 : !hal.executable_layout)[%c0] bindings([
    %c0 = (%buffer_0 : !hal.buffer)[%c0, %c40], 
    %c1 = (%buffer_0 : !hal.buffer)[%c96, %c4], 
    %c2 = (%buffer_0 : !hal.buffer)[%c48, %c40]
  ])
  cond_br %2, ^bb7, ^bb2
^bb7:  // pred: ^bb6
  hal.command_buffer.dispatch<%cmd : !hal.command_buffer> target(%3 : !hal.executable)[5] workgroups([%c1, %c1, %c1])
  hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
  hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%4 : !hal.executable_layout)[%c0] bindings([
    %c0 = (%buffer_0 : !hal.buffer)[%c48, %c40], 
    %c1 = (%buffer_0 : !hal.buffer)[%c112, %c4]
  ])
  cond_br %2, ^bb8, ^bb2
^bb8:  // pred: ^bb7
  hal.command_buffer.dispatch<%cmd : !hal.command_buffer> target(%3 : !hal.executable)[6] workgroups([%c1, %c1, %c1])
  hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
  %5 = hal.variable.load @_executable_layout_2 : !hal.executable_layout
  hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%5 : !hal.executable_layout)[%c0] bindings([
    %c0 = (%buffer_0 : !hal.buffer)[%c0, %c40], 
    %c1 = (%buffer_0 : !hal.buffer)[%c96, %c4], 
    %c2 = (%buffer_0 : !hal.buffer)[%c112, %c4], 
    %c3 = (%buffer : !hal.buffer)[%c0, %c40]
  ])
  cond_br %2, ^bb9, ^bb2
^bb9:  // pred: ^bb8
  hal.command_buffer.dispatch<%cmd : !hal.command_buffer> target(%3 : !hal.executable)[7] workgroups([%c1, %c1, %c1])
  hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
  hal.command_buffer.end<%cmd : !hal.command_buffer>
  hal.ex.submit_and_wait %device, %cmd
  return %buffer : !hal.buffer
}

// *** IR Dump After mlir::iree_compiler::IREE::HAL::CSEVariableLoadsPass ***
func @predict(%arg0: !hal.buffer) -> !hal.buffer attributes {noinline} {
  %c3136 = constant 3136 : index
  %c401408 = constant 401408 : index
  %c401920 = constant 401920 : index
  %c5120 = constant 5120 : index
  %c40 = constant 40 : index
  %c4 = constant 4 : index
  %c3 = constant 3 : index
  %c0 = constant 0 : index
  %c512 = constant 512 : index
  %c96 = constant 96 : index
  %c48 = constant 48 : index
  %c112 = constant 112 : index
  %c1024 = constant 1024 : index
  %c2 = constant 2 : index
  %c1 = constant 1 : index
  %device = hal.ex.shared_device : !hal.device
  %allocator = hal.device.allocator<%device : !hal.device> : !hal.allocator
  %buffer = hal.allocator.allocate<%allocator : !hal.allocator> type("HostVisible|DeviceVisible|DeviceLocal") usage("Transfer|Mapping|Dispatch") : !hal.buffer{%c40}
  %0 = hal.variable.load @_const_pool_storage_buffer : !hal.buffer
  %buffer_0 = hal.allocator.allocate<%allocator : !hal.allocator> type("DeviceVisible|DeviceLocal") usage("Transfer|Dispatch") : !hal.buffer{%c1024}
  %cmd = hal.command_buffer.create device(%device : !hal.device) mode("OneShot|AllowInlineExecution") categories("Transfer|Dispatch") : !hal.command_buffer
  hal.command_buffer.begin<%cmd : !hal.command_buffer>
  %1 = hal.variable.load @_executable_layout_0 : !hal.executable_layout
  hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%1 : !hal.executable_layout)[%c0] bindings([
    %c0 = (%0 : !hal.buffer)[%c512, %c401408], 
    %c1 = (%arg0 : !hal.buffer)[%c0, %c3136], 
    %c2 = (%buffer_0 : !hal.buffer)[%c0, %c512]
  ])
  %2 = hal.variable.load @_device_match_id_0 : i1
  cond_br %2, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %3 = hal.variable.load @_executable_mnist_linked_llvm_aot : !hal.executable
  hal.command_buffer.dispatch<%cmd : !hal.command_buffer> target(%3 : !hal.executable)[0] workgroups([%c2, %c1, %c1])
  hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
  hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%1 : !hal.executable_layout)[%c0] bindings([
    %c0 = (%0 : !hal.buffer)[%c0, %c512], 
    %c1 = (%buffer_0 : !hal.buffer)[%c0, %c512], 
    %c2 = (%buffer_0 : !hal.buffer)[%c512, %c512]
  ])
  cond_br %2, ^bb3, ^bb2
^bb2:  // 8 preds: ^bb0, ^bb1, ^bb3, ^bb4, ^bb5, ^bb6, ^bb7, ^bb8
  iree.unreachable "device not supported in the compiled configuration"
^bb3:  // pred: ^bb1
  hal.command_buffer.dispatch<%cmd : !hal.command_buffer> target(%3 : !hal.executable)[1] workgroups([%c1, %c1, %c1])
  hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
  hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%1 : !hal.executable_layout)[%c0] bindings([
    %c0 = (%0 : !hal.buffer)[%c401920, %c5120], 
    %c1 = (%buffer_0 : !hal.buffer)[%c512, %c512], 
    %c2 = (%buffer_0 : !hal.buffer)[%c0, %c40]
  ])
  cond_br %2, ^bb4, ^bb2
^bb4:  // pred: ^bb3
  hal.command_buffer.dispatch<%cmd : !hal.command_buffer> target(%3 : !hal.executable)[2] workgroups([%c1, %c1, %c1])
  hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
  %4 = hal.variable.load @_executable_layout_1 : !hal.executable_layout
  hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%4 : !hal.executable_layout)[%c0] bindings([
    %c0 = (%buffer_0 : !hal.buffer)[%c0, %c40], 
    %c1 = (%buffer_0 : !hal.buffer)[%c48, %c40]
  ])
  cond_br %2, ^bb5, ^bb2
^bb5:  // pred: ^bb4
  hal.command_buffer.dispatch<%cmd : !hal.command_buffer> target(%3 : !hal.executable)[3] workgroups([%c1, %c1, %c1])
  hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
  hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%4 : !hal.executable_layout)[%c0] bindings([
    %c0 = (%buffer_0 : !hal.buffer)[%c48, %c40], 
    %c1 = (%buffer_0 : !hal.buffer)[%c96, %c4]
  ])
  cond_br %2, ^bb6, ^bb2
^bb6:  // pred: ^bb5
  hal.command_buffer.dispatch<%cmd : !hal.command_buffer> target(%3 : !hal.executable)[4] workgroups([%c1, %c1, %c1])
  hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
  hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%1 : !hal.executable_layout)[%c0] bindings([
    %c0 = (%buffer_0 : !hal.buffer)[%c0, %c40], 
    %c1 = (%buffer_0 : !hal.buffer)[%c96, %c4], 
    %c2 = (%buffer_0 : !hal.buffer)[%c48, %c40]
  ])
  cond_br %2, ^bb7, ^bb2
^bb7:  // pred: ^bb6
  hal.command_buffer.dispatch<%cmd : !hal.command_buffer> target(%3 : !hal.executable)[5] workgroups([%c1, %c1, %c1])
  hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
  hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%4 : !hal.executable_layout)[%c0] bindings([
    %c0 = (%buffer_0 : !hal.buffer)[%c48, %c40], 
    %c1 = (%buffer_0 : !hal.buffer)[%c112, %c4]
  ])
  cond_br %2, ^bb8, ^bb2
^bb8:  // pred: ^bb7
  hal.command_buffer.dispatch<%cmd : !hal.command_buffer> target(%3 : !hal.executable)[6] workgroups([%c1, %c1, %c1])
  hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
  %5 = hal.variable.load @_executable_layout_2 : !hal.executable_layout
  hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%5 : !hal.executable_layout)[%c0] bindings([
    %c0 = (%buffer_0 : !hal.buffer)[%c0, %c40], 
    %c1 = (%buffer_0 : !hal.buffer)[%c96, %c4], 
    %c2 = (%buffer_0 : !hal.buffer)[%c112, %c4], 
    %c3 = (%buffer : !hal.buffer)[%c0, %c40]
  ])
  cond_br %2, ^bb9, ^bb2
^bb9:  // pred: ^bb8
  hal.command_buffer.dispatch<%cmd : !hal.command_buffer> target(%3 : !hal.executable)[7] workgroups([%c1, %c1, %c1])
  hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
  hal.command_buffer.end<%cmd : !hal.command_buffer>
  hal.ex.submit_and_wait %device, %cmd
  return %buffer : !hal.buffer
}

// *** IR Dump After Canonicalizer ***
func @predict$async(%arg0: !hal.semaphore, %arg1: index, %arg2: !hal.buffer_view, %arg3: !hal.semaphore, %arg4: index) -> !hal.buffer_view attributes {iree.module.export = "predict$async"} {
  %c1 = constant 1 : index
  %c10 = constant 10 : index
  %c50331680_i32 = constant 50331680 : i32
  %0 = hal.semaphore.await<%arg0 : !hal.semaphore> until(%arg1) : i32
  hal.check_success %0, "semaphore wait failed"
  %buffer = hal.buffer_view.buffer %arg2 : !hal.buffer
  %1 = call @predict(%buffer) : (!hal.buffer) -> !hal.buffer
  %view = hal.buffer_view.create %1, element_type = %c50331680_i32, shape = [%c1, %c10] : !hal.buffer -> !hal.buffer_view
  hal.semaphore.signal<%arg3 : !hal.semaphore> value(%arg4)
  return %view : !hal.buffer_view
}

// *** IR Dump After CSE ***
func @predict$async(%arg0: !hal.semaphore, %arg1: index, %arg2: !hal.buffer_view, %arg3: !hal.semaphore, %arg4: index) -> !hal.buffer_view attributes {iree.module.export = "predict$async"} {
  %c1 = constant 1 : index
  %c10 = constant 10 : index
  %c50331680_i32 = constant 50331680 : i32
  %0 = hal.semaphore.await<%arg0 : !hal.semaphore> until(%arg1) : i32
  hal.check_success %0, "semaphore wait failed"
  %buffer = hal.buffer_view.buffer %arg2 : !hal.buffer
  %1 = call @predict(%buffer) : (!hal.buffer) -> !hal.buffer
  %view = hal.buffer_view.create %1, element_type = %c50331680_i32, shape = [%c1, %c10] : !hal.buffer -> !hal.buffer_view
  hal.semaphore.signal<%arg3 : !hal.semaphore> value(%arg4)
  return %view : !hal.buffer_view
}

// *** IR Dump After mlir::iree_compiler::IREE::HAL::CSEVariableLoadsPass ***
func @predict$async(%arg0: !hal.semaphore, %arg1: index, %arg2: !hal.buffer_view, %arg3: !hal.semaphore, %arg4: index) -> !hal.buffer_view attributes {iree.module.export = "predict$async"} {
  %c1 = constant 1 : index
  %c10 = constant 10 : index
  %c50331680_i32 = constant 50331680 : i32
  %0 = hal.semaphore.await<%arg0 : !hal.semaphore> until(%arg1) : i32
  hal.check_success %0, "semaphore wait failed"
  %buffer = hal.buffer_view.buffer %arg2 : !hal.buffer
  %1 = call @predict(%buffer) : (!hal.buffer) -> !hal.buffer
  %view = hal.buffer_view.create %1, element_type = %c50331680_i32, shape = [%c1, %c10] : !hal.buffer -> !hal.buffer_view
  hal.semaphore.signal<%arg3 : !hal.semaphore> value(%arg4)
  return %view : !hal.buffer_view
}

// *** IR Dump After Canonicalizer ***
func @predict$sync(%arg0: !hal.buffer_view) -> !hal.buffer_view attributes {iree.abi.stub, iree.module.export = "predict", iree.reflection = {abi = "sip", abiv = 1 : i32, f = "I15!B11!d1d28d28d1R9!B6!d1d10", fv = "1", sip = "I8!S5!k0_0R3!_0"}} {
  %c0 = constant 0 : index
  %c1 = constant 1 : index
  %device = hal.ex.shared_device : !hal.device
  %semaphore = hal.semaphore.create device(%device : !hal.device) initial(%c0) : !hal.semaphore
  %0 = call @predict$async(%semaphore, %c0, %arg0, %semaphore, %c1) : (!hal.semaphore, index, !hal.buffer_view, !hal.semaphore, index) -> !hal.buffer_view
  %1 = hal.semaphore.await<%semaphore : !hal.semaphore> until(%c1) : i32
  hal.check_success %1, "semaphore wait failed"
  return %0 : !hal.buffer_view
}

// *** IR Dump After CSE ***
func @predict$sync(%arg0: !hal.buffer_view) -> !hal.buffer_view attributes {iree.abi.stub, iree.module.export = "predict", iree.reflection = {abi = "sip", abiv = 1 : i32, f = "I15!B11!d1d28d28d1R9!B6!d1d10", fv = "1", sip = "I8!S5!k0_0R3!_0"}} {
  %c0 = constant 0 : index
  %c1 = constant 1 : index
  %device = hal.ex.shared_device : !hal.device
  %semaphore = hal.semaphore.create device(%device : !hal.device) initial(%c0) : !hal.semaphore
  %0 = call @predict$async(%semaphore, %c0, %arg0, %semaphore, %c1) : (!hal.semaphore, index, !hal.buffer_view, !hal.semaphore, index) -> !hal.buffer_view
  %1 = hal.semaphore.await<%semaphore : !hal.semaphore> until(%c1) : i32
  hal.check_success %1, "semaphore wait failed"
  return %0 : !hal.buffer_view
}

// *** IR Dump After mlir::iree_compiler::IREE::HAL::CSEVariableLoadsPass ***
func @predict$sync(%arg0: !hal.buffer_view) -> !hal.buffer_view attributes {iree.abi.stub, iree.module.export = "predict", iree.reflection = {abi = "sip", abiv = 1 : i32, f = "I15!B11!d1d28d28d1R9!B6!d1d10", fv = "1", sip = "I8!S5!k0_0R3!_0"}} {
  %c0 = constant 0 : index
  %c1 = constant 1 : index
  %device = hal.ex.shared_device : !hal.device
  %semaphore = hal.semaphore.create device(%device : !hal.device) initial(%c0) : !hal.semaphore
  %0 = call @predict$async(%semaphore, %c0, %arg0, %semaphore, %c1) : (!hal.semaphore, index, !hal.buffer_view, !hal.semaphore, index) -> !hal.buffer_view
  %1 = hal.semaphore.await<%semaphore : !hal.semaphore> until(%c1) : i32
  hal.check_success %1, "semaphore wait failed"
  return %0 : !hal.buffer_view
}

// *** IR Dump After SymbolDCE ***
module  {
  hal.variable @_device_match_id_0 init(@_device_match_id_0_initializer) : i1 attributes {sym_visibility = "private"}
  func private @_device_match_id_0_initializer() -> i1 {
    %device = hal.ex.shared_device : !hal.device
    %0 = hal.device.match.id<%device : !hal.device> pattern("dylib*") : i1
    return %0 : i1
  }
  hal.variable @_descriptor_set_layout_0 init(@_descriptor_set_layout_0_initializer) : !hal.descriptor_set_layout attributes {sym_visibility = "private"}
  func private @_descriptor_set_layout_0_initializer() -> !hal.descriptor_set_layout {
    %device = hal.ex.shared_device : !hal.device
    %descriptor_set_layout = hal.descriptor_set_layout.create device(%device : !hal.device) usage(PushOnly) bindings([#hal.descriptor_set_layout_binding<0, "StorageBuffer", R>, #hal.descriptor_set_layout_binding<1, "StorageBuffer", R>, #hal.descriptor_set_layout_binding<2, "StorageBuffer", DW>]) : !hal.descriptor_set_layout
    return %descriptor_set_layout : !hal.descriptor_set_layout
  }
  hal.variable @_executable_layout_0 init(@_executable_layout_0_initializer) : !hal.executable_layout attributes {sym_visibility = "private"}
  func private @_executable_layout_0_initializer() -> !hal.executable_layout {
    %0 = hal.variable.load @_descriptor_set_layout_0 : !hal.descriptor_set_layout
    %device = hal.ex.shared_device : !hal.device
    %executable_layout = hal.executable_layout.create device(%device : !hal.device) push_constants(0) layouts([%0]) : !hal.executable_layout
    return %executable_layout : !hal.executable_layout
  }
  hal.variable @_descriptor_set_layout_1 init(@_descriptor_set_layout_1_initializer) : !hal.descriptor_set_layout attributes {sym_visibility = "private"}
  func private @_descriptor_set_layout_1_initializer() -> !hal.descriptor_set_layout {
    %device = hal.ex.shared_device : !hal.device
    %descriptor_set_layout = hal.descriptor_set_layout.create device(%device : !hal.device) usage(PushOnly) bindings([#hal.descriptor_set_layout_binding<0, "StorageBuffer", R>, #hal.descriptor_set_layout_binding<1, "StorageBuffer", DW>]) : !hal.descriptor_set_layout
    return %descriptor_set_layout : !hal.descriptor_set_layout
  }
  hal.variable @_executable_layout_1 init(@_executable_layout_1_initializer) : !hal.executable_layout attributes {sym_visibility = "private"}
  func private @_executable_layout_1_initializer() -> !hal.executable_layout {
    %0 = hal.variable.load @_descriptor_set_layout_1 : !hal.descriptor_set_layout
    %device = hal.ex.shared_device : !hal.device
    %executable_layout = hal.executable_layout.create device(%device : !hal.device) push_constants(0) layouts([%0]) : !hal.executable_layout
    return %executable_layout : !hal.executable_layout
  }
  hal.variable @_descriptor_set_layout_2 init(@_descriptor_set_layout_2_initializer) : !hal.descriptor_set_layout attributes {sym_visibility = "private"}
  func private @_descriptor_set_layout_2_initializer() -> !hal.descriptor_set_layout {
    %device = hal.ex.shared_device : !hal.device
    %descriptor_set_layout = hal.descriptor_set_layout.create device(%device : !hal.device) usage(PushOnly) bindings([#hal.descriptor_set_layout_binding<0, "StorageBuffer", R>, #hal.descriptor_set_layout_binding<1, "StorageBuffer", R>, #hal.descriptor_set_layout_binding<2, "StorageBuffer", R>, #hal.descriptor_set_layout_binding<3, "StorageBuffer", DW>]) : !hal.descriptor_set_layout
    return %descriptor_set_layout : !hal.descriptor_set_layout
  }
  hal.variable @_executable_layout_2 init(@_executable_layout_2_initializer) : !hal.executable_layout attributes {sym_visibility = "private"}
  func private @_executable_layout_2_initializer() -> !hal.executable_layout {
    %0 = hal.variable.load @_descriptor_set_layout_2 : !hal.descriptor_set_layout
    %device = hal.ex.shared_device : !hal.device
    %executable_layout = hal.executable_layout.create device(%device : !hal.device) push_constants(0) layouts([%0]) : !hal.executable_layout
    return %executable_layout : !hal.executable_layout
  }
  hal.variable @_executable_mnist_linked_llvm_aot init(@_executable_mnist_linked_llvm_aot_initializer) : !hal.executable attributes {sym_visibility = "private"}
  func private @_executable_mnist_linked_llvm_aot_initializer() -> !hal.executable {
    %device = hal.ex.shared_device : !hal.device
    %0 = hal.variable.load @_device_match_id_0 : i1
    cond_br %0, ^bb1, ^bb2
  ^bb1:  // pred: ^bb0
    %1 = hal.variable.load @_executable_layout_0 : !hal.executable_layout
    %2 = hal.variable.load @_executable_layout_1 : !hal.executable_layout
    %3 = hal.variable.load @_executable_layout_2 : !hal.executable_layout
    %exe = hal.executable.create device(%device : !hal.device) target(@mnist_linked_llvm_aot::@llvm_aot) layouts([%1, %1, %1, %2, %2, %1, %2, %3]) : !hal.executable
    br ^bb3(%exe : !hal.executable)
  ^bb2:  // pred: ^bb0
    %4 = iree.null : !hal.executable
    br ^bb3(%4 : !hal.executable)
  ^bb3(%5: !hal.executable):  // 2 preds: ^bb1, ^bb2
    return %5 : !hal.executable
  }
  hal.executable @mnist_linked_llvm_aot attributes {sym_visibility = "private"} {
    hal.interface @io_0 {
      hal.interface.binding @s0b0_ro_constant, set=0, binding=0, type="StorageBuffer", access="Read"
      hal.interface.binding @s0b1_ro_external, set=0, binding=1, type="StorageBuffer", access="Read"
      hal.interface.binding @s0b2_xw_external, set=0, binding=2, type="StorageBuffer", access="Write|Discard"
    }
    hal.interface @io_1 {
      hal.interface.binding @s0b0_ro_external, set=0, binding=0, type="StorageBuffer", access="Read"
      hal.interface.binding @s0b1_xw_external, set=0, binding=1, type="StorageBuffer", access="Write|Discard"
    }
    hal.interface @io_2 {
      hal.interface.binding @s0b0_ro_external, set=0, binding=0, type="StorageBuffer", access="Read"
      hal.interface.binding @s0b1_ro_external, set=0, binding=1, type="StorageBuffer", access="Read"
      hal.interface.binding @s0b2_xw_external, set=0, binding=2, type="StorageBuffer", access="Write|Discard"
    }
    hal.interface @io_3 {
      hal.interface.binding @s0b0_ro_external, set=0, binding=0, type="StorageBuffer", access="Read"
      hal.interface.binding @s0b1_ro_external, set=0, binding=1, type="StorageBuffer", access="Read"
      hal.interface.binding @s0b2_ro_external, set=0, binding=2, type="StorageBuffer", access="Read"
      hal.interface.binding @s0b3_xw_external, set=0, binding=3, type="StorageBuffer", access="Write|Discard"
    }
    hal.executable.binary @llvm_aot attributes {data = opaque<"_", "0xDEADBEEF"> : vector<136794xi8>, format = "DLIB", mime_type = "application/x-flatbuffers"} {
    }
  }
  hal.constant_pool @_const_pool attributes {buffer_constraints = #hal.buffer_constraints<max_allocation_size = 1073741824, min_buffer_offset_alignment = 16, max_buffer_range = 1073741824, min_buffer_range_alignment = 16>, sym_visibility = "private"} {
    hal.constant_storage @_storage = opaque<"_", "0xDEADBEEF"> : vector<407040xi8> attributes {sym_visibility = "nested"}
  }
  hal.variable @_const_pool_storage_buffer init(@_const_pool_storage_buffer_initializer) : !hal.buffer attributes {sym_visibility = "private"}
  func private @_const_pool_storage_buffer_initializer() -> !hal.buffer {
    %c0 = constant 0 : index
    %c407040 = constant 407040 : index
    %device = hal.ex.shared_device : !hal.device
    %allocator = hal.device.allocator<%device : !hal.device> : !hal.allocator
    %storage = hal.constant_storage.lookup @_const_pool::@_storage : !iree.byte_buffer
    %mapped = hal.allocator.map<%allocator : !hal.allocator> source(%storage : !iree.byte_buffer)[%c0, %c407040] type("HostVisible|DeviceVisible|DeviceLocal") usage("Constant|Transfer|Mapping|Dispatch") : !hal.buffer
    return %mapped : !hal.buffer
  }
  func @predict(%arg0: !hal.buffer) -> !hal.buffer attributes {noinline} {
    %c3136 = constant 3136 : index
    %c401408 = constant 401408 : index
    %c401920 = constant 401920 : index
    %c5120 = constant 5120 : index
    %c40 = constant 40 : index
    %c4 = constant 4 : index
    %c3 = constant 3 : index
    %c0 = constant 0 : index
    %c512 = constant 512 : index
    %c96 = constant 96 : index
    %c48 = constant 48 : index
    %c112 = constant 112 : index
    %c1024 = constant 1024 : index
    %c2 = constant 2 : index
    %c1 = constant 1 : index
    %device = hal.ex.shared_device : !hal.device
    %allocator = hal.device.allocator<%device : !hal.device> : !hal.allocator
    %buffer = hal.allocator.allocate<%allocator : !hal.allocator> type("HostVisible|DeviceVisible|DeviceLocal") usage("Transfer|Mapping|Dispatch") : !hal.buffer{%c40}
    %0 = hal.variable.load @_const_pool_storage_buffer : !hal.buffer
    %buffer_0 = hal.allocator.allocate<%allocator : !hal.allocator> type("DeviceVisible|DeviceLocal") usage("Transfer|Dispatch") : !hal.buffer{%c1024}
    %cmd = hal.command_buffer.create device(%device : !hal.device) mode("OneShot|AllowInlineExecution") categories("Transfer|Dispatch") : !hal.command_buffer
    hal.command_buffer.begin<%cmd : !hal.command_buffer>
    %1 = hal.variable.load @_executable_layout_0 : !hal.executable_layout
    hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%1 : !hal.executable_layout)[%c0] bindings([
      %c0 = (%0 : !hal.buffer)[%c512, %c401408], 
      %c1 = (%arg0 : !hal.buffer)[%c0, %c3136], 
      %c2 = (%buffer_0 : !hal.buffer)[%c0, %c512]
    ])
    %2 = hal.variable.load @_device_match_id_0 : i1
    cond_br %2, ^bb1, ^bb2
  ^bb1:  // pred: ^bb0
    %3 = hal.variable.load @_executable_mnist_linked_llvm_aot : !hal.executable
    hal.command_buffer.dispatch<%cmd : !hal.command_buffer> target(%3 : !hal.executable)[0] workgroups([%c2, %c1, %c1])
    hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
    hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%1 : !hal.executable_layout)[%c0] bindings([
      %c0 = (%0 : !hal.buffer)[%c0, %c512], 
      %c1 = (%buffer_0 : !hal.buffer)[%c0, %c512], 
      %c2 = (%buffer_0 : !hal.buffer)[%c512, %c512]
    ])
    cond_br %2, ^bb3, ^bb2
  ^bb2:  // 8 preds: ^bb0, ^bb1, ^bb3, ^bb4, ^bb5, ^bb6, ^bb7, ^bb8
    iree.unreachable "device not supported in the compiled configuration"
  ^bb3:  // pred: ^bb1
    hal.command_buffer.dispatch<%cmd : !hal.command_buffer> target(%3 : !hal.executable)[1] workgroups([%c1, %c1, %c1])
    hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
    hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%1 : !hal.executable_layout)[%c0] bindings([
      %c0 = (%0 : !hal.buffer)[%c401920, %c5120], 
      %c1 = (%buffer_0 : !hal.buffer)[%c512, %c512], 
      %c2 = (%buffer_0 : !hal.buffer)[%c0, %c40]
    ])
    cond_br %2, ^bb4, ^bb2
  ^bb4:  // pred: ^bb3
    hal.command_buffer.dispatch<%cmd : !hal.command_buffer> target(%3 : !hal.executable)[2] workgroups([%c1, %c1, %c1])
    hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
    %4 = hal.variable.load @_executable_layout_1 : !hal.executable_layout
    hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%4 : !hal.executable_layout)[%c0] bindings([
      %c0 = (%buffer_0 : !hal.buffer)[%c0, %c40], 
      %c1 = (%buffer_0 : !hal.buffer)[%c48, %c40]
    ])
    cond_br %2, ^bb5, ^bb2
  ^bb5:  // pred: ^bb4
    hal.command_buffer.dispatch<%cmd : !hal.command_buffer> target(%3 : !hal.executable)[3] workgroups([%c1, %c1, %c1])
    hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
    hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%4 : !hal.executable_layout)[%c0] bindings([
      %c0 = (%buffer_0 : !hal.buffer)[%c48, %c40], 
      %c1 = (%buffer_0 : !hal.buffer)[%c96, %c4]
    ])
    cond_br %2, ^bb6, ^bb2
  ^bb6:  // pred: ^bb5
    hal.command_buffer.dispatch<%cmd : !hal.command_buffer> target(%3 : !hal.executable)[4] workgroups([%c1, %c1, %c1])
    hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
    hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%1 : !hal.executable_layout)[%c0] bindings([
      %c0 = (%buffer_0 : !hal.buffer)[%c0, %c40], 
      %c1 = (%buffer_0 : !hal.buffer)[%c96, %c4], 
      %c2 = (%buffer_0 : !hal.buffer)[%c48, %c40]
    ])
    cond_br %2, ^bb7, ^bb2
  ^bb7:  // pred: ^bb6
    hal.command_buffer.dispatch<%cmd : !hal.command_buffer> target(%3 : !hal.executable)[5] workgroups([%c1, %c1, %c1])
    hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
    hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%4 : !hal.executable_layout)[%c0] bindings([
      %c0 = (%buffer_0 : !hal.buffer)[%c48, %c40], 
      %c1 = (%buffer_0 : !hal.buffer)[%c112, %c4]
    ])
    cond_br %2, ^bb8, ^bb2
  ^bb8:  // pred: ^bb7
    hal.command_buffer.dispatch<%cmd : !hal.command_buffer> target(%3 : !hal.executable)[6] workgroups([%c1, %c1, %c1])
    hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
    %5 = hal.variable.load @_executable_layout_2 : !hal.executable_layout
    hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%5 : !hal.executable_layout)[%c0] bindings([
      %c0 = (%buffer_0 : !hal.buffer)[%c0, %c40], 
      %c1 = (%buffer_0 : !hal.buffer)[%c96, %c4], 
      %c2 = (%buffer_0 : !hal.buffer)[%c112, %c4], 
      %c3 = (%buffer : !hal.buffer)[%c0, %c40]
    ])
    cond_br %2, ^bb9, ^bb2
  ^bb9:  // pred: ^bb8
    hal.command_buffer.dispatch<%cmd : !hal.command_buffer> target(%3 : !hal.executable)[7] workgroups([%c1, %c1, %c1])
    hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
    hal.command_buffer.end<%cmd : !hal.command_buffer>
    hal.ex.submit_and_wait %device, %cmd
    return %buffer : !hal.buffer
  }
  func @predict$async(%arg0: !hal.semaphore, %arg1: index, %arg2: !hal.buffer_view, %arg3: !hal.semaphore, %arg4: index) -> !hal.buffer_view attributes {iree.module.export = "predict$async"} {
    %c1 = constant 1 : index
    %c10 = constant 10 : index
    %c50331680_i32 = constant 50331680 : i32
    %0 = hal.semaphore.await<%arg0 : !hal.semaphore> until(%arg1) : i32
    hal.check_success %0, "semaphore wait failed"
    %buffer = hal.buffer_view.buffer %arg2 : !hal.buffer
    %1 = call @predict(%buffer) : (!hal.buffer) -> !hal.buffer
    %view = hal.buffer_view.create %1, element_type = %c50331680_i32, shape = [%c1, %c10] : !hal.buffer -> !hal.buffer_view
    hal.semaphore.signal<%arg3 : !hal.semaphore> value(%arg4)
    return %view : !hal.buffer_view
  }
  func @predict$sync(%arg0: !hal.buffer_view) -> !hal.buffer_view attributes {iree.abi.stub, iree.module.export = "predict", iree.reflection = {abi = "sip", abiv = 1 : i32, f = "I15!B11!d1d28d28d1R9!B6!d1d10", fv = "1", sip = "I8!S5!k0_0R3!_0"}} {
    %c0 = constant 0 : index
    %c1 = constant 1 : index
    %device = hal.ex.shared_device : !hal.device
    %semaphore = hal.semaphore.create device(%device : !hal.device) initial(%c0) : !hal.semaphore
    %0 = call @predict$async(%semaphore, %c0, %arg0, %semaphore, %c1) : (!hal.semaphore, index, !hal.buffer_view, !hal.semaphore, index) -> !hal.buffer_view
    %1 = hal.semaphore.await<%semaphore : !hal.semaphore> until(%c1) : i32
    hal.check_success %1, "semaphore wait failed"
    return %0 : !hal.buffer_view
  }
}


// *** IR Dump After Canonicalizer ***
func private @_device_match_id_0_initializer() -> i1 {
  %device = hal.ex.shared_device : !hal.device
  %0 = hal.device.match.id<%device : !hal.device> pattern("dylib*") : i1
  return %0 : i1
}

// *** IR Dump After LoopCoalescing ***
func private @_device_match_id_0_initializer() -> i1 {
  %device = hal.ex.shared_device : !hal.device
  %0 = hal.device.match.id<%device : !hal.device> pattern("dylib*") : i1
  return %0 : i1
}

// *** IR Dump After AffineLoopFusion ***
func private @_device_match_id_0_initializer() -> i1 {
  %device = hal.ex.shared_device : !hal.device
  %0 = hal.device.match.id<%device : !hal.device> pattern("dylib*") : i1
  return %0 : i1
}

// *** IR Dump After LoopInvariantCodeMotion ***
func private @_device_match_id_0_initializer() -> i1 {
  %device = hal.ex.shared_device : !hal.device
  %0 = hal.device.match.id<%device : !hal.device> pattern("dylib*") : i1
  return %0 : i1
}

// *** IR Dump After Canonicalizer ***
func private @_descriptor_set_layout_0_initializer() -> !hal.descriptor_set_layout {
  %device = hal.ex.shared_device : !hal.device
  %descriptor_set_layout = hal.descriptor_set_layout.create device(%device : !hal.device) usage(PushOnly) bindings([#hal.descriptor_set_layout_binding<0, "StorageBuffer", R>, #hal.descriptor_set_layout_binding<1, "StorageBuffer", R>, #hal.descriptor_set_layout_binding<2, "StorageBuffer", DW>]) : !hal.descriptor_set_layout
  return %descriptor_set_layout : !hal.descriptor_set_layout
}

// *** IR Dump After LoopCoalescing ***
func private @_descriptor_set_layout_0_initializer() -> !hal.descriptor_set_layout {
  %device = hal.ex.shared_device : !hal.device
  %descriptor_set_layout = hal.descriptor_set_layout.create device(%device : !hal.device) usage(PushOnly) bindings([#hal.descriptor_set_layout_binding<0, "StorageBuffer", R>, #hal.descriptor_set_layout_binding<1, "StorageBuffer", R>, #hal.descriptor_set_layout_binding<2, "StorageBuffer", DW>]) : !hal.descriptor_set_layout
  return %descriptor_set_layout : !hal.descriptor_set_layout
}

// *** IR Dump After AffineLoopFusion ***
func private @_descriptor_set_layout_0_initializer() -> !hal.descriptor_set_layout {
  %device = hal.ex.shared_device : !hal.device
  %descriptor_set_layout = hal.descriptor_set_layout.create device(%device : !hal.device) usage(PushOnly) bindings([#hal.descriptor_set_layout_binding<0, "StorageBuffer", R>, #hal.descriptor_set_layout_binding<1, "StorageBuffer", R>, #hal.descriptor_set_layout_binding<2, "StorageBuffer", DW>]) : !hal.descriptor_set_layout
  return %descriptor_set_layout : !hal.descriptor_set_layout
}

// *** IR Dump After LoopInvariantCodeMotion ***
func private @_descriptor_set_layout_0_initializer() -> !hal.descriptor_set_layout {
  %device = hal.ex.shared_device : !hal.device
  %descriptor_set_layout = hal.descriptor_set_layout.create device(%device : !hal.device) usage(PushOnly) bindings([#hal.descriptor_set_layout_binding<0, "StorageBuffer", R>, #hal.descriptor_set_layout_binding<1, "StorageBuffer", R>, #hal.descriptor_set_layout_binding<2, "StorageBuffer", DW>]) : !hal.descriptor_set_layout
  return %descriptor_set_layout : !hal.descriptor_set_layout
}

// *** IR Dump After Canonicalizer ***
func private @_executable_layout_0_initializer() -> !hal.executable_layout {
  %0 = hal.variable.load @_descriptor_set_layout_0 : !hal.descriptor_set_layout
  %device = hal.ex.shared_device : !hal.device
  %executable_layout = hal.executable_layout.create device(%device : !hal.device) push_constants(0) layouts([%0]) : !hal.executable_layout
  return %executable_layout : !hal.executable_layout
}

// *** IR Dump After LoopCoalescing ***
func private @_executable_layout_0_initializer() -> !hal.executable_layout {
  %0 = hal.variable.load @_descriptor_set_layout_0 : !hal.descriptor_set_layout
  %device = hal.ex.shared_device : !hal.device
  %executable_layout = hal.executable_layout.create device(%device : !hal.device) push_constants(0) layouts([%0]) : !hal.executable_layout
  return %executable_layout : !hal.executable_layout
}

// *** IR Dump After AffineLoopFusion ***
func private @_executable_layout_0_initializer() -> !hal.executable_layout {
  %0 = hal.variable.load @_descriptor_set_layout_0 : !hal.descriptor_set_layout
  %device = hal.ex.shared_device : !hal.device
  %executable_layout = hal.executable_layout.create device(%device : !hal.device) push_constants(0) layouts([%0]) : !hal.executable_layout
  return %executable_layout : !hal.executable_layout
}

// *** IR Dump After LoopInvariantCodeMotion ***
func private @_executable_layout_0_initializer() -> !hal.executable_layout {
  %0 = hal.variable.load @_descriptor_set_layout_0 : !hal.descriptor_set_layout
  %device = hal.ex.shared_device : !hal.device
  %executable_layout = hal.executable_layout.create device(%device : !hal.device) push_constants(0) layouts([%0]) : !hal.executable_layout
  return %executable_layout : !hal.executable_layout
}

// *** IR Dump After Canonicalizer ***
func private @_descriptor_set_layout_1_initializer() -> !hal.descriptor_set_layout {
  %device = hal.ex.shared_device : !hal.device
  %descriptor_set_layout = hal.descriptor_set_layout.create device(%device : !hal.device) usage(PushOnly) bindings([#hal.descriptor_set_layout_binding<0, "StorageBuffer", R>, #hal.descriptor_set_layout_binding<1, "StorageBuffer", DW>]) : !hal.descriptor_set_layout
  return %descriptor_set_layout : !hal.descriptor_set_layout
}

// *** IR Dump After LoopCoalescing ***
func private @_descriptor_set_layout_1_initializer() -> !hal.descriptor_set_layout {
  %device = hal.ex.shared_device : !hal.device
  %descriptor_set_layout = hal.descriptor_set_layout.create device(%device : !hal.device) usage(PushOnly) bindings([#hal.descriptor_set_layout_binding<0, "StorageBuffer", R>, #hal.descriptor_set_layout_binding<1, "StorageBuffer", DW>]) : !hal.descriptor_set_layout
  return %descriptor_set_layout : !hal.descriptor_set_layout
}

// *** IR Dump After AffineLoopFusion ***
func private @_descriptor_set_layout_1_initializer() -> !hal.descriptor_set_layout {
  %device = hal.ex.shared_device : !hal.device
  %descriptor_set_layout = hal.descriptor_set_layout.create device(%device : !hal.device) usage(PushOnly) bindings([#hal.descriptor_set_layout_binding<0, "StorageBuffer", R>, #hal.descriptor_set_layout_binding<1, "StorageBuffer", DW>]) : !hal.descriptor_set_layout
  return %descriptor_set_layout : !hal.descriptor_set_layout
}

// *** IR Dump After LoopInvariantCodeMotion ***
func private @_descriptor_set_layout_1_initializer() -> !hal.descriptor_set_layout {
  %device = hal.ex.shared_device : !hal.device
  %descriptor_set_layout = hal.descriptor_set_layout.create device(%device : !hal.device) usage(PushOnly) bindings([#hal.descriptor_set_layout_binding<0, "StorageBuffer", R>, #hal.descriptor_set_layout_binding<1, "StorageBuffer", DW>]) : !hal.descriptor_set_layout
  return %descriptor_set_layout : !hal.descriptor_set_layout
}

// *** IR Dump After Canonicalizer ***
func private @_executable_layout_1_initializer() -> !hal.executable_layout {
  %0 = hal.variable.load @_descriptor_set_layout_1 : !hal.descriptor_set_layout
  %device = hal.ex.shared_device : !hal.device
  %executable_layout = hal.executable_layout.create device(%device : !hal.device) push_constants(0) layouts([%0]) : !hal.executable_layout
  return %executable_layout : !hal.executable_layout
}

// *** IR Dump After LoopCoalescing ***
func private @_executable_layout_1_initializer() -> !hal.executable_layout {
  %0 = hal.variable.load @_descriptor_set_layout_1 : !hal.descriptor_set_layout
  %device = hal.ex.shared_device : !hal.device
  %executable_layout = hal.executable_layout.create device(%device : !hal.device) push_constants(0) layouts([%0]) : !hal.executable_layout
  return %executable_layout : !hal.executable_layout
}

// *** IR Dump After AffineLoopFusion ***
func private @_executable_layout_1_initializer() -> !hal.executable_layout {
  %0 = hal.variable.load @_descriptor_set_layout_1 : !hal.descriptor_set_layout
  %device = hal.ex.shared_device : !hal.device
  %executable_layout = hal.executable_layout.create device(%device : !hal.device) push_constants(0) layouts([%0]) : !hal.executable_layout
  return %executable_layout : !hal.executable_layout
}

// *** IR Dump After LoopInvariantCodeMotion ***
func private @_executable_layout_1_initializer() -> !hal.executable_layout {
  %0 = hal.variable.load @_descriptor_set_layout_1 : !hal.descriptor_set_layout
  %device = hal.ex.shared_device : !hal.device
  %executable_layout = hal.executable_layout.create device(%device : !hal.device) push_constants(0) layouts([%0]) : !hal.executable_layout
  return %executable_layout : !hal.executable_layout
}

// *** IR Dump After Canonicalizer ***
func private @_descriptor_set_layout_2_initializer() -> !hal.descriptor_set_layout {
  %device = hal.ex.shared_device : !hal.device
  %descriptor_set_layout = hal.descriptor_set_layout.create device(%device : !hal.device) usage(PushOnly) bindings([#hal.descriptor_set_layout_binding<0, "StorageBuffer", R>, #hal.descriptor_set_layout_binding<1, "StorageBuffer", R>, #hal.descriptor_set_layout_binding<2, "StorageBuffer", R>, #hal.descriptor_set_layout_binding<3, "StorageBuffer", DW>]) : !hal.descriptor_set_layout
  return %descriptor_set_layout : !hal.descriptor_set_layout
}

// *** IR Dump After LoopCoalescing ***
func private @_descriptor_set_layout_2_initializer() -> !hal.descriptor_set_layout {
  %device = hal.ex.shared_device : !hal.device
  %descriptor_set_layout = hal.descriptor_set_layout.create device(%device : !hal.device) usage(PushOnly) bindings([#hal.descriptor_set_layout_binding<0, "StorageBuffer", R>, #hal.descriptor_set_layout_binding<1, "StorageBuffer", R>, #hal.descriptor_set_layout_binding<2, "StorageBuffer", R>, #hal.descriptor_set_layout_binding<3, "StorageBuffer", DW>]) : !hal.descriptor_set_layout
  return %descriptor_set_layout : !hal.descriptor_set_layout
}

// *** IR Dump After AffineLoopFusion ***
func private @_descriptor_set_layout_2_initializer() -> !hal.descriptor_set_layout {
  %device = hal.ex.shared_device : !hal.device
  %descriptor_set_layout = hal.descriptor_set_layout.create device(%device : !hal.device) usage(PushOnly) bindings([#hal.descriptor_set_layout_binding<0, "StorageBuffer", R>, #hal.descriptor_set_layout_binding<1, "StorageBuffer", R>, #hal.descriptor_set_layout_binding<2, "StorageBuffer", R>, #hal.descriptor_set_layout_binding<3, "StorageBuffer", DW>]) : !hal.descriptor_set_layout
  return %descriptor_set_layout : !hal.descriptor_set_layout
}

// *** IR Dump After LoopInvariantCodeMotion ***
func private @_descriptor_set_layout_2_initializer() -> !hal.descriptor_set_layout {
  %device = hal.ex.shared_device : !hal.device
  %descriptor_set_layout = hal.descriptor_set_layout.create device(%device : !hal.device) usage(PushOnly) bindings([#hal.descriptor_set_layout_binding<0, "StorageBuffer", R>, #hal.descriptor_set_layout_binding<1, "StorageBuffer", R>, #hal.descriptor_set_layout_binding<2, "StorageBuffer", R>, #hal.descriptor_set_layout_binding<3, "StorageBuffer", DW>]) : !hal.descriptor_set_layout
  return %descriptor_set_layout : !hal.descriptor_set_layout
}

// *** IR Dump After Canonicalizer ***
func private @_executable_layout_2_initializer() -> !hal.executable_layout {
  %0 = hal.variable.load @_descriptor_set_layout_2 : !hal.descriptor_set_layout
  %device = hal.ex.shared_device : !hal.device
  %executable_layout = hal.executable_layout.create device(%device : !hal.device) push_constants(0) layouts([%0]) : !hal.executable_layout
  return %executable_layout : !hal.executable_layout
}

// *** IR Dump After LoopCoalescing ***
func private @_executable_layout_2_initializer() -> !hal.executable_layout {
  %0 = hal.variable.load @_descriptor_set_layout_2 : !hal.descriptor_set_layout
  %device = hal.ex.shared_device : !hal.device
  %executable_layout = hal.executable_layout.create device(%device : !hal.device) push_constants(0) layouts([%0]) : !hal.executable_layout
  return %executable_layout : !hal.executable_layout
}

// *** IR Dump After AffineLoopFusion ***
func private @_executable_layout_2_initializer() -> !hal.executable_layout {
  %0 = hal.variable.load @_descriptor_set_layout_2 : !hal.descriptor_set_layout
  %device = hal.ex.shared_device : !hal.device
  %executable_layout = hal.executable_layout.create device(%device : !hal.device) push_constants(0) layouts([%0]) : !hal.executable_layout
  return %executable_layout : !hal.executable_layout
}

// *** IR Dump After LoopInvariantCodeMotion ***
func private @_executable_layout_2_initializer() -> !hal.executable_layout {
  %0 = hal.variable.load @_descriptor_set_layout_2 : !hal.descriptor_set_layout
  %device = hal.ex.shared_device : !hal.device
  %executable_layout = hal.executable_layout.create device(%device : !hal.device) push_constants(0) layouts([%0]) : !hal.executable_layout
  return %executable_layout : !hal.executable_layout
}

// *** IR Dump After Canonicalizer ***
func private @_executable_mnist_linked_llvm_aot_initializer() -> !hal.executable {
  %device = hal.ex.shared_device : !hal.device
  %0 = hal.variable.load @_device_match_id_0 : i1
  cond_br %0, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %1 = hal.variable.load @_executable_layout_0 : !hal.executable_layout
  %2 = hal.variable.load @_executable_layout_1 : !hal.executable_layout
  %3 = hal.variable.load @_executable_layout_2 : !hal.executable_layout
  %exe = hal.executable.create device(%device : !hal.device) target(@mnist_linked_llvm_aot::@llvm_aot) layouts([%1, %1, %1, %2, %2, %1, %2, %3]) : !hal.executable
  br ^bb3(%exe : !hal.executable)
^bb2:  // pred: ^bb0
  %4 = iree.null : !hal.executable
  br ^bb3(%4 : !hal.executable)
^bb3(%5: !hal.executable):  // 2 preds: ^bb1, ^bb2
  return %5 : !hal.executable
}

// *** IR Dump After LoopCoalescing ***
func private @_executable_mnist_linked_llvm_aot_initializer() -> !hal.executable {
  %device = hal.ex.shared_device : !hal.device
  %0 = hal.variable.load @_device_match_id_0 : i1
  cond_br %0, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %1 = hal.variable.load @_executable_layout_0 : !hal.executable_layout
  %2 = hal.variable.load @_executable_layout_1 : !hal.executable_layout
  %3 = hal.variable.load @_executable_layout_2 : !hal.executable_layout
  %exe = hal.executable.create device(%device : !hal.device) target(@mnist_linked_llvm_aot::@llvm_aot) layouts([%1, %1, %1, %2, %2, %1, %2, %3]) : !hal.executable
  br ^bb3(%exe : !hal.executable)
^bb2:  // pred: ^bb0
  %4 = iree.null : !hal.executable
  br ^bb3(%4 : !hal.executable)
^bb3(%5: !hal.executable):  // 2 preds: ^bb1, ^bb2
  return %5 : !hal.executable
}

// *** IR Dump After AffineLoopFusion ***
func private @_executable_mnist_linked_llvm_aot_initializer() -> !hal.executable {
  %device = hal.ex.shared_device : !hal.device
  %0 = hal.variable.load @_device_match_id_0 : i1
  cond_br %0, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %1 = hal.variable.load @_executable_layout_0 : !hal.executable_layout
  %2 = hal.variable.load @_executable_layout_1 : !hal.executable_layout
  %3 = hal.variable.load @_executable_layout_2 : !hal.executable_layout
  %exe = hal.executable.create device(%device : !hal.device) target(@mnist_linked_llvm_aot::@llvm_aot) layouts([%1, %1, %1, %2, %2, %1, %2, %3]) : !hal.executable
  br ^bb3(%exe : !hal.executable)
^bb2:  // pred: ^bb0
  %4 = iree.null : !hal.executable
  br ^bb3(%4 : !hal.executable)
^bb3(%5: !hal.executable):  // 2 preds: ^bb1, ^bb2
  return %5 : !hal.executable
}

// *** IR Dump After LoopInvariantCodeMotion ***
func private @_executable_mnist_linked_llvm_aot_initializer() -> !hal.executable {
  %device = hal.ex.shared_device : !hal.device
  %0 = hal.variable.load @_device_match_id_0 : i1
  cond_br %0, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %1 = hal.variable.load @_executable_layout_0 : !hal.executable_layout
  %2 = hal.variable.load @_executable_layout_1 : !hal.executable_layout
  %3 = hal.variable.load @_executable_layout_2 : !hal.executable_layout
  %exe = hal.executable.create device(%device : !hal.device) target(@mnist_linked_llvm_aot::@llvm_aot) layouts([%1, %1, %1, %2, %2, %1, %2, %3]) : !hal.executable
  br ^bb3(%exe : !hal.executable)
^bb2:  // pred: ^bb0
  %4 = iree.null : !hal.executable
  br ^bb3(%4 : !hal.executable)
^bb3(%5: !hal.executable):  // 2 preds: ^bb1, ^bb2
  return %5 : !hal.executable
}

// *** IR Dump After Canonicalizer ***
func private @_const_pool_storage_buffer_initializer() -> !hal.buffer {
  %c0 = constant 0 : index
  %c407040 = constant 407040 : index
  %device = hal.ex.shared_device : !hal.device
  %allocator = hal.device.allocator<%device : !hal.device> : !hal.allocator
  %storage = hal.constant_storage.lookup @_const_pool::@_storage : !iree.byte_buffer
  %mapped = hal.allocator.map<%allocator : !hal.allocator> source(%storage : !iree.byte_buffer)[%c0, %c407040] type("HostVisible|DeviceVisible|DeviceLocal") usage("Constant|Transfer|Mapping|Dispatch") : !hal.buffer
  return %mapped : !hal.buffer
}

// *** IR Dump After LoopCoalescing ***
func private @_const_pool_storage_buffer_initializer() -> !hal.buffer {
  %c0 = constant 0 : index
  %c407040 = constant 407040 : index
  %device = hal.ex.shared_device : !hal.device
  %allocator = hal.device.allocator<%device : !hal.device> : !hal.allocator
  %storage = hal.constant_storage.lookup @_const_pool::@_storage : !iree.byte_buffer
  %mapped = hal.allocator.map<%allocator : !hal.allocator> source(%storage : !iree.byte_buffer)[%c0, %c407040] type("HostVisible|DeviceVisible|DeviceLocal") usage("Constant|Transfer|Mapping|Dispatch") : !hal.buffer
  return %mapped : !hal.buffer
}

// *** IR Dump After AffineLoopFusion ***
func private @_const_pool_storage_buffer_initializer() -> !hal.buffer {
  %c0 = constant 0 : index
  %c407040 = constant 407040 : index
  %device = hal.ex.shared_device : !hal.device
  %allocator = hal.device.allocator<%device : !hal.device> : !hal.allocator
  %storage = hal.constant_storage.lookup @_const_pool::@_storage : !iree.byte_buffer
  %mapped = hal.allocator.map<%allocator : !hal.allocator> source(%storage : !iree.byte_buffer)[%c0, %c407040] type("HostVisible|DeviceVisible|DeviceLocal") usage("Constant|Transfer|Mapping|Dispatch") : !hal.buffer
  return %mapped : !hal.buffer
}

// *** IR Dump After LoopInvariantCodeMotion ***
func private @_const_pool_storage_buffer_initializer() -> !hal.buffer {
  %c0 = constant 0 : index
  %c407040 = constant 407040 : index
  %device = hal.ex.shared_device : !hal.device
  %allocator = hal.device.allocator<%device : !hal.device> : !hal.allocator
  %storage = hal.constant_storage.lookup @_const_pool::@_storage : !iree.byte_buffer
  %mapped = hal.allocator.map<%allocator : !hal.allocator> source(%storage : !iree.byte_buffer)[%c0, %c407040] type("HostVisible|DeviceVisible|DeviceLocal") usage("Constant|Transfer|Mapping|Dispatch") : !hal.buffer
  return %mapped : !hal.buffer
}

// *** IR Dump After Canonicalizer ***
func @predict(%arg0: !hal.buffer) -> !hal.buffer attributes {noinline} {
  %c3136 = constant 3136 : index
  %c401408 = constant 401408 : index
  %c401920 = constant 401920 : index
  %c5120 = constant 5120 : index
  %c40 = constant 40 : index
  %c4 = constant 4 : index
  %c3 = constant 3 : index
  %c0 = constant 0 : index
  %c512 = constant 512 : index
  %c96 = constant 96 : index
  %c48 = constant 48 : index
  %c112 = constant 112 : index
  %c1024 = constant 1024 : index
  %c2 = constant 2 : index
  %c1 = constant 1 : index
  %device = hal.ex.shared_device : !hal.device
  %allocator = hal.device.allocator<%device : !hal.device> : !hal.allocator
  %buffer = hal.allocator.allocate<%allocator : !hal.allocator> type("HostVisible|DeviceVisible|DeviceLocal") usage("Transfer|Mapping|Dispatch") : !hal.buffer{%c40}
  %0 = hal.variable.load @_const_pool_storage_buffer : !hal.buffer
  %buffer_0 = hal.allocator.allocate<%allocator : !hal.allocator> type("DeviceVisible|DeviceLocal") usage("Transfer|Dispatch") : !hal.buffer{%c1024}
  %cmd = hal.command_buffer.create device(%device : !hal.device) mode("OneShot|AllowInlineExecution") categories("Transfer|Dispatch") : !hal.command_buffer
  hal.command_buffer.begin<%cmd : !hal.command_buffer>
  %1 = hal.variable.load @_executable_layout_0 : !hal.executable_layout
  hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%1 : !hal.executable_layout)[%c0] bindings([
    %c0 = (%0 : !hal.buffer)[%c512, %c401408], 
    %c1 = (%arg0 : !hal.buffer)[%c0, %c3136], 
    %c2 = (%buffer_0 : !hal.buffer)[%c0, %c512]
  ])
  %2 = hal.variable.load @_device_match_id_0 : i1
  cond_br %2, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %3 = hal.variable.load @_executable_mnist_linked_llvm_aot : !hal.executable
  hal.command_buffer.dispatch<%cmd : !hal.command_buffer> target(%3 : !hal.executable)[0] workgroups([%c2, %c1, %c1])
  hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
  hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%1 : !hal.executable_layout)[%c0] bindings([
    %c0 = (%0 : !hal.buffer)[%c0, %c512], 
    %c1 = (%buffer_0 : !hal.buffer)[%c0, %c512], 
    %c2 = (%buffer_0 : !hal.buffer)[%c512, %c512]
  ])
  hal.command_buffer.dispatch<%cmd : !hal.command_buffer> target(%3 : !hal.executable)[1] workgroups([%c1, %c1, %c1])
  hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
  hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%1 : !hal.executable_layout)[%c0] bindings([
    %c0 = (%0 : !hal.buffer)[%c401920, %c5120], 
    %c1 = (%buffer_0 : !hal.buffer)[%c512, %c512], 
    %c2 = (%buffer_0 : !hal.buffer)[%c0, %c40]
  ])
  hal.command_buffer.dispatch<%cmd : !hal.command_buffer> target(%3 : !hal.executable)[2] workgroups([%c1, %c1, %c1])
  hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
  %4 = hal.variable.load @_executable_layout_1 : !hal.executable_layout
  hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%4 : !hal.executable_layout)[%c0] bindings([
    %c0 = (%buffer_0 : !hal.buffer)[%c0, %c40], 
    %c1 = (%buffer_0 : !hal.buffer)[%c48, %c40]
  ])
  hal.command_buffer.dispatch<%cmd : !hal.command_buffer> target(%3 : !hal.executable)[3] workgroups([%c1, %c1, %c1])
  hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
  hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%4 : !hal.executable_layout)[%c0] bindings([
    %c0 = (%buffer_0 : !hal.buffer)[%c48, %c40], 
    %c1 = (%buffer_0 : !hal.buffer)[%c96, %c4]
  ])
  hal.command_buffer.dispatch<%cmd : !hal.command_buffer> target(%3 : !hal.executable)[4] workgroups([%c1, %c1, %c1])
  hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
  hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%1 : !hal.executable_layout)[%c0] bindings([
    %c0 = (%buffer_0 : !hal.buffer)[%c0, %c40], 
    %c1 = (%buffer_0 : !hal.buffer)[%c96, %c4], 
    %c2 = (%buffer_0 : !hal.buffer)[%c48, %c40]
  ])
  hal.command_buffer.dispatch<%cmd : !hal.command_buffer> target(%3 : !hal.executable)[5] workgroups([%c1, %c1, %c1])
  hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
  hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%4 : !hal.executable_layout)[%c0] bindings([
    %c0 = (%buffer_0 : !hal.buffer)[%c48, %c40], 
    %c1 = (%buffer_0 : !hal.buffer)[%c112, %c4]
  ])
  hal.command_buffer.dispatch<%cmd : !hal.command_buffer> target(%3 : !hal.executable)[6] workgroups([%c1, %c1, %c1])
  hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
  %5 = hal.variable.load @_executable_layout_2 : !hal.executable_layout
  hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%5 : !hal.executable_layout)[%c0] bindings([
    %c0 = (%buffer_0 : !hal.buffer)[%c0, %c40], 
    %c1 = (%buffer_0 : !hal.buffer)[%c96, %c4], 
    %c2 = (%buffer_0 : !hal.buffer)[%c112, %c4], 
    %c3 = (%buffer : !hal.buffer)[%c0, %c40]
  ])
  hal.command_buffer.dispatch<%cmd : !hal.command_buffer> target(%3 : !hal.executable)[7] workgroups([%c1, %c1, %c1])
  hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
  hal.command_buffer.end<%cmd : !hal.command_buffer>
  hal.ex.submit_and_wait %device, %cmd
  return %buffer : !hal.buffer
^bb2:  // pred: ^bb0
  iree.unreachable "device not supported in the compiled configuration"
}

// *** IR Dump After LoopCoalescing ***
func @predict(%arg0: !hal.buffer) -> !hal.buffer attributes {noinline} {
  %c3136 = constant 3136 : index
  %c401408 = constant 401408 : index
  %c401920 = constant 401920 : index
  %c5120 = constant 5120 : index
  %c40 = constant 40 : index
  %c4 = constant 4 : index
  %c3 = constant 3 : index
  %c0 = constant 0 : index
  %c512 = constant 512 : index
  %c96 = constant 96 : index
  %c48 = constant 48 : index
  %c112 = constant 112 : index
  %c1024 = constant 1024 : index
  %c2 = constant 2 : index
  %c1 = constant 1 : index
  %device = hal.ex.shared_device : !hal.device
  %allocator = hal.device.allocator<%device : !hal.device> : !hal.allocator
  %buffer = hal.allocator.allocate<%allocator : !hal.allocator> type("HostVisible|DeviceVisible|DeviceLocal") usage("Transfer|Mapping|Dispatch") : !hal.buffer{%c40}
  %0 = hal.variable.load @_const_pool_storage_buffer : !hal.buffer
  %buffer_0 = hal.allocator.allocate<%allocator : !hal.allocator> type("DeviceVisible|DeviceLocal") usage("Transfer|Dispatch") : !hal.buffer{%c1024}
  %cmd = hal.command_buffer.create device(%device : !hal.device) mode("OneShot|AllowInlineExecution") categories("Transfer|Dispatch") : !hal.command_buffer
  hal.command_buffer.begin<%cmd : !hal.command_buffer>
  %1 = hal.variable.load @_executable_layout_0 : !hal.executable_layout
  hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%1 : !hal.executable_layout)[%c0] bindings([
    %c0 = (%0 : !hal.buffer)[%c512, %c401408], 
    %c1 = (%arg0 : !hal.buffer)[%c0, %c3136], 
    %c2 = (%buffer_0 : !hal.buffer)[%c0, %c512]
  ])
  %2 = hal.variable.load @_device_match_id_0 : i1
  cond_br %2, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %3 = hal.variable.load @_executable_mnist_linked_llvm_aot : !hal.executable
  hal.command_buffer.dispatch<%cmd : !hal.command_buffer> target(%3 : !hal.executable)[0] workgroups([%c2, %c1, %c1])
  hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
  hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%1 : !hal.executable_layout)[%c0] bindings([
    %c0 = (%0 : !hal.buffer)[%c0, %c512], 
    %c1 = (%buffer_0 : !hal.buffer)[%c0, %c512], 
    %c2 = (%buffer_0 : !hal.buffer)[%c512, %c512]
  ])
  hal.command_buffer.dispatch<%cmd : !hal.command_buffer> target(%3 : !hal.executable)[1] workgroups([%c1, %c1, %c1])
  hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
  hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%1 : !hal.executable_layout)[%c0] bindings([
    %c0 = (%0 : !hal.buffer)[%c401920, %c5120], 
    %c1 = (%buffer_0 : !hal.buffer)[%c512, %c512], 
    %c2 = (%buffer_0 : !hal.buffer)[%c0, %c40]
  ])
  hal.command_buffer.dispatch<%cmd : !hal.command_buffer> target(%3 : !hal.executable)[2] workgroups([%c1, %c1, %c1])
  hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
  %4 = hal.variable.load @_executable_layout_1 : !hal.executable_layout
  hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%4 : !hal.executable_layout)[%c0] bindings([
    %c0 = (%buffer_0 : !hal.buffer)[%c0, %c40], 
    %c1 = (%buffer_0 : !hal.buffer)[%c48, %c40]
  ])
  hal.command_buffer.dispatch<%cmd : !hal.command_buffer> target(%3 : !hal.executable)[3] workgroups([%c1, %c1, %c1])
  hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
  hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%4 : !hal.executable_layout)[%c0] bindings([
    %c0 = (%buffer_0 : !hal.buffer)[%c48, %c40], 
    %c1 = (%buffer_0 : !hal.buffer)[%c96, %c4]
  ])
  hal.command_buffer.dispatch<%cmd : !hal.command_buffer> target(%3 : !hal.executable)[4] workgroups([%c1, %c1, %c1])
  hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
  hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%1 : !hal.executable_layout)[%c0] bindings([
    %c0 = (%buffer_0 : !hal.buffer)[%c0, %c40], 
    %c1 = (%buffer_0 : !hal.buffer)[%c96, %c4], 
    %c2 = (%buffer_0 : !hal.buffer)[%c48, %c40]
  ])
  hal.command_buffer.dispatch<%cmd : !hal.command_buffer> target(%3 : !hal.executable)[5] workgroups([%c1, %c1, %c1])
  hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
  hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%4 : !hal.executable_layout)[%c0] bindings([
    %c0 = (%buffer_0 : !hal.buffer)[%c48, %c40], 
    %c1 = (%buffer_0 : !hal.buffer)[%c112, %c4]
  ])
  hal.command_buffer.dispatch<%cmd : !hal.command_buffer> target(%3 : !hal.executable)[6] workgroups([%c1, %c1, %c1])
  hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
  %5 = hal.variable.load @_executable_layout_2 : !hal.executable_layout
  hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%5 : !hal.executable_layout)[%c0] bindings([
    %c0 = (%buffer_0 : !hal.buffer)[%c0, %c40], 
    %c1 = (%buffer_0 : !hal.buffer)[%c96, %c4], 
    %c2 = (%buffer_0 : !hal.buffer)[%c112, %c4], 
    %c3 = (%buffer : !hal.buffer)[%c0, %c40]
  ])
  hal.command_buffer.dispatch<%cmd : !hal.command_buffer> target(%3 : !hal.executable)[7] workgroups([%c1, %c1, %c1])
  hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
  hal.command_buffer.end<%cmd : !hal.command_buffer>
  hal.ex.submit_and_wait %device, %cmd
  return %buffer : !hal.buffer
^bb2:  // pred: ^bb0
  iree.unreachable "device not supported in the compiled configuration"
}

// *** IR Dump After AffineLoopFusion ***
func @predict(%arg0: !hal.buffer) -> !hal.buffer attributes {noinline} {
  %c3136 = constant 3136 : index
  %c401408 = constant 401408 : index
  %c401920 = constant 401920 : index
  %c5120 = constant 5120 : index
  %c40 = constant 40 : index
  %c4 = constant 4 : index
  %c3 = constant 3 : index
  %c0 = constant 0 : index
  %c512 = constant 512 : index
  %c96 = constant 96 : index
  %c48 = constant 48 : index
  %c112 = constant 112 : index
  %c1024 = constant 1024 : index
  %c2 = constant 2 : index
  %c1 = constant 1 : index
  %device = hal.ex.shared_device : !hal.device
  %allocator = hal.device.allocator<%device : !hal.device> : !hal.allocator
  %buffer = hal.allocator.allocate<%allocator : !hal.allocator> type("HostVisible|DeviceVisible|DeviceLocal") usage("Transfer|Mapping|Dispatch") : !hal.buffer{%c40}
  %0 = hal.variable.load @_const_pool_storage_buffer : !hal.buffer
  %buffer_0 = hal.allocator.allocate<%allocator : !hal.allocator> type("DeviceVisible|DeviceLocal") usage("Transfer|Dispatch") : !hal.buffer{%c1024}
  %cmd = hal.command_buffer.create device(%device : !hal.device) mode("OneShot|AllowInlineExecution") categories("Transfer|Dispatch") : !hal.command_buffer
  hal.command_buffer.begin<%cmd : !hal.command_buffer>
  %1 = hal.variable.load @_executable_layout_0 : !hal.executable_layout
  hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%1 : !hal.executable_layout)[%c0] bindings([
    %c0 = (%0 : !hal.buffer)[%c512, %c401408], 
    %c1 = (%arg0 : !hal.buffer)[%c0, %c3136], 
    %c2 = (%buffer_0 : !hal.buffer)[%c0, %c512]
  ])
  %2 = hal.variable.load @_device_match_id_0 : i1
  cond_br %2, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %3 = hal.variable.load @_executable_mnist_linked_llvm_aot : !hal.executable
  hal.command_buffer.dispatch<%cmd : !hal.command_buffer> target(%3 : !hal.executable)[0] workgroups([%c2, %c1, %c1])
  hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
  hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%1 : !hal.executable_layout)[%c0] bindings([
    %c0 = (%0 : !hal.buffer)[%c0, %c512], 
    %c1 = (%buffer_0 : !hal.buffer)[%c0, %c512], 
    %c2 = (%buffer_0 : !hal.buffer)[%c512, %c512]
  ])
  hal.command_buffer.dispatch<%cmd : !hal.command_buffer> target(%3 : !hal.executable)[1] workgroups([%c1, %c1, %c1])
  hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
  hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%1 : !hal.executable_layout)[%c0] bindings([
    %c0 = (%0 : !hal.buffer)[%c401920, %c5120], 
    %c1 = (%buffer_0 : !hal.buffer)[%c512, %c512], 
    %c2 = (%buffer_0 : !hal.buffer)[%c0, %c40]
  ])
  hal.command_buffer.dispatch<%cmd : !hal.command_buffer> target(%3 : !hal.executable)[2] workgroups([%c1, %c1, %c1])
  hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
  %4 = hal.variable.load @_executable_layout_1 : !hal.executable_layout
  hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%4 : !hal.executable_layout)[%c0] bindings([
    %c0 = (%buffer_0 : !hal.buffer)[%c0, %c40], 
    %c1 = (%buffer_0 : !hal.buffer)[%c48, %c40]
  ])
  hal.command_buffer.dispatch<%cmd : !hal.command_buffer> target(%3 : !hal.executable)[3] workgroups([%c1, %c1, %c1])
  hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
  hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%4 : !hal.executable_layout)[%c0] bindings([
    %c0 = (%buffer_0 : !hal.buffer)[%c48, %c40], 
    %c1 = (%buffer_0 : !hal.buffer)[%c96, %c4]
  ])
  hal.command_buffer.dispatch<%cmd : !hal.command_buffer> target(%3 : !hal.executable)[4] workgroups([%c1, %c1, %c1])
  hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
  hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%1 : !hal.executable_layout)[%c0] bindings([
    %c0 = (%buffer_0 : !hal.buffer)[%c0, %c40], 
    %c1 = (%buffer_0 : !hal.buffer)[%c96, %c4], 
    %c2 = (%buffer_0 : !hal.buffer)[%c48, %c40]
  ])
  hal.command_buffer.dispatch<%cmd : !hal.command_buffer> target(%3 : !hal.executable)[5] workgroups([%c1, %c1, %c1])
  hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
  hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%4 : !hal.executable_layout)[%c0] bindings([
    %c0 = (%buffer_0 : !hal.buffer)[%c48, %c40], 
    %c1 = (%buffer_0 : !hal.buffer)[%c112, %c4]
  ])
  hal.command_buffer.dispatch<%cmd : !hal.command_buffer> target(%3 : !hal.executable)[6] workgroups([%c1, %c1, %c1])
  hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
  %5 = hal.variable.load @_executable_layout_2 : !hal.executable_layout
  hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%5 : !hal.executable_layout)[%c0] bindings([
    %c0 = (%buffer_0 : !hal.buffer)[%c0, %c40], 
    %c1 = (%buffer_0 : !hal.buffer)[%c96, %c4], 
    %c2 = (%buffer_0 : !hal.buffer)[%c112, %c4], 
    %c3 = (%buffer : !hal.buffer)[%c0, %c40]
  ])
  hal.command_buffer.dispatch<%cmd : !hal.command_buffer> target(%3 : !hal.executable)[7] workgroups([%c1, %c1, %c1])
  hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
  hal.command_buffer.end<%cmd : !hal.command_buffer>
  hal.ex.submit_and_wait %device, %cmd
  return %buffer : !hal.buffer
^bb2:  // pred: ^bb0
  iree.unreachable "device not supported in the compiled configuration"
}

// *** IR Dump After LoopInvariantCodeMotion ***
func @predict(%arg0: !hal.buffer) -> !hal.buffer attributes {noinline} {
  %c3136 = constant 3136 : index
  %c401408 = constant 401408 : index
  %c401920 = constant 401920 : index
  %c5120 = constant 5120 : index
  %c40 = constant 40 : index
  %c4 = constant 4 : index
  %c3 = constant 3 : index
  %c0 = constant 0 : index
  %c512 = constant 512 : index
  %c96 = constant 96 : index
  %c48 = constant 48 : index
  %c112 = constant 112 : index
  %c1024 = constant 1024 : index
  %c2 = constant 2 : index
  %c1 = constant 1 : index
  %device = hal.ex.shared_device : !hal.device
  %allocator = hal.device.allocator<%device : !hal.device> : !hal.allocator
  %buffer = hal.allocator.allocate<%allocator : !hal.allocator> type("HostVisible|DeviceVisible|DeviceLocal") usage("Transfer|Mapping|Dispatch") : !hal.buffer{%c40}
  %0 = hal.variable.load @_const_pool_storage_buffer : !hal.buffer
  %buffer_0 = hal.allocator.allocate<%allocator : !hal.allocator> type("DeviceVisible|DeviceLocal") usage("Transfer|Dispatch") : !hal.buffer{%c1024}
  %cmd = hal.command_buffer.create device(%device : !hal.device) mode("OneShot|AllowInlineExecution") categories("Transfer|Dispatch") : !hal.command_buffer
  hal.command_buffer.begin<%cmd : !hal.command_buffer>
  %1 = hal.variable.load @_executable_layout_0 : !hal.executable_layout
  hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%1 : !hal.executable_layout)[%c0] bindings([
    %c0 = (%0 : !hal.buffer)[%c512, %c401408], 
    %c1 = (%arg0 : !hal.buffer)[%c0, %c3136], 
    %c2 = (%buffer_0 : !hal.buffer)[%c0, %c512]
  ])
  %2 = hal.variable.load @_device_match_id_0 : i1
  cond_br %2, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %3 = hal.variable.load @_executable_mnist_linked_llvm_aot : !hal.executable
  hal.command_buffer.dispatch<%cmd : !hal.command_buffer> target(%3 : !hal.executable)[0] workgroups([%c2, %c1, %c1])
  hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
  hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%1 : !hal.executable_layout)[%c0] bindings([
    %c0 = (%0 : !hal.buffer)[%c0, %c512], 
    %c1 = (%buffer_0 : !hal.buffer)[%c0, %c512], 
    %c2 = (%buffer_0 : !hal.buffer)[%c512, %c512]
  ])
  hal.command_buffer.dispatch<%cmd : !hal.command_buffer> target(%3 : !hal.executable)[1] workgroups([%c1, %c1, %c1])
  hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
  hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%1 : !hal.executable_layout)[%c0] bindings([
    %c0 = (%0 : !hal.buffer)[%c401920, %c5120], 
    %c1 = (%buffer_0 : !hal.buffer)[%c512, %c512], 
    %c2 = (%buffer_0 : !hal.buffer)[%c0, %c40]
  ])
  hal.command_buffer.dispatch<%cmd : !hal.command_buffer> target(%3 : !hal.executable)[2] workgroups([%c1, %c1, %c1])
  hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
  %4 = hal.variable.load @_executable_layout_1 : !hal.executable_layout
  hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%4 : !hal.executable_layout)[%c0] bindings([
    %c0 = (%buffer_0 : !hal.buffer)[%c0, %c40], 
    %c1 = (%buffer_0 : !hal.buffer)[%c48, %c40]
  ])
  hal.command_buffer.dispatch<%cmd : !hal.command_buffer> target(%3 : !hal.executable)[3] workgroups([%c1, %c1, %c1])
  hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
  hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%4 : !hal.executable_layout)[%c0] bindings([
    %c0 = (%buffer_0 : !hal.buffer)[%c48, %c40], 
    %c1 = (%buffer_0 : !hal.buffer)[%c96, %c4]
  ])
  hal.command_buffer.dispatch<%cmd : !hal.command_buffer> target(%3 : !hal.executable)[4] workgroups([%c1, %c1, %c1])
  hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
  hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%1 : !hal.executable_layout)[%c0] bindings([
    %c0 = (%buffer_0 : !hal.buffer)[%c0, %c40], 
    %c1 = (%buffer_0 : !hal.buffer)[%c96, %c4], 
    %c2 = (%buffer_0 : !hal.buffer)[%c48, %c40]
  ])
  hal.command_buffer.dispatch<%cmd : !hal.command_buffer> target(%3 : !hal.executable)[5] workgroups([%c1, %c1, %c1])
  hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
  hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%4 : !hal.executable_layout)[%c0] bindings([
    %c0 = (%buffer_0 : !hal.buffer)[%c48, %c40], 
    %c1 = (%buffer_0 : !hal.buffer)[%c112, %c4]
  ])
  hal.command_buffer.dispatch<%cmd : !hal.command_buffer> target(%3 : !hal.executable)[6] workgroups([%c1, %c1, %c1])
  hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
  %5 = hal.variable.load @_executable_layout_2 : !hal.executable_layout
  hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%5 : !hal.executable_layout)[%c0] bindings([
    %c0 = (%buffer_0 : !hal.buffer)[%c0, %c40], 
    %c1 = (%buffer_0 : !hal.buffer)[%c96, %c4], 
    %c2 = (%buffer_0 : !hal.buffer)[%c112, %c4], 
    %c3 = (%buffer : !hal.buffer)[%c0, %c40]
  ])
  hal.command_buffer.dispatch<%cmd : !hal.command_buffer> target(%3 : !hal.executable)[7] workgroups([%c1, %c1, %c1])
  hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
  hal.command_buffer.end<%cmd : !hal.command_buffer>
  hal.ex.submit_and_wait %device, %cmd
  return %buffer : !hal.buffer
^bb2:  // pred: ^bb0
  iree.unreachable "device not supported in the compiled configuration"
}

// *** IR Dump After Canonicalizer ***
func @predict$async(%arg0: !hal.semaphore, %arg1: index, %arg2: !hal.buffer_view, %arg3: !hal.semaphore, %arg4: index) -> !hal.buffer_view attributes {iree.module.export = "predict$async"} {
  %c1 = constant 1 : index
  %c10 = constant 10 : index
  %c50331680_i32 = constant 50331680 : i32
  %0 = hal.semaphore.await<%arg0 : !hal.semaphore> until(%arg1) : i32
  hal.check_success %0, "semaphore wait failed"
  %buffer = hal.buffer_view.buffer %arg2 : !hal.buffer
  %1 = call @predict(%buffer) : (!hal.buffer) -> !hal.buffer
  %view = hal.buffer_view.create %1, element_type = %c50331680_i32, shape = [%c1, %c10] : !hal.buffer -> !hal.buffer_view
  hal.semaphore.signal<%arg3 : !hal.semaphore> value(%arg4)
  return %view : !hal.buffer_view
}

// *** IR Dump After LoopCoalescing ***
func @predict$async(%arg0: !hal.semaphore, %arg1: index, %arg2: !hal.buffer_view, %arg3: !hal.semaphore, %arg4: index) -> !hal.buffer_view attributes {iree.module.export = "predict$async"} {
  %c1 = constant 1 : index
  %c10 = constant 10 : index
  %c50331680_i32 = constant 50331680 : i32
  %0 = hal.semaphore.await<%arg0 : !hal.semaphore> until(%arg1) : i32
  hal.check_success %0, "semaphore wait failed"
  %buffer = hal.buffer_view.buffer %arg2 : !hal.buffer
  %1 = call @predict(%buffer) : (!hal.buffer) -> !hal.buffer
  %view = hal.buffer_view.create %1, element_type = %c50331680_i32, shape = [%c1, %c10] : !hal.buffer -> !hal.buffer_view
  hal.semaphore.signal<%arg3 : !hal.semaphore> value(%arg4)
  return %view : !hal.buffer_view
}

// *** IR Dump After AffineLoopFusion ***
func @predict$async(%arg0: !hal.semaphore, %arg1: index, %arg2: !hal.buffer_view, %arg3: !hal.semaphore, %arg4: index) -> !hal.buffer_view attributes {iree.module.export = "predict$async"} {
  %c1 = constant 1 : index
  %c10 = constant 10 : index
  %c50331680_i32 = constant 50331680 : i32
  %0 = hal.semaphore.await<%arg0 : !hal.semaphore> until(%arg1) : i32
  hal.check_success %0, "semaphore wait failed"
  %buffer = hal.buffer_view.buffer %arg2 : !hal.buffer
  %1 = call @predict(%buffer) : (!hal.buffer) -> !hal.buffer
  %view = hal.buffer_view.create %1, element_type = %c50331680_i32, shape = [%c1, %c10] : !hal.buffer -> !hal.buffer_view
  hal.semaphore.signal<%arg3 : !hal.semaphore> value(%arg4)
  return %view : !hal.buffer_view
}

// *** IR Dump After LoopInvariantCodeMotion ***
func @predict$async(%arg0: !hal.semaphore, %arg1: index, %arg2: !hal.buffer_view, %arg3: !hal.semaphore, %arg4: index) -> !hal.buffer_view attributes {iree.module.export = "predict$async"} {
  %c1 = constant 1 : index
  %c10 = constant 10 : index
  %c50331680_i32 = constant 50331680 : i32
  %0 = hal.semaphore.await<%arg0 : !hal.semaphore> until(%arg1) : i32
  hal.check_success %0, "semaphore wait failed"
  %buffer = hal.buffer_view.buffer %arg2 : !hal.buffer
  %1 = call @predict(%buffer) : (!hal.buffer) -> !hal.buffer
  %view = hal.buffer_view.create %1, element_type = %c50331680_i32, shape = [%c1, %c10] : !hal.buffer -> !hal.buffer_view
  hal.semaphore.signal<%arg3 : !hal.semaphore> value(%arg4)
  return %view : !hal.buffer_view
}

// *** IR Dump After Canonicalizer ***
func @predict$sync(%arg0: !hal.buffer_view) -> !hal.buffer_view attributes {iree.abi.stub, iree.module.export = "predict", iree.reflection = {abi = "sip", abiv = 1 : i32, f = "I15!B11!d1d28d28d1R9!B6!d1d10", fv = "1", sip = "I8!S5!k0_0R3!_0"}} {
  %c0 = constant 0 : index
  %c1 = constant 1 : index
  %device = hal.ex.shared_device : !hal.device
  %semaphore = hal.semaphore.create device(%device : !hal.device) initial(%c0) : !hal.semaphore
  %0 = call @predict$async(%semaphore, %c0, %arg0, %semaphore, %c1) : (!hal.semaphore, index, !hal.buffer_view, !hal.semaphore, index) -> !hal.buffer_view
  %1 = hal.semaphore.await<%semaphore : !hal.semaphore> until(%c1) : i32
  hal.check_success %1, "semaphore wait failed"
  return %0 : !hal.buffer_view
}

// *** IR Dump After LoopCoalescing ***
func @predict$sync(%arg0: !hal.buffer_view) -> !hal.buffer_view attributes {iree.abi.stub, iree.module.export = "predict", iree.reflection = {abi = "sip", abiv = 1 : i32, f = "I15!B11!d1d28d28d1R9!B6!d1d10", fv = "1", sip = "I8!S5!k0_0R3!_0"}} {
  %c0 = constant 0 : index
  %c1 = constant 1 : index
  %device = hal.ex.shared_device : !hal.device
  %semaphore = hal.semaphore.create device(%device : !hal.device) initial(%c0) : !hal.semaphore
  %0 = call @predict$async(%semaphore, %c0, %arg0, %semaphore, %c1) : (!hal.semaphore, index, !hal.buffer_view, !hal.semaphore, index) -> !hal.buffer_view
  %1 = hal.semaphore.await<%semaphore : !hal.semaphore> until(%c1) : i32
  hal.check_success %1, "semaphore wait failed"
  return %0 : !hal.buffer_view
}

// *** IR Dump After AffineLoopFusion ***
func @predict$sync(%arg0: !hal.buffer_view) -> !hal.buffer_view attributes {iree.abi.stub, iree.module.export = "predict", iree.reflection = {abi = "sip", abiv = 1 : i32, f = "I15!B11!d1d28d28d1R9!B6!d1d10", fv = "1", sip = "I8!S5!k0_0R3!_0"}} {
  %c0 = constant 0 : index
  %c1 = constant 1 : index
  %device = hal.ex.shared_device : !hal.device
  %semaphore = hal.semaphore.create device(%device : !hal.device) initial(%c0) : !hal.semaphore
  %0 = call @predict$async(%semaphore, %c0, %arg0, %semaphore, %c1) : (!hal.semaphore, index, !hal.buffer_view, !hal.semaphore, index) -> !hal.buffer_view
  %1 = hal.semaphore.await<%semaphore : !hal.semaphore> until(%c1) : i32
  hal.check_success %1, "semaphore wait failed"
  return %0 : !hal.buffer_view
}

// *** IR Dump After LoopInvariantCodeMotion ***
func @predict$sync(%arg0: !hal.buffer_view) -> !hal.buffer_view attributes {iree.abi.stub, iree.module.export = "predict", iree.reflection = {abi = "sip", abiv = 1 : i32, f = "I15!B11!d1d28d28d1R9!B6!d1d10", fv = "1", sip = "I8!S5!k0_0R3!_0"}} {
  %c0 = constant 0 : index
  %c1 = constant 1 : index
  %device = hal.ex.shared_device : !hal.device
  %semaphore = hal.semaphore.create device(%device : !hal.device) initial(%c0) : !hal.semaphore
  %0 = call @predict$async(%semaphore, %c0, %arg0, %semaphore, %c1) : (!hal.semaphore, index, !hal.buffer_view, !hal.semaphore, index) -> !hal.buffer_view
  %1 = hal.semaphore.await<%semaphore : !hal.semaphore> until(%c1) : i32
  hal.check_success %1, "semaphore wait failed"
  return %0 : !hal.buffer_view
}

// *** IR Dump After Canonicalizer ***
module  {
  hal.variable @_device_match_id_0 init(@_device_match_id_0_initializer) : i1 attributes {sym_visibility = "private"}
  func private @_device_match_id_0_initializer() -> i1 {
    %device = hal.ex.shared_device : !hal.device
    %0 = hal.device.match.id<%device : !hal.device> pattern("dylib*") : i1
    return %0 : i1
  }
  hal.variable @_descriptor_set_layout_0 init(@_descriptor_set_layout_0_initializer) : !hal.descriptor_set_layout attributes {sym_visibility = "private"}
  func private @_descriptor_set_layout_0_initializer() -> !hal.descriptor_set_layout {
    %device = hal.ex.shared_device : !hal.device
    %descriptor_set_layout = hal.descriptor_set_layout.create device(%device : !hal.device) usage(PushOnly) bindings([#hal.descriptor_set_layout_binding<0, "StorageBuffer", R>, #hal.descriptor_set_layout_binding<1, "StorageBuffer", R>, #hal.descriptor_set_layout_binding<2, "StorageBuffer", DW>]) : !hal.descriptor_set_layout
    return %descriptor_set_layout : !hal.descriptor_set_layout
  }
  hal.variable @_executable_layout_0 init(@_executable_layout_0_initializer) : !hal.executable_layout attributes {sym_visibility = "private"}
  func private @_executable_layout_0_initializer() -> !hal.executable_layout {
    %0 = hal.variable.load @_descriptor_set_layout_0 : !hal.descriptor_set_layout
    %device = hal.ex.shared_device : !hal.device
    %executable_layout = hal.executable_layout.create device(%device : !hal.device) push_constants(0) layouts([%0]) : !hal.executable_layout
    return %executable_layout : !hal.executable_layout
  }
  hal.variable @_descriptor_set_layout_1 init(@_descriptor_set_layout_1_initializer) : !hal.descriptor_set_layout attributes {sym_visibility = "private"}
  func private @_descriptor_set_layout_1_initializer() -> !hal.descriptor_set_layout {
    %device = hal.ex.shared_device : !hal.device
    %descriptor_set_layout = hal.descriptor_set_layout.create device(%device : !hal.device) usage(PushOnly) bindings([#hal.descriptor_set_layout_binding<0, "StorageBuffer", R>, #hal.descriptor_set_layout_binding<1, "StorageBuffer", DW>]) : !hal.descriptor_set_layout
    return %descriptor_set_layout : !hal.descriptor_set_layout
  }
  hal.variable @_executable_layout_1 init(@_executable_layout_1_initializer) : !hal.executable_layout attributes {sym_visibility = "private"}
  func private @_executable_layout_1_initializer() -> !hal.executable_layout {
    %0 = hal.variable.load @_descriptor_set_layout_1 : !hal.descriptor_set_layout
    %device = hal.ex.shared_device : !hal.device
    %executable_layout = hal.executable_layout.create device(%device : !hal.device) push_constants(0) layouts([%0]) : !hal.executable_layout
    return %executable_layout : !hal.executable_layout
  }
  hal.variable @_descriptor_set_layout_2 init(@_descriptor_set_layout_2_initializer) : !hal.descriptor_set_layout attributes {sym_visibility = "private"}
  func private @_descriptor_set_layout_2_initializer() -> !hal.descriptor_set_layout {
    %device = hal.ex.shared_device : !hal.device
    %descriptor_set_layout = hal.descriptor_set_layout.create device(%device : !hal.device) usage(PushOnly) bindings([#hal.descriptor_set_layout_binding<0, "StorageBuffer", R>, #hal.descriptor_set_layout_binding<1, "StorageBuffer", R>, #hal.descriptor_set_layout_binding<2, "StorageBuffer", R>, #hal.descriptor_set_layout_binding<3, "StorageBuffer", DW>]) : !hal.descriptor_set_layout
    return %descriptor_set_layout : !hal.descriptor_set_layout
  }
  hal.variable @_executable_layout_2 init(@_executable_layout_2_initializer) : !hal.executable_layout attributes {sym_visibility = "private"}
  func private @_executable_layout_2_initializer() -> !hal.executable_layout {
    %0 = hal.variable.load @_descriptor_set_layout_2 : !hal.descriptor_set_layout
    %device = hal.ex.shared_device : !hal.device
    %executable_layout = hal.executable_layout.create device(%device : !hal.device) push_constants(0) layouts([%0]) : !hal.executable_layout
    return %executable_layout : !hal.executable_layout
  }
  hal.variable @_executable_mnist_linked_llvm_aot init(@_executable_mnist_linked_llvm_aot_initializer) : !hal.executable attributes {sym_visibility = "private"}
  func private @_executable_mnist_linked_llvm_aot_initializer() -> !hal.executable {
    %device = hal.ex.shared_device : !hal.device
    %0 = hal.variable.load @_device_match_id_0 : i1
    cond_br %0, ^bb1, ^bb2
  ^bb1:  // pred: ^bb0
    %1 = hal.variable.load @_executable_layout_0 : !hal.executable_layout
    %2 = hal.variable.load @_executable_layout_1 : !hal.executable_layout
    %3 = hal.variable.load @_executable_layout_2 : !hal.executable_layout
    %exe = hal.executable.create device(%device : !hal.device) target(@mnist_linked_llvm_aot::@llvm_aot) layouts([%1, %1, %1, %2, %2, %1, %2, %3]) : !hal.executable
    br ^bb3(%exe : !hal.executable)
  ^bb2:  // pred: ^bb0
    %4 = iree.null : !hal.executable
    br ^bb3(%4 : !hal.executable)
  ^bb3(%5: !hal.executable):  // 2 preds: ^bb1, ^bb2
    return %5 : !hal.executable
  }
  hal.executable @mnist_linked_llvm_aot attributes {sym_visibility = "private"} {
    hal.interface @io_0 {
      hal.interface.binding @s0b0_ro_constant, set=0, binding=0, type="StorageBuffer", access="Read"
      hal.interface.binding @s0b1_ro_external, set=0, binding=1, type="StorageBuffer", access="Read"
      hal.interface.binding @s0b2_xw_external, set=0, binding=2, type="StorageBuffer", access="Write|Discard"
    }
    hal.interface @io_1 {
      hal.interface.binding @s0b0_ro_external, set=0, binding=0, type="StorageBuffer", access="Read"
      hal.interface.binding @s0b1_xw_external, set=0, binding=1, type="StorageBuffer", access="Write|Discard"
    }
    hal.interface @io_2 {
      hal.interface.binding @s0b0_ro_external, set=0, binding=0, type="StorageBuffer", access="Read"
      hal.interface.binding @s0b1_ro_external, set=0, binding=1, type="StorageBuffer", access="Read"
      hal.interface.binding @s0b2_xw_external, set=0, binding=2, type="StorageBuffer", access="Write|Discard"
    }
    hal.interface @io_3 {
      hal.interface.binding @s0b0_ro_external, set=0, binding=0, type="StorageBuffer", access="Read"
      hal.interface.binding @s0b1_ro_external, set=0, binding=1, type="StorageBuffer", access="Read"
      hal.interface.binding @s0b2_ro_external, set=0, binding=2, type="StorageBuffer", access="Read"
      hal.interface.binding @s0b3_xw_external, set=0, binding=3, type="StorageBuffer", access="Write|Discard"
    }
    hal.executable.binary @llvm_aot attributes {data = opaque<"_", "0xDEADBEEF"> : vector<136794xi8>, format = "DLIB", mime_type = "application/x-flatbuffers"} {
    }
  }
  hal.constant_pool @_const_pool attributes {buffer_constraints = #hal.buffer_constraints<max_allocation_size = 1073741824, min_buffer_offset_alignment = 16, max_buffer_range = 1073741824, min_buffer_range_alignment = 16>, sym_visibility = "private"} {
    hal.constant_storage @_storage = opaque<"_", "0xDEADBEEF"> : vector<407040xi8> attributes {sym_visibility = "nested"}
  }
  hal.variable @_const_pool_storage_buffer init(@_const_pool_storage_buffer_initializer) : !hal.buffer attributes {sym_visibility = "private"}
  func private @_const_pool_storage_buffer_initializer() -> !hal.buffer {
    %c0 = constant 0 : index
    %c407040 = constant 407040 : index
    %device = hal.ex.shared_device : !hal.device
    %allocator = hal.device.allocator<%device : !hal.device> : !hal.allocator
    %storage = hal.constant_storage.lookup @_const_pool::@_storage : !iree.byte_buffer
    %mapped = hal.allocator.map<%allocator : !hal.allocator> source(%storage : !iree.byte_buffer)[%c0, %c407040] type("HostVisible|DeviceVisible|DeviceLocal") usage("Constant|Transfer|Mapping|Dispatch") : !hal.buffer
    return %mapped : !hal.buffer
  }
  func @predict(%arg0: !hal.buffer) -> !hal.buffer attributes {noinline} {
    %c3136 = constant 3136 : index
    %c401408 = constant 401408 : index
    %c401920 = constant 401920 : index
    %c5120 = constant 5120 : index
    %c40 = constant 40 : index
    %c4 = constant 4 : index
    %c3 = constant 3 : index
    %c0 = constant 0 : index
    %c512 = constant 512 : index
    %c96 = constant 96 : index
    %c48 = constant 48 : index
    %c112 = constant 112 : index
    %c1024 = constant 1024 : index
    %c2 = constant 2 : index
    %c1 = constant 1 : index
    %device = hal.ex.shared_device : !hal.device
    %allocator = hal.device.allocator<%device : !hal.device> : !hal.allocator
    %buffer = hal.allocator.allocate<%allocator : !hal.allocator> type("HostVisible|DeviceVisible|DeviceLocal") usage("Transfer|Mapping|Dispatch") : !hal.buffer{%c40}
    %0 = hal.variable.load @_const_pool_storage_buffer : !hal.buffer
    %buffer_0 = hal.allocator.allocate<%allocator : !hal.allocator> type("DeviceVisible|DeviceLocal") usage("Transfer|Dispatch") : !hal.buffer{%c1024}
    %cmd = hal.command_buffer.create device(%device : !hal.device) mode("OneShot|AllowInlineExecution") categories("Transfer|Dispatch") : !hal.command_buffer
    hal.command_buffer.begin<%cmd : !hal.command_buffer>
    %1 = hal.variable.load @_executable_layout_0 : !hal.executable_layout
    hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%1 : !hal.executable_layout)[%c0] bindings([
      %c0 = (%0 : !hal.buffer)[%c512, %c401408], 
      %c1 = (%arg0 : !hal.buffer)[%c0, %c3136], 
      %c2 = (%buffer_0 : !hal.buffer)[%c0, %c512]
    ])
    %2 = hal.variable.load @_device_match_id_0 : i1
    cond_br %2, ^bb1, ^bb2
  ^bb1:  // pred: ^bb0
    %3 = hal.variable.load @_executable_mnist_linked_llvm_aot : !hal.executable
    hal.command_buffer.dispatch<%cmd : !hal.command_buffer> target(%3 : !hal.executable)[0] workgroups([%c2, %c1, %c1])
    hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
    hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%1 : !hal.executable_layout)[%c0] bindings([
      %c0 = (%0 : !hal.buffer)[%c0, %c512], 
      %c1 = (%buffer_0 : !hal.buffer)[%c0, %c512], 
      %c2 = (%buffer_0 : !hal.buffer)[%c512, %c512]
    ])
    hal.command_buffer.dispatch<%cmd : !hal.command_buffer> target(%3 : !hal.executable)[1] workgroups([%c1, %c1, %c1])
    hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
    hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%1 : !hal.executable_layout)[%c0] bindings([
      %c0 = (%0 : !hal.buffer)[%c401920, %c5120], 
      %c1 = (%buffer_0 : !hal.buffer)[%c512, %c512], 
      %c2 = (%buffer_0 : !hal.buffer)[%c0, %c40]
    ])
    hal.command_buffer.dispatch<%cmd : !hal.command_buffer> target(%3 : !hal.executable)[2] workgroups([%c1, %c1, %c1])
    hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
    %4 = hal.variable.load @_executable_layout_1 : !hal.executable_layout
    hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%4 : !hal.executable_layout)[%c0] bindings([
      %c0 = (%buffer_0 : !hal.buffer)[%c0, %c40], 
      %c1 = (%buffer_0 : !hal.buffer)[%c48, %c40]
    ])
    hal.command_buffer.dispatch<%cmd : !hal.command_buffer> target(%3 : !hal.executable)[3] workgroups([%c1, %c1, %c1])
    hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
    hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%4 : !hal.executable_layout)[%c0] bindings([
      %c0 = (%buffer_0 : !hal.buffer)[%c48, %c40], 
      %c1 = (%buffer_0 : !hal.buffer)[%c96, %c4]
    ])
    hal.command_buffer.dispatch<%cmd : !hal.command_buffer> target(%3 : !hal.executable)[4] workgroups([%c1, %c1, %c1])
    hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
    hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%1 : !hal.executable_layout)[%c0] bindings([
      %c0 = (%buffer_0 : !hal.buffer)[%c0, %c40], 
      %c1 = (%buffer_0 : !hal.buffer)[%c96, %c4], 
      %c2 = (%buffer_0 : !hal.buffer)[%c48, %c40]
    ])
    hal.command_buffer.dispatch<%cmd : !hal.command_buffer> target(%3 : !hal.executable)[5] workgroups([%c1, %c1, %c1])
    hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
    hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%4 : !hal.executable_layout)[%c0] bindings([
      %c0 = (%buffer_0 : !hal.buffer)[%c48, %c40], 
      %c1 = (%buffer_0 : !hal.buffer)[%c112, %c4]
    ])
    hal.command_buffer.dispatch<%cmd : !hal.command_buffer> target(%3 : !hal.executable)[6] workgroups([%c1, %c1, %c1])
    hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
    %5 = hal.variable.load @_executable_layout_2 : !hal.executable_layout
    hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%5 : !hal.executable_layout)[%c0] bindings([
      %c0 = (%buffer_0 : !hal.buffer)[%c0, %c40], 
      %c1 = (%buffer_0 : !hal.buffer)[%c96, %c4], 
      %c2 = (%buffer_0 : !hal.buffer)[%c112, %c4], 
      %c3 = (%buffer : !hal.buffer)[%c0, %c40]
    ])
    hal.command_buffer.dispatch<%cmd : !hal.command_buffer> target(%3 : !hal.executable)[7] workgroups([%c1, %c1, %c1])
    hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
    hal.command_buffer.end<%cmd : !hal.command_buffer>
    hal.ex.submit_and_wait %device, %cmd
    return %buffer : !hal.buffer
  ^bb2:  // pred: ^bb0
    iree.unreachable "device not supported in the compiled configuration"
  }
  func @predict$async(%arg0: !hal.semaphore, %arg1: index, %arg2: !hal.buffer_view, %arg3: !hal.semaphore, %arg4: index) -> !hal.buffer_view attributes {iree.module.export = "predict$async"} {
    %c1 = constant 1 : index
    %c10 = constant 10 : index
    %c50331680_i32 = constant 50331680 : i32
    %0 = hal.semaphore.await<%arg0 : !hal.semaphore> until(%arg1) : i32
    hal.check_success %0, "semaphore wait failed"
    %buffer = hal.buffer_view.buffer %arg2 : !hal.buffer
    %1 = call @predict(%buffer) : (!hal.buffer) -> !hal.buffer
    %view = hal.buffer_view.create %1, element_type = %c50331680_i32, shape = [%c1, %c10] : !hal.buffer -> !hal.buffer_view
    hal.semaphore.signal<%arg3 : !hal.semaphore> value(%arg4)
    return %view : !hal.buffer_view
  }
  func @predict$sync(%arg0: !hal.buffer_view) -> !hal.buffer_view attributes {iree.abi.stub, iree.module.export = "predict", iree.reflection = {abi = "sip", abiv = 1 : i32, f = "I15!B11!d1d28d28d1R9!B6!d1d10", fv = "1", sip = "I8!S5!k0_0R3!_0"}} {
    %c0 = constant 0 : index
    %c1 = constant 1 : index
    %device = hal.ex.shared_device : !hal.device
    %semaphore = hal.semaphore.create device(%device : !hal.device) initial(%c0) : !hal.semaphore
    %0 = call @predict$async(%semaphore, %c0, %arg0, %semaphore, %c1) : (!hal.semaphore, index, !hal.buffer_view, !hal.semaphore, index) -> !hal.buffer_view
    %1 = hal.semaphore.await<%semaphore : !hal.semaphore> until(%c1) : i32
    hal.check_success %1, "semaphore wait failed"
    return %0 : !hal.buffer_view
  }
}


// *** IR Dump After CSE ***
module  {
  hal.variable @_device_match_id_0 init(@_device_match_id_0_initializer) : i1 attributes {sym_visibility = "private"}
  func private @_device_match_id_0_initializer() -> i1 {
    %device = hal.ex.shared_device : !hal.device
    %0 = hal.device.match.id<%device : !hal.device> pattern("dylib*") : i1
    return %0 : i1
  }
  hal.variable @_descriptor_set_layout_0 init(@_descriptor_set_layout_0_initializer) : !hal.descriptor_set_layout attributes {sym_visibility = "private"}
  func private @_descriptor_set_layout_0_initializer() -> !hal.descriptor_set_layout {
    %device = hal.ex.shared_device : !hal.device
    %descriptor_set_layout = hal.descriptor_set_layout.create device(%device : !hal.device) usage(PushOnly) bindings([#hal.descriptor_set_layout_binding<0, "StorageBuffer", R>, #hal.descriptor_set_layout_binding<1, "StorageBuffer", R>, #hal.descriptor_set_layout_binding<2, "StorageBuffer", DW>]) : !hal.descriptor_set_layout
    return %descriptor_set_layout : !hal.descriptor_set_layout
  }
  hal.variable @_executable_layout_0 init(@_executable_layout_0_initializer) : !hal.executable_layout attributes {sym_visibility = "private"}
  func private @_executable_layout_0_initializer() -> !hal.executable_layout {
    %0 = hal.variable.load @_descriptor_set_layout_0 : !hal.descriptor_set_layout
    %device = hal.ex.shared_device : !hal.device
    %executable_layout = hal.executable_layout.create device(%device : !hal.device) push_constants(0) layouts([%0]) : !hal.executable_layout
    return %executable_layout : !hal.executable_layout
  }
  hal.variable @_descriptor_set_layout_1 init(@_descriptor_set_layout_1_initializer) : !hal.descriptor_set_layout attributes {sym_visibility = "private"}
  func private @_descriptor_set_layout_1_initializer() -> !hal.descriptor_set_layout {
    %device = hal.ex.shared_device : !hal.device
    %descriptor_set_layout = hal.descriptor_set_layout.create device(%device : !hal.device) usage(PushOnly) bindings([#hal.descriptor_set_layout_binding<0, "StorageBuffer", R>, #hal.descriptor_set_layout_binding<1, "StorageBuffer", DW>]) : !hal.descriptor_set_layout
    return %descriptor_set_layout : !hal.descriptor_set_layout
  }
  hal.variable @_executable_layout_1 init(@_executable_layout_1_initializer) : !hal.executable_layout attributes {sym_visibility = "private"}
  func private @_executable_layout_1_initializer() -> !hal.executable_layout {
    %0 = hal.variable.load @_descriptor_set_layout_1 : !hal.descriptor_set_layout
    %device = hal.ex.shared_device : !hal.device
    %executable_layout = hal.executable_layout.create device(%device : !hal.device) push_constants(0) layouts([%0]) : !hal.executable_layout
    return %executable_layout : !hal.executable_layout
  }
  hal.variable @_descriptor_set_layout_2 init(@_descriptor_set_layout_2_initializer) : !hal.descriptor_set_layout attributes {sym_visibility = "private"}
  func private @_descriptor_set_layout_2_initializer() -> !hal.descriptor_set_layout {
    %device = hal.ex.shared_device : !hal.device
    %descriptor_set_layout = hal.descriptor_set_layout.create device(%device : !hal.device) usage(PushOnly) bindings([#hal.descriptor_set_layout_binding<0, "StorageBuffer", R>, #hal.descriptor_set_layout_binding<1, "StorageBuffer", R>, #hal.descriptor_set_layout_binding<2, "StorageBuffer", R>, #hal.descriptor_set_layout_binding<3, "StorageBuffer", DW>]) : !hal.descriptor_set_layout
    return %descriptor_set_layout : !hal.descriptor_set_layout
  }
  hal.variable @_executable_layout_2 init(@_executable_layout_2_initializer) : !hal.executable_layout attributes {sym_visibility = "private"}
  func private @_executable_layout_2_initializer() -> !hal.executable_layout {
    %0 = hal.variable.load @_descriptor_set_layout_2 : !hal.descriptor_set_layout
    %device = hal.ex.shared_device : !hal.device
    %executable_layout = hal.executable_layout.create device(%device : !hal.device) push_constants(0) layouts([%0]) : !hal.executable_layout
    return %executable_layout : !hal.executable_layout
  }
  hal.variable @_executable_mnist_linked_llvm_aot init(@_executable_mnist_linked_llvm_aot_initializer) : !hal.executable attributes {sym_visibility = "private"}
  func private @_executable_mnist_linked_llvm_aot_initializer() -> !hal.executable {
    %device = hal.ex.shared_device : !hal.device
    %0 = hal.variable.load @_device_match_id_0 : i1
    cond_br %0, ^bb1, ^bb2
  ^bb1:  // pred: ^bb0
    %1 = hal.variable.load @_executable_layout_0 : !hal.executable_layout
    %2 = hal.variable.load @_executable_layout_1 : !hal.executable_layout
    %3 = hal.variable.load @_executable_layout_2 : !hal.executable_layout
    %exe = hal.executable.create device(%device : !hal.device) target(@mnist_linked_llvm_aot::@llvm_aot) layouts([%1, %1, %1, %2, %2, %1, %2, %3]) : !hal.executable
    br ^bb3(%exe : !hal.executable)
  ^bb2:  // pred: ^bb0
    %4 = iree.null : !hal.executable
    br ^bb3(%4 : !hal.executable)
  ^bb3(%5: !hal.executable):  // 2 preds: ^bb1, ^bb2
    return %5 : !hal.executable
  }
  hal.executable @mnist_linked_llvm_aot attributes {sym_visibility = "private"} {
    hal.interface @io_0 {
      hal.interface.binding @s0b0_ro_constant, set=0, binding=0, type="StorageBuffer", access="Read"
      hal.interface.binding @s0b1_ro_external, set=0, binding=1, type="StorageBuffer", access="Read"
      hal.interface.binding @s0b2_xw_external, set=0, binding=2, type="StorageBuffer", access="Write|Discard"
    }
    hal.interface @io_1 {
      hal.interface.binding @s0b0_ro_external, set=0, binding=0, type="StorageBuffer", access="Read"
      hal.interface.binding @s0b1_xw_external, set=0, binding=1, type="StorageBuffer", access="Write|Discard"
    }
    hal.interface @io_2 {
      hal.interface.binding @s0b0_ro_external, set=0, binding=0, type="StorageBuffer", access="Read"
      hal.interface.binding @s0b1_ro_external, set=0, binding=1, type="StorageBuffer", access="Read"
      hal.interface.binding @s0b2_xw_external, set=0, binding=2, type="StorageBuffer", access="Write|Discard"
    }
    hal.interface @io_3 {
      hal.interface.binding @s0b0_ro_external, set=0, binding=0, type="StorageBuffer", access="Read"
      hal.interface.binding @s0b1_ro_external, set=0, binding=1, type="StorageBuffer", access="Read"
      hal.interface.binding @s0b2_ro_external, set=0, binding=2, type="StorageBuffer", access="Read"
      hal.interface.binding @s0b3_xw_external, set=0, binding=3, type="StorageBuffer", access="Write|Discard"
    }
    hal.executable.binary @llvm_aot attributes {data = opaque<"_", "0xDEADBEEF"> : vector<136794xi8>, format = "DLIB", mime_type = "application/x-flatbuffers"} {
    }
  }
  hal.constant_pool @_const_pool attributes {buffer_constraints = #hal.buffer_constraints<max_allocation_size = 1073741824, min_buffer_offset_alignment = 16, max_buffer_range = 1073741824, min_buffer_range_alignment = 16>, sym_visibility = "private"} {
    hal.constant_storage @_storage = opaque<"_", "0xDEADBEEF"> : vector<407040xi8> attributes {sym_visibility = "nested"}
  }
  hal.variable @_const_pool_storage_buffer init(@_const_pool_storage_buffer_initializer) : !hal.buffer attributes {sym_visibility = "private"}
  func private @_const_pool_storage_buffer_initializer() -> !hal.buffer {
    %c0 = constant 0 : index
    %c407040 = constant 407040 : index
    %device = hal.ex.shared_device : !hal.device
    %allocator = hal.device.allocator<%device : !hal.device> : !hal.allocator
    %storage = hal.constant_storage.lookup @_const_pool::@_storage : !iree.byte_buffer
    %mapped = hal.allocator.map<%allocator : !hal.allocator> source(%storage : !iree.byte_buffer)[%c0, %c407040] type("HostVisible|DeviceVisible|DeviceLocal") usage("Constant|Transfer|Mapping|Dispatch") : !hal.buffer
    return %mapped : !hal.buffer
  }
  func @predict(%arg0: !hal.buffer) -> !hal.buffer attributes {noinline} {
    %c3136 = constant 3136 : index
    %c401408 = constant 401408 : index
    %c401920 = constant 401920 : index
    %c5120 = constant 5120 : index
    %c40 = constant 40 : index
    %c4 = constant 4 : index
    %c3 = constant 3 : index
    %c0 = constant 0 : index
    %c512 = constant 512 : index
    %c96 = constant 96 : index
    %c48 = constant 48 : index
    %c112 = constant 112 : index
    %c1024 = constant 1024 : index
    %c2 = constant 2 : index
    %c1 = constant 1 : index
    %device = hal.ex.shared_device : !hal.device
    %allocator = hal.device.allocator<%device : !hal.device> : !hal.allocator
    %buffer = hal.allocator.allocate<%allocator : !hal.allocator> type("HostVisible|DeviceVisible|DeviceLocal") usage("Transfer|Mapping|Dispatch") : !hal.buffer{%c40}
    %0 = hal.variable.load @_const_pool_storage_buffer : !hal.buffer
    %buffer_0 = hal.allocator.allocate<%allocator : !hal.allocator> type("DeviceVisible|DeviceLocal") usage("Transfer|Dispatch") : !hal.buffer{%c1024}
    %cmd = hal.command_buffer.create device(%device : !hal.device) mode("OneShot|AllowInlineExecution") categories("Transfer|Dispatch") : !hal.command_buffer
    hal.command_buffer.begin<%cmd : !hal.command_buffer>
    %1 = hal.variable.load @_executable_layout_0 : !hal.executable_layout
    hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%1 : !hal.executable_layout)[%c0] bindings([
      %c0 = (%0 : !hal.buffer)[%c512, %c401408], 
      %c1 = (%arg0 : !hal.buffer)[%c0, %c3136], 
      %c2 = (%buffer_0 : !hal.buffer)[%c0, %c512]
    ])
    %2 = hal.variable.load @_device_match_id_0 : i1
    cond_br %2, ^bb1, ^bb2
  ^bb1:  // pred: ^bb0
    %3 = hal.variable.load @_executable_mnist_linked_llvm_aot : !hal.executable
    hal.command_buffer.dispatch<%cmd : !hal.command_buffer> target(%3 : !hal.executable)[0] workgroups([%c2, %c1, %c1])
    hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
    hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%1 : !hal.executable_layout)[%c0] bindings([
      %c0 = (%0 : !hal.buffer)[%c0, %c512], 
      %c1 = (%buffer_0 : !hal.buffer)[%c0, %c512], 
      %c2 = (%buffer_0 : !hal.buffer)[%c512, %c512]
    ])
    hal.command_buffer.dispatch<%cmd : !hal.command_buffer> target(%3 : !hal.executable)[1] workgroups([%c1, %c1, %c1])
    hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
    hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%1 : !hal.executable_layout)[%c0] bindings([
      %c0 = (%0 : !hal.buffer)[%c401920, %c5120], 
      %c1 = (%buffer_0 : !hal.buffer)[%c512, %c512], 
      %c2 = (%buffer_0 : !hal.buffer)[%c0, %c40]
    ])
    hal.command_buffer.dispatch<%cmd : !hal.command_buffer> target(%3 : !hal.executable)[2] workgroups([%c1, %c1, %c1])
    hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
    %4 = hal.variable.load @_executable_layout_1 : !hal.executable_layout
    hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%4 : !hal.executable_layout)[%c0] bindings([
      %c0 = (%buffer_0 : !hal.buffer)[%c0, %c40], 
      %c1 = (%buffer_0 : !hal.buffer)[%c48, %c40]
    ])
    hal.command_buffer.dispatch<%cmd : !hal.command_buffer> target(%3 : !hal.executable)[3] workgroups([%c1, %c1, %c1])
    hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
    hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%4 : !hal.executable_layout)[%c0] bindings([
      %c0 = (%buffer_0 : !hal.buffer)[%c48, %c40], 
      %c1 = (%buffer_0 : !hal.buffer)[%c96, %c4]
    ])
    hal.command_buffer.dispatch<%cmd : !hal.command_buffer> target(%3 : !hal.executable)[4] workgroups([%c1, %c1, %c1])
    hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
    hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%1 : !hal.executable_layout)[%c0] bindings([
      %c0 = (%buffer_0 : !hal.buffer)[%c0, %c40], 
      %c1 = (%buffer_0 : !hal.buffer)[%c96, %c4], 
      %c2 = (%buffer_0 : !hal.buffer)[%c48, %c40]
    ])
    hal.command_buffer.dispatch<%cmd : !hal.command_buffer> target(%3 : !hal.executable)[5] workgroups([%c1, %c1, %c1])
    hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
    hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%4 : !hal.executable_layout)[%c0] bindings([
      %c0 = (%buffer_0 : !hal.buffer)[%c48, %c40], 
      %c1 = (%buffer_0 : !hal.buffer)[%c112, %c4]
    ])
    hal.command_buffer.dispatch<%cmd : !hal.command_buffer> target(%3 : !hal.executable)[6] workgroups([%c1, %c1, %c1])
    hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
    %5 = hal.variable.load @_executable_layout_2 : !hal.executable_layout
    hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%5 : !hal.executable_layout)[%c0] bindings([
      %c0 = (%buffer_0 : !hal.buffer)[%c0, %c40], 
      %c1 = (%buffer_0 : !hal.buffer)[%c96, %c4], 
      %c2 = (%buffer_0 : !hal.buffer)[%c112, %c4], 
      %c3 = (%buffer : !hal.buffer)[%c0, %c40]
    ])
    hal.command_buffer.dispatch<%cmd : !hal.command_buffer> target(%3 : !hal.executable)[7] workgroups([%c1, %c1, %c1])
    hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
    hal.command_buffer.end<%cmd : !hal.command_buffer>
    hal.ex.submit_and_wait %device, %cmd
    return %buffer : !hal.buffer
  ^bb2:  // pred: ^bb0
    iree.unreachable "device not supported in the compiled configuration"
  }
  func @predict$async(%arg0: !hal.semaphore, %arg1: index, %arg2: !hal.buffer_view, %arg3: !hal.semaphore, %arg4: index) -> !hal.buffer_view attributes {iree.module.export = "predict$async"} {
    %c1 = constant 1 : index
    %c10 = constant 10 : index
    %c50331680_i32 = constant 50331680 : i32
    %0 = hal.semaphore.await<%arg0 : !hal.semaphore> until(%arg1) : i32
    hal.check_success %0, "semaphore wait failed"
    %buffer = hal.buffer_view.buffer %arg2 : !hal.buffer
    %1 = call @predict(%buffer) : (!hal.buffer) -> !hal.buffer
    %view = hal.buffer_view.create %1, element_type = %c50331680_i32, shape = [%c1, %c10] : !hal.buffer -> !hal.buffer_view
    hal.semaphore.signal<%arg3 : !hal.semaphore> value(%arg4)
    return %view : !hal.buffer_view
  }
  func @predict$sync(%arg0: !hal.buffer_view) -> !hal.buffer_view attributes {iree.abi.stub, iree.module.export = "predict", iree.reflection = {abi = "sip", abiv = 1 : i32, f = "I15!B11!d1d28d28d1R9!B6!d1d10", fv = "1", sip = "I8!S5!k0_0R3!_0"}} {
    %c0 = constant 0 : index
    %c1 = constant 1 : index
    %device = hal.ex.shared_device : !hal.device
    %semaphore = hal.semaphore.create device(%device : !hal.device) initial(%c0) : !hal.semaphore
    %0 = call @predict$async(%semaphore, %c0, %arg0, %semaphore, %c1) : (!hal.semaphore, index, !hal.buffer_view, !hal.semaphore, index) -> !hal.buffer_view
    %1 = hal.semaphore.await<%semaphore : !hal.semaphore> until(%c1) : i32
    hal.check_success %1, "semaphore wait failed"
    return %0 : !hal.buffer_view
  }
}


// *** IR Dump After SCFToStandard ***
func private @_device_match_id_0_initializer() -> i1 {
  %device = hal.ex.shared_device : !hal.device
  %0 = hal.device.match.id<%device : !hal.device> pattern("dylib*") : i1
  return %0 : i1
}

// *** IR Dump After SCFToStandard ***
func private @_descriptor_set_layout_0_initializer() -> !hal.descriptor_set_layout {
  %device = hal.ex.shared_device : !hal.device
  %descriptor_set_layout = hal.descriptor_set_layout.create device(%device : !hal.device) usage(PushOnly) bindings([#hal.descriptor_set_layout_binding<0, "StorageBuffer", R>, #hal.descriptor_set_layout_binding<1, "StorageBuffer", R>, #hal.descriptor_set_layout_binding<2, "StorageBuffer", DW>]) : !hal.descriptor_set_layout
  return %descriptor_set_layout : !hal.descriptor_set_layout
}

// *** IR Dump After SCFToStandard ***
func private @_executable_layout_0_initializer() -> !hal.executable_layout {
  %0 = hal.variable.load @_descriptor_set_layout_0 : !hal.descriptor_set_layout
  %device = hal.ex.shared_device : !hal.device
  %executable_layout = hal.executable_layout.create device(%device : !hal.device) push_constants(0) layouts([%0]) : !hal.executable_layout
  return %executable_layout : !hal.executable_layout
}

// *** IR Dump After SCFToStandard ***
func private @_descriptor_set_layout_1_initializer() -> !hal.descriptor_set_layout {
  %device = hal.ex.shared_device : !hal.device
  %descriptor_set_layout = hal.descriptor_set_layout.create device(%device : !hal.device) usage(PushOnly) bindings([#hal.descriptor_set_layout_binding<0, "StorageBuffer", R>, #hal.descriptor_set_layout_binding<1, "StorageBuffer", DW>]) : !hal.descriptor_set_layout
  return %descriptor_set_layout : !hal.descriptor_set_layout
}

// *** IR Dump After SCFToStandard ***
func private @_executable_layout_1_initializer() -> !hal.executable_layout {
  %0 = hal.variable.load @_descriptor_set_layout_1 : !hal.descriptor_set_layout
  %device = hal.ex.shared_device : !hal.device
  %executable_layout = hal.executable_layout.create device(%device : !hal.device) push_constants(0) layouts([%0]) : !hal.executable_layout
  return %executable_layout : !hal.executable_layout
}

// *** IR Dump After SCFToStandard ***
func private @_descriptor_set_layout_2_initializer() -> !hal.descriptor_set_layout {
  %device = hal.ex.shared_device : !hal.device
  %descriptor_set_layout = hal.descriptor_set_layout.create device(%device : !hal.device) usage(PushOnly) bindings([#hal.descriptor_set_layout_binding<0, "StorageBuffer", R>, #hal.descriptor_set_layout_binding<1, "StorageBuffer", R>, #hal.descriptor_set_layout_binding<2, "StorageBuffer", R>, #hal.descriptor_set_layout_binding<3, "StorageBuffer", DW>]) : !hal.descriptor_set_layout
  return %descriptor_set_layout : !hal.descriptor_set_layout
}

// *** IR Dump After SCFToStandard ***
func private @_executable_layout_2_initializer() -> !hal.executable_layout {
  %0 = hal.variable.load @_descriptor_set_layout_2 : !hal.descriptor_set_layout
  %device = hal.ex.shared_device : !hal.device
  %executable_layout = hal.executable_layout.create device(%device : !hal.device) push_constants(0) layouts([%0]) : !hal.executable_layout
  return %executable_layout : !hal.executable_layout
}

// *** IR Dump After SCFToStandard ***
func private @_executable_mnist_linked_llvm_aot_initializer() -> !hal.executable {
  %device = hal.ex.shared_device : !hal.device
  %0 = hal.variable.load @_device_match_id_0 : i1
  cond_br %0, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %1 = hal.variable.load @_executable_layout_0 : !hal.executable_layout
  %2 = hal.variable.load @_executable_layout_1 : !hal.executable_layout
  %3 = hal.variable.load @_executable_layout_2 : !hal.executable_layout
  %exe = hal.executable.create device(%device : !hal.device) target(@mnist_linked_llvm_aot::@llvm_aot) layouts([%1, %1, %1, %2, %2, %1, %2, %3]) : !hal.executable
  br ^bb3(%exe : !hal.executable)
^bb2:  // pred: ^bb0
  %4 = iree.null : !hal.executable
  br ^bb3(%4 : !hal.executable)
^bb3(%5: !hal.executable):  // 2 preds: ^bb1, ^bb2
  return %5 : !hal.executable
}

// *** IR Dump After SCFToStandard ***
func private @_const_pool_storage_buffer_initializer() -> !hal.buffer {
  %c0 = constant 0 : index
  %c407040 = constant 407040 : index
  %device = hal.ex.shared_device : !hal.device
  %allocator = hal.device.allocator<%device : !hal.device> : !hal.allocator
  %storage = hal.constant_storage.lookup @_const_pool::@_storage : !iree.byte_buffer
  %mapped = hal.allocator.map<%allocator : !hal.allocator> source(%storage : !iree.byte_buffer)[%c0, %c407040] type("HostVisible|DeviceVisible|DeviceLocal") usage("Constant|Transfer|Mapping|Dispatch") : !hal.buffer
  return %mapped : !hal.buffer
}

// *** IR Dump After SCFToStandard ***
func @predict(%arg0: !hal.buffer) -> !hal.buffer attributes {noinline} {
  %c3136 = constant 3136 : index
  %c401408 = constant 401408 : index
  %c401920 = constant 401920 : index
  %c5120 = constant 5120 : index
  %c40 = constant 40 : index
  %c4 = constant 4 : index
  %c3 = constant 3 : index
  %c0 = constant 0 : index
  %c512 = constant 512 : index
  %c96 = constant 96 : index
  %c48 = constant 48 : index
  %c112 = constant 112 : index
  %c1024 = constant 1024 : index
  %c2 = constant 2 : index
  %c1 = constant 1 : index
  %device = hal.ex.shared_device : !hal.device
  %allocator = hal.device.allocator<%device : !hal.device> : !hal.allocator
  %buffer = hal.allocator.allocate<%allocator : !hal.allocator> type("HostVisible|DeviceVisible|DeviceLocal") usage("Transfer|Mapping|Dispatch") : !hal.buffer{%c40}
  %0 = hal.variable.load @_const_pool_storage_buffer : !hal.buffer
  %buffer_0 = hal.allocator.allocate<%allocator : !hal.allocator> type("DeviceVisible|DeviceLocal") usage("Transfer|Dispatch") : !hal.buffer{%c1024}
  %cmd = hal.command_buffer.create device(%device : !hal.device) mode("OneShot|AllowInlineExecution") categories("Transfer|Dispatch") : !hal.command_buffer
  hal.command_buffer.begin<%cmd : !hal.command_buffer>
  %1 = hal.variable.load @_executable_layout_0 : !hal.executable_layout
  hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%1 : !hal.executable_layout)[%c0] bindings([
    %c0 = (%0 : !hal.buffer)[%c512, %c401408], 
    %c1 = (%arg0 : !hal.buffer)[%c0, %c3136], 
    %c2 = (%buffer_0 : !hal.buffer)[%c0, %c512]
  ])
  %2 = hal.variable.load @_device_match_id_0 : i1
  cond_br %2, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %3 = hal.variable.load @_executable_mnist_linked_llvm_aot : !hal.executable
  hal.command_buffer.dispatch<%cmd : !hal.command_buffer> target(%3 : !hal.executable)[0] workgroups([%c2, %c1, %c1])
  hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
  hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%1 : !hal.executable_layout)[%c0] bindings([
    %c0 = (%0 : !hal.buffer)[%c0, %c512], 
    %c1 = (%buffer_0 : !hal.buffer)[%c0, %c512], 
    %c2 = (%buffer_0 : !hal.buffer)[%c512, %c512]
  ])
  hal.command_buffer.dispatch<%cmd : !hal.command_buffer> target(%3 : !hal.executable)[1] workgroups([%c1, %c1, %c1])
  hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
  hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%1 : !hal.executable_layout)[%c0] bindings([
    %c0 = (%0 : !hal.buffer)[%c401920, %c5120], 
    %c1 = (%buffer_0 : !hal.buffer)[%c512, %c512], 
    %c2 = (%buffer_0 : !hal.buffer)[%c0, %c40]
  ])
  hal.command_buffer.dispatch<%cmd : !hal.command_buffer> target(%3 : !hal.executable)[2] workgroups([%c1, %c1, %c1])
  hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
  %4 = hal.variable.load @_executable_layout_1 : !hal.executable_layout
  hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%4 : !hal.executable_layout)[%c0] bindings([
    %c0 = (%buffer_0 : !hal.buffer)[%c0, %c40], 
    %c1 = (%buffer_0 : !hal.buffer)[%c48, %c40]
  ])
  hal.command_buffer.dispatch<%cmd : !hal.command_buffer> target(%3 : !hal.executable)[3] workgroups([%c1, %c1, %c1])
  hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
  hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%4 : !hal.executable_layout)[%c0] bindings([
    %c0 = (%buffer_0 : !hal.buffer)[%c48, %c40], 
    %c1 = (%buffer_0 : !hal.buffer)[%c96, %c4]
  ])
  hal.command_buffer.dispatch<%cmd : !hal.command_buffer> target(%3 : !hal.executable)[4] workgroups([%c1, %c1, %c1])
  hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
  hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%1 : !hal.executable_layout)[%c0] bindings([
    %c0 = (%buffer_0 : !hal.buffer)[%c0, %c40], 
    %c1 = (%buffer_0 : !hal.buffer)[%c96, %c4], 
    %c2 = (%buffer_0 : !hal.buffer)[%c48, %c40]
  ])
  hal.command_buffer.dispatch<%cmd : !hal.command_buffer> target(%3 : !hal.executable)[5] workgroups([%c1, %c1, %c1])
  hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
  hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%4 : !hal.executable_layout)[%c0] bindings([
    %c0 = (%buffer_0 : !hal.buffer)[%c48, %c40], 
    %c1 = (%buffer_0 : !hal.buffer)[%c112, %c4]
  ])
  hal.command_buffer.dispatch<%cmd : !hal.command_buffer> target(%3 : !hal.executable)[6] workgroups([%c1, %c1, %c1])
  hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
  %5 = hal.variable.load @_executable_layout_2 : !hal.executable_layout
  hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%5 : !hal.executable_layout)[%c0] bindings([
    %c0 = (%buffer_0 : !hal.buffer)[%c0, %c40], 
    %c1 = (%buffer_0 : !hal.buffer)[%c96, %c4], 
    %c2 = (%buffer_0 : !hal.buffer)[%c112, %c4], 
    %c3 = (%buffer : !hal.buffer)[%c0, %c40]
  ])
  hal.command_buffer.dispatch<%cmd : !hal.command_buffer> target(%3 : !hal.executable)[7] workgroups([%c1, %c1, %c1])
  hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
  hal.command_buffer.end<%cmd : !hal.command_buffer>
  hal.ex.submit_and_wait %device, %cmd
  return %buffer : !hal.buffer
^bb2:  // pred: ^bb0
  iree.unreachable "device not supported in the compiled configuration"
}

// *** IR Dump After SCFToStandard ***
func @predict$async(%arg0: !hal.semaphore, %arg1: index, %arg2: !hal.buffer_view, %arg3: !hal.semaphore, %arg4: index) -> !hal.buffer_view attributes {iree.module.export = "predict$async"} {
  %c1 = constant 1 : index
  %c10 = constant 10 : index
  %c50331680_i32 = constant 50331680 : i32
  %0 = hal.semaphore.await<%arg0 : !hal.semaphore> until(%arg1) : i32
  hal.check_success %0, "semaphore wait failed"
  %buffer = hal.buffer_view.buffer %arg2 : !hal.buffer
  %1 = call @predict(%buffer) : (!hal.buffer) -> !hal.buffer
  %view = hal.buffer_view.create %1, element_type = %c50331680_i32, shape = [%c1, %c10] : !hal.buffer -> !hal.buffer_view
  hal.semaphore.signal<%arg3 : !hal.semaphore> value(%arg4)
  return %view : !hal.buffer_view
}

// *** IR Dump After SCFToStandard ***
func @predict$sync(%arg0: !hal.buffer_view) -> !hal.buffer_view attributes {iree.abi.stub, iree.module.export = "predict", iree.reflection = {abi = "sip", abiv = 1 : i32, f = "I15!B11!d1d28d28d1R9!B6!d1d10", fv = "1", sip = "I8!S5!k0_0R3!_0"}} {
  %c0 = constant 0 : index
  %c1 = constant 1 : index
  %device = hal.ex.shared_device : !hal.device
  %semaphore = hal.semaphore.create device(%device : !hal.device) initial(%c0) : !hal.semaphore
  %0 = call @predict$async(%semaphore, %c0, %arg0, %semaphore, %c1) : (!hal.semaphore, index, !hal.buffer_view, !hal.semaphore, index) -> !hal.buffer_view
  %1 = hal.semaphore.await<%semaphore : !hal.semaphore> until(%c1) : i32
  hal.check_success %1, "semaphore wait failed"
  return %0 : !hal.buffer_view
}

// *** IR Dump After Canonicalizer ***
module  {
  hal.variable @_device_match_id_0 init(@_device_match_id_0_initializer) : i1 attributes {sym_visibility = "private"}
  func private @_device_match_id_0_initializer() -> i1 {
    %device = hal.ex.shared_device : !hal.device
    %0 = hal.device.match.id<%device : !hal.device> pattern("dylib*") : i1
    return %0 : i1
  }
  hal.variable @_descriptor_set_layout_0 init(@_descriptor_set_layout_0_initializer) : !hal.descriptor_set_layout attributes {sym_visibility = "private"}
  func private @_descriptor_set_layout_0_initializer() -> !hal.descriptor_set_layout {
    %device = hal.ex.shared_device : !hal.device
    %descriptor_set_layout = hal.descriptor_set_layout.create device(%device : !hal.device) usage(PushOnly) bindings([#hal.descriptor_set_layout_binding<0, "StorageBuffer", R>, #hal.descriptor_set_layout_binding<1, "StorageBuffer", R>, #hal.descriptor_set_layout_binding<2, "StorageBuffer", DW>]) : !hal.descriptor_set_layout
    return %descriptor_set_layout : !hal.descriptor_set_layout
  }
  hal.variable @_executable_layout_0 init(@_executable_layout_0_initializer) : !hal.executable_layout attributes {sym_visibility = "private"}
  func private @_executable_layout_0_initializer() -> !hal.executable_layout {
    %0 = hal.variable.load @_descriptor_set_layout_0 : !hal.descriptor_set_layout
    %device = hal.ex.shared_device : !hal.device
    %executable_layout = hal.executable_layout.create device(%device : !hal.device) push_constants(0) layouts([%0]) : !hal.executable_layout
    return %executable_layout : !hal.executable_layout
  }
  hal.variable @_descriptor_set_layout_1 init(@_descriptor_set_layout_1_initializer) : !hal.descriptor_set_layout attributes {sym_visibility = "private"}
  func private @_descriptor_set_layout_1_initializer() -> !hal.descriptor_set_layout {
    %device = hal.ex.shared_device : !hal.device
    %descriptor_set_layout = hal.descriptor_set_layout.create device(%device : !hal.device) usage(PushOnly) bindings([#hal.descriptor_set_layout_binding<0, "StorageBuffer", R>, #hal.descriptor_set_layout_binding<1, "StorageBuffer", DW>]) : !hal.descriptor_set_layout
    return %descriptor_set_layout : !hal.descriptor_set_layout
  }
  hal.variable @_executable_layout_1 init(@_executable_layout_1_initializer) : !hal.executable_layout attributes {sym_visibility = "private"}
  func private @_executable_layout_1_initializer() -> !hal.executable_layout {
    %0 = hal.variable.load @_descriptor_set_layout_1 : !hal.descriptor_set_layout
    %device = hal.ex.shared_device : !hal.device
    %executable_layout = hal.executable_layout.create device(%device : !hal.device) push_constants(0) layouts([%0]) : !hal.executable_layout
    return %executable_layout : !hal.executable_layout
  }
  hal.variable @_descriptor_set_layout_2 init(@_descriptor_set_layout_2_initializer) : !hal.descriptor_set_layout attributes {sym_visibility = "private"}
  func private @_descriptor_set_layout_2_initializer() -> !hal.descriptor_set_layout {
    %device = hal.ex.shared_device : !hal.device
    %descriptor_set_layout = hal.descriptor_set_layout.create device(%device : !hal.device) usage(PushOnly) bindings([#hal.descriptor_set_layout_binding<0, "StorageBuffer", R>, #hal.descriptor_set_layout_binding<1, "StorageBuffer", R>, #hal.descriptor_set_layout_binding<2, "StorageBuffer", R>, #hal.descriptor_set_layout_binding<3, "StorageBuffer", DW>]) : !hal.descriptor_set_layout
    return %descriptor_set_layout : !hal.descriptor_set_layout
  }
  hal.variable @_executable_layout_2 init(@_executable_layout_2_initializer) : !hal.executable_layout attributes {sym_visibility = "private"}
  func private @_executable_layout_2_initializer() -> !hal.executable_layout {
    %0 = hal.variable.load @_descriptor_set_layout_2 : !hal.descriptor_set_layout
    %device = hal.ex.shared_device : !hal.device
    %executable_layout = hal.executable_layout.create device(%device : !hal.device) push_constants(0) layouts([%0]) : !hal.executable_layout
    return %executable_layout : !hal.executable_layout
  }
  hal.variable @_executable_mnist_linked_llvm_aot init(@_executable_mnist_linked_llvm_aot_initializer) : !hal.executable attributes {sym_visibility = "private"}
  func private @_executable_mnist_linked_llvm_aot_initializer() -> !hal.executable {
    %device = hal.ex.shared_device : !hal.device
    %0 = hal.variable.load @_device_match_id_0 : i1
    cond_br %0, ^bb1, ^bb2
  ^bb1:  // pred: ^bb0
    %1 = hal.variable.load @_executable_layout_0 : !hal.executable_layout
    %2 = hal.variable.load @_executable_layout_1 : !hal.executable_layout
    %3 = hal.variable.load @_executable_layout_2 : !hal.executable_layout
    %exe = hal.executable.create device(%device : !hal.device) target(@mnist_linked_llvm_aot::@llvm_aot) layouts([%1, %1, %1, %2, %2, %1, %2, %3]) : !hal.executable
    br ^bb3(%exe : !hal.executable)
  ^bb2:  // pred: ^bb0
    %4 = iree.null : !hal.executable
    br ^bb3(%4 : !hal.executable)
  ^bb3(%5: !hal.executable):  // 2 preds: ^bb1, ^bb2
    return %5 : !hal.executable
  }
  hal.executable @mnist_linked_llvm_aot attributes {sym_visibility = "private"} {
    hal.interface @io_0 {
      hal.interface.binding @s0b0_ro_constant, set=0, binding=0, type="StorageBuffer", access="Read"
      hal.interface.binding @s0b1_ro_external, set=0, binding=1, type="StorageBuffer", access="Read"
      hal.interface.binding @s0b2_xw_external, set=0, binding=2, type="StorageBuffer", access="Write|Discard"
    }
    hal.interface @io_1 {
      hal.interface.binding @s0b0_ro_external, set=0, binding=0, type="StorageBuffer", access="Read"
      hal.interface.binding @s0b1_xw_external, set=0, binding=1, type="StorageBuffer", access="Write|Discard"
    }
    hal.interface @io_2 {
      hal.interface.binding @s0b0_ro_external, set=0, binding=0, type="StorageBuffer", access="Read"
      hal.interface.binding @s0b1_ro_external, set=0, binding=1, type="StorageBuffer", access="Read"
      hal.interface.binding @s0b2_xw_external, set=0, binding=2, type="StorageBuffer", access="Write|Discard"
    }
    hal.interface @io_3 {
      hal.interface.binding @s0b0_ro_external, set=0, binding=0, type="StorageBuffer", access="Read"
      hal.interface.binding @s0b1_ro_external, set=0, binding=1, type="StorageBuffer", access="Read"
      hal.interface.binding @s0b2_ro_external, set=0, binding=2, type="StorageBuffer", access="Read"
      hal.interface.binding @s0b3_xw_external, set=0, binding=3, type="StorageBuffer", access="Write|Discard"
    }
    hal.executable.binary @llvm_aot attributes {data = opaque<"_", "0xDEADBEEF"> : vector<136794xi8>, format = "DLIB", mime_type = "application/x-flatbuffers"} {
    }
  }
  hal.constant_pool @_const_pool attributes {buffer_constraints = #hal.buffer_constraints<max_allocation_size = 1073741824, min_buffer_offset_alignment = 16, max_buffer_range = 1073741824, min_buffer_range_alignment = 16>, sym_visibility = "private"} {
    hal.constant_storage @_storage = opaque<"_", "0xDEADBEEF"> : vector<407040xi8> attributes {sym_visibility = "nested"}
  }
  hal.variable @_const_pool_storage_buffer init(@_const_pool_storage_buffer_initializer) : !hal.buffer attributes {sym_visibility = "private"}
  func private @_const_pool_storage_buffer_initializer() -> !hal.buffer {
    %c0 = constant 0 : index
    %c407040 = constant 407040 : index
    %device = hal.ex.shared_device : !hal.device
    %allocator = hal.device.allocator<%device : !hal.device> : !hal.allocator
    %storage = hal.constant_storage.lookup @_const_pool::@_storage : !iree.byte_buffer
    %mapped = hal.allocator.map<%allocator : !hal.allocator> source(%storage : !iree.byte_buffer)[%c0, %c407040] type("HostVisible|DeviceVisible|DeviceLocal") usage("Constant|Transfer|Mapping|Dispatch") : !hal.buffer
    return %mapped : !hal.buffer
  }
  func @predict(%arg0: !hal.buffer) -> !hal.buffer attributes {noinline} {
    %c3136 = constant 3136 : index
    %c401408 = constant 401408 : index
    %c401920 = constant 401920 : index
    %c5120 = constant 5120 : index
    %c40 = constant 40 : index
    %c4 = constant 4 : index
    %c3 = constant 3 : index
    %c0 = constant 0 : index
    %c512 = constant 512 : index
    %c96 = constant 96 : index
    %c48 = constant 48 : index
    %c112 = constant 112 : index
    %c1024 = constant 1024 : index
    %c2 = constant 2 : index
    %c1 = constant 1 : index
    %device = hal.ex.shared_device : !hal.device
    %allocator = hal.device.allocator<%device : !hal.device> : !hal.allocator
    %buffer = hal.allocator.allocate<%allocator : !hal.allocator> type("HostVisible|DeviceVisible|DeviceLocal") usage("Transfer|Mapping|Dispatch") : !hal.buffer{%c40}
    %0 = hal.variable.load @_const_pool_storage_buffer : !hal.buffer
    %buffer_0 = hal.allocator.allocate<%allocator : !hal.allocator> type("DeviceVisible|DeviceLocal") usage("Transfer|Dispatch") : !hal.buffer{%c1024}
    %cmd = hal.command_buffer.create device(%device : !hal.device) mode("OneShot|AllowInlineExecution") categories("Transfer|Dispatch") : !hal.command_buffer
    hal.command_buffer.begin<%cmd : !hal.command_buffer>
    %1 = hal.variable.load @_executable_layout_0 : !hal.executable_layout
    hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%1 : !hal.executable_layout)[%c0] bindings([
      %c0 = (%0 : !hal.buffer)[%c512, %c401408], 
      %c1 = (%arg0 : !hal.buffer)[%c0, %c3136], 
      %c2 = (%buffer_0 : !hal.buffer)[%c0, %c512]
    ])
    %2 = hal.variable.load @_device_match_id_0 : i1
    cond_br %2, ^bb1, ^bb2
  ^bb1:  // pred: ^bb0
    %3 = hal.variable.load @_executable_mnist_linked_llvm_aot : !hal.executable
    hal.command_buffer.dispatch<%cmd : !hal.command_buffer> target(%3 : !hal.executable)[0] workgroups([%c2, %c1, %c1])
    hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
    hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%1 : !hal.executable_layout)[%c0] bindings([
      %c0 = (%0 : !hal.buffer)[%c0, %c512], 
      %c1 = (%buffer_0 : !hal.buffer)[%c0, %c512], 
      %c2 = (%buffer_0 : !hal.buffer)[%c512, %c512]
    ])
    hal.command_buffer.dispatch<%cmd : !hal.command_buffer> target(%3 : !hal.executable)[1] workgroups([%c1, %c1, %c1])
    hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
    hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%1 : !hal.executable_layout)[%c0] bindings([
      %c0 = (%0 : !hal.buffer)[%c401920, %c5120], 
      %c1 = (%buffer_0 : !hal.buffer)[%c512, %c512], 
      %c2 = (%buffer_0 : !hal.buffer)[%c0, %c40]
    ])
    hal.command_buffer.dispatch<%cmd : !hal.command_buffer> target(%3 : !hal.executable)[2] workgroups([%c1, %c1, %c1])
    hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
    %4 = hal.variable.load @_executable_layout_1 : !hal.executable_layout
    hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%4 : !hal.executable_layout)[%c0] bindings([
      %c0 = (%buffer_0 : !hal.buffer)[%c0, %c40], 
      %c1 = (%buffer_0 : !hal.buffer)[%c48, %c40]
    ])
    hal.command_buffer.dispatch<%cmd : !hal.command_buffer> target(%3 : !hal.executable)[3] workgroups([%c1, %c1, %c1])
    hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
    hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%4 : !hal.executable_layout)[%c0] bindings([
      %c0 = (%buffer_0 : !hal.buffer)[%c48, %c40], 
      %c1 = (%buffer_0 : !hal.buffer)[%c96, %c4]
    ])
    hal.command_buffer.dispatch<%cmd : !hal.command_buffer> target(%3 : !hal.executable)[4] workgroups([%c1, %c1, %c1])
    hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
    hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%1 : !hal.executable_layout)[%c0] bindings([
      %c0 = (%buffer_0 : !hal.buffer)[%c0, %c40], 
      %c1 = (%buffer_0 : !hal.buffer)[%c96, %c4], 
      %c2 = (%buffer_0 : !hal.buffer)[%c48, %c40]
    ])
    hal.command_buffer.dispatch<%cmd : !hal.command_buffer> target(%3 : !hal.executable)[5] workgroups([%c1, %c1, %c1])
    hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
    hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%4 : !hal.executable_layout)[%c0] bindings([
      %c0 = (%buffer_0 : !hal.buffer)[%c48, %c40], 
      %c1 = (%buffer_0 : !hal.buffer)[%c112, %c4]
    ])
    hal.command_buffer.dispatch<%cmd : !hal.command_buffer> target(%3 : !hal.executable)[6] workgroups([%c1, %c1, %c1])
    hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
    %5 = hal.variable.load @_executable_layout_2 : !hal.executable_layout
    hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%5 : !hal.executable_layout)[%c0] bindings([
      %c0 = (%buffer_0 : !hal.buffer)[%c0, %c40], 
      %c1 = (%buffer_0 : !hal.buffer)[%c96, %c4], 
      %c2 = (%buffer_0 : !hal.buffer)[%c112, %c4], 
      %c3 = (%buffer : !hal.buffer)[%c0, %c40]
    ])
    hal.command_buffer.dispatch<%cmd : !hal.command_buffer> target(%3 : !hal.executable)[7] workgroups([%c1, %c1, %c1])
    hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
    hal.command_buffer.end<%cmd : !hal.command_buffer>
    hal.ex.submit_and_wait %device, %cmd
    return %buffer : !hal.buffer
  ^bb2:  // pred: ^bb0
    iree.unreachable "device not supported in the compiled configuration"
  }
  func @predict$async(%arg0: !hal.semaphore, %arg1: index, %arg2: !hal.buffer_view, %arg3: !hal.semaphore, %arg4: index) -> !hal.buffer_view attributes {iree.module.export = "predict$async"} {
    %c1 = constant 1 : index
    %c10 = constant 10 : index
    %c50331680_i32 = constant 50331680 : i32
    %0 = hal.semaphore.await<%arg0 : !hal.semaphore> until(%arg1) : i32
    hal.check_success %0, "semaphore wait failed"
    %buffer = hal.buffer_view.buffer %arg2 : !hal.buffer
    %1 = call @predict(%buffer) : (!hal.buffer) -> !hal.buffer
    %view = hal.buffer_view.create %1, element_type = %c50331680_i32, shape = [%c1, %c10] : !hal.buffer -> !hal.buffer_view
    hal.semaphore.signal<%arg3 : !hal.semaphore> value(%arg4)
    return %view : !hal.buffer_view
  }
  func @predict$sync(%arg0: !hal.buffer_view) -> !hal.buffer_view attributes {iree.abi.stub, iree.module.export = "predict", iree.reflection = {abi = "sip", abiv = 1 : i32, f = "I15!B11!d1d28d28d1R9!B6!d1d10", fv = "1", sip = "I8!S5!k0_0R3!_0"}} {
    %c0 = constant 0 : index
    %c1 = constant 1 : index
    %device = hal.ex.shared_device : !hal.device
    %semaphore = hal.semaphore.create device(%device : !hal.device) initial(%c0) : !hal.semaphore
    %0 = call @predict$async(%semaphore, %c0, %arg0, %semaphore, %c1) : (!hal.semaphore, index, !hal.buffer_view, !hal.semaphore, index) -> !hal.buffer_view
    %1 = hal.semaphore.await<%semaphore : !hal.semaphore> until(%c1) : i32
    hal.check_success %1, "semaphore wait failed"
    return %0 : !hal.buffer_view
  }
}


// *** IR Dump After CSE ***
module  {
  hal.variable @_device_match_id_0 init(@_device_match_id_0_initializer) : i1 attributes {sym_visibility = "private"}
  func private @_device_match_id_0_initializer() -> i1 {
    %device = hal.ex.shared_device : !hal.device
    %0 = hal.device.match.id<%device : !hal.device> pattern("dylib*") : i1
    return %0 : i1
  }
  hal.variable @_descriptor_set_layout_0 init(@_descriptor_set_layout_0_initializer) : !hal.descriptor_set_layout attributes {sym_visibility = "private"}
  func private @_descriptor_set_layout_0_initializer() -> !hal.descriptor_set_layout {
    %device = hal.ex.shared_device : !hal.device
    %descriptor_set_layout = hal.descriptor_set_layout.create device(%device : !hal.device) usage(PushOnly) bindings([#hal.descriptor_set_layout_binding<0, "StorageBuffer", R>, #hal.descriptor_set_layout_binding<1, "StorageBuffer", R>, #hal.descriptor_set_layout_binding<2, "StorageBuffer", DW>]) : !hal.descriptor_set_layout
    return %descriptor_set_layout : !hal.descriptor_set_layout
  }
  hal.variable @_executable_layout_0 init(@_executable_layout_0_initializer) : !hal.executable_layout attributes {sym_visibility = "private"}
  func private @_executable_layout_0_initializer() -> !hal.executable_layout {
    %0 = hal.variable.load @_descriptor_set_layout_0 : !hal.descriptor_set_layout
    %device = hal.ex.shared_device : !hal.device
    %executable_layout = hal.executable_layout.create device(%device : !hal.device) push_constants(0) layouts([%0]) : !hal.executable_layout
    return %executable_layout : !hal.executable_layout
  }
  hal.variable @_descriptor_set_layout_1 init(@_descriptor_set_layout_1_initializer) : !hal.descriptor_set_layout attributes {sym_visibility = "private"}
  func private @_descriptor_set_layout_1_initializer() -> !hal.descriptor_set_layout {
    %device = hal.ex.shared_device : !hal.device
    %descriptor_set_layout = hal.descriptor_set_layout.create device(%device : !hal.device) usage(PushOnly) bindings([#hal.descriptor_set_layout_binding<0, "StorageBuffer", R>, #hal.descriptor_set_layout_binding<1, "StorageBuffer", DW>]) : !hal.descriptor_set_layout
    return %descriptor_set_layout : !hal.descriptor_set_layout
  }
  hal.variable @_executable_layout_1 init(@_executable_layout_1_initializer) : !hal.executable_layout attributes {sym_visibility = "private"}
  func private @_executable_layout_1_initializer() -> !hal.executable_layout {
    %0 = hal.variable.load @_descriptor_set_layout_1 : !hal.descriptor_set_layout
    %device = hal.ex.shared_device : !hal.device
    %executable_layout = hal.executable_layout.create device(%device : !hal.device) push_constants(0) layouts([%0]) : !hal.executable_layout
    return %executable_layout : !hal.executable_layout
  }
  hal.variable @_descriptor_set_layout_2 init(@_descriptor_set_layout_2_initializer) : !hal.descriptor_set_layout attributes {sym_visibility = "private"}
  func private @_descriptor_set_layout_2_initializer() -> !hal.descriptor_set_layout {
    %device = hal.ex.shared_device : !hal.device
    %descriptor_set_layout = hal.descriptor_set_layout.create device(%device : !hal.device) usage(PushOnly) bindings([#hal.descriptor_set_layout_binding<0, "StorageBuffer", R>, #hal.descriptor_set_layout_binding<1, "StorageBuffer", R>, #hal.descriptor_set_layout_binding<2, "StorageBuffer", R>, #hal.descriptor_set_layout_binding<3, "StorageBuffer", DW>]) : !hal.descriptor_set_layout
    return %descriptor_set_layout : !hal.descriptor_set_layout
  }
  hal.variable @_executable_layout_2 init(@_executable_layout_2_initializer) : !hal.executable_layout attributes {sym_visibility = "private"}
  func private @_executable_layout_2_initializer() -> !hal.executable_layout {
    %0 = hal.variable.load @_descriptor_set_layout_2 : !hal.descriptor_set_layout
    %device = hal.ex.shared_device : !hal.device
    %executable_layout = hal.executable_layout.create device(%device : !hal.device) push_constants(0) layouts([%0]) : !hal.executable_layout
    return %executable_layout : !hal.executable_layout
  }
  hal.variable @_executable_mnist_linked_llvm_aot init(@_executable_mnist_linked_llvm_aot_initializer) : !hal.executable attributes {sym_visibility = "private"}
  func private @_executable_mnist_linked_llvm_aot_initializer() -> !hal.executable {
    %device = hal.ex.shared_device : !hal.device
    %0 = hal.variable.load @_device_match_id_0 : i1
    cond_br %0, ^bb1, ^bb2
  ^bb1:  // pred: ^bb0
    %1 = hal.variable.load @_executable_layout_0 : !hal.executable_layout
    %2 = hal.variable.load @_executable_layout_1 : !hal.executable_layout
    %3 = hal.variable.load @_executable_layout_2 : !hal.executable_layout
    %exe = hal.executable.create device(%device : !hal.device) target(@mnist_linked_llvm_aot::@llvm_aot) layouts([%1, %1, %1, %2, %2, %1, %2, %3]) : !hal.executable
    br ^bb3(%exe : !hal.executable)
  ^bb2:  // pred: ^bb0
    %4 = iree.null : !hal.executable
    br ^bb3(%4 : !hal.executable)
  ^bb3(%5: !hal.executable):  // 2 preds: ^bb1, ^bb2
    return %5 : !hal.executable
  }
  hal.executable @mnist_linked_llvm_aot attributes {sym_visibility = "private"} {
    hal.interface @io_0 {
      hal.interface.binding @s0b0_ro_constant, set=0, binding=0, type="StorageBuffer", access="Read"
      hal.interface.binding @s0b1_ro_external, set=0, binding=1, type="StorageBuffer", access="Read"
      hal.interface.binding @s0b2_xw_external, set=0, binding=2, type="StorageBuffer", access="Write|Discard"
    }
    hal.interface @io_1 {
      hal.interface.binding @s0b0_ro_external, set=0, binding=0, type="StorageBuffer", access="Read"
      hal.interface.binding @s0b1_xw_external, set=0, binding=1, type="StorageBuffer", access="Write|Discard"
    }
    hal.interface @io_2 {
      hal.interface.binding @s0b0_ro_external, set=0, binding=0, type="StorageBuffer", access="Read"
      hal.interface.binding @s0b1_ro_external, set=0, binding=1, type="StorageBuffer", access="Read"
      hal.interface.binding @s0b2_xw_external, set=0, binding=2, type="StorageBuffer", access="Write|Discard"
    }
    hal.interface @io_3 {
      hal.interface.binding @s0b0_ro_external, set=0, binding=0, type="StorageBuffer", access="Read"
      hal.interface.binding @s0b1_ro_external, set=0, binding=1, type="StorageBuffer", access="Read"
      hal.interface.binding @s0b2_ro_external, set=0, binding=2, type="StorageBuffer", access="Read"
      hal.interface.binding @s0b3_xw_external, set=0, binding=3, type="StorageBuffer", access="Write|Discard"
    }
    hal.executable.binary @llvm_aot attributes {data = opaque<"_", "0xDEADBEEF"> : vector<136794xi8>, format = "DLIB", mime_type = "application/x-flatbuffers"} {
    }
  }
  hal.constant_pool @_const_pool attributes {buffer_constraints = #hal.buffer_constraints<max_allocation_size = 1073741824, min_buffer_offset_alignment = 16, max_buffer_range = 1073741824, min_buffer_range_alignment = 16>, sym_visibility = "private"} {
    hal.constant_storage @_storage = opaque<"_", "0xDEADBEEF"> : vector<407040xi8> attributes {sym_visibility = "nested"}
  }
  hal.variable @_const_pool_storage_buffer init(@_const_pool_storage_buffer_initializer) : !hal.buffer attributes {sym_visibility = "private"}
  func private @_const_pool_storage_buffer_initializer() -> !hal.buffer {
    %c0 = constant 0 : index
    %c407040 = constant 407040 : index
    %device = hal.ex.shared_device : !hal.device
    %allocator = hal.device.allocator<%device : !hal.device> : !hal.allocator
    %storage = hal.constant_storage.lookup @_const_pool::@_storage : !iree.byte_buffer
    %mapped = hal.allocator.map<%allocator : !hal.allocator> source(%storage : !iree.byte_buffer)[%c0, %c407040] type("HostVisible|DeviceVisible|DeviceLocal") usage("Constant|Transfer|Mapping|Dispatch") : !hal.buffer
    return %mapped : !hal.buffer
  }
  func @predict(%arg0: !hal.buffer) -> !hal.buffer attributes {noinline} {
    %c3136 = constant 3136 : index
    %c401408 = constant 401408 : index
    %c401920 = constant 401920 : index
    %c5120 = constant 5120 : index
    %c40 = constant 40 : index
    %c4 = constant 4 : index
    %c3 = constant 3 : index
    %c0 = constant 0 : index
    %c512 = constant 512 : index
    %c96 = constant 96 : index
    %c48 = constant 48 : index
    %c112 = constant 112 : index
    %c1024 = constant 1024 : index
    %c2 = constant 2 : index
    %c1 = constant 1 : index
    %device = hal.ex.shared_device : !hal.device
    %allocator = hal.device.allocator<%device : !hal.device> : !hal.allocator
    %buffer = hal.allocator.allocate<%allocator : !hal.allocator> type("HostVisible|DeviceVisible|DeviceLocal") usage("Transfer|Mapping|Dispatch") : !hal.buffer{%c40}
    %0 = hal.variable.load @_const_pool_storage_buffer : !hal.buffer
    %buffer_0 = hal.allocator.allocate<%allocator : !hal.allocator> type("DeviceVisible|DeviceLocal") usage("Transfer|Dispatch") : !hal.buffer{%c1024}
    %cmd = hal.command_buffer.create device(%device : !hal.device) mode("OneShot|AllowInlineExecution") categories("Transfer|Dispatch") : !hal.command_buffer
    hal.command_buffer.begin<%cmd : !hal.command_buffer>
    %1 = hal.variable.load @_executable_layout_0 : !hal.executable_layout
    hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%1 : !hal.executable_layout)[%c0] bindings([
      %c0 = (%0 : !hal.buffer)[%c512, %c401408], 
      %c1 = (%arg0 : !hal.buffer)[%c0, %c3136], 
      %c2 = (%buffer_0 : !hal.buffer)[%c0, %c512]
    ])
    %2 = hal.variable.load @_device_match_id_0 : i1
    cond_br %2, ^bb1, ^bb2
  ^bb1:  // pred: ^bb0
    %3 = hal.variable.load @_executable_mnist_linked_llvm_aot : !hal.executable
    hal.command_buffer.dispatch<%cmd : !hal.command_buffer> target(%3 : !hal.executable)[0] workgroups([%c2, %c1, %c1])
    hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
    hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%1 : !hal.executable_layout)[%c0] bindings([
      %c0 = (%0 : !hal.buffer)[%c0, %c512], 
      %c1 = (%buffer_0 : !hal.buffer)[%c0, %c512], 
      %c2 = (%buffer_0 : !hal.buffer)[%c512, %c512]
    ])
    hal.command_buffer.dispatch<%cmd : !hal.command_buffer> target(%3 : !hal.executable)[1] workgroups([%c1, %c1, %c1])
    hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
    hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%1 : !hal.executable_layout)[%c0] bindings([
      %c0 = (%0 : !hal.buffer)[%c401920, %c5120], 
      %c1 = (%buffer_0 : !hal.buffer)[%c512, %c512], 
      %c2 = (%buffer_0 : !hal.buffer)[%c0, %c40]
    ])
    hal.command_buffer.dispatch<%cmd : !hal.command_buffer> target(%3 : !hal.executable)[2] workgroups([%c1, %c1, %c1])
    hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
    %4 = hal.variable.load @_executable_layout_1 : !hal.executable_layout
    hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%4 : !hal.executable_layout)[%c0] bindings([
      %c0 = (%buffer_0 : !hal.buffer)[%c0, %c40], 
      %c1 = (%buffer_0 : !hal.buffer)[%c48, %c40]
    ])
    hal.command_buffer.dispatch<%cmd : !hal.command_buffer> target(%3 : !hal.executable)[3] workgroups([%c1, %c1, %c1])
    hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
    hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%4 : !hal.executable_layout)[%c0] bindings([
      %c0 = (%buffer_0 : !hal.buffer)[%c48, %c40], 
      %c1 = (%buffer_0 : !hal.buffer)[%c96, %c4]
    ])
    hal.command_buffer.dispatch<%cmd : !hal.command_buffer> target(%3 : !hal.executable)[4] workgroups([%c1, %c1, %c1])
    hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
    hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%1 : !hal.executable_layout)[%c0] bindings([
      %c0 = (%buffer_0 : !hal.buffer)[%c0, %c40], 
      %c1 = (%buffer_0 : !hal.buffer)[%c96, %c4], 
      %c2 = (%buffer_0 : !hal.buffer)[%c48, %c40]
    ])
    hal.command_buffer.dispatch<%cmd : !hal.command_buffer> target(%3 : !hal.executable)[5] workgroups([%c1, %c1, %c1])
    hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
    hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%4 : !hal.executable_layout)[%c0] bindings([
      %c0 = (%buffer_0 : !hal.buffer)[%c48, %c40], 
      %c1 = (%buffer_0 : !hal.buffer)[%c112, %c4]
    ])
    hal.command_buffer.dispatch<%cmd : !hal.command_buffer> target(%3 : !hal.executable)[6] workgroups([%c1, %c1, %c1])
    hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
    %5 = hal.variable.load @_executable_layout_2 : !hal.executable_layout
    hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%5 : !hal.executable_layout)[%c0] bindings([
      %c0 = (%buffer_0 : !hal.buffer)[%c0, %c40], 
      %c1 = (%buffer_0 : !hal.buffer)[%c96, %c4], 
      %c2 = (%buffer_0 : !hal.buffer)[%c112, %c4], 
      %c3 = (%buffer : !hal.buffer)[%c0, %c40]
    ])
    hal.command_buffer.dispatch<%cmd : !hal.command_buffer> target(%3 : !hal.executable)[7] workgroups([%c1, %c1, %c1])
    hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
    hal.command_buffer.end<%cmd : !hal.command_buffer>
    hal.ex.submit_and_wait %device, %cmd
    return %buffer : !hal.buffer
  ^bb2:  // pred: ^bb0
    iree.unreachable "device not supported in the compiled configuration"
  }
  func @predict$async(%arg0: !hal.semaphore, %arg1: index, %arg2: !hal.buffer_view, %arg3: !hal.semaphore, %arg4: index) -> !hal.buffer_view attributes {iree.module.export = "predict$async"} {
    %c1 = constant 1 : index
    %c10 = constant 10 : index
    %c50331680_i32 = constant 50331680 : i32
    %0 = hal.semaphore.await<%arg0 : !hal.semaphore> until(%arg1) : i32
    hal.check_success %0, "semaphore wait failed"
    %buffer = hal.buffer_view.buffer %arg2 : !hal.buffer
    %1 = call @predict(%buffer) : (!hal.buffer) -> !hal.buffer
    %view = hal.buffer_view.create %1, element_type = %c50331680_i32, shape = [%c1, %c10] : !hal.buffer -> !hal.buffer_view
    hal.semaphore.signal<%arg3 : !hal.semaphore> value(%arg4)
    return %view : !hal.buffer_view
  }
  func @predict$sync(%arg0: !hal.buffer_view) -> !hal.buffer_view attributes {iree.abi.stub, iree.module.export = "predict", iree.reflection = {abi = "sip", abiv = 1 : i32, f = "I15!B11!d1d28d28d1R9!B6!d1d10", fv = "1", sip = "I8!S5!k0_0R3!_0"}} {
    %c0 = constant 0 : index
    %c1 = constant 1 : index
    %device = hal.ex.shared_device : !hal.device
    %semaphore = hal.semaphore.create device(%device : !hal.device) initial(%c0) : !hal.semaphore
    %0 = call @predict$async(%semaphore, %c0, %arg0, %semaphore, %c1) : (!hal.semaphore, index, !hal.buffer_view, !hal.semaphore, index) -> !hal.buffer_view
    %1 = hal.semaphore.await<%semaphore : !hal.semaphore> until(%c1) : i32
    hal.check_success %1, "semaphore wait failed"
    return %0 : !hal.buffer_view
  }
}


// *** IR Dump After mlir::iree_compiler::IREE::VM::ConversionPass ***
module  {
  vm.module @module {
    vm.global.i32 @_device_match_id_0 init(@_device_match_id_0_initializer) : i32
    vm.func private @_device_match_id_0_initializer() -> i32 {
      %ref = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
      %buffer = vm.rodata.inline "_utf8_dylib_971286B245550E6D" {alignment = 1 : i64} : !vm.buffer = dense<[100, 121, 108, 105, 98, 42]> : vector<6xi8>
      %0 = vm.call @hal.device.match.id(%ref, %buffer) : (!vm.ref<!hal.device>, !vm.buffer) -> i32
      vm.return %0 : i32
    }
    vm.global.ref @_descriptor_set_layout_0 init(@_descriptor_set_layout_0_initializer) : !vm.ref<!hal.descriptor_set_layout>
    vm.func private @_descriptor_set_layout_0_initializer() -> !vm.ref<!hal.descriptor_set_layout> {
      %ref = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
      %c1 = vm.const.i32 1 : i32
      %zero = vm.const.i32.zero : i32
      %c7 = vm.const.i32 7 : i32
      %c1_0 = vm.const.i32 1 : i32
      %c1_1 = vm.const.i32 1 : i32
      %c7_2 = vm.const.i32 7 : i32
      %c1_3 = vm.const.i32 1 : i32
      %c2 = vm.const.i32 2 : i32
      %c7_4 = vm.const.i32 7 : i32
      %c6 = vm.const.i32 6 : i32
      %ref_5 = vm.call.variadic @hal.descriptor_set_layout.create(%ref, %c1, [(%zero, %c7, %c1_0), (%c1_1, %c7_2, %c1_3), (%c2, %c7_4, %c6)]) : (!vm.ref<!hal.device>, i32, tuple<i32, i32, i32> ...) -> !vm.ref<!hal.descriptor_set_layout>
      vm.return %ref_5 : !vm.ref<!hal.descriptor_set_layout>
    }
    vm.global.ref @_executable_layout_0 init(@_executable_layout_0_initializer) : !vm.ref<!hal.executable_layout>
    vm.func private @_executable_layout_0_initializer() -> !vm.ref<!hal.executable_layout> {
      %_descriptor_set_layout_0 = vm.global.load.ref @_descriptor_set_layout_0 : !vm.ref<!hal.descriptor_set_layout>
      %ref = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
      %zero = vm.const.i32.zero : i32
      %ref_0 = vm.call.variadic @hal.executable_layout.create(%ref, %zero, [%_descriptor_set_layout_0]) : (!vm.ref<!hal.device>, i32, !vm.ref<!hal.descriptor_set_layout> ...) -> !vm.ref<!hal.executable_layout>
      vm.return %ref_0 : !vm.ref<!hal.executable_layout>
    }
    vm.global.ref @_descriptor_set_layout_1 init(@_descriptor_set_layout_1_initializer) : !vm.ref<!hal.descriptor_set_layout>
    vm.func private @_descriptor_set_layout_1_initializer() -> !vm.ref<!hal.descriptor_set_layout> {
      %ref = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
      %c1 = vm.const.i32 1 : i32
      %zero = vm.const.i32.zero : i32
      %c7 = vm.const.i32 7 : i32
      %c1_0 = vm.const.i32 1 : i32
      %c1_1 = vm.const.i32 1 : i32
      %c7_2 = vm.const.i32 7 : i32
      %c6 = vm.const.i32 6 : i32
      %ref_3 = vm.call.variadic @hal.descriptor_set_layout.create(%ref, %c1, [(%zero, %c7, %c1_0), (%c1_1, %c7_2, %c6)]) : (!vm.ref<!hal.device>, i32, tuple<i32, i32, i32> ...) -> !vm.ref<!hal.descriptor_set_layout>
      vm.return %ref_3 : !vm.ref<!hal.descriptor_set_layout>
    }
    vm.global.ref @_executable_layout_1 init(@_executable_layout_1_initializer) : !vm.ref<!hal.executable_layout>
    vm.func private @_executable_layout_1_initializer() -> !vm.ref<!hal.executable_layout> {
      %_descriptor_set_layout_1 = vm.global.load.ref @_descriptor_set_layout_1 : !vm.ref<!hal.descriptor_set_layout>
      %ref = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
      %zero = vm.const.i32.zero : i32
      %ref_0 = vm.call.variadic @hal.executable_layout.create(%ref, %zero, [%_descriptor_set_layout_1]) : (!vm.ref<!hal.device>, i32, !vm.ref<!hal.descriptor_set_layout> ...) -> !vm.ref<!hal.executable_layout>
      vm.return %ref_0 : !vm.ref<!hal.executable_layout>
    }
    vm.global.ref @_descriptor_set_layout_2 init(@_descriptor_set_layout_2_initializer) : !vm.ref<!hal.descriptor_set_layout>
    vm.func private @_descriptor_set_layout_2_initializer() -> !vm.ref<!hal.descriptor_set_layout> {
      %ref = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
      %c1 = vm.const.i32 1 : i32
      %zero = vm.const.i32.zero : i32
      %c7 = vm.const.i32 7 : i32
      %c1_0 = vm.const.i32 1 : i32
      %c1_1 = vm.const.i32 1 : i32
      %c7_2 = vm.const.i32 7 : i32
      %c1_3 = vm.const.i32 1 : i32
      %c2 = vm.const.i32 2 : i32
      %c7_4 = vm.const.i32 7 : i32
      %c1_5 = vm.const.i32 1 : i32
      %c3 = vm.const.i32 3 : i32
      %c7_6 = vm.const.i32 7 : i32
      %c6 = vm.const.i32 6 : i32
      %ref_7 = vm.call.variadic @hal.descriptor_set_layout.create(%ref, %c1, [(%zero, %c7, %c1_0), (%c1_1, %c7_2, %c1_3), (%c2, %c7_4, %c1_5), (%c3, %c7_6, %c6)]) : (!vm.ref<!hal.device>, i32, tuple<i32, i32, i32> ...) -> !vm.ref<!hal.descriptor_set_layout>
      vm.return %ref_7 : !vm.ref<!hal.descriptor_set_layout>
    }
    vm.global.ref @_executable_layout_2 init(@_executable_layout_2_initializer) : !vm.ref<!hal.executable_layout>
    vm.func private @_executable_layout_2_initializer() -> !vm.ref<!hal.executable_layout> {
      %_descriptor_set_layout_2 = vm.global.load.ref @_descriptor_set_layout_2 : !vm.ref<!hal.descriptor_set_layout>
      %ref = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
      %zero = vm.const.i32.zero : i32
      %ref_0 = vm.call.variadic @hal.executable_layout.create(%ref, %zero, [%_descriptor_set_layout_2]) : (!vm.ref<!hal.device>, i32, !vm.ref<!hal.descriptor_set_layout> ...) -> !vm.ref<!hal.executable_layout>
      vm.return %ref_0 : !vm.ref<!hal.executable_layout>
    }
    vm.global.ref @_executable_mnist_linked_llvm_aot init(@_executable_mnist_linked_llvm_aot_initializer) : !vm.ref<!hal.executable>
    vm.rodata @_mnist_linked_llvm_aot_llvm_aot_binary_dlib opaque<"_", "0xDEADBEEF"> : vector<136794xi8>
    vm.func private @_executable_mnist_linked_llvm_aot_initializer() -> !vm.ref<!hal.executable> {
      %ref = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
      %_device_match_id_0 = vm.global.load.i32 @_device_match_id_0 : i32
      vm.cond_br %_device_match_id_0, ^bb1, ^bb2
    ^bb1:  // pred: ^bb0
      %_executable_layout_0 = vm.global.load.ref @_executable_layout_0 : !vm.ref<!hal.executable_layout>
      %_executable_layout_1 = vm.global.load.ref @_executable_layout_1 : !vm.ref<!hal.executable_layout>
      %_executable_layout_2 = vm.global.load.ref @_executable_layout_2 : !vm.ref<!hal.executable_layout>
      %buffer = vm.rodata.inline "_utf8_dlib_F45B9BA87AEFAACB" {alignment = 1 : i64} : !vm.buffer = dense<[68, 76, 73, 66]> : vector<4xi8>
      %_mnist_linked_llvm_aot_llvm_aot_binary_dlib = vm.const.ref.rodata @_mnist_linked_llvm_aot_llvm_aot_binary_dlib : !vm.buffer
      %ref_0 = vm.call.variadic @hal.executable.create(%ref, %buffer, %_mnist_linked_llvm_aot_llvm_aot_binary_dlib, [%_executable_layout_0, %_executable_layout_0, %_executable_layout_0, %_executable_layout_1, %_executable_layout_1, %_executable_layout_0, %_executable_layout_1, %_executable_layout_2]) : (!vm.ref<!hal.device>, !vm.buffer, !vm.buffer, !vm.ref<!hal.executable_layout> ...) -> !vm.ref<!hal.executable>
      vm.br ^bb3(%ref_0 : !vm.ref<!hal.executable>)
    ^bb2:  // pred: ^bb0
      %null = vm.const.ref.zero : !vm.ref<!hal.executable>
      vm.br ^bb3(%null : !vm.ref<!hal.executable>)
    ^bb3(%0: !vm.ref<!hal.executable>):  // 2 preds: ^bb1, ^bb2
      vm.return %0 : !vm.ref<!hal.executable>
    }
    vm.rodata @_const_pool_storage opaque<"_", "0xDEADBEEF"> : vector<407040xi8>
    vm.global.ref @_const_pool_storage_buffer init(@_const_pool_storage_buffer_initializer) : !vm.ref<!hal.buffer>
    vm.func private @_const_pool_storage_buffer_initializer() -> !vm.ref<!hal.buffer> {
      %zero = vm.const.i32.zero : i32
      %c407040 = vm.const.i32 407040 : i32
      %ref = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
      %ref_0 = vm.call @hal.device.allocator(%ref) : (!vm.ref<!hal.device>) -> !vm.ref<!hal.allocator>
      %_const_pool_storage = vm.const.ref.rodata @_const_pool_storage : !vm.buffer
      %c50 = vm.const.i32 50 : i32
      %c15 = vm.const.i32 15 : i32
      %ref_1 = vm.call @hal.allocator.wrap.byte_buffer(%ref_0, %c50, %c15, %_const_pool_storage, %zero, %c407040) : (!vm.ref<!hal.allocator>, i32, i32, !vm.buffer, i32, i32) -> !vm.ref<!hal.buffer>
      vm.return %ref_1 : !vm.ref<!hal.buffer>
    }
    vm.func @predict(%arg0: !vm.ref<!hal.buffer>) -> !vm.ref<!hal.buffer> attributes {noinline} {
      %c3136 = vm.const.i32 3136 : i32
      %c401408 = vm.const.i32 401408 : i32
      %c401920 = vm.const.i32 401920 : i32
      %c5120 = vm.const.i32 5120 : i32
      %c40 = vm.const.i32 40 : i32
      %c4 = vm.const.i32 4 : i32
      %c3 = vm.const.i32 3 : i32
      %zero = vm.const.i32.zero : i32
      %c512 = vm.const.i32 512 : i32
      %c96 = vm.const.i32 96 : i32
      %c48 = vm.const.i32 48 : i32
      %c112 = vm.const.i32 112 : i32
      %c1024 = vm.const.i32 1024 : i32
      %c2 = vm.const.i32 2 : i32
      %c1 = vm.const.i32 1 : i32
      %ref = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
      %ref_0 = vm.call @hal.device.allocator(%ref) : (!vm.ref<!hal.device>) -> !vm.ref<!hal.allocator>
      %c50 = vm.const.i32 50 : i32
      %c14 = vm.const.i32 14 : i32
      %ref_1 = vm.call @hal.allocator.allocate(%ref_0, %c50, %c14, %c40) : (!vm.ref<!hal.allocator>, i32, i32, i32) -> !vm.ref<!hal.buffer>
      %_const_pool_storage_buffer = vm.global.load.ref @_const_pool_storage_buffer : !vm.ref<!hal.buffer>
      %c48_2 = vm.const.i32 48 : i32
      %c10 = vm.const.i32 10 : i32
      %ref_3 = vm.call @hal.allocator.allocate(%ref_0, %c48_2, %c10, %c1024) : (!vm.ref<!hal.allocator>, i32, i32, i32) -> !vm.ref<!hal.buffer>
      %c17 = vm.const.i32 17 : i32
      %c3_4 = vm.const.i32 3 : i32
      %ref_5 = vm.call @hal.command_buffer.create(%ref, %c17, %c3_4) : (!vm.ref<!hal.device>, i32, i32) -> !vm.ref<!hal.command_buffer>
      vm.call @hal.command_buffer.begin(%ref_5) : (!vm.ref<!hal.command_buffer>) -> ()
      %_executable_layout_0 = vm.global.load.ref @_executable_layout_0 : !vm.ref<!hal.executable_layout>
      vm.call.variadic @hal.command_buffer.push_descriptor_set(%ref_5, %_executable_layout_0, %zero, [(%zero, %_const_pool_storage_buffer, %c512, %c401408), (%c1, %arg0, %zero, %c3136), (%c2, %ref_3, %zero, %c512)]) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable_layout>, i32, tuple<i32, !vm.ref<!hal.buffer>, i32, i32> ...)
      %_device_match_id_0 = vm.global.load.i32 @_device_match_id_0 : i32
      vm.cond_br %_device_match_id_0, ^bb1, ^bb2
    ^bb1:  // pred: ^bb0
      %_executable_mnist_linked_llvm_aot = vm.global.load.ref @_executable_mnist_linked_llvm_aot : !vm.ref<!hal.executable>
      %zero_6 = vm.const.i32.zero : i32
      vm.call @hal.command_buffer.dispatch(%ref_5, %_executable_mnist_linked_llvm_aot, %zero_6, %c2, %c1, %c1) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable>, i32, i32, i32, i32) -> ()
      %c20 = vm.const.i32 20 : i32
      %c5 = vm.const.i32 5 : i32
      %zero_7 = vm.const.i32.zero : i32
      vm.call @hal.command_buffer.execution_barrier(%ref_5, %c20, %c5, %zero_7) : (!vm.ref<!hal.command_buffer>, i32, i32, i32) -> ()
      vm.call.variadic @hal.command_buffer.push_descriptor_set(%ref_5, %_executable_layout_0, %zero, [(%zero, %_const_pool_storage_buffer, %zero, %c512), (%c1, %ref_3, %zero, %c512), (%c2, %ref_3, %c512, %c512)]) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable_layout>, i32, tuple<i32, !vm.ref<!hal.buffer>, i32, i32> ...)
      %c1_8 = vm.const.i32 1 : i32
      vm.call @hal.command_buffer.dispatch(%ref_5, %_executable_mnist_linked_llvm_aot, %c1_8, %c1, %c1, %c1) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable>, i32, i32, i32, i32) -> ()
      %c20_9 = vm.const.i32 20 : i32
      %c5_10 = vm.const.i32 5 : i32
      %zero_11 = vm.const.i32.zero : i32
      vm.call @hal.command_buffer.execution_barrier(%ref_5, %c20_9, %c5_10, %zero_11) : (!vm.ref<!hal.command_buffer>, i32, i32, i32) -> ()
      vm.call.variadic @hal.command_buffer.push_descriptor_set(%ref_5, %_executable_layout_0, %zero, [(%zero, %_const_pool_storage_buffer, %c401920, %c5120), (%c1, %ref_3, %c512, %c512), (%c2, %ref_3, %zero, %c40)]) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable_layout>, i32, tuple<i32, !vm.ref<!hal.buffer>, i32, i32> ...)
      %c2_12 = vm.const.i32 2 : i32
      vm.call @hal.command_buffer.dispatch(%ref_5, %_executable_mnist_linked_llvm_aot, %c2_12, %c1, %c1, %c1) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable>, i32, i32, i32, i32) -> ()
      %c20_13 = vm.const.i32 20 : i32
      %c5_14 = vm.const.i32 5 : i32
      %zero_15 = vm.const.i32.zero : i32
      vm.call @hal.command_buffer.execution_barrier(%ref_5, %c20_13, %c5_14, %zero_15) : (!vm.ref<!hal.command_buffer>, i32, i32, i32) -> ()
      %_executable_layout_1 = vm.global.load.ref @_executable_layout_1 : !vm.ref<!hal.executable_layout>
      vm.call.variadic @hal.command_buffer.push_descriptor_set(%ref_5, %_executable_layout_1, %zero, [(%zero, %ref_3, %zero, %c40), (%c1, %ref_3, %c48, %c40)]) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable_layout>, i32, tuple<i32, !vm.ref<!hal.buffer>, i32, i32> ...)
      %c3_16 = vm.const.i32 3 : i32
      vm.call @hal.command_buffer.dispatch(%ref_5, %_executable_mnist_linked_llvm_aot, %c3_16, %c1, %c1, %c1) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable>, i32, i32, i32, i32) -> ()
      %c20_17 = vm.const.i32 20 : i32
      %c5_18 = vm.const.i32 5 : i32
      %zero_19 = vm.const.i32.zero : i32
      vm.call @hal.command_buffer.execution_barrier(%ref_5, %c20_17, %c5_18, %zero_19) : (!vm.ref<!hal.command_buffer>, i32, i32, i32) -> ()
      vm.call.variadic @hal.command_buffer.push_descriptor_set(%ref_5, %_executable_layout_1, %zero, [(%zero, %ref_3, %c48, %c40), (%c1, %ref_3, %c96, %c4)]) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable_layout>, i32, tuple<i32, !vm.ref<!hal.buffer>, i32, i32> ...)
      %c4_20 = vm.const.i32 4 : i32
      vm.call @hal.command_buffer.dispatch(%ref_5, %_executable_mnist_linked_llvm_aot, %c4_20, %c1, %c1, %c1) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable>, i32, i32, i32, i32) -> ()
      %c20_21 = vm.const.i32 20 : i32
      %c5_22 = vm.const.i32 5 : i32
      %zero_23 = vm.const.i32.zero : i32
      vm.call @hal.command_buffer.execution_barrier(%ref_5, %c20_21, %c5_22, %zero_23) : (!vm.ref<!hal.command_buffer>, i32, i32, i32) -> ()
      vm.call.variadic @hal.command_buffer.push_descriptor_set(%ref_5, %_executable_layout_0, %zero, [(%zero, %ref_3, %zero, %c40), (%c1, %ref_3, %c96, %c4), (%c2, %ref_3, %c48, %c40)]) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable_layout>, i32, tuple<i32, !vm.ref<!hal.buffer>, i32, i32> ...)
      %c5_24 = vm.const.i32 5 : i32
      vm.call @hal.command_buffer.dispatch(%ref_5, %_executable_mnist_linked_llvm_aot, %c5_24, %c1, %c1, %c1) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable>, i32, i32, i32, i32) -> ()
      %c20_25 = vm.const.i32 20 : i32
      %c5_26 = vm.const.i32 5 : i32
      %zero_27 = vm.const.i32.zero : i32
      vm.call @hal.command_buffer.execution_barrier(%ref_5, %c20_25, %c5_26, %zero_27) : (!vm.ref<!hal.command_buffer>, i32, i32, i32) -> ()
      vm.call.variadic @hal.command_buffer.push_descriptor_set(%ref_5, %_executable_layout_1, %zero, [(%zero, %ref_3, %c48, %c40), (%c1, %ref_3, %c112, %c4)]) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable_layout>, i32, tuple<i32, !vm.ref<!hal.buffer>, i32, i32> ...)
      %c6 = vm.const.i32 6 : i32
      vm.call @hal.command_buffer.dispatch(%ref_5, %_executable_mnist_linked_llvm_aot, %c6, %c1, %c1, %c1) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable>, i32, i32, i32, i32) -> ()
      %c20_28 = vm.const.i32 20 : i32
      %c5_29 = vm.const.i32 5 : i32
      %zero_30 = vm.const.i32.zero : i32
      vm.call @hal.command_buffer.execution_barrier(%ref_5, %c20_28, %c5_29, %zero_30) : (!vm.ref<!hal.command_buffer>, i32, i32, i32) -> ()
      %_executable_layout_2 = vm.global.load.ref @_executable_layout_2 : !vm.ref<!hal.executable_layout>
      vm.call.variadic @hal.command_buffer.push_descriptor_set(%ref_5, %_executable_layout_2, %zero, [(%zero, %ref_3, %zero, %c40), (%c1, %ref_3, %c96, %c4), (%c2, %ref_3, %c112, %c4), (%c3, %ref_1, %zero, %c40)]) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable_layout>, i32, tuple<i32, !vm.ref<!hal.buffer>, i32, i32> ...)
      %c7 = vm.const.i32 7 : i32
      vm.call @hal.command_buffer.dispatch(%ref_5, %_executable_mnist_linked_llvm_aot, %c7, %c1, %c1, %c1) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable>, i32, i32, i32, i32) -> ()
      %c20_31 = vm.const.i32 20 : i32
      %c5_32 = vm.const.i32 5 : i32
      %zero_33 = vm.const.i32.zero : i32
      vm.call @hal.command_buffer.execution_barrier(%ref_5, %c20_31, %c5_32, %zero_33) : (!vm.ref<!hal.command_buffer>, i32, i32, i32) -> ()
      vm.call @hal.command_buffer.end(%ref_5) : (!vm.ref<!hal.command_buffer>) -> ()
      vm.call @hal.ex.submit_and_wait(%ref, %ref_5) : (!vm.ref<!hal.device>, !vm.ref<!hal.command_buffer>) -> ()
      vm.return %ref_1 : !vm.ref<!hal.buffer>
    ^bb2:  // pred: ^bb0
      %c2_34 = vm.const.i32 2 : i32
      vm.fail %c2_34, "device not supported in the compiled configuration"
    }
    vm.func @predict$async(%arg0: !vm.ref<!hal.semaphore>, %arg1: i32, %arg2: !vm.ref<!hal.buffer_view>, %arg3: !vm.ref<!hal.semaphore>, %arg4: i32) -> !vm.ref<!hal.buffer_view> {
      %c1 = vm.const.i32 1 : i32
      %c10 = vm.const.i32 10 : i32
      %c50331680 = vm.const.i32 50331680 : i32
      %0 = vm.call @hal.semaphore.await(%arg0, %arg1) : (!vm.ref<!hal.semaphore>, i32) -> i32
      vm.cond_fail %0, "semaphore wait failed"
      %ref = vm.call @hal.buffer_view.buffer(%arg2) : (!vm.ref<!hal.buffer_view>) -> !vm.ref<!hal.buffer>
      %ref_0 = vm.call @predict(%ref) : (!vm.ref<!hal.buffer>) -> !vm.ref<!hal.buffer>
      %ref_1 = vm.call.variadic @hal.buffer_view.create(%ref_0, %c50331680, [%c1, %c10]) : (!vm.ref<!hal.buffer>, i32, i32 ...) -> !vm.ref<!hal.buffer_view>
      vm.call @hal.semaphore.signal(%arg3, %arg4) : (!vm.ref<!hal.semaphore>, i32) -> ()
      vm.return %ref_1 : !vm.ref<!hal.buffer_view>
    }
    vm.export @predict$async
    vm.import @hal.ex.shared_device() -> !vm.ref<!hal.device> attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.ex.submit_and_wait(%device : !vm.ref<!hal.device>, %command_buffer : !vm.ref<!hal.command_buffer>) attributes {sym_visibility = "private"}
    vm.import @hal.allocator.allocate(%allocator : !vm.ref<!hal.allocator>, %memory_types : i32, %buffer_usage : i32, %allocation_size : i32) -> !vm.ref<!hal.buffer> attributes {sym_visibility = "private"}
    vm.import @hal.allocator.wrap.byte_buffer(%allocator : !vm.ref<!hal.allocator>, %memory_types : i32, %buffer_usage : i32, %source : !vm.buffer, %offset : i32, %length : i32) -> !vm.ref<!hal.buffer> attributes {sym_visibility = "private"}
    vm.import @hal.buffer.allocator(%buffer : !vm.ref<!hal.buffer>) -> !vm.ref<!hal.allocator> attributes {sym_visibility = "private"}
    vm.import @hal.buffer.subspan(%source_buffer : !vm.ref<!hal.buffer>, %source_offset : i32, %length : i32) -> !vm.ref<!hal.buffer> attributes {sym_visibility = "private"}
    vm.import @hal.buffer.load(%source_buffer : !vm.ref<!hal.buffer>, %source_offset : i32, %length : i32) -> i32 attributes {sym_visibility = "private"}
    vm.import @hal.buffer.store(%value : i32, %target_buffer : !vm.ref<!hal.buffer>, %target_offset : i32, %length : i32) attributes {sym_visibility = "private"}
    vm.import @hal.buffer_view.create(%buffer : !vm.ref<!hal.buffer>, %element_type : i32, %shape : i32 ...) -> !vm.ref<!hal.buffer_view> attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.buffer_view.buffer(%buffer_view : !vm.ref<!hal.buffer_view>) -> !vm.ref<!hal.buffer> attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.buffer_view.byte_length(%buffer_view : !vm.ref<!hal.buffer_view>) -> i32 attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.buffer_view.element_type(%buffer_view : !vm.ref<!hal.buffer_view>) -> i32 attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.buffer_view.rank(%buffer_view : !vm.ref<!hal.buffer_view>) -> i32 attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.buffer_view.dim(%buffer_view : !vm.ref<!hal.buffer_view>, %index : i32) -> i32 attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.buffer_view.trace(%key : !vm.buffer, %operands : !vm.ref<!hal.buffer_view> ...) attributes {sym_visibility = "private"}
    vm.import @hal.command_buffer.create(%device : !vm.ref<!hal.device>, %modes : i32, %command_categories : i32) -> !vm.ref<!hal.command_buffer> attributes {sym_visibility = "private"}
    vm.import @hal.command_buffer.begin(%command_buffer : !vm.ref<!hal.command_buffer>) attributes {sym_visibility = "private"}
    vm.import @hal.command_buffer.end(%command_buffer : !vm.ref<!hal.command_buffer>) attributes {sym_visibility = "private"}
    vm.import @hal.command_buffer.execution_barrier(%command_buffer : !vm.ref<!hal.command_buffer>, %source_stage_mask : i32, %target_stage_mask : i32, %flags : i32) attributes {sym_visibility = "private"}
    vm.import @hal.command_buffer.fill_buffer(%command_buffer : !vm.ref<!hal.command_buffer>, %target_buffer : !vm.ref<!hal.buffer>, %target_offset : i32, %length : i32, %pattern : i32) attributes {sym_visibility = "private"}
    vm.import @hal.command_buffer.copy_buffer(%command_buffer : !vm.ref<!hal.command_buffer>, %source_buffer : !vm.ref<!hal.buffer>, %source_offset : i32, %target_buffer : !vm.ref<!hal.buffer>, %target_offset : i32, %length : i32) attributes {sym_visibility = "private"}
    vm.import @hal.command_buffer.push_constants(%command_buffer : !vm.ref<!hal.command_buffer>, %executable_layout : !vm.ref<!hal.executable_layout>, %offset : i32, %values : i32 ...) attributes {sym_visibility = "private"}
    vm.import @hal.command_buffer.push_descriptor_set(%command_buffer : !vm.ref<!hal.command_buffer>, %executable_layout : !vm.ref<!hal.executable_layout>, %set : i32, %bindings : tuple<i32, !vm.ref<!hal.buffer>, i32, i32> ...) attributes {sym_visibility = "private"}
    vm.import @hal.command_buffer.bind_descriptor_set(%command_buffer : !vm.ref<!hal.command_buffer>, %executable_layout : !vm.ref<!hal.executable_layout>, %set : i32, %descriptor_set : !vm.ref<!hal.descriptor_set>, %dynamic_offsets : i32 ...) attributes {sym_visibility = "private"}
    vm.import @hal.command_buffer.dispatch(%command_buffer : !vm.ref<!hal.command_buffer>, %executable : !vm.ref<!hal.executable>, %entry_point : i32, %workgroup_x : i32, %workgroup_y : i32, %workgroup_z : i32) attributes {sym_visibility = "private"}
    vm.import @hal.command_buffer.dispatch.indirect(%command_buffer : !vm.ref<!hal.command_buffer>, %executable : !vm.ref<!hal.executable>, %entry_point : i32, %workgroups_buffer : !vm.ref<!hal.buffer>, %workgroups_offset : i32) attributes {sym_visibility = "private"}
    vm.import @hal.descriptor_set.create(%device : !vm.ref<!hal.device>, %set_layout : !vm.ref<!hal.descriptor_set_layout>, %bindings : tuple<i32, !vm.ref<!hal.buffer>, i32, i32> ...) -> !vm.ref<!hal.descriptor_set> attributes {sym_visibility = "private"}
    vm.import @hal.descriptor_set_layout.create(%device : !vm.ref<!hal.device>, %usage_type : i32, %bindings : tuple<i32, i32, i32> ...) -> !vm.ref<!hal.descriptor_set_layout> attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.device.allocator(%device : !vm.ref<!hal.device>) -> !vm.ref<!hal.allocator> attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.device.query.i32(%device : !vm.ref<!hal.device>, %key : !vm.buffer) -> (i32, i32) attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.device.match.id(%device : !vm.ref<!hal.device>, %pattern : !vm.buffer) -> i32 attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.executable.create(%device : !vm.ref<!hal.device>, %executable_format : !vm.buffer, %executable_data : !vm.buffer, %executable_layouts : !vm.ref<!hal.executable_layout> ...) -> !vm.ref<!hal.executable> attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.executable_layout.create(%device : !vm.ref<!hal.device>, %push_constants : i32, %set_layouts : !vm.ref<!hal.descriptor_set_layout> ...) -> !vm.ref<!hal.executable_layout> attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.semaphore.create(%device : !vm.ref<!hal.device>, %initial_value : i32) -> !vm.ref<!hal.semaphore> attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.semaphore.query(%semaphore : !vm.ref<!hal.semaphore>) -> (i32, i32) attributes {sym_visibility = "private"}
    vm.import @hal.semaphore.signal(%semaphore : !vm.ref<!hal.semaphore>, %new_value : i32) attributes {sym_visibility = "private"}
    vm.import @hal.semaphore.fail(%semaphore : !vm.ref<!hal.semaphore>, %status : i32) attributes {sym_visibility = "private"}
    vm.import @hal.semaphore.await(%semaphore : !vm.ref<!hal.semaphore>, %min_value : i32) -> i32 attributes {sym_visibility = "private"}
    vm.func @predict$sync(%arg0: !vm.ref<!hal.buffer_view>) -> !vm.ref<!hal.buffer_view> attributes {iree.reflection = {abi = "sip", abiv = 1 : i32, f = "I15!B11!d1d28d28d1R9!B6!d1d10", fv = "1", sip = "I8!S5!k0_0R3!_0"}} {
      %zero = vm.const.i32.zero : i32
      %c1 = vm.const.i32 1 : i32
      %ref = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
      %ref_0 = vm.call @hal.semaphore.create(%ref, %zero) : (!vm.ref<!hal.device>, i32) -> !vm.ref<!hal.semaphore>
      %ref_1 = vm.call @predict$async(%ref_0, %zero, %arg0, %ref_0, %c1) : (!vm.ref<!hal.semaphore>, i32, !vm.ref<!hal.buffer_view>, !vm.ref<!hal.semaphore>, i32) -> !vm.ref<!hal.buffer_view>
      %0 = vm.call @hal.semaphore.await(%ref_0, %c1) : (!vm.ref<!hal.semaphore>, i32) -> i32
      vm.cond_fail %0, "semaphore wait failed"
      vm.return %ref_1 : !vm.ref<!hal.buffer_view>
    }
    vm.export @predict$sync as("predict")
  }
}


// *** IR Dump After mlir::iree_compiler::IREE::VM::HoistInlinedRodataPass ***
vm.module @module {
  vm.global.i32 @_device_match_id_0 init(@_device_match_id_0_initializer) : i32
  vm.rodata @_utf8_dylib_971286B245550E6D dense<[100, 121, 108, 105, 98, 42]> : vector<6xi8>
  vm.func private @_device_match_id_0_initializer() -> i32 {
    %ref = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
    %_utf8_dylib_971286B245550E6D = vm.const.ref.rodata @_utf8_dylib_971286B245550E6D : !vm.buffer
    %0 = vm.call @hal.device.match.id(%ref, %_utf8_dylib_971286B245550E6D) : (!vm.ref<!hal.device>, !vm.buffer) -> i32
    vm.return %0 : i32
  }
  vm.global.ref @_descriptor_set_layout_0 init(@_descriptor_set_layout_0_initializer) : !vm.ref<!hal.descriptor_set_layout>
  vm.func private @_descriptor_set_layout_0_initializer() -> !vm.ref<!hal.descriptor_set_layout> {
    %ref = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
    %c1 = vm.const.i32 1 : i32
    %zero = vm.const.i32.zero : i32
    %c7 = vm.const.i32 7 : i32
    %c1_0 = vm.const.i32 1 : i32
    %c1_1 = vm.const.i32 1 : i32
    %c7_2 = vm.const.i32 7 : i32
    %c1_3 = vm.const.i32 1 : i32
    %c2 = vm.const.i32 2 : i32
    %c7_4 = vm.const.i32 7 : i32
    %c6 = vm.const.i32 6 : i32
    %ref_5 = vm.call.variadic @hal.descriptor_set_layout.create(%ref, %c1, [(%zero, %c7, %c1_0), (%c1_1, %c7_2, %c1_3), (%c2, %c7_4, %c6)]) : (!vm.ref<!hal.device>, i32, tuple<i32, i32, i32> ...) -> !vm.ref<!hal.descriptor_set_layout>
    vm.return %ref_5 : !vm.ref<!hal.descriptor_set_layout>
  }
  vm.global.ref @_executable_layout_0 init(@_executable_layout_0_initializer) : !vm.ref<!hal.executable_layout>
  vm.func private @_executable_layout_0_initializer() -> !vm.ref<!hal.executable_layout> {
    %_descriptor_set_layout_0 = vm.global.load.ref @_descriptor_set_layout_0 : !vm.ref<!hal.descriptor_set_layout>
    %ref = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
    %zero = vm.const.i32.zero : i32
    %ref_0 = vm.call.variadic @hal.executable_layout.create(%ref, %zero, [%_descriptor_set_layout_0]) : (!vm.ref<!hal.device>, i32, !vm.ref<!hal.descriptor_set_layout> ...) -> !vm.ref<!hal.executable_layout>
    vm.return %ref_0 : !vm.ref<!hal.executable_layout>
  }
  vm.global.ref @_descriptor_set_layout_1 init(@_descriptor_set_layout_1_initializer) : !vm.ref<!hal.descriptor_set_layout>
  vm.func private @_descriptor_set_layout_1_initializer() -> !vm.ref<!hal.descriptor_set_layout> {
    %ref = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
    %c1 = vm.const.i32 1 : i32
    %zero = vm.const.i32.zero : i32
    %c7 = vm.const.i32 7 : i32
    %c1_0 = vm.const.i32 1 : i32
    %c1_1 = vm.const.i32 1 : i32
    %c7_2 = vm.const.i32 7 : i32
    %c6 = vm.const.i32 6 : i32
    %ref_3 = vm.call.variadic @hal.descriptor_set_layout.create(%ref, %c1, [(%zero, %c7, %c1_0), (%c1_1, %c7_2, %c6)]) : (!vm.ref<!hal.device>, i32, tuple<i32, i32, i32> ...) -> !vm.ref<!hal.descriptor_set_layout>
    vm.return %ref_3 : !vm.ref<!hal.descriptor_set_layout>
  }
  vm.global.ref @_executable_layout_1 init(@_executable_layout_1_initializer) : !vm.ref<!hal.executable_layout>
  vm.func private @_executable_layout_1_initializer() -> !vm.ref<!hal.executable_layout> {
    %_descriptor_set_layout_1 = vm.global.load.ref @_descriptor_set_layout_1 : !vm.ref<!hal.descriptor_set_layout>
    %ref = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
    %zero = vm.const.i32.zero : i32
    %ref_0 = vm.call.variadic @hal.executable_layout.create(%ref, %zero, [%_descriptor_set_layout_1]) : (!vm.ref<!hal.device>, i32, !vm.ref<!hal.descriptor_set_layout> ...) -> !vm.ref<!hal.executable_layout>
    vm.return %ref_0 : !vm.ref<!hal.executable_layout>
  }
  vm.global.ref @_descriptor_set_layout_2 init(@_descriptor_set_layout_2_initializer) : !vm.ref<!hal.descriptor_set_layout>
  vm.func private @_descriptor_set_layout_2_initializer() -> !vm.ref<!hal.descriptor_set_layout> {
    %ref = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
    %c1 = vm.const.i32 1 : i32
    %zero = vm.const.i32.zero : i32
    %c7 = vm.const.i32 7 : i32
    %c1_0 = vm.const.i32 1 : i32
    %c1_1 = vm.const.i32 1 : i32
    %c7_2 = vm.const.i32 7 : i32
    %c1_3 = vm.const.i32 1 : i32
    %c2 = vm.const.i32 2 : i32
    %c7_4 = vm.const.i32 7 : i32
    %c1_5 = vm.const.i32 1 : i32
    %c3 = vm.const.i32 3 : i32
    %c7_6 = vm.const.i32 7 : i32
    %c6 = vm.const.i32 6 : i32
    %ref_7 = vm.call.variadic @hal.descriptor_set_layout.create(%ref, %c1, [(%zero, %c7, %c1_0), (%c1_1, %c7_2, %c1_3), (%c2, %c7_4, %c1_5), (%c3, %c7_6, %c6)]) : (!vm.ref<!hal.device>, i32, tuple<i32, i32, i32> ...) -> !vm.ref<!hal.descriptor_set_layout>
    vm.return %ref_7 : !vm.ref<!hal.descriptor_set_layout>
  }
  vm.global.ref @_executable_layout_2 init(@_executable_layout_2_initializer) : !vm.ref<!hal.executable_layout>
  vm.func private @_executable_layout_2_initializer() -> !vm.ref<!hal.executable_layout> {
    %_descriptor_set_layout_2 = vm.global.load.ref @_descriptor_set_layout_2 : !vm.ref<!hal.descriptor_set_layout>
    %ref = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
    %zero = vm.const.i32.zero : i32
    %ref_0 = vm.call.variadic @hal.executable_layout.create(%ref, %zero, [%_descriptor_set_layout_2]) : (!vm.ref<!hal.device>, i32, !vm.ref<!hal.descriptor_set_layout> ...) -> !vm.ref<!hal.executable_layout>
    vm.return %ref_0 : !vm.ref<!hal.executable_layout>
  }
  vm.global.ref @_executable_mnist_linked_llvm_aot init(@_executable_mnist_linked_llvm_aot_initializer) : !vm.ref<!hal.executable>
  vm.rodata @_mnist_linked_llvm_aot_llvm_aot_binary_dlib opaque<"_", "0xDEADBEEF"> : vector<136794xi8>
  vm.rodata @_utf8_dlib_F45B9BA87AEFAACB dense<[68, 76, 73, 66]> : vector<4xi8>
  vm.func private @_executable_mnist_linked_llvm_aot_initializer() -> !vm.ref<!hal.executable> {
    %ref = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
    %_device_match_id_0 = vm.global.load.i32 @_device_match_id_0 : i32
    vm.cond_br %_device_match_id_0, ^bb1, ^bb2
  ^bb1:  // pred: ^bb0
    %_executable_layout_0 = vm.global.load.ref @_executable_layout_0 : !vm.ref<!hal.executable_layout>
    %_executable_layout_1 = vm.global.load.ref @_executable_layout_1 : !vm.ref<!hal.executable_layout>
    %_executable_layout_2 = vm.global.load.ref @_executable_layout_2 : !vm.ref<!hal.executable_layout>
    %_utf8_dlib_F45B9BA87AEFAACB = vm.const.ref.rodata @_utf8_dlib_F45B9BA87AEFAACB : !vm.buffer
    %_mnist_linked_llvm_aot_llvm_aot_binary_dlib = vm.const.ref.rodata @_mnist_linked_llvm_aot_llvm_aot_binary_dlib : !vm.buffer
    %ref_0 = vm.call.variadic @hal.executable.create(%ref, %_utf8_dlib_F45B9BA87AEFAACB, %_mnist_linked_llvm_aot_llvm_aot_binary_dlib, [%_executable_layout_0, %_executable_layout_0, %_executable_layout_0, %_executable_layout_1, %_executable_layout_1, %_executable_layout_0, %_executable_layout_1, %_executable_layout_2]) : (!vm.ref<!hal.device>, !vm.buffer, !vm.buffer, !vm.ref<!hal.executable_layout> ...) -> !vm.ref<!hal.executable>
    vm.br ^bb3(%ref_0 : !vm.ref<!hal.executable>)
  ^bb2:  // pred: ^bb0
    %null = vm.const.ref.zero : !vm.ref<!hal.executable>
    vm.br ^bb3(%null : !vm.ref<!hal.executable>)
  ^bb3(%0: !vm.ref<!hal.executable>):  // 2 preds: ^bb1, ^bb2
    vm.return %0 : !vm.ref<!hal.executable>
  }
  vm.rodata @_const_pool_storage opaque<"_", "0xDEADBEEF"> : vector<407040xi8>
  vm.global.ref @_const_pool_storage_buffer init(@_const_pool_storage_buffer_initializer) : !vm.ref<!hal.buffer>
  vm.func private @_const_pool_storage_buffer_initializer() -> !vm.ref<!hal.buffer> {
    %zero = vm.const.i32.zero : i32
    %c407040 = vm.const.i32 407040 : i32
    %ref = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
    %ref_0 = vm.call @hal.device.allocator(%ref) : (!vm.ref<!hal.device>) -> !vm.ref<!hal.allocator>
    %_const_pool_storage = vm.const.ref.rodata @_const_pool_storage : !vm.buffer
    %c50 = vm.const.i32 50 : i32
    %c15 = vm.const.i32 15 : i32
    %ref_1 = vm.call @hal.allocator.wrap.byte_buffer(%ref_0, %c50, %c15, %_const_pool_storage, %zero, %c407040) : (!vm.ref<!hal.allocator>, i32, i32, !vm.buffer, i32, i32) -> !vm.ref<!hal.buffer>
    vm.return %ref_1 : !vm.ref<!hal.buffer>
  }
  vm.func @predict(%arg0: !vm.ref<!hal.buffer>) -> !vm.ref<!hal.buffer> attributes {noinline} {
    %c3136 = vm.const.i32 3136 : i32
    %c401408 = vm.const.i32 401408 : i32
    %c401920 = vm.const.i32 401920 : i32
    %c5120 = vm.const.i32 5120 : i32
    %c40 = vm.const.i32 40 : i32
    %c4 = vm.const.i32 4 : i32
    %c3 = vm.const.i32 3 : i32
    %zero = vm.const.i32.zero : i32
    %c512 = vm.const.i32 512 : i32
    %c96 = vm.const.i32 96 : i32
    %c48 = vm.const.i32 48 : i32
    %c112 = vm.const.i32 112 : i32
    %c1024 = vm.const.i32 1024 : i32
    %c2 = vm.const.i32 2 : i32
    %c1 = vm.const.i32 1 : i32
    %ref = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
    %ref_0 = vm.call @hal.device.allocator(%ref) : (!vm.ref<!hal.device>) -> !vm.ref<!hal.allocator>
    %c50 = vm.const.i32 50 : i32
    %c14 = vm.const.i32 14 : i32
    %ref_1 = vm.call @hal.allocator.allocate(%ref_0, %c50, %c14, %c40) : (!vm.ref<!hal.allocator>, i32, i32, i32) -> !vm.ref<!hal.buffer>
    %_const_pool_storage_buffer = vm.global.load.ref @_const_pool_storage_buffer : !vm.ref<!hal.buffer>
    %c48_2 = vm.const.i32 48 : i32
    %c10 = vm.const.i32 10 : i32
    %ref_3 = vm.call @hal.allocator.allocate(%ref_0, %c48_2, %c10, %c1024) : (!vm.ref<!hal.allocator>, i32, i32, i32) -> !vm.ref<!hal.buffer>
    %c17 = vm.const.i32 17 : i32
    %c3_4 = vm.const.i32 3 : i32
    %ref_5 = vm.call @hal.command_buffer.create(%ref, %c17, %c3_4) : (!vm.ref<!hal.device>, i32, i32) -> !vm.ref<!hal.command_buffer>
    vm.call @hal.command_buffer.begin(%ref_5) : (!vm.ref<!hal.command_buffer>) -> ()
    %_executable_layout_0 = vm.global.load.ref @_executable_layout_0 : !vm.ref<!hal.executable_layout>
    vm.call.variadic @hal.command_buffer.push_descriptor_set(%ref_5, %_executable_layout_0, %zero, [(%zero, %_const_pool_storage_buffer, %c512, %c401408), (%c1, %arg0, %zero, %c3136), (%c2, %ref_3, %zero, %c512)]) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable_layout>, i32, tuple<i32, !vm.ref<!hal.buffer>, i32, i32> ...)
    %_device_match_id_0 = vm.global.load.i32 @_device_match_id_0 : i32
    vm.cond_br %_device_match_id_0, ^bb1, ^bb2
  ^bb1:  // pred: ^bb0
    %_executable_mnist_linked_llvm_aot = vm.global.load.ref @_executable_mnist_linked_llvm_aot : !vm.ref<!hal.executable>
    %zero_6 = vm.const.i32.zero : i32
    vm.call @hal.command_buffer.dispatch(%ref_5, %_executable_mnist_linked_llvm_aot, %zero_6, %c2, %c1, %c1) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable>, i32, i32, i32, i32) -> ()
    %c20 = vm.const.i32 20 : i32
    %c5 = vm.const.i32 5 : i32
    %zero_7 = vm.const.i32.zero : i32
    vm.call @hal.command_buffer.execution_barrier(%ref_5, %c20, %c5, %zero_7) : (!vm.ref<!hal.command_buffer>, i32, i32, i32) -> ()
    vm.call.variadic @hal.command_buffer.push_descriptor_set(%ref_5, %_executable_layout_0, %zero, [(%zero, %_const_pool_storage_buffer, %zero, %c512), (%c1, %ref_3, %zero, %c512), (%c2, %ref_3, %c512, %c512)]) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable_layout>, i32, tuple<i32, !vm.ref<!hal.buffer>, i32, i32> ...)
    %c1_8 = vm.const.i32 1 : i32
    vm.call @hal.command_buffer.dispatch(%ref_5, %_executable_mnist_linked_llvm_aot, %c1_8, %c1, %c1, %c1) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable>, i32, i32, i32, i32) -> ()
    %c20_9 = vm.const.i32 20 : i32
    %c5_10 = vm.const.i32 5 : i32
    %zero_11 = vm.const.i32.zero : i32
    vm.call @hal.command_buffer.execution_barrier(%ref_5, %c20_9, %c5_10, %zero_11) : (!vm.ref<!hal.command_buffer>, i32, i32, i32) -> ()
    vm.call.variadic @hal.command_buffer.push_descriptor_set(%ref_5, %_executable_layout_0, %zero, [(%zero, %_const_pool_storage_buffer, %c401920, %c5120), (%c1, %ref_3, %c512, %c512), (%c2, %ref_3, %zero, %c40)]) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable_layout>, i32, tuple<i32, !vm.ref<!hal.buffer>, i32, i32> ...)
    %c2_12 = vm.const.i32 2 : i32
    vm.call @hal.command_buffer.dispatch(%ref_5, %_executable_mnist_linked_llvm_aot, %c2_12, %c1, %c1, %c1) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable>, i32, i32, i32, i32) -> ()
    %c20_13 = vm.const.i32 20 : i32
    %c5_14 = vm.const.i32 5 : i32
    %zero_15 = vm.const.i32.zero : i32
    vm.call @hal.command_buffer.execution_barrier(%ref_5, %c20_13, %c5_14, %zero_15) : (!vm.ref<!hal.command_buffer>, i32, i32, i32) -> ()
    %_executable_layout_1 = vm.global.load.ref @_executable_layout_1 : !vm.ref<!hal.executable_layout>
    vm.call.variadic @hal.command_buffer.push_descriptor_set(%ref_5, %_executable_layout_1, %zero, [(%zero, %ref_3, %zero, %c40), (%c1, %ref_3, %c48, %c40)]) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable_layout>, i32, tuple<i32, !vm.ref<!hal.buffer>, i32, i32> ...)
    %c3_16 = vm.const.i32 3 : i32
    vm.call @hal.command_buffer.dispatch(%ref_5, %_executable_mnist_linked_llvm_aot, %c3_16, %c1, %c1, %c1) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable>, i32, i32, i32, i32) -> ()
    %c20_17 = vm.const.i32 20 : i32
    %c5_18 = vm.const.i32 5 : i32
    %zero_19 = vm.const.i32.zero : i32
    vm.call @hal.command_buffer.execution_barrier(%ref_5, %c20_17, %c5_18, %zero_19) : (!vm.ref<!hal.command_buffer>, i32, i32, i32) -> ()
    vm.call.variadic @hal.command_buffer.push_descriptor_set(%ref_5, %_executable_layout_1, %zero, [(%zero, %ref_3, %c48, %c40), (%c1, %ref_3, %c96, %c4)]) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable_layout>, i32, tuple<i32, !vm.ref<!hal.buffer>, i32, i32> ...)
    %c4_20 = vm.const.i32 4 : i32
    vm.call @hal.command_buffer.dispatch(%ref_5, %_executable_mnist_linked_llvm_aot, %c4_20, %c1, %c1, %c1) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable>, i32, i32, i32, i32) -> ()
    %c20_21 = vm.const.i32 20 : i32
    %c5_22 = vm.const.i32 5 : i32
    %zero_23 = vm.const.i32.zero : i32
    vm.call @hal.command_buffer.execution_barrier(%ref_5, %c20_21, %c5_22, %zero_23) : (!vm.ref<!hal.command_buffer>, i32, i32, i32) -> ()
    vm.call.variadic @hal.command_buffer.push_descriptor_set(%ref_5, %_executable_layout_0, %zero, [(%zero, %ref_3, %zero, %c40), (%c1, %ref_3, %c96, %c4), (%c2, %ref_3, %c48, %c40)]) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable_layout>, i32, tuple<i32, !vm.ref<!hal.buffer>, i32, i32> ...)
    %c5_24 = vm.const.i32 5 : i32
    vm.call @hal.command_buffer.dispatch(%ref_5, %_executable_mnist_linked_llvm_aot, %c5_24, %c1, %c1, %c1) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable>, i32, i32, i32, i32) -> ()
    %c20_25 = vm.const.i32 20 : i32
    %c5_26 = vm.const.i32 5 : i32
    %zero_27 = vm.const.i32.zero : i32
    vm.call @hal.command_buffer.execution_barrier(%ref_5, %c20_25, %c5_26, %zero_27) : (!vm.ref<!hal.command_buffer>, i32, i32, i32) -> ()
    vm.call.variadic @hal.command_buffer.push_descriptor_set(%ref_5, %_executable_layout_1, %zero, [(%zero, %ref_3, %c48, %c40), (%c1, %ref_3, %c112, %c4)]) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable_layout>, i32, tuple<i32, !vm.ref<!hal.buffer>, i32, i32> ...)
    %c6 = vm.const.i32 6 : i32
    vm.call @hal.command_buffer.dispatch(%ref_5, %_executable_mnist_linked_llvm_aot, %c6, %c1, %c1, %c1) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable>, i32, i32, i32, i32) -> ()
    %c20_28 = vm.const.i32 20 : i32
    %c5_29 = vm.const.i32 5 : i32
    %zero_30 = vm.const.i32.zero : i32
    vm.call @hal.command_buffer.execution_barrier(%ref_5, %c20_28, %c5_29, %zero_30) : (!vm.ref<!hal.command_buffer>, i32, i32, i32) -> ()
    %_executable_layout_2 = vm.global.load.ref @_executable_layout_2 : !vm.ref<!hal.executable_layout>
    vm.call.variadic @hal.command_buffer.push_descriptor_set(%ref_5, %_executable_layout_2, %zero, [(%zero, %ref_3, %zero, %c40), (%c1, %ref_3, %c96, %c4), (%c2, %ref_3, %c112, %c4), (%c3, %ref_1, %zero, %c40)]) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable_layout>, i32, tuple<i32, !vm.ref<!hal.buffer>, i32, i32> ...)
    %c7 = vm.const.i32 7 : i32
    vm.call @hal.command_buffer.dispatch(%ref_5, %_executable_mnist_linked_llvm_aot, %c7, %c1, %c1, %c1) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable>, i32, i32, i32, i32) -> ()
    %c20_31 = vm.const.i32 20 : i32
    %c5_32 = vm.const.i32 5 : i32
    %zero_33 = vm.const.i32.zero : i32
    vm.call @hal.command_buffer.execution_barrier(%ref_5, %c20_31, %c5_32, %zero_33) : (!vm.ref<!hal.command_buffer>, i32, i32, i32) -> ()
    vm.call @hal.command_buffer.end(%ref_5) : (!vm.ref<!hal.command_buffer>) -> ()
    vm.call @hal.ex.submit_and_wait(%ref, %ref_5) : (!vm.ref<!hal.device>, !vm.ref<!hal.command_buffer>) -> ()
    vm.return %ref_1 : !vm.ref<!hal.buffer>
  ^bb2:  // pred: ^bb0
    %c2_34 = vm.const.i32 2 : i32
    vm.fail %c2_34, "device not supported in the compiled configuration"
  }
  vm.func @predict$async(%arg0: !vm.ref<!hal.semaphore>, %arg1: i32, %arg2: !vm.ref<!hal.buffer_view>, %arg3: !vm.ref<!hal.semaphore>, %arg4: i32) -> !vm.ref<!hal.buffer_view> {
    %c1 = vm.const.i32 1 : i32
    %c10 = vm.const.i32 10 : i32
    %c50331680 = vm.const.i32 50331680 : i32
    %0 = vm.call @hal.semaphore.await(%arg0, %arg1) : (!vm.ref<!hal.semaphore>, i32) -> i32
    vm.cond_fail %0, "semaphore wait failed"
    %ref = vm.call @hal.buffer_view.buffer(%arg2) : (!vm.ref<!hal.buffer_view>) -> !vm.ref<!hal.buffer>
    %ref_0 = vm.call @predict(%ref) : (!vm.ref<!hal.buffer>) -> !vm.ref<!hal.buffer>
    %ref_1 = vm.call.variadic @hal.buffer_view.create(%ref_0, %c50331680, [%c1, %c10]) : (!vm.ref<!hal.buffer>, i32, i32 ...) -> !vm.ref<!hal.buffer_view>
    vm.call @hal.semaphore.signal(%arg3, %arg4) : (!vm.ref<!hal.semaphore>, i32) -> ()
    vm.return %ref_1 : !vm.ref<!hal.buffer_view>
  }
  vm.export @predict$async
  vm.import @hal.ex.shared_device() -> !vm.ref<!hal.device> attributes {nosideeffects, sym_visibility = "private"}
  vm.import @hal.ex.submit_and_wait(%device : !vm.ref<!hal.device>, %command_buffer : !vm.ref<!hal.command_buffer>) attributes {sym_visibility = "private"}
  vm.import @hal.allocator.allocate(%allocator : !vm.ref<!hal.allocator>, %memory_types : i32, %buffer_usage : i32, %allocation_size : i32) -> !vm.ref<!hal.buffer> attributes {sym_visibility = "private"}
  vm.import @hal.allocator.wrap.byte_buffer(%allocator : !vm.ref<!hal.allocator>, %memory_types : i32, %buffer_usage : i32, %source : !vm.buffer, %offset : i32, %length : i32) -> !vm.ref<!hal.buffer> attributes {sym_visibility = "private"}
  vm.import @hal.buffer.allocator(%buffer : !vm.ref<!hal.buffer>) -> !vm.ref<!hal.allocator> attributes {sym_visibility = "private"}
  vm.import @hal.buffer.subspan(%source_buffer : !vm.ref<!hal.buffer>, %source_offset : i32, %length : i32) -> !vm.ref<!hal.buffer> attributes {sym_visibility = "private"}
  vm.import @hal.buffer.load(%source_buffer : !vm.ref<!hal.buffer>, %source_offset : i32, %length : i32) -> i32 attributes {sym_visibility = "private"}
  vm.import @hal.buffer.store(%value : i32, %target_buffer : !vm.ref<!hal.buffer>, %target_offset : i32, %length : i32) attributes {sym_visibility = "private"}
  vm.import @hal.buffer_view.create(%buffer : !vm.ref<!hal.buffer>, %element_type : i32, %shape : i32 ...) -> !vm.ref<!hal.buffer_view> attributes {nosideeffects, sym_visibility = "private"}
  vm.import @hal.buffer_view.buffer(%buffer_view : !vm.ref<!hal.buffer_view>) -> !vm.ref<!hal.buffer> attributes {nosideeffects, sym_visibility = "private"}
  vm.import @hal.buffer_view.byte_length(%buffer_view : !vm.ref<!hal.buffer_view>) -> i32 attributes {nosideeffects, sym_visibility = "private"}
  vm.import @hal.buffer_view.element_type(%buffer_view : !vm.ref<!hal.buffer_view>) -> i32 attributes {nosideeffects, sym_visibility = "private"}
  vm.import @hal.buffer_view.rank(%buffer_view : !vm.ref<!hal.buffer_view>) -> i32 attributes {nosideeffects, sym_visibility = "private"}
  vm.import @hal.buffer_view.dim(%buffer_view : !vm.ref<!hal.buffer_view>, %index : i32) -> i32 attributes {nosideeffects, sym_visibility = "private"}
  vm.import @hal.buffer_view.trace(%key : !vm.buffer, %operands : !vm.ref<!hal.buffer_view> ...) attributes {sym_visibility = "private"}
  vm.import @hal.command_buffer.create(%device : !vm.ref<!hal.device>, %modes : i32, %command_categories : i32) -> !vm.ref<!hal.command_buffer> attributes {sym_visibility = "private"}
  vm.import @hal.command_buffer.begin(%command_buffer : !vm.ref<!hal.command_buffer>) attributes {sym_visibility = "private"}
  vm.import @hal.command_buffer.end(%command_buffer : !vm.ref<!hal.command_buffer>) attributes {sym_visibility = "private"}
  vm.import @hal.command_buffer.execution_barrier(%command_buffer : !vm.ref<!hal.command_buffer>, %source_stage_mask : i32, %target_stage_mask : i32, %flags : i32) attributes {sym_visibility = "private"}
  vm.import @hal.command_buffer.fill_buffer(%command_buffer : !vm.ref<!hal.command_buffer>, %target_buffer : !vm.ref<!hal.buffer>, %target_offset : i32, %length : i32, %pattern : i32) attributes {sym_visibility = "private"}
  vm.import @hal.command_buffer.copy_buffer(%command_buffer : !vm.ref<!hal.command_buffer>, %source_buffer : !vm.ref<!hal.buffer>, %source_offset : i32, %target_buffer : !vm.ref<!hal.buffer>, %target_offset : i32, %length : i32) attributes {sym_visibility = "private"}
  vm.import @hal.command_buffer.push_constants(%command_buffer : !vm.ref<!hal.command_buffer>, %executable_layout : !vm.ref<!hal.executable_layout>, %offset : i32, %values : i32 ...) attributes {sym_visibility = "private"}
  vm.import @hal.command_buffer.push_descriptor_set(%command_buffer : !vm.ref<!hal.command_buffer>, %executable_layout : !vm.ref<!hal.executable_layout>, %set : i32, %bindings : tuple<i32, !vm.ref<!hal.buffer>, i32, i32> ...) attributes {sym_visibility = "private"}
  vm.import @hal.command_buffer.bind_descriptor_set(%command_buffer : !vm.ref<!hal.command_buffer>, %executable_layout : !vm.ref<!hal.executable_layout>, %set : i32, %descriptor_set : !vm.ref<!hal.descriptor_set>, %dynamic_offsets : i32 ...) attributes {sym_visibility = "private"}
  vm.import @hal.command_buffer.dispatch(%command_buffer : !vm.ref<!hal.command_buffer>, %executable : !vm.ref<!hal.executable>, %entry_point : i32, %workgroup_x : i32, %workgroup_y : i32, %workgroup_z : i32) attributes {sym_visibility = "private"}
  vm.import @hal.command_buffer.dispatch.indirect(%command_buffer : !vm.ref<!hal.command_buffer>, %executable : !vm.ref<!hal.executable>, %entry_point : i32, %workgroups_buffer : !vm.ref<!hal.buffer>, %workgroups_offset : i32) attributes {sym_visibility = "private"}
  vm.import @hal.descriptor_set.create(%device : !vm.ref<!hal.device>, %set_layout : !vm.ref<!hal.descriptor_set_layout>, %bindings : tuple<i32, !vm.ref<!hal.buffer>, i32, i32> ...) -> !vm.ref<!hal.descriptor_set> attributes {sym_visibility = "private"}
  vm.import @hal.descriptor_set_layout.create(%device : !vm.ref<!hal.device>, %usage_type : i32, %bindings : tuple<i32, i32, i32> ...) -> !vm.ref<!hal.descriptor_set_layout> attributes {nosideeffects, sym_visibility = "private"}
  vm.import @hal.device.allocator(%device : !vm.ref<!hal.device>) -> !vm.ref<!hal.allocator> attributes {nosideeffects, sym_visibility = "private"}
  vm.import @hal.device.query.i32(%device : !vm.ref<!hal.device>, %key : !vm.buffer) -> (i32, i32) attributes {nosideeffects, sym_visibility = "private"}
  vm.import @hal.device.match.id(%device : !vm.ref<!hal.device>, %pattern : !vm.buffer) -> i32 attributes {nosideeffects, sym_visibility = "private"}
  vm.import @hal.executable.create(%device : !vm.ref<!hal.device>, %executable_format : !vm.buffer, %executable_data : !vm.buffer, %executable_layouts : !vm.ref<!hal.executable_layout> ...) -> !vm.ref<!hal.executable> attributes {nosideeffects, sym_visibility = "private"}
  vm.import @hal.executable_layout.create(%device : !vm.ref<!hal.device>, %push_constants : i32, %set_layouts : !vm.ref<!hal.descriptor_set_layout> ...) -> !vm.ref<!hal.executable_layout> attributes {nosideeffects, sym_visibility = "private"}
  vm.import @hal.semaphore.create(%device : !vm.ref<!hal.device>, %initial_value : i32) -> !vm.ref<!hal.semaphore> attributes {nosideeffects, sym_visibility = "private"}
  vm.import @hal.semaphore.query(%semaphore : !vm.ref<!hal.semaphore>) -> (i32, i32) attributes {sym_visibility = "private"}
  vm.import @hal.semaphore.signal(%semaphore : !vm.ref<!hal.semaphore>, %new_value : i32) attributes {sym_visibility = "private"}
  vm.import @hal.semaphore.fail(%semaphore : !vm.ref<!hal.semaphore>, %status : i32) attributes {sym_visibility = "private"}
  vm.import @hal.semaphore.await(%semaphore : !vm.ref<!hal.semaphore>, %min_value : i32) -> i32 attributes {sym_visibility = "private"}
  vm.func @predict$sync(%arg0: !vm.ref<!hal.buffer_view>) -> !vm.ref<!hal.buffer_view> attributes {iree.reflection = {abi = "sip", abiv = 1 : i32, f = "I15!B11!d1d28d28d1R9!B6!d1d10", fv = "1", sip = "I8!S5!k0_0R3!_0"}} {
    %zero = vm.const.i32.zero : i32
    %c1 = vm.const.i32 1 : i32
    %ref = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
    %ref_0 = vm.call @hal.semaphore.create(%ref, %zero) : (!vm.ref<!hal.device>, i32) -> !vm.ref<!hal.semaphore>
    %ref_1 = vm.call @predict$async(%ref_0, %zero, %arg0, %ref_0, %c1) : (!vm.ref<!hal.semaphore>, i32, !vm.ref<!hal.buffer_view>, !vm.ref<!hal.semaphore>, i32) -> !vm.ref<!hal.buffer_view>
    %0 = vm.call @hal.semaphore.await(%ref_0, %c1) : (!vm.ref<!hal.semaphore>, i32) -> i32
    vm.cond_fail %0, "semaphore wait failed"
    vm.return %ref_1 : !vm.ref<!hal.buffer_view>
  }
  vm.export @predict$sync as("predict")
}

// *** IR Dump After mlir::iree_compiler::IREE::VM::GlobalInitializationPass ***
vm.module @module {
  vm.global.i32 @_device_match_id_0 mutable : i32
  vm.rodata @_utf8_dylib_971286B245550E6D dense<[100, 121, 108, 105, 98, 42]> : vector<6xi8>
  vm.func private @_device_match_id_0_initializer() -> i32 {
    %ref = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
    %_utf8_dylib_971286B245550E6D = vm.const.ref.rodata @_utf8_dylib_971286B245550E6D : !vm.buffer
    %0 = vm.call @hal.device.match.id(%ref, %_utf8_dylib_971286B245550E6D) : (!vm.ref<!hal.device>, !vm.buffer) -> i32
    vm.return %0 : i32
  }
  vm.global.ref @_descriptor_set_layout_0 mutable : !vm.ref<!hal.descriptor_set_layout>
  vm.func private @_descriptor_set_layout_0_initializer() -> !vm.ref<!hal.descriptor_set_layout> {
    %ref = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
    %c1 = vm.const.i32 1 : i32
    %zero = vm.const.i32.zero : i32
    %c7 = vm.const.i32 7 : i32
    %c1_0 = vm.const.i32 1 : i32
    %c1_1 = vm.const.i32 1 : i32
    %c7_2 = vm.const.i32 7 : i32
    %c1_3 = vm.const.i32 1 : i32
    %c2 = vm.const.i32 2 : i32
    %c7_4 = vm.const.i32 7 : i32
    %c6 = vm.const.i32 6 : i32
    %ref_5 = vm.call.variadic @hal.descriptor_set_layout.create(%ref, %c1, [(%zero, %c7, %c1_0), (%c1_1, %c7_2, %c1_3), (%c2, %c7_4, %c6)]) : (!vm.ref<!hal.device>, i32, tuple<i32, i32, i32> ...) -> !vm.ref<!hal.descriptor_set_layout>
    vm.return %ref_5 : !vm.ref<!hal.descriptor_set_layout>
  }
  vm.global.ref @_executable_layout_0 mutable : !vm.ref<!hal.executable_layout>
  vm.func private @_executable_layout_0_initializer() -> !vm.ref<!hal.executable_layout> {
    %_descriptor_set_layout_0 = vm.global.load.ref @_descriptor_set_layout_0 : !vm.ref<!hal.descriptor_set_layout>
    %ref = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
    %zero = vm.const.i32.zero : i32
    %ref_0 = vm.call.variadic @hal.executable_layout.create(%ref, %zero, [%_descriptor_set_layout_0]) : (!vm.ref<!hal.device>, i32, !vm.ref<!hal.descriptor_set_layout> ...) -> !vm.ref<!hal.executable_layout>
    vm.return %ref_0 : !vm.ref<!hal.executable_layout>
  }
  vm.global.ref @_descriptor_set_layout_1 mutable : !vm.ref<!hal.descriptor_set_layout>
  vm.func private @_descriptor_set_layout_1_initializer() -> !vm.ref<!hal.descriptor_set_layout> {
    %ref = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
    %c1 = vm.const.i32 1 : i32
    %zero = vm.const.i32.zero : i32
    %c7 = vm.const.i32 7 : i32
    %c1_0 = vm.const.i32 1 : i32
    %c1_1 = vm.const.i32 1 : i32
    %c7_2 = vm.const.i32 7 : i32
    %c6 = vm.const.i32 6 : i32
    %ref_3 = vm.call.variadic @hal.descriptor_set_layout.create(%ref, %c1, [(%zero, %c7, %c1_0), (%c1_1, %c7_2, %c6)]) : (!vm.ref<!hal.device>, i32, tuple<i32, i32, i32> ...) -> !vm.ref<!hal.descriptor_set_layout>
    vm.return %ref_3 : !vm.ref<!hal.descriptor_set_layout>
  }
  vm.global.ref @_executable_layout_1 mutable : !vm.ref<!hal.executable_layout>
  vm.func private @_executable_layout_1_initializer() -> !vm.ref<!hal.executable_layout> {
    %_descriptor_set_layout_1 = vm.global.load.ref @_descriptor_set_layout_1 : !vm.ref<!hal.descriptor_set_layout>
    %ref = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
    %zero = vm.const.i32.zero : i32
    %ref_0 = vm.call.variadic @hal.executable_layout.create(%ref, %zero, [%_descriptor_set_layout_1]) : (!vm.ref<!hal.device>, i32, !vm.ref<!hal.descriptor_set_layout> ...) -> !vm.ref<!hal.executable_layout>
    vm.return %ref_0 : !vm.ref<!hal.executable_layout>
  }
  vm.global.ref @_descriptor_set_layout_2 mutable : !vm.ref<!hal.descriptor_set_layout>
  vm.func private @_descriptor_set_layout_2_initializer() -> !vm.ref<!hal.descriptor_set_layout> {
    %ref = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
    %c1 = vm.const.i32 1 : i32
    %zero = vm.const.i32.zero : i32
    %c7 = vm.const.i32 7 : i32
    %c1_0 = vm.const.i32 1 : i32
    %c1_1 = vm.const.i32 1 : i32
    %c7_2 = vm.const.i32 7 : i32
    %c1_3 = vm.const.i32 1 : i32
    %c2 = vm.const.i32 2 : i32
    %c7_4 = vm.const.i32 7 : i32
    %c1_5 = vm.const.i32 1 : i32
    %c3 = vm.const.i32 3 : i32
    %c7_6 = vm.const.i32 7 : i32
    %c6 = vm.const.i32 6 : i32
    %ref_7 = vm.call.variadic @hal.descriptor_set_layout.create(%ref, %c1, [(%zero, %c7, %c1_0), (%c1_1, %c7_2, %c1_3), (%c2, %c7_4, %c1_5), (%c3, %c7_6, %c6)]) : (!vm.ref<!hal.device>, i32, tuple<i32, i32, i32> ...) -> !vm.ref<!hal.descriptor_set_layout>
    vm.return %ref_7 : !vm.ref<!hal.descriptor_set_layout>
  }
  vm.global.ref @_executable_layout_2 mutable : !vm.ref<!hal.executable_layout>
  vm.func private @_executable_layout_2_initializer() -> !vm.ref<!hal.executable_layout> {
    %_descriptor_set_layout_2 = vm.global.load.ref @_descriptor_set_layout_2 : !vm.ref<!hal.descriptor_set_layout>
    %ref = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
    %zero = vm.const.i32.zero : i32
    %ref_0 = vm.call.variadic @hal.executable_layout.create(%ref, %zero, [%_descriptor_set_layout_2]) : (!vm.ref<!hal.device>, i32, !vm.ref<!hal.descriptor_set_layout> ...) -> !vm.ref<!hal.executable_layout>
    vm.return %ref_0 : !vm.ref<!hal.executable_layout>
  }
  vm.global.ref @_executable_mnist_linked_llvm_aot mutable : !vm.ref<!hal.executable>
  vm.rodata @_mnist_linked_llvm_aot_llvm_aot_binary_dlib opaque<"_", "0xDEADBEEF"> : vector<136794xi8>
  vm.rodata @_utf8_dlib_F45B9BA87AEFAACB dense<[68, 76, 73, 66]> : vector<4xi8>
  vm.func private @_executable_mnist_linked_llvm_aot_initializer() -> !vm.ref<!hal.executable> {
    %ref = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
    %_device_match_id_0 = vm.global.load.i32 @_device_match_id_0 : i32
    vm.cond_br %_device_match_id_0, ^bb1, ^bb2
  ^bb1:  // pred: ^bb0
    %_executable_layout_0 = vm.global.load.ref @_executable_layout_0 : !vm.ref<!hal.executable_layout>
    %_executable_layout_1 = vm.global.load.ref @_executable_layout_1 : !vm.ref<!hal.executable_layout>
    %_executable_layout_2 = vm.global.load.ref @_executable_layout_2 : !vm.ref<!hal.executable_layout>
    %_utf8_dlib_F45B9BA87AEFAACB = vm.const.ref.rodata @_utf8_dlib_F45B9BA87AEFAACB : !vm.buffer
    %_mnist_linked_llvm_aot_llvm_aot_binary_dlib = vm.const.ref.rodata @_mnist_linked_llvm_aot_llvm_aot_binary_dlib : !vm.buffer
    %ref_0 = vm.call.variadic @hal.executable.create(%ref, %_utf8_dlib_F45B9BA87AEFAACB, %_mnist_linked_llvm_aot_llvm_aot_binary_dlib, [%_executable_layout_0, %_executable_layout_0, %_executable_layout_0, %_executable_layout_1, %_executable_layout_1, %_executable_layout_0, %_executable_layout_1, %_executable_layout_2]) : (!vm.ref<!hal.device>, !vm.buffer, !vm.buffer, !vm.ref<!hal.executable_layout> ...) -> !vm.ref<!hal.executable>
    vm.br ^bb3(%ref_0 : !vm.ref<!hal.executable>)
  ^bb2:  // pred: ^bb0
    %null = vm.const.ref.zero : !vm.ref<!hal.executable>
    vm.br ^bb3(%null : !vm.ref<!hal.executable>)
  ^bb3(%0: !vm.ref<!hal.executable>):  // 2 preds: ^bb1, ^bb2
    vm.return %0 : !vm.ref<!hal.executable>
  }
  vm.rodata @_const_pool_storage opaque<"_", "0xDEADBEEF"> : vector<407040xi8>
  vm.global.ref @_const_pool_storage_buffer mutable : !vm.ref<!hal.buffer>
  vm.func private @_const_pool_storage_buffer_initializer() -> !vm.ref<!hal.buffer> {
    %zero = vm.const.i32.zero : i32
    %c407040 = vm.const.i32 407040 : i32
    %ref = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
    %ref_0 = vm.call @hal.device.allocator(%ref) : (!vm.ref<!hal.device>) -> !vm.ref<!hal.allocator>
    %_const_pool_storage = vm.const.ref.rodata @_const_pool_storage : !vm.buffer
    %c50 = vm.const.i32 50 : i32
    %c15 = vm.const.i32 15 : i32
    %ref_1 = vm.call @hal.allocator.wrap.byte_buffer(%ref_0, %c50, %c15, %_const_pool_storage, %zero, %c407040) : (!vm.ref<!hal.allocator>, i32, i32, !vm.buffer, i32, i32) -> !vm.ref<!hal.buffer>
    vm.return %ref_1 : !vm.ref<!hal.buffer>
  }
  vm.func @predict(%arg0: !vm.ref<!hal.buffer>) -> !vm.ref<!hal.buffer> attributes {noinline} {
    %c3136 = vm.const.i32 3136 : i32
    %c401408 = vm.const.i32 401408 : i32
    %c401920 = vm.const.i32 401920 : i32
    %c5120 = vm.const.i32 5120 : i32
    %c40 = vm.const.i32 40 : i32
    %c4 = vm.const.i32 4 : i32
    %c3 = vm.const.i32 3 : i32
    %zero = vm.const.i32.zero : i32
    %c512 = vm.const.i32 512 : i32
    %c96 = vm.const.i32 96 : i32
    %c48 = vm.const.i32 48 : i32
    %c112 = vm.const.i32 112 : i32
    %c1024 = vm.const.i32 1024 : i32
    %c2 = vm.const.i32 2 : i32
    %c1 = vm.const.i32 1 : i32
    %ref = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
    %ref_0 = vm.call @hal.device.allocator(%ref) : (!vm.ref<!hal.device>) -> !vm.ref<!hal.allocator>
    %c50 = vm.const.i32 50 : i32
    %c14 = vm.const.i32 14 : i32
    %ref_1 = vm.call @hal.allocator.allocate(%ref_0, %c50, %c14, %c40) : (!vm.ref<!hal.allocator>, i32, i32, i32) -> !vm.ref<!hal.buffer>
    %_const_pool_storage_buffer = vm.global.load.ref @_const_pool_storage_buffer : !vm.ref<!hal.buffer>
    %c48_2 = vm.const.i32 48 : i32
    %c10 = vm.const.i32 10 : i32
    %ref_3 = vm.call @hal.allocator.allocate(%ref_0, %c48_2, %c10, %c1024) : (!vm.ref<!hal.allocator>, i32, i32, i32) -> !vm.ref<!hal.buffer>
    %c17 = vm.const.i32 17 : i32
    %c3_4 = vm.const.i32 3 : i32
    %ref_5 = vm.call @hal.command_buffer.create(%ref, %c17, %c3_4) : (!vm.ref<!hal.device>, i32, i32) -> !vm.ref<!hal.command_buffer>
    vm.call @hal.command_buffer.begin(%ref_5) : (!vm.ref<!hal.command_buffer>) -> ()
    %_executable_layout_0 = vm.global.load.ref @_executable_layout_0 : !vm.ref<!hal.executable_layout>
    vm.call.variadic @hal.command_buffer.push_descriptor_set(%ref_5, %_executable_layout_0, %zero, [(%zero, %_const_pool_storage_buffer, %c512, %c401408), (%c1, %arg0, %zero, %c3136), (%c2, %ref_3, %zero, %c512)]) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable_layout>, i32, tuple<i32, !vm.ref<!hal.buffer>, i32, i32> ...)
    %_device_match_id_0 = vm.global.load.i32 @_device_match_id_0 : i32
    vm.cond_br %_device_match_id_0, ^bb1, ^bb2
  ^bb1:  // pred: ^bb0
    %_executable_mnist_linked_llvm_aot = vm.global.load.ref @_executable_mnist_linked_llvm_aot : !vm.ref<!hal.executable>
    %zero_6 = vm.const.i32.zero : i32
    vm.call @hal.command_buffer.dispatch(%ref_5, %_executable_mnist_linked_llvm_aot, %zero_6, %c2, %c1, %c1) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable>, i32, i32, i32, i32) -> ()
    %c20 = vm.const.i32 20 : i32
    %c5 = vm.const.i32 5 : i32
    %zero_7 = vm.const.i32.zero : i32
    vm.call @hal.command_buffer.execution_barrier(%ref_5, %c20, %c5, %zero_7) : (!vm.ref<!hal.command_buffer>, i32, i32, i32) -> ()
    vm.call.variadic @hal.command_buffer.push_descriptor_set(%ref_5, %_executable_layout_0, %zero, [(%zero, %_const_pool_storage_buffer, %zero, %c512), (%c1, %ref_3, %zero, %c512), (%c2, %ref_3, %c512, %c512)]) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable_layout>, i32, tuple<i32, !vm.ref<!hal.buffer>, i32, i32> ...)
    %c1_8 = vm.const.i32 1 : i32
    vm.call @hal.command_buffer.dispatch(%ref_5, %_executable_mnist_linked_llvm_aot, %c1_8, %c1, %c1, %c1) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable>, i32, i32, i32, i32) -> ()
    %c20_9 = vm.const.i32 20 : i32
    %c5_10 = vm.const.i32 5 : i32
    %zero_11 = vm.const.i32.zero : i32
    vm.call @hal.command_buffer.execution_barrier(%ref_5, %c20_9, %c5_10, %zero_11) : (!vm.ref<!hal.command_buffer>, i32, i32, i32) -> ()
    vm.call.variadic @hal.command_buffer.push_descriptor_set(%ref_5, %_executable_layout_0, %zero, [(%zero, %_const_pool_storage_buffer, %c401920, %c5120), (%c1, %ref_3, %c512, %c512), (%c2, %ref_3, %zero, %c40)]) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable_layout>, i32, tuple<i32, !vm.ref<!hal.buffer>, i32, i32> ...)
    %c2_12 = vm.const.i32 2 : i32
    vm.call @hal.command_buffer.dispatch(%ref_5, %_executable_mnist_linked_llvm_aot, %c2_12, %c1, %c1, %c1) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable>, i32, i32, i32, i32) -> ()
    %c20_13 = vm.const.i32 20 : i32
    %c5_14 = vm.const.i32 5 : i32
    %zero_15 = vm.const.i32.zero : i32
    vm.call @hal.command_buffer.execution_barrier(%ref_5, %c20_13, %c5_14, %zero_15) : (!vm.ref<!hal.command_buffer>, i32, i32, i32) -> ()
    %_executable_layout_1 = vm.global.load.ref @_executable_layout_1 : !vm.ref<!hal.executable_layout>
    vm.call.variadic @hal.command_buffer.push_descriptor_set(%ref_5, %_executable_layout_1, %zero, [(%zero, %ref_3, %zero, %c40), (%c1, %ref_3, %c48, %c40)]) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable_layout>, i32, tuple<i32, !vm.ref<!hal.buffer>, i32, i32> ...)
    %c3_16 = vm.const.i32 3 : i32
    vm.call @hal.command_buffer.dispatch(%ref_5, %_executable_mnist_linked_llvm_aot, %c3_16, %c1, %c1, %c1) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable>, i32, i32, i32, i32) -> ()
    %c20_17 = vm.const.i32 20 : i32
    %c5_18 = vm.const.i32 5 : i32
    %zero_19 = vm.const.i32.zero : i32
    vm.call @hal.command_buffer.execution_barrier(%ref_5, %c20_17, %c5_18, %zero_19) : (!vm.ref<!hal.command_buffer>, i32, i32, i32) -> ()
    vm.call.variadic @hal.command_buffer.push_descriptor_set(%ref_5, %_executable_layout_1, %zero, [(%zero, %ref_3, %c48, %c40), (%c1, %ref_3, %c96, %c4)]) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable_layout>, i32, tuple<i32, !vm.ref<!hal.buffer>, i32, i32> ...)
    %c4_20 = vm.const.i32 4 : i32
    vm.call @hal.command_buffer.dispatch(%ref_5, %_executable_mnist_linked_llvm_aot, %c4_20, %c1, %c1, %c1) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable>, i32, i32, i32, i32) -> ()
    %c20_21 = vm.const.i32 20 : i32
    %c5_22 = vm.const.i32 5 : i32
    %zero_23 = vm.const.i32.zero : i32
    vm.call @hal.command_buffer.execution_barrier(%ref_5, %c20_21, %c5_22, %zero_23) : (!vm.ref<!hal.command_buffer>, i32, i32, i32) -> ()
    vm.call.variadic @hal.command_buffer.push_descriptor_set(%ref_5, %_executable_layout_0, %zero, [(%zero, %ref_3, %zero, %c40), (%c1, %ref_3, %c96, %c4), (%c2, %ref_3, %c48, %c40)]) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable_layout>, i32, tuple<i32, !vm.ref<!hal.buffer>, i32, i32> ...)
    %c5_24 = vm.const.i32 5 : i32
    vm.call @hal.command_buffer.dispatch(%ref_5, %_executable_mnist_linked_llvm_aot, %c5_24, %c1, %c1, %c1) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable>, i32, i32, i32, i32) -> ()
    %c20_25 = vm.const.i32 20 : i32
    %c5_26 = vm.const.i32 5 : i32
    %zero_27 = vm.const.i32.zero : i32
    vm.call @hal.command_buffer.execution_barrier(%ref_5, %c20_25, %c5_26, %zero_27) : (!vm.ref<!hal.command_buffer>, i32, i32, i32) -> ()
    vm.call.variadic @hal.command_buffer.push_descriptor_set(%ref_5, %_executable_layout_1, %zero, [(%zero, %ref_3, %c48, %c40), (%c1, %ref_3, %c112, %c4)]) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable_layout>, i32, tuple<i32, !vm.ref<!hal.buffer>, i32, i32> ...)
    %c6 = vm.const.i32 6 : i32
    vm.call @hal.command_buffer.dispatch(%ref_5, %_executable_mnist_linked_llvm_aot, %c6, %c1, %c1, %c1) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable>, i32, i32, i32, i32) -> ()
    %c20_28 = vm.const.i32 20 : i32
    %c5_29 = vm.const.i32 5 : i32
    %zero_30 = vm.const.i32.zero : i32
    vm.call @hal.command_buffer.execution_barrier(%ref_5, %c20_28, %c5_29, %zero_30) : (!vm.ref<!hal.command_buffer>, i32, i32, i32) -> ()
    %_executable_layout_2 = vm.global.load.ref @_executable_layout_2 : !vm.ref<!hal.executable_layout>
    vm.call.variadic @hal.command_buffer.push_descriptor_set(%ref_5, %_executable_layout_2, %zero, [(%zero, %ref_3, %zero, %c40), (%c1, %ref_3, %c96, %c4), (%c2, %ref_3, %c112, %c4), (%c3, %ref_1, %zero, %c40)]) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable_layout>, i32, tuple<i32, !vm.ref<!hal.buffer>, i32, i32> ...)
    %c7 = vm.const.i32 7 : i32
    vm.call @hal.command_buffer.dispatch(%ref_5, %_executable_mnist_linked_llvm_aot, %c7, %c1, %c1, %c1) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable>, i32, i32, i32, i32) -> ()
    %c20_31 = vm.const.i32 20 : i32
    %c5_32 = vm.const.i32 5 : i32
    %zero_33 = vm.const.i32.zero : i32
    vm.call @hal.command_buffer.execution_barrier(%ref_5, %c20_31, %c5_32, %zero_33) : (!vm.ref<!hal.command_buffer>, i32, i32, i32) -> ()
    vm.call @hal.command_buffer.end(%ref_5) : (!vm.ref<!hal.command_buffer>) -> ()
    vm.call @hal.ex.submit_and_wait(%ref, %ref_5) : (!vm.ref<!hal.device>, !vm.ref<!hal.command_buffer>) -> ()
    vm.return %ref_1 : !vm.ref<!hal.buffer>
  ^bb2:  // pred: ^bb0
    %c2_34 = vm.const.i32 2 : i32
    vm.fail %c2_34, "device not supported in the compiled configuration"
  }
  vm.func @predict$async(%arg0: !vm.ref<!hal.semaphore>, %arg1: i32, %arg2: !vm.ref<!hal.buffer_view>, %arg3: !vm.ref<!hal.semaphore>, %arg4: i32) -> !vm.ref<!hal.buffer_view> {
    %c1 = vm.const.i32 1 : i32
    %c10 = vm.const.i32 10 : i32
    %c50331680 = vm.const.i32 50331680 : i32
    %0 = vm.call @hal.semaphore.await(%arg0, %arg1) : (!vm.ref<!hal.semaphore>, i32) -> i32
    vm.cond_fail %0, "semaphore wait failed"
    %ref = vm.call @hal.buffer_view.buffer(%arg2) : (!vm.ref<!hal.buffer_view>) -> !vm.ref<!hal.buffer>
    %ref_0 = vm.call @predict(%ref) : (!vm.ref<!hal.buffer>) -> !vm.ref<!hal.buffer>
    %ref_1 = vm.call.variadic @hal.buffer_view.create(%ref_0, %c50331680, [%c1, %c10]) : (!vm.ref<!hal.buffer>, i32, i32 ...) -> !vm.ref<!hal.buffer_view>
    vm.call @hal.semaphore.signal(%arg3, %arg4) : (!vm.ref<!hal.semaphore>, i32) -> ()
    vm.return %ref_1 : !vm.ref<!hal.buffer_view>
  }
  vm.export @predict$async
  vm.import @hal.ex.shared_device() -> !vm.ref<!hal.device> attributes {nosideeffects, sym_visibility = "private"}
  vm.import @hal.ex.submit_and_wait(%device : !vm.ref<!hal.device>, %command_buffer : !vm.ref<!hal.command_buffer>) attributes {sym_visibility = "private"}
  vm.import @hal.allocator.allocate(%allocator : !vm.ref<!hal.allocator>, %memory_types : i32, %buffer_usage : i32, %allocation_size : i32) -> !vm.ref<!hal.buffer> attributes {sym_visibility = "private"}
  vm.import @hal.allocator.wrap.byte_buffer(%allocator : !vm.ref<!hal.allocator>, %memory_types : i32, %buffer_usage : i32, %source : !vm.buffer, %offset : i32, %length : i32) -> !vm.ref<!hal.buffer> attributes {sym_visibility = "private"}
  vm.import @hal.buffer.allocator(%buffer : !vm.ref<!hal.buffer>) -> !vm.ref<!hal.allocator> attributes {sym_visibility = "private"}
  vm.import @hal.buffer.subspan(%source_buffer : !vm.ref<!hal.buffer>, %source_offset : i32, %length : i32) -> !vm.ref<!hal.buffer> attributes {sym_visibility = "private"}
  vm.import @hal.buffer.load(%source_buffer : !vm.ref<!hal.buffer>, %source_offset : i32, %length : i32) -> i32 attributes {sym_visibility = "private"}
  vm.import @hal.buffer.store(%value : i32, %target_buffer : !vm.ref<!hal.buffer>, %target_offset : i32, %length : i32) attributes {sym_visibility = "private"}
  vm.import @hal.buffer_view.create(%buffer : !vm.ref<!hal.buffer>, %element_type : i32, %shape : i32 ...) -> !vm.ref<!hal.buffer_view> attributes {nosideeffects, sym_visibility = "private"}
  vm.import @hal.buffer_view.buffer(%buffer_view : !vm.ref<!hal.buffer_view>) -> !vm.ref<!hal.buffer> attributes {nosideeffects, sym_visibility = "private"}
  vm.import @hal.buffer_view.byte_length(%buffer_view : !vm.ref<!hal.buffer_view>) -> i32 attributes {nosideeffects, sym_visibility = "private"}
  vm.import @hal.buffer_view.element_type(%buffer_view : !vm.ref<!hal.buffer_view>) -> i32 attributes {nosideeffects, sym_visibility = "private"}
  vm.import @hal.buffer_view.rank(%buffer_view : !vm.ref<!hal.buffer_view>) -> i32 attributes {nosideeffects, sym_visibility = "private"}
  vm.import @hal.buffer_view.dim(%buffer_view : !vm.ref<!hal.buffer_view>, %index : i32) -> i32 attributes {nosideeffects, sym_visibility = "private"}
  vm.import @hal.buffer_view.trace(%key : !vm.buffer, %operands : !vm.ref<!hal.buffer_view> ...) attributes {sym_visibility = "private"}
  vm.import @hal.command_buffer.create(%device : !vm.ref<!hal.device>, %modes : i32, %command_categories : i32) -> !vm.ref<!hal.command_buffer> attributes {sym_visibility = "private"}
  vm.import @hal.command_buffer.begin(%command_buffer : !vm.ref<!hal.command_buffer>) attributes {sym_visibility = "private"}
  vm.import @hal.command_buffer.end(%command_buffer : !vm.ref<!hal.command_buffer>) attributes {sym_visibility = "private"}
  vm.import @hal.command_buffer.execution_barrier(%command_buffer : !vm.ref<!hal.command_buffer>, %source_stage_mask : i32, %target_stage_mask : i32, %flags : i32) attributes {sym_visibility = "private"}
  vm.import @hal.command_buffer.fill_buffer(%command_buffer : !vm.ref<!hal.command_buffer>, %target_buffer : !vm.ref<!hal.buffer>, %target_offset : i32, %length : i32, %pattern : i32) attributes {sym_visibility = "private"}
  vm.import @hal.command_buffer.copy_buffer(%command_buffer : !vm.ref<!hal.command_buffer>, %source_buffer : !vm.ref<!hal.buffer>, %source_offset : i32, %target_buffer : !vm.ref<!hal.buffer>, %target_offset : i32, %length : i32) attributes {sym_visibility = "private"}
  vm.import @hal.command_buffer.push_constants(%command_buffer : !vm.ref<!hal.command_buffer>, %executable_layout : !vm.ref<!hal.executable_layout>, %offset : i32, %values : i32 ...) attributes {sym_visibility = "private"}
  vm.import @hal.command_buffer.push_descriptor_set(%command_buffer : !vm.ref<!hal.command_buffer>, %executable_layout : !vm.ref<!hal.executable_layout>, %set : i32, %bindings : tuple<i32, !vm.ref<!hal.buffer>, i32, i32> ...) attributes {sym_visibility = "private"}
  vm.import @hal.command_buffer.bind_descriptor_set(%command_buffer : !vm.ref<!hal.command_buffer>, %executable_layout : !vm.ref<!hal.executable_layout>, %set : i32, %descriptor_set : !vm.ref<!hal.descriptor_set>, %dynamic_offsets : i32 ...) attributes {sym_visibility = "private"}
  vm.import @hal.command_buffer.dispatch(%command_buffer : !vm.ref<!hal.command_buffer>, %executable : !vm.ref<!hal.executable>, %entry_point : i32, %workgroup_x : i32, %workgroup_y : i32, %workgroup_z : i32) attributes {sym_visibility = "private"}
  vm.import @hal.command_buffer.dispatch.indirect(%command_buffer : !vm.ref<!hal.command_buffer>, %executable : !vm.ref<!hal.executable>, %entry_point : i32, %workgroups_buffer : !vm.ref<!hal.buffer>, %workgroups_offset : i32) attributes {sym_visibility = "private"}
  vm.import @hal.descriptor_set.create(%device : !vm.ref<!hal.device>, %set_layout : !vm.ref<!hal.descriptor_set_layout>, %bindings : tuple<i32, !vm.ref<!hal.buffer>, i32, i32> ...) -> !vm.ref<!hal.descriptor_set> attributes {sym_visibility = "private"}
  vm.import @hal.descriptor_set_layout.create(%device : !vm.ref<!hal.device>, %usage_type : i32, %bindings : tuple<i32, i32, i32> ...) -> !vm.ref<!hal.descriptor_set_layout> attributes {nosideeffects, sym_visibility = "private"}
  vm.import @hal.device.allocator(%device : !vm.ref<!hal.device>) -> !vm.ref<!hal.allocator> attributes {nosideeffects, sym_visibility = "private"}
  vm.import @hal.device.query.i32(%device : !vm.ref<!hal.device>, %key : !vm.buffer) -> (i32, i32) attributes {nosideeffects, sym_visibility = "private"}
  vm.import @hal.device.match.id(%device : !vm.ref<!hal.device>, %pattern : !vm.buffer) -> i32 attributes {nosideeffects, sym_visibility = "private"}
  vm.import @hal.executable.create(%device : !vm.ref<!hal.device>, %executable_format : !vm.buffer, %executable_data : !vm.buffer, %executable_layouts : !vm.ref<!hal.executable_layout> ...) -> !vm.ref<!hal.executable> attributes {nosideeffects, sym_visibility = "private"}
  vm.import @hal.executable_layout.create(%device : !vm.ref<!hal.device>, %push_constants : i32, %set_layouts : !vm.ref<!hal.descriptor_set_layout> ...) -> !vm.ref<!hal.executable_layout> attributes {nosideeffects, sym_visibility = "private"}
  vm.import @hal.semaphore.create(%device : !vm.ref<!hal.device>, %initial_value : i32) -> !vm.ref<!hal.semaphore> attributes {nosideeffects, sym_visibility = "private"}
  vm.import @hal.semaphore.query(%semaphore : !vm.ref<!hal.semaphore>) -> (i32, i32) attributes {sym_visibility = "private"}
  vm.import @hal.semaphore.signal(%semaphore : !vm.ref<!hal.semaphore>, %new_value : i32) attributes {sym_visibility = "private"}
  vm.import @hal.semaphore.fail(%semaphore : !vm.ref<!hal.semaphore>, %status : i32) attributes {sym_visibility = "private"}
  vm.import @hal.semaphore.await(%semaphore : !vm.ref<!hal.semaphore>, %min_value : i32) -> i32 attributes {sym_visibility = "private"}
  vm.func @predict$sync(%arg0: !vm.ref<!hal.buffer_view>) -> !vm.ref<!hal.buffer_view> attributes {iree.reflection = {abi = "sip", abiv = 1 : i32, f = "I15!B11!d1d28d28d1R9!B6!d1d10", fv = "1", sip = "I8!S5!k0_0R3!_0"}} {
    %zero = vm.const.i32.zero : i32
    %c1 = vm.const.i32 1 : i32
    %ref = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
    %ref_0 = vm.call @hal.semaphore.create(%ref, %zero) : (!vm.ref<!hal.device>, i32) -> !vm.ref<!hal.semaphore>
    %ref_1 = vm.call @predict$async(%ref_0, %zero, %arg0, %ref_0, %c1) : (!vm.ref<!hal.semaphore>, i32, !vm.ref<!hal.buffer_view>, !vm.ref<!hal.semaphore>, i32) -> !vm.ref<!hal.buffer_view>
    %0 = vm.call @hal.semaphore.await(%ref_0, %c1) : (!vm.ref<!hal.semaphore>, i32) -> i32
    vm.cond_fail %0, "semaphore wait failed"
    vm.return %ref_1 : !vm.ref<!hal.buffer_view>
  }
  vm.export @predict$sync as("predict")
  vm.func @__init() {
    %0 = vm.call @_device_match_id_0_initializer() : () -> i32
    vm.global.store.i32 %0, @_device_match_id_0 : i32
    %ref = vm.call @_descriptor_set_layout_0_initializer() : () -> !vm.ref<!hal.descriptor_set_layout>
    vm.global.store.ref %ref, @_descriptor_set_layout_0 : !vm.ref<!hal.descriptor_set_layout>
    %ref_0 = vm.call @_executable_layout_0_initializer() : () -> !vm.ref<!hal.executable_layout>
    vm.global.store.ref %ref_0, @_executable_layout_0 : !vm.ref<!hal.executable_layout>
    %ref_1 = vm.call @_descriptor_set_layout_1_initializer() : () -> !vm.ref<!hal.descriptor_set_layout>
    vm.global.store.ref %ref_1, @_descriptor_set_layout_1 : !vm.ref<!hal.descriptor_set_layout>
    %ref_2 = vm.call @_executable_layout_1_initializer() : () -> !vm.ref<!hal.executable_layout>
    vm.global.store.ref %ref_2, @_executable_layout_1 : !vm.ref<!hal.executable_layout>
    %ref_3 = vm.call @_descriptor_set_layout_2_initializer() : () -> !vm.ref<!hal.descriptor_set_layout>
    vm.global.store.ref %ref_3, @_descriptor_set_layout_2 : !vm.ref<!hal.descriptor_set_layout>
    %ref_4 = vm.call @_executable_layout_2_initializer() : () -> !vm.ref<!hal.executable_layout>
    vm.global.store.ref %ref_4, @_executable_layout_2 : !vm.ref<!hal.executable_layout>
    %ref_5 = vm.call @_executable_mnist_linked_llvm_aot_initializer() : () -> !vm.ref<!hal.executable>
    vm.global.store.ref %ref_5, @_executable_mnist_linked_llvm_aot : !vm.ref<!hal.executable>
    %ref_6 = vm.call @_const_pool_storage_buffer_initializer() : () -> !vm.ref<!hal.buffer>
    vm.global.store.ref %ref_6, @_const_pool_storage_buffer : !vm.ref<!hal.buffer>
    vm.return
  }
  vm.export @__init
}

// *** IR Dump After Canonicalizer ***
vm.func @__init() {
  %0 = vm.call @_device_match_id_0_initializer() : () -> i32
  vm.global.store.i32 %0, @_device_match_id_0 : i32
  %ref = vm.call @_descriptor_set_layout_0_initializer() : () -> !vm.ref<!hal.descriptor_set_layout>
  vm.global.store.ref %ref, @_descriptor_set_layout_0 : !vm.ref<!hal.descriptor_set_layout>
  %ref_0 = vm.call @_executable_layout_0_initializer() : () -> !vm.ref<!hal.executable_layout>
  vm.global.store.ref %ref_0, @_executable_layout_0 : !vm.ref<!hal.executable_layout>
  %ref_1 = vm.call @_descriptor_set_layout_1_initializer() : () -> !vm.ref<!hal.descriptor_set_layout>
  vm.global.store.ref %ref_1, @_descriptor_set_layout_1 : !vm.ref<!hal.descriptor_set_layout>
  %ref_2 = vm.call @_executable_layout_1_initializer() : () -> !vm.ref<!hal.executable_layout>
  vm.global.store.ref %ref_2, @_executable_layout_1 : !vm.ref<!hal.executable_layout>
  %ref_3 = vm.call @_descriptor_set_layout_2_initializer() : () -> !vm.ref<!hal.descriptor_set_layout>
  vm.global.store.ref %ref_3, @_descriptor_set_layout_2 : !vm.ref<!hal.descriptor_set_layout>
  %ref_4 = vm.call @_executable_layout_2_initializer() : () -> !vm.ref<!hal.executable_layout>
  vm.global.store.ref %ref_4, @_executable_layout_2 : !vm.ref<!hal.executable_layout>
  %ref_5 = vm.call @_executable_mnist_linked_llvm_aot_initializer() : () -> !vm.ref<!hal.executable>
  vm.global.store.ref %ref_5, @_executable_mnist_linked_llvm_aot : !vm.ref<!hal.executable>
  %ref_6 = vm.call @_const_pool_storage_buffer_initializer() : () -> !vm.ref<!hal.buffer>
  vm.global.store.ref %ref_6, @_const_pool_storage_buffer : !vm.ref<!hal.buffer>
  vm.return
}

// *** IR Dump After Canonicalizer ***
vm.func @predict$sync(%arg0: !vm.ref<!hal.buffer_view>) -> !vm.ref<!hal.buffer_view> attributes {iree.reflection = {abi = "sip", abiv = 1 : i32, f = "I15!B11!d1d28d28d1R9!B6!d1d10", fv = "1", sip = "I8!S5!k0_0R3!_0"}} {
  %zero = vm.const.i32.zero : i32
  %c1 = vm.const.i32 1 : i32
  %ref = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
  %ref_0 = vm.call @hal.semaphore.create(%ref, %zero) : (!vm.ref<!hal.device>, i32) -> !vm.ref<!hal.semaphore>
  %ref_1 = vm.call @predict$async(%ref_0, %zero, %arg0, %ref_0, %c1) : (!vm.ref<!hal.semaphore>, i32, !vm.ref<!hal.buffer_view>, !vm.ref<!hal.semaphore>, i32) -> !vm.ref<!hal.buffer_view>
  %0 = vm.call @hal.semaphore.await(%ref_0, %c1) : (!vm.ref<!hal.semaphore>, i32) -> i32
  vm.cond_br %0, ^bb2(%0 : i32), ^bb1
^bb1:  // pred: ^bb0
  vm.return %ref_1 : !vm.ref<!hal.buffer_view>
^bb2(%1: i32):  // pred: ^bb0
  vm.fail %1, "semaphore wait failed"
}

// *** IR Dump After Canonicalizer ***
vm.func @predict$async(%arg0: !vm.ref<!hal.semaphore>, %arg1: i32, %arg2: !vm.ref<!hal.buffer_view>, %arg3: !vm.ref<!hal.semaphore>, %arg4: i32) -> !vm.ref<!hal.buffer_view> {
  %c1 = vm.const.i32 1 : i32
  %c10 = vm.const.i32 10 : i32
  %c50331680 = vm.const.i32 50331680 : i32
  %0 = vm.call @hal.semaphore.await(%arg0, %arg1) : (!vm.ref<!hal.semaphore>, i32) -> i32
  vm.cond_br %0, ^bb2(%0 : i32), ^bb1
^bb1:  // pred: ^bb0
  %ref = vm.call @hal.buffer_view.buffer(%arg2) : (!vm.ref<!hal.buffer_view>) -> !vm.ref<!hal.buffer>
  %ref_0 = vm.call @predict(%ref) : (!vm.ref<!hal.buffer>) -> !vm.ref<!hal.buffer>
  %ref_1 = vm.call.variadic @hal.buffer_view.create(%ref_0, %c50331680, [%c1, %c10]) : (!vm.ref<!hal.buffer>, i32, i32 ...) -> !vm.ref<!hal.buffer_view>
  vm.call @hal.semaphore.signal(%arg3, %arg4) : (!vm.ref<!hal.semaphore>, i32) -> ()
  vm.return %ref_1 : !vm.ref<!hal.buffer_view>
^bb2(%1: i32):  // pred: ^bb0
  vm.fail %1, "semaphore wait failed"
}

// *** IR Dump After Canonicalizer ***
vm.func @predict(%arg0: !vm.ref<!hal.buffer>) -> !vm.ref<!hal.buffer> attributes {noinline} {
  %c3136 = vm.const.i32 3136 : i32
  %c401408 = vm.const.i32 401408 : i32
  %c401920 = vm.const.i32 401920 : i32
  %c5120 = vm.const.i32 5120 : i32
  %c40 = vm.const.i32 40 : i32
  %c512 = vm.const.i32 512 : i32
  %c96 = vm.const.i32 96 : i32
  %c112 = vm.const.i32 112 : i32
  %c1024 = vm.const.i32 1024 : i32
  %c50 = vm.const.i32 50 : i32
  %c14 = vm.const.i32 14 : i32
  %c48 = vm.const.i32 48 : i32
  %c10 = vm.const.i32 10 : i32
  %c17 = vm.const.i32 17 : i32
  %c1 = vm.const.i32 1 : i32
  %c3 = vm.const.i32 3 : i32
  %c4 = vm.const.i32 4 : i32
  %c6 = vm.const.i32 6 : i32
  %c7 = vm.const.i32 7 : i32
  %c20 = vm.const.i32 20 : i32
  %c5 = vm.const.i32 5 : i32
  %zero = vm.const.i32.zero : i32
  %c2 = vm.const.i32 2 : i32
  %ref = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
  %ref_0 = vm.call @hal.device.allocator(%ref) : (!vm.ref<!hal.device>) -> !vm.ref<!hal.allocator>
  %ref_1 = vm.call @hal.allocator.allocate(%ref_0, %c50, %c14, %c40) : (!vm.ref<!hal.allocator>, i32, i32, i32) -> !vm.ref<!hal.buffer>
  %_const_pool_storage_buffer = vm.global.load.ref @_const_pool_storage_buffer : !vm.ref<!hal.buffer>
  %ref_2 = vm.call @hal.allocator.allocate(%ref_0, %c48, %c10, %c1024) : (!vm.ref<!hal.allocator>, i32, i32, i32) -> !vm.ref<!hal.buffer>
  %ref_3 = vm.call @hal.command_buffer.create(%ref, %c17, %c3) : (!vm.ref<!hal.device>, i32, i32) -> !vm.ref<!hal.command_buffer>
  vm.call @hal.command_buffer.begin(%ref_3) : (!vm.ref<!hal.command_buffer>) -> ()
  %_executable_layout_0 = vm.global.load.ref @_executable_layout_0 : !vm.ref<!hal.executable_layout>
  vm.call.variadic @hal.command_buffer.push_descriptor_set(%ref_3, %_executable_layout_0, %zero, [(%zero, %_const_pool_storage_buffer, %c512, %c401408), (%c1, %arg0, %zero, %c3136), (%c2, %ref_2, %zero, %c512)]) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable_layout>, i32, tuple<i32, !vm.ref<!hal.buffer>, i32, i32> ...)
  %_device_match_id_0 = vm.global.load.i32 @_device_match_id_0 : i32
  vm.cond_br %_device_match_id_0, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %_executable_mnist_linked_llvm_aot = vm.global.load.ref @_executable_mnist_linked_llvm_aot : !vm.ref<!hal.executable>
  vm.call @hal.command_buffer.dispatch(%ref_3, %_executable_mnist_linked_llvm_aot, %zero, %c2, %c1, %c1) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable>, i32, i32, i32, i32) -> ()
  vm.call @hal.command_buffer.execution_barrier(%ref_3, %c20, %c5, %zero) : (!vm.ref<!hal.command_buffer>, i32, i32, i32) -> ()
  vm.call.variadic @hal.command_buffer.push_descriptor_set(%ref_3, %_executable_layout_0, %zero, [(%zero, %_const_pool_storage_buffer, %zero, %c512), (%c1, %ref_2, %zero, %c512), (%c2, %ref_2, %c512, %c512)]) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable_layout>, i32, tuple<i32, !vm.ref<!hal.buffer>, i32, i32> ...)
  vm.call @hal.command_buffer.dispatch(%ref_3, %_executable_mnist_linked_llvm_aot, %c1, %c1, %c1, %c1) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable>, i32, i32, i32, i32) -> ()
  vm.call @hal.command_buffer.execution_barrier(%ref_3, %c20, %c5, %zero) : (!vm.ref<!hal.command_buffer>, i32, i32, i32) -> ()
  vm.call.variadic @hal.command_buffer.push_descriptor_set(%ref_3, %_executable_layout_0, %zero, [(%zero, %_const_pool_storage_buffer, %c401920, %c5120), (%c1, %ref_2, %c512, %c512), (%c2, %ref_2, %zero, %c40)]) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable_layout>, i32, tuple<i32, !vm.ref<!hal.buffer>, i32, i32> ...)
  vm.call @hal.command_buffer.dispatch(%ref_3, %_executable_mnist_linked_llvm_aot, %c2, %c1, %c1, %c1) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable>, i32, i32, i32, i32) -> ()
  vm.call @hal.command_buffer.execution_barrier(%ref_3, %c20, %c5, %zero) : (!vm.ref<!hal.command_buffer>, i32, i32, i32) -> ()
  %_executable_layout_1 = vm.global.load.ref @_executable_layout_1 : !vm.ref<!hal.executable_layout>
  vm.call.variadic @hal.command_buffer.push_descriptor_set(%ref_3, %_executable_layout_1, %zero, [(%zero, %ref_2, %zero, %c40), (%c1, %ref_2, %c48, %c40)]) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable_layout>, i32, tuple<i32, !vm.ref<!hal.buffer>, i32, i32> ...)
  vm.call @hal.command_buffer.dispatch(%ref_3, %_executable_mnist_linked_llvm_aot, %c3, %c1, %c1, %c1) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable>, i32, i32, i32, i32) -> ()
  vm.call @hal.command_buffer.execution_barrier(%ref_3, %c20, %c5, %zero) : (!vm.ref<!hal.command_buffer>, i32, i32, i32) -> ()
  vm.call.variadic @hal.command_buffer.push_descriptor_set(%ref_3, %_executable_layout_1, %zero, [(%zero, %ref_2, %c48, %c40), (%c1, %ref_2, %c96, %c4)]) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable_layout>, i32, tuple<i32, !vm.ref<!hal.buffer>, i32, i32> ...)
  vm.call @hal.command_buffer.dispatch(%ref_3, %_executable_mnist_linked_llvm_aot, %c4, %c1, %c1, %c1) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable>, i32, i32, i32, i32) -> ()
  vm.call @hal.command_buffer.execution_barrier(%ref_3, %c20, %c5, %zero) : (!vm.ref<!hal.command_buffer>, i32, i32, i32) -> ()
  vm.call.variadic @hal.command_buffer.push_descriptor_set(%ref_3, %_executable_layout_0, %zero, [(%zero, %ref_2, %zero, %c40), (%c1, %ref_2, %c96, %c4), (%c2, %ref_2, %c48, %c40)]) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable_layout>, i32, tuple<i32, !vm.ref<!hal.buffer>, i32, i32> ...)
  vm.call @hal.command_buffer.dispatch(%ref_3, %_executable_mnist_linked_llvm_aot, %c5, %c1, %c1, %c1) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable>, i32, i32, i32, i32) -> ()
  vm.call @hal.command_buffer.execution_barrier(%ref_3, %c20, %c5, %zero) : (!vm.ref<!hal.command_buffer>, i32, i32, i32) -> ()
  vm.call.variadic @hal.command_buffer.push_descriptor_set(%ref_3, %_executable_layout_1, %zero, [(%zero, %ref_2, %c48, %c40), (%c1, %ref_2, %c112, %c4)]) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable_layout>, i32, tuple<i32, !vm.ref<!hal.buffer>, i32, i32> ...)
  vm.call @hal.command_buffer.dispatch(%ref_3, %_executable_mnist_linked_llvm_aot, %c6, %c1, %c1, %c1) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable>, i32, i32, i32, i32) -> ()
  vm.call @hal.command_buffer.execution_barrier(%ref_3, %c20, %c5, %zero) : (!vm.ref<!hal.command_buffer>, i32, i32, i32) -> ()
  %_executable_layout_2 = vm.global.load.ref @_executable_layout_2 : !vm.ref<!hal.executable_layout>
  vm.call.variadic @hal.command_buffer.push_descriptor_set(%ref_3, %_executable_layout_2, %zero, [(%zero, %ref_2, %zero, %c40), (%c1, %ref_2, %c96, %c4), (%c2, %ref_2, %c112, %c4), (%c3, %ref_1, %zero, %c40)]) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable_layout>, i32, tuple<i32, !vm.ref<!hal.buffer>, i32, i32> ...)
  vm.call @hal.command_buffer.dispatch(%ref_3, %_executable_mnist_linked_llvm_aot, %c7, %c1, %c1, %c1) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable>, i32, i32, i32, i32) -> ()
  vm.call @hal.command_buffer.execution_barrier(%ref_3, %c20, %c5, %zero) : (!vm.ref<!hal.command_buffer>, i32, i32, i32) -> ()
  vm.call @hal.command_buffer.end(%ref_3) : (!vm.ref<!hal.command_buffer>) -> ()
  vm.call @hal.ex.submit_and_wait(%ref, %ref_3) : (!vm.ref<!hal.device>, !vm.ref<!hal.command_buffer>) -> ()
  vm.return %ref_1 : !vm.ref<!hal.buffer>
^bb2:  // pred: ^bb0
  vm.fail %c2, "device not supported in the compiled configuration"
}

// *** IR Dump After Canonicalizer ***
vm.func private @_const_pool_storage_buffer_initializer() -> !vm.ref<!hal.buffer> {
  %zero = vm.const.i32.zero : i32
  %c407040 = vm.const.i32 407040 : i32
  %c50 = vm.const.i32 50 : i32
  %c15 = vm.const.i32 15 : i32
  %ref = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
  %ref_0 = vm.call @hal.device.allocator(%ref) : (!vm.ref<!hal.device>) -> !vm.ref<!hal.allocator>
  %_const_pool_storage = vm.const.ref.rodata @_const_pool_storage : !vm.buffer
  %ref_1 = vm.call @hal.allocator.wrap.byte_buffer(%ref_0, %c50, %c15, %_const_pool_storage, %zero, %c407040) : (!vm.ref<!hal.allocator>, i32, i32, !vm.buffer, i32, i32) -> !vm.ref<!hal.buffer>
  vm.return %ref_1 : !vm.ref<!hal.buffer>
}

// *** IR Dump After Canonicalizer ***
vm.func private @_executable_mnist_linked_llvm_aot_initializer() -> !vm.ref<!hal.executable> {
  %null = vm.const.ref.zero : !vm.ref<!hal.executable>
  %ref = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
  %_device_match_id_0 = vm.global.load.i32 @_device_match_id_0 : i32
  vm.cond_br %_device_match_id_0, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %_executable_layout_0 = vm.global.load.ref @_executable_layout_0 : !vm.ref<!hal.executable_layout>
  %_executable_layout_1 = vm.global.load.ref @_executable_layout_1 : !vm.ref<!hal.executable_layout>
  %_executable_layout_2 = vm.global.load.ref @_executable_layout_2 : !vm.ref<!hal.executable_layout>
  %_utf8_dlib_F45B9BA87AEFAACB = vm.const.ref.rodata @_utf8_dlib_F45B9BA87AEFAACB : !vm.buffer
  %_mnist_linked_llvm_aot_llvm_aot_binary_dlib = vm.const.ref.rodata @_mnist_linked_llvm_aot_llvm_aot_binary_dlib : !vm.buffer
  %ref_0 = vm.call.variadic @hal.executable.create(%ref, %_utf8_dlib_F45B9BA87AEFAACB, %_mnist_linked_llvm_aot_llvm_aot_binary_dlib, [%_executable_layout_0, %_executable_layout_0, %_executable_layout_0, %_executable_layout_1, %_executable_layout_1, %_executable_layout_0, %_executable_layout_1, %_executable_layout_2]) : (!vm.ref<!hal.device>, !vm.buffer, !vm.buffer, !vm.ref<!hal.executable_layout> ...) -> !vm.ref<!hal.executable>
  vm.br ^bb3(%ref_0 : !vm.ref<!hal.executable>)
^bb2:  // pred: ^bb0
  vm.br ^bb3(%null : !vm.ref<!hal.executable>)
^bb3(%0: !vm.ref<!hal.executable>):  // 2 preds: ^bb1, ^bb2
  vm.return %0 : !vm.ref<!hal.executable>
}

// *** IR Dump After Canonicalizer ***
vm.func private @_executable_layout_2_initializer() -> !vm.ref<!hal.executable_layout> {
  %zero = vm.const.i32.zero : i32
  %_descriptor_set_layout_2 = vm.global.load.ref @_descriptor_set_layout_2 : !vm.ref<!hal.descriptor_set_layout>
  %ref = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
  %ref_0 = vm.call.variadic @hal.executable_layout.create(%ref, %zero, [%_descriptor_set_layout_2]) : (!vm.ref<!hal.device>, i32, !vm.ref<!hal.descriptor_set_layout> ...) -> !vm.ref<!hal.executable_layout>
  vm.return %ref_0 : !vm.ref<!hal.executable_layout>
}

// *** IR Dump After Canonicalizer ***
vm.func private @_descriptor_set_layout_2_initializer() -> !vm.ref<!hal.descriptor_set_layout> {
  %zero = vm.const.i32.zero : i32
  %c2 = vm.const.i32 2 : i32
  %c1 = vm.const.i32 1 : i32
  %c3 = vm.const.i32 3 : i32
  %c7 = vm.const.i32 7 : i32
  %c6 = vm.const.i32 6 : i32
  %ref = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
  %ref_0 = vm.call.variadic @hal.descriptor_set_layout.create(%ref, %c1, [(%zero, %c7, %c1), (%c1, %c7, %c1), (%c2, %c7, %c1), (%c3, %c7, %c6)]) : (!vm.ref<!hal.device>, i32, tuple<i32, i32, i32> ...) -> !vm.ref<!hal.descriptor_set_layout>
  vm.return %ref_0 : !vm.ref<!hal.descriptor_set_layout>
}

// *** IR Dump After Canonicalizer ***
vm.func private @_executable_layout_1_initializer() -> !vm.ref<!hal.executable_layout> {
  %zero = vm.const.i32.zero : i32
  %_descriptor_set_layout_1 = vm.global.load.ref @_descriptor_set_layout_1 : !vm.ref<!hal.descriptor_set_layout>
  %ref = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
  %ref_0 = vm.call.variadic @hal.executable_layout.create(%ref, %zero, [%_descriptor_set_layout_1]) : (!vm.ref<!hal.device>, i32, !vm.ref<!hal.descriptor_set_layout> ...) -> !vm.ref<!hal.executable_layout>
  vm.return %ref_0 : !vm.ref<!hal.executable_layout>
}

// *** IR Dump After Canonicalizer ***
vm.func private @_descriptor_set_layout_1_initializer() -> !vm.ref<!hal.descriptor_set_layout> {
  %zero = vm.const.i32.zero : i32
  %c1 = vm.const.i32 1 : i32
  %c7 = vm.const.i32 7 : i32
  %c6 = vm.const.i32 6 : i32
  %ref = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
  %ref_0 = vm.call.variadic @hal.descriptor_set_layout.create(%ref, %c1, [(%zero, %c7, %c1), (%c1, %c7, %c6)]) : (!vm.ref<!hal.device>, i32, tuple<i32, i32, i32> ...) -> !vm.ref<!hal.descriptor_set_layout>
  vm.return %ref_0 : !vm.ref<!hal.descriptor_set_layout>
}

// *** IR Dump After Canonicalizer ***
vm.func private @_executable_layout_0_initializer() -> !vm.ref<!hal.executable_layout> {
  %zero = vm.const.i32.zero : i32
  %_descriptor_set_layout_0 = vm.global.load.ref @_descriptor_set_layout_0 : !vm.ref<!hal.descriptor_set_layout>
  %ref = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
  %ref_0 = vm.call.variadic @hal.executable_layout.create(%ref, %zero, [%_descriptor_set_layout_0]) : (!vm.ref<!hal.device>, i32, !vm.ref<!hal.descriptor_set_layout> ...) -> !vm.ref<!hal.executable_layout>
  vm.return %ref_0 : !vm.ref<!hal.executable_layout>
}

// *** IR Dump After Canonicalizer ***
vm.func private @_descriptor_set_layout_0_initializer() -> !vm.ref<!hal.descriptor_set_layout> {
  %zero = vm.const.i32.zero : i32
  %c1 = vm.const.i32 1 : i32
  %c2 = vm.const.i32 2 : i32
  %c7 = vm.const.i32 7 : i32
  %c6 = vm.const.i32 6 : i32
  %ref = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
  %ref_0 = vm.call.variadic @hal.descriptor_set_layout.create(%ref, %c1, [(%zero, %c7, %c1), (%c1, %c7, %c1), (%c2, %c7, %c6)]) : (!vm.ref<!hal.device>, i32, tuple<i32, i32, i32> ...) -> !vm.ref<!hal.descriptor_set_layout>
  vm.return %ref_0 : !vm.ref<!hal.descriptor_set_layout>
}

// *** IR Dump After Canonicalizer ***
vm.func private @_device_match_id_0_initializer() -> i32 {
  %ref = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
  %_utf8_dylib_971286B245550E6D = vm.const.ref.rodata @_utf8_dylib_971286B245550E6D : !vm.buffer
  %0 = vm.call @hal.device.match.id(%ref, %_utf8_dylib_971286B245550E6D) : (!vm.ref<!hal.device>, !vm.buffer) -> i32
  vm.return %0 : i32
}

// *** IR Dump After Canonicalizer ***
vm.func @__init() {
  %c2 = vm.const.i32 2 : i32
  %c1 = vm.const.i32 1 : i32
  %c3 = vm.const.i32 3 : i32
  %c7 = vm.const.i32 7 : i32
  %c6 = vm.const.i32 6 : i32
  %null = vm.const.ref.zero : !vm.ref<!hal.executable>
  %zero = vm.const.i32.zero : i32
  %c407040 = vm.const.i32 407040 : i32
  %c50 = vm.const.i32 50 : i32
  %c15 = vm.const.i32 15 : i32
  %ref = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
  %_utf8_dylib_971286B245550E6D = vm.const.ref.rodata @_utf8_dylib_971286B245550E6D : !vm.buffer
  %0 = vm.call @hal.device.match.id(%ref, %_utf8_dylib_971286B245550E6D) : (!vm.ref<!hal.device>, !vm.buffer) -> i32
  vm.global.store.i32 %0, @_device_match_id_0 : i32
  %ref_0 = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
  %ref_1 = vm.call.variadic @hal.descriptor_set_layout.create(%ref_0, %c1, [(%zero, %c7, %c1), (%c1, %c7, %c1), (%c2, %c7, %c6)]) : (!vm.ref<!hal.device>, i32, tuple<i32, i32, i32> ...) -> !vm.ref<!hal.descriptor_set_layout>
  vm.global.store.ref %ref_1, @_descriptor_set_layout_0 : !vm.ref<!hal.descriptor_set_layout>
  %_descriptor_set_layout_0 = vm.global.load.ref @_descriptor_set_layout_0 : !vm.ref<!hal.descriptor_set_layout>
  %ref_2 = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
  %ref_3 = vm.call.variadic @hal.executable_layout.create(%ref_2, %zero, [%_descriptor_set_layout_0]) : (!vm.ref<!hal.device>, i32, !vm.ref<!hal.descriptor_set_layout> ...) -> !vm.ref<!hal.executable_layout>
  vm.global.store.ref %ref_3, @_executable_layout_0 : !vm.ref<!hal.executable_layout>
  %ref_4 = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
  %ref_5 = vm.call.variadic @hal.descriptor_set_layout.create(%ref_4, %c1, [(%zero, %c7, %c1), (%c1, %c7, %c6)]) : (!vm.ref<!hal.device>, i32, tuple<i32, i32, i32> ...) -> !vm.ref<!hal.descriptor_set_layout>
  vm.global.store.ref %ref_5, @_descriptor_set_layout_1 : !vm.ref<!hal.descriptor_set_layout>
  %_descriptor_set_layout_1 = vm.global.load.ref @_descriptor_set_layout_1 : !vm.ref<!hal.descriptor_set_layout>
  %ref_6 = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
  %ref_7 = vm.call.variadic @hal.executable_layout.create(%ref_6, %zero, [%_descriptor_set_layout_1]) : (!vm.ref<!hal.device>, i32, !vm.ref<!hal.descriptor_set_layout> ...) -> !vm.ref<!hal.executable_layout>
  vm.global.store.ref %ref_7, @_executable_layout_1 : !vm.ref<!hal.executable_layout>
  %ref_8 = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
  %ref_9 = vm.call.variadic @hal.descriptor_set_layout.create(%ref_8, %c1, [(%zero, %c7, %c1), (%c1, %c7, %c1), (%c2, %c7, %c1), (%c3, %c7, %c6)]) : (!vm.ref<!hal.device>, i32, tuple<i32, i32, i32> ...) -> !vm.ref<!hal.descriptor_set_layout>
  vm.global.store.ref %ref_9, @_descriptor_set_layout_2 : !vm.ref<!hal.descriptor_set_layout>
  %_descriptor_set_layout_2 = vm.global.load.ref @_descriptor_set_layout_2 : !vm.ref<!hal.descriptor_set_layout>
  %ref_10 = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
  %ref_11 = vm.call.variadic @hal.executable_layout.create(%ref_10, %zero, [%_descriptor_set_layout_2]) : (!vm.ref<!hal.device>, i32, !vm.ref<!hal.descriptor_set_layout> ...) -> !vm.ref<!hal.executable_layout>
  vm.global.store.ref %ref_11, @_executable_layout_2 : !vm.ref<!hal.executable_layout>
  %ref_12 = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
  %_device_match_id_0 = vm.global.load.i32 @_device_match_id_0 : i32
  vm.cond_br %_device_match_id_0, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %_executable_layout_0 = vm.global.load.ref @_executable_layout_0 : !vm.ref<!hal.executable_layout>
  %_executable_layout_1 = vm.global.load.ref @_executable_layout_1 : !vm.ref<!hal.executable_layout>
  %_executable_layout_2 = vm.global.load.ref @_executable_layout_2 : !vm.ref<!hal.executable_layout>
  %_utf8_dlib_F45B9BA87AEFAACB = vm.const.ref.rodata @_utf8_dlib_F45B9BA87AEFAACB : !vm.buffer
  %_mnist_linked_llvm_aot_llvm_aot_binary_dlib = vm.const.ref.rodata @_mnist_linked_llvm_aot_llvm_aot_binary_dlib : !vm.buffer
  %ref_13 = vm.call.variadic @hal.executable.create(%ref_12, %_utf8_dlib_F45B9BA87AEFAACB, %_mnist_linked_llvm_aot_llvm_aot_binary_dlib, [%_executable_layout_0, %_executable_layout_0, %_executable_layout_0, %_executable_layout_1, %_executable_layout_1, %_executable_layout_0, %_executable_layout_1, %_executable_layout_2]) : (!vm.ref<!hal.device>, !vm.buffer, !vm.buffer, !vm.ref<!hal.executable_layout> ...) -> !vm.ref<!hal.executable>
  vm.br ^bb3(%ref_13 : !vm.ref<!hal.executable>)
^bb2:  // pred: ^bb0
  vm.br ^bb3(%null : !vm.ref<!hal.executable>)
^bb3(%1: !vm.ref<!hal.executable>):  // 2 preds: ^bb1, ^bb2
  vm.global.store.ref %1, @_executable_mnist_linked_llvm_aot : !vm.ref<!hal.executable>
  %ref_14 = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
  %ref_15 = vm.call @hal.device.allocator(%ref_14) : (!vm.ref<!hal.device>) -> !vm.ref<!hal.allocator>
  %_const_pool_storage = vm.const.ref.rodata @_const_pool_storage : !vm.buffer
  %ref_16 = vm.call @hal.allocator.wrap.byte_buffer(%ref_15, %c50, %c15, %_const_pool_storage, %zero, %c407040) : (!vm.ref<!hal.allocator>, i32, i32, !vm.buffer, i32, i32) -> !vm.ref<!hal.buffer>
  vm.global.store.ref %ref_16, @_const_pool_storage_buffer : !vm.ref<!hal.buffer>
  vm.return
}

// *** IR Dump After Canonicalizer ***
vm.func @predict$sync(%arg0: !vm.ref<!hal.buffer_view>) -> !vm.ref<!hal.buffer_view> attributes {iree.reflection = {abi = "sip", abiv = 1 : i32, f = "I15!B11!d1d28d28d1R9!B6!d1d10", fv = "1", sip = "I8!S5!k0_0R3!_0"}} {
  %zero = vm.const.i32.zero : i32
  %c1 = vm.const.i32 1 : i32
  %c10 = vm.const.i32 10 : i32
  %c50331680 = vm.const.i32 50331680 : i32
  %ref = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
  %ref_0 = vm.call @hal.semaphore.create(%ref, %zero) : (!vm.ref<!hal.device>, i32) -> !vm.ref<!hal.semaphore>
  %0 = vm.call @hal.semaphore.await(%ref_0, %zero) : (!vm.ref<!hal.semaphore>, i32) -> i32
  vm.cond_br %0, ^bb2(%0 : i32), ^bb1
^bb1:  // pred: ^bb0
  %ref_1 = vm.call @hal.buffer_view.buffer(%arg0) : (!vm.ref<!hal.buffer_view>) -> !vm.ref<!hal.buffer>
  %ref_2 = vm.call @predict(%ref_1) : (!vm.ref<!hal.buffer>) -> !vm.ref<!hal.buffer>
  %ref_3 = vm.call.variadic @hal.buffer_view.create(%ref_2, %c50331680, [%c1, %c10]) : (!vm.ref<!hal.buffer>, i32, i32 ...) -> !vm.ref<!hal.buffer_view>
  vm.call @hal.semaphore.signal(%ref_0, %c1) : (!vm.ref<!hal.semaphore>, i32) -> ()
  %1 = vm.call @hal.semaphore.await(%ref_0, %c1) : (!vm.ref<!hal.semaphore>, i32) -> i32
  vm.cond_br %1, ^bb2(%1 : i32), ^bb3
^bb2(%2: i32):  // 2 preds: ^bb0, ^bb1
  vm.fail %2, "semaphore wait failed"
^bb3:  // pred: ^bb1
  vm.return %ref_3 : !vm.ref<!hal.buffer_view>
}

// *** IR Dump After Canonicalizer ***
vm.func @predict$async(%arg0: !vm.ref<!hal.semaphore>, %arg1: i32, %arg2: !vm.ref<!hal.buffer_view>, %arg3: !vm.ref<!hal.semaphore>, %arg4: i32) -> !vm.ref<!hal.buffer_view> {
  %c1 = vm.const.i32 1 : i32
  %c10 = vm.const.i32 10 : i32
  %c50331680 = vm.const.i32 50331680 : i32
  %0 = vm.call @hal.semaphore.await(%arg0, %arg1) : (!vm.ref<!hal.semaphore>, i32) -> i32
  vm.cond_br %0, ^bb2(%0 : i32), ^bb1
^bb1:  // pred: ^bb0
  %ref = vm.call @hal.buffer_view.buffer(%arg2) : (!vm.ref<!hal.buffer_view>) -> !vm.ref<!hal.buffer>
  %ref_0 = vm.call @predict(%ref) : (!vm.ref<!hal.buffer>) -> !vm.ref<!hal.buffer>
  %ref_1 = vm.call.variadic @hal.buffer_view.create(%ref_0, %c50331680, [%c1, %c10]) : (!vm.ref<!hal.buffer>, i32, i32 ...) -> !vm.ref<!hal.buffer_view>
  vm.call @hal.semaphore.signal(%arg3, %arg4) : (!vm.ref<!hal.semaphore>, i32) -> ()
  vm.return %ref_1 : !vm.ref<!hal.buffer_view>
^bb2(%1: i32):  // pred: ^bb0
  vm.fail %1, "semaphore wait failed"
}

// *** IR Dump After Canonicalizer ***
vm.func @predict(%arg0: !vm.ref<!hal.buffer>) -> !vm.ref<!hal.buffer> attributes {noinline} {
  %c3136 = vm.const.i32 3136 : i32
  %c401408 = vm.const.i32 401408 : i32
  %c401920 = vm.const.i32 401920 : i32
  %c5120 = vm.const.i32 5120 : i32
  %c40 = vm.const.i32 40 : i32
  %c512 = vm.const.i32 512 : i32
  %c96 = vm.const.i32 96 : i32
  %c112 = vm.const.i32 112 : i32
  %c1024 = vm.const.i32 1024 : i32
  %c50 = vm.const.i32 50 : i32
  %c14 = vm.const.i32 14 : i32
  %c48 = vm.const.i32 48 : i32
  %c10 = vm.const.i32 10 : i32
  %c17 = vm.const.i32 17 : i32
  %c1 = vm.const.i32 1 : i32
  %c3 = vm.const.i32 3 : i32
  %c4 = vm.const.i32 4 : i32
  %c6 = vm.const.i32 6 : i32
  %c7 = vm.const.i32 7 : i32
  %c20 = vm.const.i32 20 : i32
  %c5 = vm.const.i32 5 : i32
  %zero = vm.const.i32.zero : i32
  %c2 = vm.const.i32 2 : i32
  %ref = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
  %ref_0 = vm.call @hal.device.allocator(%ref) : (!vm.ref<!hal.device>) -> !vm.ref<!hal.allocator>
  %ref_1 = vm.call @hal.allocator.allocate(%ref_0, %c50, %c14, %c40) : (!vm.ref<!hal.allocator>, i32, i32, i32) -> !vm.ref<!hal.buffer>
  %_const_pool_storage_buffer = vm.global.load.ref @_const_pool_storage_buffer : !vm.ref<!hal.buffer>
  %ref_2 = vm.call @hal.allocator.allocate(%ref_0, %c48, %c10, %c1024) : (!vm.ref<!hal.allocator>, i32, i32, i32) -> !vm.ref<!hal.buffer>
  %ref_3 = vm.call @hal.command_buffer.create(%ref, %c17, %c3) : (!vm.ref<!hal.device>, i32, i32) -> !vm.ref<!hal.command_buffer>
  vm.call @hal.command_buffer.begin(%ref_3) : (!vm.ref<!hal.command_buffer>) -> ()
  %_executable_layout_0 = vm.global.load.ref @_executable_layout_0 : !vm.ref<!hal.executable_layout>
  vm.call.variadic @hal.command_buffer.push_descriptor_set(%ref_3, %_executable_layout_0, %zero, [(%zero, %_const_pool_storage_buffer, %c512, %c401408), (%c1, %arg0, %zero, %c3136), (%c2, %ref_2, %zero, %c512)]) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable_layout>, i32, tuple<i32, !vm.ref<!hal.buffer>, i32, i32> ...)
  %_device_match_id_0 = vm.global.load.i32 @_device_match_id_0 : i32
  vm.cond_br %_device_match_id_0, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %_executable_mnist_linked_llvm_aot = vm.global.load.ref @_executable_mnist_linked_llvm_aot : !vm.ref<!hal.executable>
  vm.call @hal.command_buffer.dispatch(%ref_3, %_executable_mnist_linked_llvm_aot, %zero, %c2, %c1, %c1) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable>, i32, i32, i32, i32) -> ()
  vm.call @hal.command_buffer.execution_barrier(%ref_3, %c20, %c5, %zero) : (!vm.ref<!hal.command_buffer>, i32, i32, i32) -> ()
  vm.call.variadic @hal.command_buffer.push_descriptor_set(%ref_3, %_executable_layout_0, %zero, [(%zero, %_const_pool_storage_buffer, %zero, %c512), (%c1, %ref_2, %zero, %c512), (%c2, %ref_2, %c512, %c512)]) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable_layout>, i32, tuple<i32, !vm.ref<!hal.buffer>, i32, i32> ...)
  vm.call @hal.command_buffer.dispatch(%ref_3, %_executable_mnist_linked_llvm_aot, %c1, %c1, %c1, %c1) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable>, i32, i32, i32, i32) -> ()
  vm.call @hal.command_buffer.execution_barrier(%ref_3, %c20, %c5, %zero) : (!vm.ref<!hal.command_buffer>, i32, i32, i32) -> ()
  vm.call.variadic @hal.command_buffer.push_descriptor_set(%ref_3, %_executable_layout_0, %zero, [(%zero, %_const_pool_storage_buffer, %c401920, %c5120), (%c1, %ref_2, %c512, %c512), (%c2, %ref_2, %zero, %c40)]) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable_layout>, i32, tuple<i32, !vm.ref<!hal.buffer>, i32, i32> ...)
  vm.call @hal.command_buffer.dispatch(%ref_3, %_executable_mnist_linked_llvm_aot, %c2, %c1, %c1, %c1) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable>, i32, i32, i32, i32) -> ()
  vm.call @hal.command_buffer.execution_barrier(%ref_3, %c20, %c5, %zero) : (!vm.ref<!hal.command_buffer>, i32, i32, i32) -> ()
  %_executable_layout_1 = vm.global.load.ref @_executable_layout_1 : !vm.ref<!hal.executable_layout>
  vm.call.variadic @hal.command_buffer.push_descriptor_set(%ref_3, %_executable_layout_1, %zero, [(%zero, %ref_2, %zero, %c40), (%c1, %ref_2, %c48, %c40)]) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable_layout>, i32, tuple<i32, !vm.ref<!hal.buffer>, i32, i32> ...)
  vm.call @hal.command_buffer.dispatch(%ref_3, %_executable_mnist_linked_llvm_aot, %c3, %c1, %c1, %c1) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable>, i32, i32, i32, i32) -> ()
  vm.call @hal.command_buffer.execution_barrier(%ref_3, %c20, %c5, %zero) : (!vm.ref<!hal.command_buffer>, i32, i32, i32) -> ()
  vm.call.variadic @hal.command_buffer.push_descriptor_set(%ref_3, %_executable_layout_1, %zero, [(%zero, %ref_2, %c48, %c40), (%c1, %ref_2, %c96, %c4)]) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable_layout>, i32, tuple<i32, !vm.ref<!hal.buffer>, i32, i32> ...)
  vm.call @hal.command_buffer.dispatch(%ref_3, %_executable_mnist_linked_llvm_aot, %c4, %c1, %c1, %c1) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable>, i32, i32, i32, i32) -> ()
  vm.call @hal.command_buffer.execution_barrier(%ref_3, %c20, %c5, %zero) : (!vm.ref<!hal.command_buffer>, i32, i32, i32) -> ()
  vm.call.variadic @hal.command_buffer.push_descriptor_set(%ref_3, %_executable_layout_0, %zero, [(%zero, %ref_2, %zero, %c40), (%c1, %ref_2, %c96, %c4), (%c2, %ref_2, %c48, %c40)]) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable_layout>, i32, tuple<i32, !vm.ref<!hal.buffer>, i32, i32> ...)
  vm.call @hal.command_buffer.dispatch(%ref_3, %_executable_mnist_linked_llvm_aot, %c5, %c1, %c1, %c1) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable>, i32, i32, i32, i32) -> ()
  vm.call @hal.command_buffer.execution_barrier(%ref_3, %c20, %c5, %zero) : (!vm.ref<!hal.command_buffer>, i32, i32, i32) -> ()
  vm.call.variadic @hal.command_buffer.push_descriptor_set(%ref_3, %_executable_layout_1, %zero, [(%zero, %ref_2, %c48, %c40), (%c1, %ref_2, %c112, %c4)]) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable_layout>, i32, tuple<i32, !vm.ref<!hal.buffer>, i32, i32> ...)
  vm.call @hal.command_buffer.dispatch(%ref_3, %_executable_mnist_linked_llvm_aot, %c6, %c1, %c1, %c1) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable>, i32, i32, i32, i32) -> ()
  vm.call @hal.command_buffer.execution_barrier(%ref_3, %c20, %c5, %zero) : (!vm.ref<!hal.command_buffer>, i32, i32, i32) -> ()
  %_executable_layout_2 = vm.global.load.ref @_executable_layout_2 : !vm.ref<!hal.executable_layout>
  vm.call.variadic @hal.command_buffer.push_descriptor_set(%ref_3, %_executable_layout_2, %zero, [(%zero, %ref_2, %zero, %c40), (%c1, %ref_2, %c96, %c4), (%c2, %ref_2, %c112, %c4), (%c3, %ref_1, %zero, %c40)]) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable_layout>, i32, tuple<i32, !vm.ref<!hal.buffer>, i32, i32> ...)
  vm.call @hal.command_buffer.dispatch(%ref_3, %_executable_mnist_linked_llvm_aot, %c7, %c1, %c1, %c1) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable>, i32, i32, i32, i32) -> ()
  vm.call @hal.command_buffer.execution_barrier(%ref_3, %c20, %c5, %zero) : (!vm.ref<!hal.command_buffer>, i32, i32, i32) -> ()
  vm.call @hal.command_buffer.end(%ref_3) : (!vm.ref<!hal.command_buffer>) -> ()
  vm.call @hal.ex.submit_and_wait(%ref, %ref_3) : (!vm.ref<!hal.device>, !vm.ref<!hal.command_buffer>) -> ()
  vm.return %ref_1 : !vm.ref<!hal.buffer>
^bb2:  // pred: ^bb0
  vm.fail %c2, "device not supported in the compiled configuration"
}

// *** IR Dump After Inliner ***
module  {
  vm.module @module {
    vm.global.i32 @_device_match_id_0 mutable : i32
    vm.rodata @_utf8_dylib_971286B245550E6D dense<[100, 121, 108, 105, 98, 42]> : vector<6xi8>
    vm.global.ref @_descriptor_set_layout_0 mutable : !vm.ref<!hal.descriptor_set_layout>
    vm.global.ref @_executable_layout_0 mutable : !vm.ref<!hal.executable_layout>
    vm.global.ref @_descriptor_set_layout_1 mutable : !vm.ref<!hal.descriptor_set_layout>
    vm.global.ref @_executable_layout_1 mutable : !vm.ref<!hal.executable_layout>
    vm.global.ref @_descriptor_set_layout_2 mutable : !vm.ref<!hal.descriptor_set_layout>
    vm.global.ref @_executable_layout_2 mutable : !vm.ref<!hal.executable_layout>
    vm.global.ref @_executable_mnist_linked_llvm_aot mutable : !vm.ref<!hal.executable>
    vm.rodata @_mnist_linked_llvm_aot_llvm_aot_binary_dlib opaque<"_", "0xDEADBEEF"> : vector<136794xi8>
    vm.rodata @_utf8_dlib_F45B9BA87AEFAACB dense<[68, 76, 73, 66]> : vector<4xi8>
    vm.rodata @_const_pool_storage opaque<"_", "0xDEADBEEF"> : vector<407040xi8>
    vm.global.ref @_const_pool_storage_buffer mutable : !vm.ref<!hal.buffer>
    vm.func @predict(%arg0: !vm.ref<!hal.buffer>) -> !vm.ref<!hal.buffer> attributes {noinline} {
      %c3136 = vm.const.i32 3136 : i32
      %c401408 = vm.const.i32 401408 : i32
      %c401920 = vm.const.i32 401920 : i32
      %c5120 = vm.const.i32 5120 : i32
      %c40 = vm.const.i32 40 : i32
      %c512 = vm.const.i32 512 : i32
      %c96 = vm.const.i32 96 : i32
      %c112 = vm.const.i32 112 : i32
      %c1024 = vm.const.i32 1024 : i32
      %c50 = vm.const.i32 50 : i32
      %c14 = vm.const.i32 14 : i32
      %c48 = vm.const.i32 48 : i32
      %c10 = vm.const.i32 10 : i32
      %c17 = vm.const.i32 17 : i32
      %c1 = vm.const.i32 1 : i32
      %c3 = vm.const.i32 3 : i32
      %c4 = vm.const.i32 4 : i32
      %c6 = vm.const.i32 6 : i32
      %c7 = vm.const.i32 7 : i32
      %c20 = vm.const.i32 20 : i32
      %c5 = vm.const.i32 5 : i32
      %zero = vm.const.i32.zero : i32
      %c2 = vm.const.i32 2 : i32
      %ref = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
      %ref_0 = vm.call @hal.device.allocator(%ref) : (!vm.ref<!hal.device>) -> !vm.ref<!hal.allocator>
      %ref_1 = vm.call @hal.allocator.allocate(%ref_0, %c50, %c14, %c40) : (!vm.ref<!hal.allocator>, i32, i32, i32) -> !vm.ref<!hal.buffer>
      %_const_pool_storage_buffer = vm.global.load.ref @_const_pool_storage_buffer : !vm.ref<!hal.buffer>
      %ref_2 = vm.call @hal.allocator.allocate(%ref_0, %c48, %c10, %c1024) : (!vm.ref<!hal.allocator>, i32, i32, i32) -> !vm.ref<!hal.buffer>
      %ref_3 = vm.call @hal.command_buffer.create(%ref, %c17, %c3) : (!vm.ref<!hal.device>, i32, i32) -> !vm.ref<!hal.command_buffer>
      vm.call @hal.command_buffer.begin(%ref_3) : (!vm.ref<!hal.command_buffer>) -> ()
      %_executable_layout_0 = vm.global.load.ref @_executable_layout_0 : !vm.ref<!hal.executable_layout>
      vm.call.variadic @hal.command_buffer.push_descriptor_set(%ref_3, %_executable_layout_0, %zero, [(%zero, %_const_pool_storage_buffer, %c512, %c401408), (%c1, %arg0, %zero, %c3136), (%c2, %ref_2, %zero, %c512)]) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable_layout>, i32, tuple<i32, !vm.ref<!hal.buffer>, i32, i32> ...)
      %_device_match_id_0 = vm.global.load.i32 @_device_match_id_0 : i32
      vm.cond_br %_device_match_id_0, ^bb1, ^bb2
    ^bb1:  // pred: ^bb0
      %_executable_mnist_linked_llvm_aot = vm.global.load.ref @_executable_mnist_linked_llvm_aot : !vm.ref<!hal.executable>
      vm.call @hal.command_buffer.dispatch(%ref_3, %_executable_mnist_linked_llvm_aot, %zero, %c2, %c1, %c1) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable>, i32, i32, i32, i32) -> ()
      vm.call @hal.command_buffer.execution_barrier(%ref_3, %c20, %c5, %zero) : (!vm.ref<!hal.command_buffer>, i32, i32, i32) -> ()
      vm.call.variadic @hal.command_buffer.push_descriptor_set(%ref_3, %_executable_layout_0, %zero, [(%zero, %_const_pool_storage_buffer, %zero, %c512), (%c1, %ref_2, %zero, %c512), (%c2, %ref_2, %c512, %c512)]) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable_layout>, i32, tuple<i32, !vm.ref<!hal.buffer>, i32, i32> ...)
      vm.call @hal.command_buffer.dispatch(%ref_3, %_executable_mnist_linked_llvm_aot, %c1, %c1, %c1, %c1) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable>, i32, i32, i32, i32) -> ()
      vm.call @hal.command_buffer.execution_barrier(%ref_3, %c20, %c5, %zero) : (!vm.ref<!hal.command_buffer>, i32, i32, i32) -> ()
      vm.call.variadic @hal.command_buffer.push_descriptor_set(%ref_3, %_executable_layout_0, %zero, [(%zero, %_const_pool_storage_buffer, %c401920, %c5120), (%c1, %ref_2, %c512, %c512), (%c2, %ref_2, %zero, %c40)]) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable_layout>, i32, tuple<i32, !vm.ref<!hal.buffer>, i32, i32> ...)
      vm.call @hal.command_buffer.dispatch(%ref_3, %_executable_mnist_linked_llvm_aot, %c2, %c1, %c1, %c1) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable>, i32, i32, i32, i32) -> ()
      vm.call @hal.command_buffer.execution_barrier(%ref_3, %c20, %c5, %zero) : (!vm.ref<!hal.command_buffer>, i32, i32, i32) -> ()
      %_executable_layout_1 = vm.global.load.ref @_executable_layout_1 : !vm.ref<!hal.executable_layout>
      vm.call.variadic @hal.command_buffer.push_descriptor_set(%ref_3, %_executable_layout_1, %zero, [(%zero, %ref_2, %zero, %c40), (%c1, %ref_2, %c48, %c40)]) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable_layout>, i32, tuple<i32, !vm.ref<!hal.buffer>, i32, i32> ...)
      vm.call @hal.command_buffer.dispatch(%ref_3, %_executable_mnist_linked_llvm_aot, %c3, %c1, %c1, %c1) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable>, i32, i32, i32, i32) -> ()
      vm.call @hal.command_buffer.execution_barrier(%ref_3, %c20, %c5, %zero) : (!vm.ref<!hal.command_buffer>, i32, i32, i32) -> ()
      vm.call.variadic @hal.command_buffer.push_descriptor_set(%ref_3, %_executable_layout_1, %zero, [(%zero, %ref_2, %c48, %c40), (%c1, %ref_2, %c96, %c4)]) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable_layout>, i32, tuple<i32, !vm.ref<!hal.buffer>, i32, i32> ...)
      vm.call @hal.command_buffer.dispatch(%ref_3, %_executable_mnist_linked_llvm_aot, %c4, %c1, %c1, %c1) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable>, i32, i32, i32, i32) -> ()
      vm.call @hal.command_buffer.execution_barrier(%ref_3, %c20, %c5, %zero) : (!vm.ref<!hal.command_buffer>, i32, i32, i32) -> ()
      vm.call.variadic @hal.command_buffer.push_descriptor_set(%ref_3, %_executable_layout_0, %zero, [(%zero, %ref_2, %zero, %c40), (%c1, %ref_2, %c96, %c4), (%c2, %ref_2, %c48, %c40)]) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable_layout>, i32, tuple<i32, !vm.ref<!hal.buffer>, i32, i32> ...)
      vm.call @hal.command_buffer.dispatch(%ref_3, %_executable_mnist_linked_llvm_aot, %c5, %c1, %c1, %c1) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable>, i32, i32, i32, i32) -> ()
      vm.call @hal.command_buffer.execution_barrier(%ref_3, %c20, %c5, %zero) : (!vm.ref<!hal.command_buffer>, i32, i32, i32) -> ()
      vm.call.variadic @hal.command_buffer.push_descriptor_set(%ref_3, %_executable_layout_1, %zero, [(%zero, %ref_2, %c48, %c40), (%c1, %ref_2, %c112, %c4)]) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable_layout>, i32, tuple<i32, !vm.ref<!hal.buffer>, i32, i32> ...)
      vm.call @hal.command_buffer.dispatch(%ref_3, %_executable_mnist_linked_llvm_aot, %c6, %c1, %c1, %c1) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable>, i32, i32, i32, i32) -> ()
      vm.call @hal.command_buffer.execution_barrier(%ref_3, %c20, %c5, %zero) : (!vm.ref<!hal.command_buffer>, i32, i32, i32) -> ()
      %_executable_layout_2 = vm.global.load.ref @_executable_layout_2 : !vm.ref<!hal.executable_layout>
      vm.call.variadic @hal.command_buffer.push_descriptor_set(%ref_3, %_executable_layout_2, %zero, [(%zero, %ref_2, %zero, %c40), (%c1, %ref_2, %c96, %c4), (%c2, %ref_2, %c112, %c4), (%c3, %ref_1, %zero, %c40)]) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable_layout>, i32, tuple<i32, !vm.ref<!hal.buffer>, i32, i32> ...)
      vm.call @hal.command_buffer.dispatch(%ref_3, %_executable_mnist_linked_llvm_aot, %c7, %c1, %c1, %c1) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable>, i32, i32, i32, i32) -> ()
      vm.call @hal.command_buffer.execution_barrier(%ref_3, %c20, %c5, %zero) : (!vm.ref<!hal.command_buffer>, i32, i32, i32) -> ()
      vm.call @hal.command_buffer.end(%ref_3) : (!vm.ref<!hal.command_buffer>) -> ()
      vm.call @hal.ex.submit_and_wait(%ref, %ref_3) : (!vm.ref<!hal.device>, !vm.ref<!hal.command_buffer>) -> ()
      vm.return %ref_1 : !vm.ref<!hal.buffer>
    ^bb2:  // pred: ^bb0
      vm.fail %c2, "device not supported in the compiled configuration"
    }
    vm.func @predict$async(%arg0: !vm.ref<!hal.semaphore>, %arg1: i32, %arg2: !vm.ref<!hal.buffer_view>, %arg3: !vm.ref<!hal.semaphore>, %arg4: i32) -> !vm.ref<!hal.buffer_view> {
      %c1 = vm.const.i32 1 : i32
      %c10 = vm.const.i32 10 : i32
      %c50331680 = vm.const.i32 50331680 : i32
      %0 = vm.call @hal.semaphore.await(%arg0, %arg1) : (!vm.ref<!hal.semaphore>, i32) -> i32
      vm.cond_br %0, ^bb2(%0 : i32), ^bb1
    ^bb1:  // pred: ^bb0
      %ref = vm.call @hal.buffer_view.buffer(%arg2) : (!vm.ref<!hal.buffer_view>) -> !vm.ref<!hal.buffer>
      %ref_0 = vm.call @predict(%ref) : (!vm.ref<!hal.buffer>) -> !vm.ref<!hal.buffer>
      %ref_1 = vm.call.variadic @hal.buffer_view.create(%ref_0, %c50331680, [%c1, %c10]) : (!vm.ref<!hal.buffer>, i32, i32 ...) -> !vm.ref<!hal.buffer_view>
      vm.call @hal.semaphore.signal(%arg3, %arg4) : (!vm.ref<!hal.semaphore>, i32) -> ()
      vm.return %ref_1 : !vm.ref<!hal.buffer_view>
    ^bb2(%1: i32):  // pred: ^bb0
      vm.fail %1, "semaphore wait failed"
    }
    vm.export @predict$async
    vm.import @hal.ex.shared_device() -> !vm.ref<!hal.device> attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.ex.submit_and_wait(%device : !vm.ref<!hal.device>, %command_buffer : !vm.ref<!hal.command_buffer>) attributes {sym_visibility = "private"}
    vm.import @hal.allocator.allocate(%allocator : !vm.ref<!hal.allocator>, %memory_types : i32, %buffer_usage : i32, %allocation_size : i32) -> !vm.ref<!hal.buffer> attributes {sym_visibility = "private"}
    vm.import @hal.allocator.wrap.byte_buffer(%allocator : !vm.ref<!hal.allocator>, %memory_types : i32, %buffer_usage : i32, %source : !vm.buffer, %offset : i32, %length : i32) -> !vm.ref<!hal.buffer> attributes {sym_visibility = "private"}
    vm.import @hal.buffer.allocator(%buffer : !vm.ref<!hal.buffer>) -> !vm.ref<!hal.allocator> attributes {sym_visibility = "private"}
    vm.import @hal.buffer.subspan(%source_buffer : !vm.ref<!hal.buffer>, %source_offset : i32, %length : i32) -> !vm.ref<!hal.buffer> attributes {sym_visibility = "private"}
    vm.import @hal.buffer.load(%source_buffer : !vm.ref<!hal.buffer>, %source_offset : i32, %length : i32) -> i32 attributes {sym_visibility = "private"}
    vm.import @hal.buffer.store(%value : i32, %target_buffer : !vm.ref<!hal.buffer>, %target_offset : i32, %length : i32) attributes {sym_visibility = "private"}
    vm.import @hal.buffer_view.create(%buffer : !vm.ref<!hal.buffer>, %element_type : i32, %shape : i32 ...) -> !vm.ref<!hal.buffer_view> attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.buffer_view.buffer(%buffer_view : !vm.ref<!hal.buffer_view>) -> !vm.ref<!hal.buffer> attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.buffer_view.byte_length(%buffer_view : !vm.ref<!hal.buffer_view>) -> i32 attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.buffer_view.element_type(%buffer_view : !vm.ref<!hal.buffer_view>) -> i32 attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.buffer_view.rank(%buffer_view : !vm.ref<!hal.buffer_view>) -> i32 attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.buffer_view.dim(%buffer_view : !vm.ref<!hal.buffer_view>, %index : i32) -> i32 attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.buffer_view.trace(%key : !vm.buffer, %operands : !vm.ref<!hal.buffer_view> ...) attributes {sym_visibility = "private"}
    vm.import @hal.command_buffer.create(%device : !vm.ref<!hal.device>, %modes : i32, %command_categories : i32) -> !vm.ref<!hal.command_buffer> attributes {sym_visibility = "private"}
    vm.import @hal.command_buffer.begin(%command_buffer : !vm.ref<!hal.command_buffer>) attributes {sym_visibility = "private"}
    vm.import @hal.command_buffer.end(%command_buffer : !vm.ref<!hal.command_buffer>) attributes {sym_visibility = "private"}
    vm.import @hal.command_buffer.execution_barrier(%command_buffer : !vm.ref<!hal.command_buffer>, %source_stage_mask : i32, %target_stage_mask : i32, %flags : i32) attributes {sym_visibility = "private"}
    vm.import @hal.command_buffer.fill_buffer(%command_buffer : !vm.ref<!hal.command_buffer>, %target_buffer : !vm.ref<!hal.buffer>, %target_offset : i32, %length : i32, %pattern : i32) attributes {sym_visibility = "private"}
    vm.import @hal.command_buffer.copy_buffer(%command_buffer : !vm.ref<!hal.command_buffer>, %source_buffer : !vm.ref<!hal.buffer>, %source_offset : i32, %target_buffer : !vm.ref<!hal.buffer>, %target_offset : i32, %length : i32) attributes {sym_visibility = "private"}
    vm.import @hal.command_buffer.push_constants(%command_buffer : !vm.ref<!hal.command_buffer>, %executable_layout : !vm.ref<!hal.executable_layout>, %offset : i32, %values : i32 ...) attributes {sym_visibility = "private"}
    vm.import @hal.command_buffer.push_descriptor_set(%command_buffer : !vm.ref<!hal.command_buffer>, %executable_layout : !vm.ref<!hal.executable_layout>, %set : i32, %bindings : tuple<i32, !vm.ref<!hal.buffer>, i32, i32> ...) attributes {sym_visibility = "private"}
    vm.import @hal.command_buffer.bind_descriptor_set(%command_buffer : !vm.ref<!hal.command_buffer>, %executable_layout : !vm.ref<!hal.executable_layout>, %set : i32, %descriptor_set : !vm.ref<!hal.descriptor_set>, %dynamic_offsets : i32 ...) attributes {sym_visibility = "private"}
    vm.import @hal.command_buffer.dispatch(%command_buffer : !vm.ref<!hal.command_buffer>, %executable : !vm.ref<!hal.executable>, %entry_point : i32, %workgroup_x : i32, %workgroup_y : i32, %workgroup_z : i32) attributes {sym_visibility = "private"}
    vm.import @hal.command_buffer.dispatch.indirect(%command_buffer : !vm.ref<!hal.command_buffer>, %executable : !vm.ref<!hal.executable>, %entry_point : i32, %workgroups_buffer : !vm.ref<!hal.buffer>, %workgroups_offset : i32) attributes {sym_visibility = "private"}
    vm.import @hal.descriptor_set.create(%device : !vm.ref<!hal.device>, %set_layout : !vm.ref<!hal.descriptor_set_layout>, %bindings : tuple<i32, !vm.ref<!hal.buffer>, i32, i32> ...) -> !vm.ref<!hal.descriptor_set> attributes {sym_visibility = "private"}
    vm.import @hal.descriptor_set_layout.create(%device : !vm.ref<!hal.device>, %usage_type : i32, %bindings : tuple<i32, i32, i32> ...) -> !vm.ref<!hal.descriptor_set_layout> attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.device.allocator(%device : !vm.ref<!hal.device>) -> !vm.ref<!hal.allocator> attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.device.query.i32(%device : !vm.ref<!hal.device>, %key : !vm.buffer) -> (i32, i32) attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.device.match.id(%device : !vm.ref<!hal.device>, %pattern : !vm.buffer) -> i32 attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.executable.create(%device : !vm.ref<!hal.device>, %executable_format : !vm.buffer, %executable_data : !vm.buffer, %executable_layouts : !vm.ref<!hal.executable_layout> ...) -> !vm.ref<!hal.executable> attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.executable_layout.create(%device : !vm.ref<!hal.device>, %push_constants : i32, %set_layouts : !vm.ref<!hal.descriptor_set_layout> ...) -> !vm.ref<!hal.executable_layout> attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.semaphore.create(%device : !vm.ref<!hal.device>, %initial_value : i32) -> !vm.ref<!hal.semaphore> attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.semaphore.query(%semaphore : !vm.ref<!hal.semaphore>) -> (i32, i32) attributes {sym_visibility = "private"}
    vm.import @hal.semaphore.signal(%semaphore : !vm.ref<!hal.semaphore>, %new_value : i32) attributes {sym_visibility = "private"}
    vm.import @hal.semaphore.fail(%semaphore : !vm.ref<!hal.semaphore>, %status : i32) attributes {sym_visibility = "private"}
    vm.import @hal.semaphore.await(%semaphore : !vm.ref<!hal.semaphore>, %min_value : i32) -> i32 attributes {sym_visibility = "private"}
    vm.func @predict$sync(%arg0: !vm.ref<!hal.buffer_view>) -> !vm.ref<!hal.buffer_view> attributes {iree.reflection = {abi = "sip", abiv = 1 : i32, f = "I15!B11!d1d28d28d1R9!B6!d1d10", fv = "1", sip = "I8!S5!k0_0R3!_0"}} {
      %zero = vm.const.i32.zero : i32
      %c1 = vm.const.i32 1 : i32
      %c10 = vm.const.i32 10 : i32
      %c50331680 = vm.const.i32 50331680 : i32
      %ref = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
      %ref_0 = vm.call @hal.semaphore.create(%ref, %zero) : (!vm.ref<!hal.device>, i32) -> !vm.ref<!hal.semaphore>
      %0 = vm.call @hal.semaphore.await(%ref_0, %zero) : (!vm.ref<!hal.semaphore>, i32) -> i32
      vm.cond_br %0, ^bb2(%0 : i32), ^bb1
    ^bb1:  // pred: ^bb0
      %ref_1 = vm.call @hal.buffer_view.buffer(%arg0) : (!vm.ref<!hal.buffer_view>) -> !vm.ref<!hal.buffer>
      %ref_2 = vm.call @predict(%ref_1) : (!vm.ref<!hal.buffer>) -> !vm.ref<!hal.buffer>
      %ref_3 = vm.call.variadic @hal.buffer_view.create(%ref_2, %c50331680, [%c1, %c10]) : (!vm.ref<!hal.buffer>, i32, i32 ...) -> !vm.ref<!hal.buffer_view>
      vm.call @hal.semaphore.signal(%ref_0, %c1) : (!vm.ref<!hal.semaphore>, i32) -> ()
      %1 = vm.call @hal.semaphore.await(%ref_0, %c1) : (!vm.ref<!hal.semaphore>, i32) -> i32
      vm.cond_br %1, ^bb2(%1 : i32), ^bb3
    ^bb2(%2: i32):  // 2 preds: ^bb0, ^bb1
      vm.fail %2, "semaphore wait failed"
    ^bb3:  // pred: ^bb1
      vm.return %ref_3 : !vm.ref<!hal.buffer_view>
    }
    vm.export @predict$sync as("predict")
    vm.func @__init() {
      %c2 = vm.const.i32 2 : i32
      %c1 = vm.const.i32 1 : i32
      %c3 = vm.const.i32 3 : i32
      %c7 = vm.const.i32 7 : i32
      %c6 = vm.const.i32 6 : i32
      %null = vm.const.ref.zero : !vm.ref<!hal.executable>
      %zero = vm.const.i32.zero : i32
      %c407040 = vm.const.i32 407040 : i32
      %c50 = vm.const.i32 50 : i32
      %c15 = vm.const.i32 15 : i32
      %ref = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
      %_utf8_dylib_971286B245550E6D = vm.const.ref.rodata @_utf8_dylib_971286B245550E6D : !vm.buffer
      %0 = vm.call @hal.device.match.id(%ref, %_utf8_dylib_971286B245550E6D) : (!vm.ref<!hal.device>, !vm.buffer) -> i32
      vm.global.store.i32 %0, @_device_match_id_0 : i32
      %ref_0 = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
      %ref_1 = vm.call.variadic @hal.descriptor_set_layout.create(%ref_0, %c1, [(%zero, %c7, %c1), (%c1, %c7, %c1), (%c2, %c7, %c6)]) : (!vm.ref<!hal.device>, i32, tuple<i32, i32, i32> ...) -> !vm.ref<!hal.descriptor_set_layout>
      vm.global.store.ref %ref_1, @_descriptor_set_layout_0 : !vm.ref<!hal.descriptor_set_layout>
      %_descriptor_set_layout_0 = vm.global.load.ref @_descriptor_set_layout_0 : !vm.ref<!hal.descriptor_set_layout>
      %ref_2 = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
      %ref_3 = vm.call.variadic @hal.executable_layout.create(%ref_2, %zero, [%_descriptor_set_layout_0]) : (!vm.ref<!hal.device>, i32, !vm.ref<!hal.descriptor_set_layout> ...) -> !vm.ref<!hal.executable_layout>
      vm.global.store.ref %ref_3, @_executable_layout_0 : !vm.ref<!hal.executable_layout>
      %ref_4 = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
      %ref_5 = vm.call.variadic @hal.descriptor_set_layout.create(%ref_4, %c1, [(%zero, %c7, %c1), (%c1, %c7, %c6)]) : (!vm.ref<!hal.device>, i32, tuple<i32, i32, i32> ...) -> !vm.ref<!hal.descriptor_set_layout>
      vm.global.store.ref %ref_5, @_descriptor_set_layout_1 : !vm.ref<!hal.descriptor_set_layout>
      %_descriptor_set_layout_1 = vm.global.load.ref @_descriptor_set_layout_1 : !vm.ref<!hal.descriptor_set_layout>
      %ref_6 = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
      %ref_7 = vm.call.variadic @hal.executable_layout.create(%ref_6, %zero, [%_descriptor_set_layout_1]) : (!vm.ref<!hal.device>, i32, !vm.ref<!hal.descriptor_set_layout> ...) -> !vm.ref<!hal.executable_layout>
      vm.global.store.ref %ref_7, @_executable_layout_1 : !vm.ref<!hal.executable_layout>
      %ref_8 = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
      %ref_9 = vm.call.variadic @hal.descriptor_set_layout.create(%ref_8, %c1, [(%zero, %c7, %c1), (%c1, %c7, %c1), (%c2, %c7, %c1), (%c3, %c7, %c6)]) : (!vm.ref<!hal.device>, i32, tuple<i32, i32, i32> ...) -> !vm.ref<!hal.descriptor_set_layout>
      vm.global.store.ref %ref_9, @_descriptor_set_layout_2 : !vm.ref<!hal.descriptor_set_layout>
      %_descriptor_set_layout_2 = vm.global.load.ref @_descriptor_set_layout_2 : !vm.ref<!hal.descriptor_set_layout>
      %ref_10 = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
      %ref_11 = vm.call.variadic @hal.executable_layout.create(%ref_10, %zero, [%_descriptor_set_layout_2]) : (!vm.ref<!hal.device>, i32, !vm.ref<!hal.descriptor_set_layout> ...) -> !vm.ref<!hal.executable_layout>
      vm.global.store.ref %ref_11, @_executable_layout_2 : !vm.ref<!hal.executable_layout>
      %ref_12 = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
      %_device_match_id_0 = vm.global.load.i32 @_device_match_id_0 : i32
      vm.cond_br %_device_match_id_0, ^bb1, ^bb2
    ^bb1:  // pred: ^bb0
      %_executable_layout_0 = vm.global.load.ref @_executable_layout_0 : !vm.ref<!hal.executable_layout>
      %_executable_layout_1 = vm.global.load.ref @_executable_layout_1 : !vm.ref<!hal.executable_layout>
      %_executable_layout_2 = vm.global.load.ref @_executable_layout_2 : !vm.ref<!hal.executable_layout>
      %_utf8_dlib_F45B9BA87AEFAACB = vm.const.ref.rodata @_utf8_dlib_F45B9BA87AEFAACB : !vm.buffer
      %_mnist_linked_llvm_aot_llvm_aot_binary_dlib = vm.const.ref.rodata @_mnist_linked_llvm_aot_llvm_aot_binary_dlib : !vm.buffer
      %ref_13 = vm.call.variadic @hal.executable.create(%ref_12, %_utf8_dlib_F45B9BA87AEFAACB, %_mnist_linked_llvm_aot_llvm_aot_binary_dlib, [%_executable_layout_0, %_executable_layout_0, %_executable_layout_0, %_executable_layout_1, %_executable_layout_1, %_executable_layout_0, %_executable_layout_1, %_executable_layout_2]) : (!vm.ref<!hal.device>, !vm.buffer, !vm.buffer, !vm.ref<!hal.executable_layout> ...) -> !vm.ref<!hal.executable>
      vm.br ^bb3(%ref_13 : !vm.ref<!hal.executable>)
    ^bb2:  // pred: ^bb0
      vm.br ^bb3(%null : !vm.ref<!hal.executable>)
    ^bb3(%1: !vm.ref<!hal.executable>):  // 2 preds: ^bb1, ^bb2
      vm.global.store.ref %1, @_executable_mnist_linked_llvm_aot : !vm.ref<!hal.executable>
      %ref_14 = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
      %ref_15 = vm.call @hal.device.allocator(%ref_14) : (!vm.ref<!hal.device>) -> !vm.ref<!hal.allocator>
      %_const_pool_storage = vm.const.ref.rodata @_const_pool_storage : !vm.buffer
      %ref_16 = vm.call @hal.allocator.wrap.byte_buffer(%ref_15, %c50, %c15, %_const_pool_storage, %zero, %c407040) : (!vm.ref<!hal.allocator>, i32, i32, !vm.buffer, i32, i32) -> !vm.ref<!hal.buffer>
      vm.global.store.ref %ref_16, @_const_pool_storage_buffer : !vm.ref<!hal.buffer>
      vm.return
    }
    vm.export @__init
  }
}


// *** IR Dump After Canonicalizer ***
module  {
  vm.module @module {
    vm.global.i32 @_device_match_id_0 mutable : i32
    vm.rodata @_utf8_dylib_971286B245550E6D dense<[100, 121, 108, 105, 98, 42]> : vector<6xi8>
    vm.global.ref @_descriptor_set_layout_0 mutable : !vm.ref<!hal.descriptor_set_layout>
    vm.global.ref @_executable_layout_0 mutable : !vm.ref<!hal.executable_layout>
    vm.global.ref @_descriptor_set_layout_1 mutable : !vm.ref<!hal.descriptor_set_layout>
    vm.global.ref @_executable_layout_1 mutable : !vm.ref<!hal.executable_layout>
    vm.global.ref @_descriptor_set_layout_2 mutable : !vm.ref<!hal.descriptor_set_layout>
    vm.global.ref @_executable_layout_2 mutable : !vm.ref<!hal.executable_layout>
    vm.global.ref @_executable_mnist_linked_llvm_aot mutable : !vm.ref<!hal.executable>
    vm.rodata @_mnist_linked_llvm_aot_llvm_aot_binary_dlib opaque<"_", "0xDEADBEEF"> : vector<136794xi8>
    vm.rodata @_utf8_dlib_F45B9BA87AEFAACB dense<[68, 76, 73, 66]> : vector<4xi8>
    vm.rodata @_const_pool_storage opaque<"_", "0xDEADBEEF"> : vector<407040xi8>
    vm.global.ref @_const_pool_storage_buffer mutable : !vm.ref<!hal.buffer>
    vm.func @predict(%arg0: !vm.ref<!hal.buffer>) -> !vm.ref<!hal.buffer> attributes {noinline} {
      %c3136 = vm.const.i32 3136 : i32
      %c401408 = vm.const.i32 401408 : i32
      %c401920 = vm.const.i32 401920 : i32
      %c5120 = vm.const.i32 5120 : i32
      %c40 = vm.const.i32 40 : i32
      %c512 = vm.const.i32 512 : i32
      %c96 = vm.const.i32 96 : i32
      %c112 = vm.const.i32 112 : i32
      %c1024 = vm.const.i32 1024 : i32
      %c50 = vm.const.i32 50 : i32
      %c14 = vm.const.i32 14 : i32
      %c48 = vm.const.i32 48 : i32
      %c10 = vm.const.i32 10 : i32
      %c17 = vm.const.i32 17 : i32
      %c1 = vm.const.i32 1 : i32
      %c3 = vm.const.i32 3 : i32
      %c4 = vm.const.i32 4 : i32
      %c6 = vm.const.i32 6 : i32
      %c7 = vm.const.i32 7 : i32
      %c20 = vm.const.i32 20 : i32
      %c5 = vm.const.i32 5 : i32
      %zero = vm.const.i32.zero : i32
      %c2 = vm.const.i32 2 : i32
      %ref = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
      %ref_0 = vm.call @hal.device.allocator(%ref) : (!vm.ref<!hal.device>) -> !vm.ref<!hal.allocator>
      %ref_1 = vm.call @hal.allocator.allocate(%ref_0, %c50, %c14, %c40) : (!vm.ref<!hal.allocator>, i32, i32, i32) -> !vm.ref<!hal.buffer>
      %_const_pool_storage_buffer = vm.global.load.ref @_const_pool_storage_buffer : !vm.ref<!hal.buffer>
      %ref_2 = vm.call @hal.allocator.allocate(%ref_0, %c48, %c10, %c1024) : (!vm.ref<!hal.allocator>, i32, i32, i32) -> !vm.ref<!hal.buffer>
      %ref_3 = vm.call @hal.command_buffer.create(%ref, %c17, %c3) : (!vm.ref<!hal.device>, i32, i32) -> !vm.ref<!hal.command_buffer>
      vm.call @hal.command_buffer.begin(%ref_3) : (!vm.ref<!hal.command_buffer>) -> ()
      %_executable_layout_0 = vm.global.load.ref @_executable_layout_0 : !vm.ref<!hal.executable_layout>
      vm.call.variadic @hal.command_buffer.push_descriptor_set(%ref_3, %_executable_layout_0, %zero, [(%zero, %_const_pool_storage_buffer, %c512, %c401408), (%c1, %arg0, %zero, %c3136), (%c2, %ref_2, %zero, %c512)]) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable_layout>, i32, tuple<i32, !vm.ref<!hal.buffer>, i32, i32> ...)
      %_device_match_id_0 = vm.global.load.i32 @_device_match_id_0 : i32
      vm.cond_br %_device_match_id_0, ^bb1, ^bb2
    ^bb1:  // pred: ^bb0
      %_executable_mnist_linked_llvm_aot = vm.global.load.ref @_executable_mnist_linked_llvm_aot : !vm.ref<!hal.executable>
      vm.call @hal.command_buffer.dispatch(%ref_3, %_executable_mnist_linked_llvm_aot, %zero, %c2, %c1, %c1) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable>, i32, i32, i32, i32) -> ()
      vm.call @hal.command_buffer.execution_barrier(%ref_3, %c20, %c5, %zero) : (!vm.ref<!hal.command_buffer>, i32, i32, i32) -> ()
      vm.call.variadic @hal.command_buffer.push_descriptor_set(%ref_3, %_executable_layout_0, %zero, [(%zero, %_const_pool_storage_buffer, %zero, %c512), (%c1, %ref_2, %zero, %c512), (%c2, %ref_2, %c512, %c512)]) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable_layout>, i32, tuple<i32, !vm.ref<!hal.buffer>, i32, i32> ...)
      vm.call @hal.command_buffer.dispatch(%ref_3, %_executable_mnist_linked_llvm_aot, %c1, %c1, %c1, %c1) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable>, i32, i32, i32, i32) -> ()
      vm.call @hal.command_buffer.execution_barrier(%ref_3, %c20, %c5, %zero) : (!vm.ref<!hal.command_buffer>, i32, i32, i32) -> ()
      vm.call.variadic @hal.command_buffer.push_descriptor_set(%ref_3, %_executable_layout_0, %zero, [(%zero, %_const_pool_storage_buffer, %c401920, %c5120), (%c1, %ref_2, %c512, %c512), (%c2, %ref_2, %zero, %c40)]) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable_layout>, i32, tuple<i32, !vm.ref<!hal.buffer>, i32, i32> ...)
      vm.call @hal.command_buffer.dispatch(%ref_3, %_executable_mnist_linked_llvm_aot, %c2, %c1, %c1, %c1) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable>, i32, i32, i32, i32) -> ()
      vm.call @hal.command_buffer.execution_barrier(%ref_3, %c20, %c5, %zero) : (!vm.ref<!hal.command_buffer>, i32, i32, i32) -> ()
      %_executable_layout_1 = vm.global.load.ref @_executable_layout_1 : !vm.ref<!hal.executable_layout>
      vm.call.variadic @hal.command_buffer.push_descriptor_set(%ref_3, %_executable_layout_1, %zero, [(%zero, %ref_2, %zero, %c40), (%c1, %ref_2, %c48, %c40)]) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable_layout>, i32, tuple<i32, !vm.ref<!hal.buffer>, i32, i32> ...)
      vm.call @hal.command_buffer.dispatch(%ref_3, %_executable_mnist_linked_llvm_aot, %c3, %c1, %c1, %c1) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable>, i32, i32, i32, i32) -> ()
      vm.call @hal.command_buffer.execution_barrier(%ref_3, %c20, %c5, %zero) : (!vm.ref<!hal.command_buffer>, i32, i32, i32) -> ()
      vm.call.variadic @hal.command_buffer.push_descriptor_set(%ref_3, %_executable_layout_1, %zero, [(%zero, %ref_2, %c48, %c40), (%c1, %ref_2, %c96, %c4)]) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable_layout>, i32, tuple<i32, !vm.ref<!hal.buffer>, i32, i32> ...)
      vm.call @hal.command_buffer.dispatch(%ref_3, %_executable_mnist_linked_llvm_aot, %c4, %c1, %c1, %c1) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable>, i32, i32, i32, i32) -> ()
      vm.call @hal.command_buffer.execution_barrier(%ref_3, %c20, %c5, %zero) : (!vm.ref<!hal.command_buffer>, i32, i32, i32) -> ()
      vm.call.variadic @hal.command_buffer.push_descriptor_set(%ref_3, %_executable_layout_0, %zero, [(%zero, %ref_2, %zero, %c40), (%c1, %ref_2, %c96, %c4), (%c2, %ref_2, %c48, %c40)]) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable_layout>, i32, tuple<i32, !vm.ref<!hal.buffer>, i32, i32> ...)
      vm.call @hal.command_buffer.dispatch(%ref_3, %_executable_mnist_linked_llvm_aot, %c5, %c1, %c1, %c1) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable>, i32, i32, i32, i32) -> ()
      vm.call @hal.command_buffer.execution_barrier(%ref_3, %c20, %c5, %zero) : (!vm.ref<!hal.command_buffer>, i32, i32, i32) -> ()
      vm.call.variadic @hal.command_buffer.push_descriptor_set(%ref_3, %_executable_layout_1, %zero, [(%zero, %ref_2, %c48, %c40), (%c1, %ref_2, %c112, %c4)]) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable_layout>, i32, tuple<i32, !vm.ref<!hal.buffer>, i32, i32> ...)
      vm.call @hal.command_buffer.dispatch(%ref_3, %_executable_mnist_linked_llvm_aot, %c6, %c1, %c1, %c1) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable>, i32, i32, i32, i32) -> ()
      vm.call @hal.command_buffer.execution_barrier(%ref_3, %c20, %c5, %zero) : (!vm.ref<!hal.command_buffer>, i32, i32, i32) -> ()
      %_executable_layout_2 = vm.global.load.ref @_executable_layout_2 : !vm.ref<!hal.executable_layout>
      vm.call.variadic @hal.command_buffer.push_descriptor_set(%ref_3, %_executable_layout_2, %zero, [(%zero, %ref_2, %zero, %c40), (%c1, %ref_2, %c96, %c4), (%c2, %ref_2, %c112, %c4), (%c3, %ref_1, %zero, %c40)]) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable_layout>, i32, tuple<i32, !vm.ref<!hal.buffer>, i32, i32> ...)
      vm.call @hal.command_buffer.dispatch(%ref_3, %_executable_mnist_linked_llvm_aot, %c7, %c1, %c1, %c1) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable>, i32, i32, i32, i32) -> ()
      vm.call @hal.command_buffer.execution_barrier(%ref_3, %c20, %c5, %zero) : (!vm.ref<!hal.command_buffer>, i32, i32, i32) -> ()
      vm.call @hal.command_buffer.end(%ref_3) : (!vm.ref<!hal.command_buffer>) -> ()
      vm.call @hal.ex.submit_and_wait(%ref, %ref_3) : (!vm.ref<!hal.device>, !vm.ref<!hal.command_buffer>) -> ()
      vm.return %ref_1 : !vm.ref<!hal.buffer>
    ^bb2:  // pred: ^bb0
      vm.fail %c2, "device not supported in the compiled configuration"
    }
    vm.func @predict$async(%arg0: !vm.ref<!hal.semaphore>, %arg1: i32, %arg2: !vm.ref<!hal.buffer_view>, %arg3: !vm.ref<!hal.semaphore>, %arg4: i32) -> !vm.ref<!hal.buffer_view> {
      %c1 = vm.const.i32 1 : i32
      %c10 = vm.const.i32 10 : i32
      %c50331680 = vm.const.i32 50331680 : i32
      %0 = vm.call @hal.semaphore.await(%arg0, %arg1) : (!vm.ref<!hal.semaphore>, i32) -> i32
      vm.cond_br %0, ^bb2(%0 : i32), ^bb1
    ^bb1:  // pred: ^bb0
      %ref = vm.call @hal.buffer_view.buffer(%arg2) : (!vm.ref<!hal.buffer_view>) -> !vm.ref<!hal.buffer>
      %ref_0 = vm.call @predict(%ref) : (!vm.ref<!hal.buffer>) -> !vm.ref<!hal.buffer>
      %ref_1 = vm.call.variadic @hal.buffer_view.create(%ref_0, %c50331680, [%c1, %c10]) : (!vm.ref<!hal.buffer>, i32, i32 ...) -> !vm.ref<!hal.buffer_view>
      vm.call @hal.semaphore.signal(%arg3, %arg4) : (!vm.ref<!hal.semaphore>, i32) -> ()
      vm.return %ref_1 : !vm.ref<!hal.buffer_view>
    ^bb2(%1: i32):  // pred: ^bb0
      vm.fail %1, "semaphore wait failed"
    }
    vm.export @predict$async
    vm.import @hal.ex.shared_device() -> !vm.ref<!hal.device> attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.ex.submit_and_wait(%device : !vm.ref<!hal.device>, %command_buffer : !vm.ref<!hal.command_buffer>) attributes {sym_visibility = "private"}
    vm.import @hal.allocator.allocate(%allocator : !vm.ref<!hal.allocator>, %memory_types : i32, %buffer_usage : i32, %allocation_size : i32) -> !vm.ref<!hal.buffer> attributes {sym_visibility = "private"}
    vm.import @hal.allocator.wrap.byte_buffer(%allocator : !vm.ref<!hal.allocator>, %memory_types : i32, %buffer_usage : i32, %source : !vm.buffer, %offset : i32, %length : i32) -> !vm.ref<!hal.buffer> attributes {sym_visibility = "private"}
    vm.import @hal.buffer.allocator(%buffer : !vm.ref<!hal.buffer>) -> !vm.ref<!hal.allocator> attributes {sym_visibility = "private"}
    vm.import @hal.buffer.subspan(%source_buffer : !vm.ref<!hal.buffer>, %source_offset : i32, %length : i32) -> !vm.ref<!hal.buffer> attributes {sym_visibility = "private"}
    vm.import @hal.buffer.load(%source_buffer : !vm.ref<!hal.buffer>, %source_offset : i32, %length : i32) -> i32 attributes {sym_visibility = "private"}
    vm.import @hal.buffer.store(%value : i32, %target_buffer : !vm.ref<!hal.buffer>, %target_offset : i32, %length : i32) attributes {sym_visibility = "private"}
    vm.import @hal.buffer_view.create(%buffer : !vm.ref<!hal.buffer>, %element_type : i32, %shape : i32 ...) -> !vm.ref<!hal.buffer_view> attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.buffer_view.buffer(%buffer_view : !vm.ref<!hal.buffer_view>) -> !vm.ref<!hal.buffer> attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.buffer_view.byte_length(%buffer_view : !vm.ref<!hal.buffer_view>) -> i32 attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.buffer_view.element_type(%buffer_view : !vm.ref<!hal.buffer_view>) -> i32 attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.buffer_view.rank(%buffer_view : !vm.ref<!hal.buffer_view>) -> i32 attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.buffer_view.dim(%buffer_view : !vm.ref<!hal.buffer_view>, %index : i32) -> i32 attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.buffer_view.trace(%key : !vm.buffer, %operands : !vm.ref<!hal.buffer_view> ...) attributes {sym_visibility = "private"}
    vm.import @hal.command_buffer.create(%device : !vm.ref<!hal.device>, %modes : i32, %command_categories : i32) -> !vm.ref<!hal.command_buffer> attributes {sym_visibility = "private"}
    vm.import @hal.command_buffer.begin(%command_buffer : !vm.ref<!hal.command_buffer>) attributes {sym_visibility = "private"}
    vm.import @hal.command_buffer.end(%command_buffer : !vm.ref<!hal.command_buffer>) attributes {sym_visibility = "private"}
    vm.import @hal.command_buffer.execution_barrier(%command_buffer : !vm.ref<!hal.command_buffer>, %source_stage_mask : i32, %target_stage_mask : i32, %flags : i32) attributes {sym_visibility = "private"}
    vm.import @hal.command_buffer.fill_buffer(%command_buffer : !vm.ref<!hal.command_buffer>, %target_buffer : !vm.ref<!hal.buffer>, %target_offset : i32, %length : i32, %pattern : i32) attributes {sym_visibility = "private"}
    vm.import @hal.command_buffer.copy_buffer(%command_buffer : !vm.ref<!hal.command_buffer>, %source_buffer : !vm.ref<!hal.buffer>, %source_offset : i32, %target_buffer : !vm.ref<!hal.buffer>, %target_offset : i32, %length : i32) attributes {sym_visibility = "private"}
    vm.import @hal.command_buffer.push_constants(%command_buffer : !vm.ref<!hal.command_buffer>, %executable_layout : !vm.ref<!hal.executable_layout>, %offset : i32, %values : i32 ...) attributes {sym_visibility = "private"}
    vm.import @hal.command_buffer.push_descriptor_set(%command_buffer : !vm.ref<!hal.command_buffer>, %executable_layout : !vm.ref<!hal.executable_layout>, %set : i32, %bindings : tuple<i32, !vm.ref<!hal.buffer>, i32, i32> ...) attributes {sym_visibility = "private"}
    vm.import @hal.command_buffer.bind_descriptor_set(%command_buffer : !vm.ref<!hal.command_buffer>, %executable_layout : !vm.ref<!hal.executable_layout>, %set : i32, %descriptor_set : !vm.ref<!hal.descriptor_set>, %dynamic_offsets : i32 ...) attributes {sym_visibility = "private"}
    vm.import @hal.command_buffer.dispatch(%command_buffer : !vm.ref<!hal.command_buffer>, %executable : !vm.ref<!hal.executable>, %entry_point : i32, %workgroup_x : i32, %workgroup_y : i32, %workgroup_z : i32) attributes {sym_visibility = "private"}
    vm.import @hal.command_buffer.dispatch.indirect(%command_buffer : !vm.ref<!hal.command_buffer>, %executable : !vm.ref<!hal.executable>, %entry_point : i32, %workgroups_buffer : !vm.ref<!hal.buffer>, %workgroups_offset : i32) attributes {sym_visibility = "private"}
    vm.import @hal.descriptor_set.create(%device : !vm.ref<!hal.device>, %set_layout : !vm.ref<!hal.descriptor_set_layout>, %bindings : tuple<i32, !vm.ref<!hal.buffer>, i32, i32> ...) -> !vm.ref<!hal.descriptor_set> attributes {sym_visibility = "private"}
    vm.import @hal.descriptor_set_layout.create(%device : !vm.ref<!hal.device>, %usage_type : i32, %bindings : tuple<i32, i32, i32> ...) -> !vm.ref<!hal.descriptor_set_layout> attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.device.allocator(%device : !vm.ref<!hal.device>) -> !vm.ref<!hal.allocator> attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.device.query.i32(%device : !vm.ref<!hal.device>, %key : !vm.buffer) -> (i32, i32) attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.device.match.id(%device : !vm.ref<!hal.device>, %pattern : !vm.buffer) -> i32 attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.executable.create(%device : !vm.ref<!hal.device>, %executable_format : !vm.buffer, %executable_data : !vm.buffer, %executable_layouts : !vm.ref<!hal.executable_layout> ...) -> !vm.ref<!hal.executable> attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.executable_layout.create(%device : !vm.ref<!hal.device>, %push_constants : i32, %set_layouts : !vm.ref<!hal.descriptor_set_layout> ...) -> !vm.ref<!hal.executable_layout> attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.semaphore.create(%device : !vm.ref<!hal.device>, %initial_value : i32) -> !vm.ref<!hal.semaphore> attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.semaphore.query(%semaphore : !vm.ref<!hal.semaphore>) -> (i32, i32) attributes {sym_visibility = "private"}
    vm.import @hal.semaphore.signal(%semaphore : !vm.ref<!hal.semaphore>, %new_value : i32) attributes {sym_visibility = "private"}
    vm.import @hal.semaphore.fail(%semaphore : !vm.ref<!hal.semaphore>, %status : i32) attributes {sym_visibility = "private"}
    vm.import @hal.semaphore.await(%semaphore : !vm.ref<!hal.semaphore>, %min_value : i32) -> i32 attributes {sym_visibility = "private"}
    vm.func @predict$sync(%arg0: !vm.ref<!hal.buffer_view>) -> !vm.ref<!hal.buffer_view> attributes {iree.reflection = {abi = "sip", abiv = 1 : i32, f = "I15!B11!d1d28d28d1R9!B6!d1d10", fv = "1", sip = "I8!S5!k0_0R3!_0"}} {
      %zero = vm.const.i32.zero : i32
      %c1 = vm.const.i32 1 : i32
      %c10 = vm.const.i32 10 : i32
      %c50331680 = vm.const.i32 50331680 : i32
      %ref = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
      %ref_0 = vm.call @hal.semaphore.create(%ref, %zero) : (!vm.ref<!hal.device>, i32) -> !vm.ref<!hal.semaphore>
      %0 = vm.call @hal.semaphore.await(%ref_0, %zero) : (!vm.ref<!hal.semaphore>, i32) -> i32
      vm.cond_br %0, ^bb2(%0 : i32), ^bb1
    ^bb1:  // pred: ^bb0
      %ref_1 = vm.call @hal.buffer_view.buffer(%arg0) : (!vm.ref<!hal.buffer_view>) -> !vm.ref<!hal.buffer>
      %ref_2 = vm.call @predict(%ref_1) : (!vm.ref<!hal.buffer>) -> !vm.ref<!hal.buffer>
      %ref_3 = vm.call.variadic @hal.buffer_view.create(%ref_2, %c50331680, [%c1, %c10]) : (!vm.ref<!hal.buffer>, i32, i32 ...) -> !vm.ref<!hal.buffer_view>
      vm.call @hal.semaphore.signal(%ref_0, %c1) : (!vm.ref<!hal.semaphore>, i32) -> ()
      %1 = vm.call @hal.semaphore.await(%ref_0, %c1) : (!vm.ref<!hal.semaphore>, i32) -> i32
      vm.cond_br %1, ^bb2(%1 : i32), ^bb3
    ^bb2(%2: i32):  // 2 preds: ^bb0, ^bb1
      vm.fail %2, "semaphore wait failed"
    ^bb3:  // pred: ^bb1
      vm.return %ref_3 : !vm.ref<!hal.buffer_view>
    }
    vm.export @predict$sync as("predict")
    vm.func @__init() {
      %c2 = vm.const.i32 2 : i32
      %c1 = vm.const.i32 1 : i32
      %c3 = vm.const.i32 3 : i32
      %c7 = vm.const.i32 7 : i32
      %c6 = vm.const.i32 6 : i32
      %null = vm.const.ref.zero : !vm.ref<!hal.executable>
      %zero = vm.const.i32.zero : i32
      %c407040 = vm.const.i32 407040 : i32
      %c50 = vm.const.i32 50 : i32
      %c15 = vm.const.i32 15 : i32
      %ref = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
      %_utf8_dylib_971286B245550E6D = vm.const.ref.rodata @_utf8_dylib_971286B245550E6D : !vm.buffer
      %0 = vm.call @hal.device.match.id(%ref, %_utf8_dylib_971286B245550E6D) : (!vm.ref<!hal.device>, !vm.buffer) -> i32
      vm.global.store.i32 %0, @_device_match_id_0 : i32
      %ref_0 = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
      %ref_1 = vm.call.variadic @hal.descriptor_set_layout.create(%ref_0, %c1, [(%zero, %c7, %c1), (%c1, %c7, %c1), (%c2, %c7, %c6)]) : (!vm.ref<!hal.device>, i32, tuple<i32, i32, i32> ...) -> !vm.ref<!hal.descriptor_set_layout>
      vm.global.store.ref %ref_1, @_descriptor_set_layout_0 : !vm.ref<!hal.descriptor_set_layout>
      %_descriptor_set_layout_0 = vm.global.load.ref @_descriptor_set_layout_0 : !vm.ref<!hal.descriptor_set_layout>
      %ref_2 = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
      %ref_3 = vm.call.variadic @hal.executable_layout.create(%ref_2, %zero, [%_descriptor_set_layout_0]) : (!vm.ref<!hal.device>, i32, !vm.ref<!hal.descriptor_set_layout> ...) -> !vm.ref<!hal.executable_layout>
      vm.global.store.ref %ref_3, @_executable_layout_0 : !vm.ref<!hal.executable_layout>
      %ref_4 = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
      %ref_5 = vm.call.variadic @hal.descriptor_set_layout.create(%ref_4, %c1, [(%zero, %c7, %c1), (%c1, %c7, %c6)]) : (!vm.ref<!hal.device>, i32, tuple<i32, i32, i32> ...) -> !vm.ref<!hal.descriptor_set_layout>
      vm.global.store.ref %ref_5, @_descriptor_set_layout_1 : !vm.ref<!hal.descriptor_set_layout>
      %_descriptor_set_layout_1 = vm.global.load.ref @_descriptor_set_layout_1 : !vm.ref<!hal.descriptor_set_layout>
      %ref_6 = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
      %ref_7 = vm.call.variadic @hal.executable_layout.create(%ref_6, %zero, [%_descriptor_set_layout_1]) : (!vm.ref<!hal.device>, i32, !vm.ref<!hal.descriptor_set_layout> ...) -> !vm.ref<!hal.executable_layout>
      vm.global.store.ref %ref_7, @_executable_layout_1 : !vm.ref<!hal.executable_layout>
      %ref_8 = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
      %ref_9 = vm.call.variadic @hal.descriptor_set_layout.create(%ref_8, %c1, [(%zero, %c7, %c1), (%c1, %c7, %c1), (%c2, %c7, %c1), (%c3, %c7, %c6)]) : (!vm.ref<!hal.device>, i32, tuple<i32, i32, i32> ...) -> !vm.ref<!hal.descriptor_set_layout>
      vm.global.store.ref %ref_9, @_descriptor_set_layout_2 : !vm.ref<!hal.descriptor_set_layout>
      %_descriptor_set_layout_2 = vm.global.load.ref @_descriptor_set_layout_2 : !vm.ref<!hal.descriptor_set_layout>
      %ref_10 = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
      %ref_11 = vm.call.variadic @hal.executable_layout.create(%ref_10, %zero, [%_descriptor_set_layout_2]) : (!vm.ref<!hal.device>, i32, !vm.ref<!hal.descriptor_set_layout> ...) -> !vm.ref<!hal.executable_layout>
      vm.global.store.ref %ref_11, @_executable_layout_2 : !vm.ref<!hal.executable_layout>
      %ref_12 = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
      %_device_match_id_0 = vm.global.load.i32 @_device_match_id_0 : i32
      vm.cond_br %_device_match_id_0, ^bb1, ^bb2
    ^bb1:  // pred: ^bb0
      %_executable_layout_0 = vm.global.load.ref @_executable_layout_0 : !vm.ref<!hal.executable_layout>
      %_executable_layout_1 = vm.global.load.ref @_executable_layout_1 : !vm.ref<!hal.executable_layout>
      %_executable_layout_2 = vm.global.load.ref @_executable_layout_2 : !vm.ref<!hal.executable_layout>
      %_utf8_dlib_F45B9BA87AEFAACB = vm.const.ref.rodata @_utf8_dlib_F45B9BA87AEFAACB : !vm.buffer
      %_mnist_linked_llvm_aot_llvm_aot_binary_dlib = vm.const.ref.rodata @_mnist_linked_llvm_aot_llvm_aot_binary_dlib : !vm.buffer
      %ref_13 = vm.call.variadic @hal.executable.create(%ref_12, %_utf8_dlib_F45B9BA87AEFAACB, %_mnist_linked_llvm_aot_llvm_aot_binary_dlib, [%_executable_layout_0, %_executable_layout_0, %_executable_layout_0, %_executable_layout_1, %_executable_layout_1, %_executable_layout_0, %_executable_layout_1, %_executable_layout_2]) : (!vm.ref<!hal.device>, !vm.buffer, !vm.buffer, !vm.ref<!hal.executable_layout> ...) -> !vm.ref<!hal.executable>
      vm.br ^bb3(%ref_13 : !vm.ref<!hal.executable>)
    ^bb2:  // pred: ^bb0
      vm.br ^bb3(%null : !vm.ref<!hal.executable>)
    ^bb3(%1: !vm.ref<!hal.executable>):  // 2 preds: ^bb1, ^bb2
      vm.global.store.ref %1, @_executable_mnist_linked_llvm_aot : !vm.ref<!hal.executable>
      %ref_14 = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
      %ref_15 = vm.call @hal.device.allocator(%ref_14) : (!vm.ref<!hal.device>) -> !vm.ref<!hal.allocator>
      %_const_pool_storage = vm.const.ref.rodata @_const_pool_storage : !vm.buffer
      %ref_16 = vm.call @hal.allocator.wrap.byte_buffer(%ref_15, %c50, %c15, %_const_pool_storage, %zero, %c407040) : (!vm.ref<!hal.allocator>, i32, i32, !vm.buffer, i32, i32) -> !vm.ref<!hal.buffer>
      vm.global.store.ref %ref_16, @_const_pool_storage_buffer : !vm.ref<!hal.buffer>
      vm.return
    }
    vm.export @__init
  }
}


// *** IR Dump After CSE ***
module  {
  vm.module @module {
    vm.global.i32 @_device_match_id_0 mutable : i32
    vm.rodata @_utf8_dylib_971286B245550E6D dense<[100, 121, 108, 105, 98, 42]> : vector<6xi8>
    vm.global.ref @_descriptor_set_layout_0 mutable : !vm.ref<!hal.descriptor_set_layout>
    vm.global.ref @_executable_layout_0 mutable : !vm.ref<!hal.executable_layout>
    vm.global.ref @_descriptor_set_layout_1 mutable : !vm.ref<!hal.descriptor_set_layout>
    vm.global.ref @_executable_layout_1 mutable : !vm.ref<!hal.executable_layout>
    vm.global.ref @_descriptor_set_layout_2 mutable : !vm.ref<!hal.descriptor_set_layout>
    vm.global.ref @_executable_layout_2 mutable : !vm.ref<!hal.executable_layout>
    vm.global.ref @_executable_mnist_linked_llvm_aot mutable : !vm.ref<!hal.executable>
    vm.rodata @_mnist_linked_llvm_aot_llvm_aot_binary_dlib opaque<"_", "0xDEADBEEF"> : vector<136794xi8>
    vm.rodata @_utf8_dlib_F45B9BA87AEFAACB dense<[68, 76, 73, 66]> : vector<4xi8>
    vm.rodata @_const_pool_storage opaque<"_", "0xDEADBEEF"> : vector<407040xi8>
    vm.global.ref @_const_pool_storage_buffer mutable : !vm.ref<!hal.buffer>
    vm.func @predict(%arg0: !vm.ref<!hal.buffer>) -> !vm.ref<!hal.buffer> attributes {noinline} {
      %c3136 = vm.const.i32 3136 : i32
      %c401408 = vm.const.i32 401408 : i32
      %c401920 = vm.const.i32 401920 : i32
      %c5120 = vm.const.i32 5120 : i32
      %c40 = vm.const.i32 40 : i32
      %c512 = vm.const.i32 512 : i32
      %c96 = vm.const.i32 96 : i32
      %c112 = vm.const.i32 112 : i32
      %c1024 = vm.const.i32 1024 : i32
      %c50 = vm.const.i32 50 : i32
      %c14 = vm.const.i32 14 : i32
      %c48 = vm.const.i32 48 : i32
      %c10 = vm.const.i32 10 : i32
      %c17 = vm.const.i32 17 : i32
      %c1 = vm.const.i32 1 : i32
      %c3 = vm.const.i32 3 : i32
      %c4 = vm.const.i32 4 : i32
      %c6 = vm.const.i32 6 : i32
      %c7 = vm.const.i32 7 : i32
      %c20 = vm.const.i32 20 : i32
      %c5 = vm.const.i32 5 : i32
      %zero = vm.const.i32.zero : i32
      %c2 = vm.const.i32 2 : i32
      %ref = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
      %ref_0 = vm.call @hal.device.allocator(%ref) : (!vm.ref<!hal.device>) -> !vm.ref<!hal.allocator>
      %ref_1 = vm.call @hal.allocator.allocate(%ref_0, %c50, %c14, %c40) : (!vm.ref<!hal.allocator>, i32, i32, i32) -> !vm.ref<!hal.buffer>
      %_const_pool_storage_buffer = vm.global.load.ref @_const_pool_storage_buffer : !vm.ref<!hal.buffer>
      %ref_2 = vm.call @hal.allocator.allocate(%ref_0, %c48, %c10, %c1024) : (!vm.ref<!hal.allocator>, i32, i32, i32) -> !vm.ref<!hal.buffer>
      %ref_3 = vm.call @hal.command_buffer.create(%ref, %c17, %c3) : (!vm.ref<!hal.device>, i32, i32) -> !vm.ref<!hal.command_buffer>
      vm.call @hal.command_buffer.begin(%ref_3) : (!vm.ref<!hal.command_buffer>) -> ()
      %_executable_layout_0 = vm.global.load.ref @_executable_layout_0 : !vm.ref<!hal.executable_layout>
      vm.call.variadic @hal.command_buffer.push_descriptor_set(%ref_3, %_executable_layout_0, %zero, [(%zero, %_const_pool_storage_buffer, %c512, %c401408), (%c1, %arg0, %zero, %c3136), (%c2, %ref_2, %zero, %c512)]) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable_layout>, i32, tuple<i32, !vm.ref<!hal.buffer>, i32, i32> ...)
      %_device_match_id_0 = vm.global.load.i32 @_device_match_id_0 : i32
      vm.cond_br %_device_match_id_0, ^bb1, ^bb2
    ^bb1:  // pred: ^bb0
      %_executable_mnist_linked_llvm_aot = vm.global.load.ref @_executable_mnist_linked_llvm_aot : !vm.ref<!hal.executable>
      vm.call @hal.command_buffer.dispatch(%ref_3, %_executable_mnist_linked_llvm_aot, %zero, %c2, %c1, %c1) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable>, i32, i32, i32, i32) -> ()
      vm.call @hal.command_buffer.execution_barrier(%ref_3, %c20, %c5, %zero) : (!vm.ref<!hal.command_buffer>, i32, i32, i32) -> ()
      vm.call.variadic @hal.command_buffer.push_descriptor_set(%ref_3, %_executable_layout_0, %zero, [(%zero, %_const_pool_storage_buffer, %zero, %c512), (%c1, %ref_2, %zero, %c512), (%c2, %ref_2, %c512, %c512)]) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable_layout>, i32, tuple<i32, !vm.ref<!hal.buffer>, i32, i32> ...)
      vm.call @hal.command_buffer.dispatch(%ref_3, %_executable_mnist_linked_llvm_aot, %c1, %c1, %c1, %c1) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable>, i32, i32, i32, i32) -> ()
      vm.call @hal.command_buffer.execution_barrier(%ref_3, %c20, %c5, %zero) : (!vm.ref<!hal.command_buffer>, i32, i32, i32) -> ()
      vm.call.variadic @hal.command_buffer.push_descriptor_set(%ref_3, %_executable_layout_0, %zero, [(%zero, %_const_pool_storage_buffer, %c401920, %c5120), (%c1, %ref_2, %c512, %c512), (%c2, %ref_2, %zero, %c40)]) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable_layout>, i32, tuple<i32, !vm.ref<!hal.buffer>, i32, i32> ...)
      vm.call @hal.command_buffer.dispatch(%ref_3, %_executable_mnist_linked_llvm_aot, %c2, %c1, %c1, %c1) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable>, i32, i32, i32, i32) -> ()
      vm.call @hal.command_buffer.execution_barrier(%ref_3, %c20, %c5, %zero) : (!vm.ref<!hal.command_buffer>, i32, i32, i32) -> ()
      %_executable_layout_1 = vm.global.load.ref @_executable_layout_1 : !vm.ref<!hal.executable_layout>
      vm.call.variadic @hal.command_buffer.push_descriptor_set(%ref_3, %_executable_layout_1, %zero, [(%zero, %ref_2, %zero, %c40), (%c1, %ref_2, %c48, %c40)]) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable_layout>, i32, tuple<i32, !vm.ref<!hal.buffer>, i32, i32> ...)
      vm.call @hal.command_buffer.dispatch(%ref_3, %_executable_mnist_linked_llvm_aot, %c3, %c1, %c1, %c1) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable>, i32, i32, i32, i32) -> ()
      vm.call @hal.command_buffer.execution_barrier(%ref_3, %c20, %c5, %zero) : (!vm.ref<!hal.command_buffer>, i32, i32, i32) -> ()
      vm.call.variadic @hal.command_buffer.push_descriptor_set(%ref_3, %_executable_layout_1, %zero, [(%zero, %ref_2, %c48, %c40), (%c1, %ref_2, %c96, %c4)]) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable_layout>, i32, tuple<i32, !vm.ref<!hal.buffer>, i32, i32> ...)
      vm.call @hal.command_buffer.dispatch(%ref_3, %_executable_mnist_linked_llvm_aot, %c4, %c1, %c1, %c1) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable>, i32, i32, i32, i32) -> ()
      vm.call @hal.command_buffer.execution_barrier(%ref_3, %c20, %c5, %zero) : (!vm.ref<!hal.command_buffer>, i32, i32, i32) -> ()
      vm.call.variadic @hal.command_buffer.push_descriptor_set(%ref_3, %_executable_layout_0, %zero, [(%zero, %ref_2, %zero, %c40), (%c1, %ref_2, %c96, %c4), (%c2, %ref_2, %c48, %c40)]) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable_layout>, i32, tuple<i32, !vm.ref<!hal.buffer>, i32, i32> ...)
      vm.call @hal.command_buffer.dispatch(%ref_3, %_executable_mnist_linked_llvm_aot, %c5, %c1, %c1, %c1) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable>, i32, i32, i32, i32) -> ()
      vm.call @hal.command_buffer.execution_barrier(%ref_3, %c20, %c5, %zero) : (!vm.ref<!hal.command_buffer>, i32, i32, i32) -> ()
      vm.call.variadic @hal.command_buffer.push_descriptor_set(%ref_3, %_executable_layout_1, %zero, [(%zero, %ref_2, %c48, %c40), (%c1, %ref_2, %c112, %c4)]) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable_layout>, i32, tuple<i32, !vm.ref<!hal.buffer>, i32, i32> ...)
      vm.call @hal.command_buffer.dispatch(%ref_3, %_executable_mnist_linked_llvm_aot, %c6, %c1, %c1, %c1) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable>, i32, i32, i32, i32) -> ()
      vm.call @hal.command_buffer.execution_barrier(%ref_3, %c20, %c5, %zero) : (!vm.ref<!hal.command_buffer>, i32, i32, i32) -> ()
      %_executable_layout_2 = vm.global.load.ref @_executable_layout_2 : !vm.ref<!hal.executable_layout>
      vm.call.variadic @hal.command_buffer.push_descriptor_set(%ref_3, %_executable_layout_2, %zero, [(%zero, %ref_2, %zero, %c40), (%c1, %ref_2, %c96, %c4), (%c2, %ref_2, %c112, %c4), (%c3, %ref_1, %zero, %c40)]) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable_layout>, i32, tuple<i32, !vm.ref<!hal.buffer>, i32, i32> ...)
      vm.call @hal.command_buffer.dispatch(%ref_3, %_executable_mnist_linked_llvm_aot, %c7, %c1, %c1, %c1) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable>, i32, i32, i32, i32) -> ()
      vm.call @hal.command_buffer.execution_barrier(%ref_3, %c20, %c5, %zero) : (!vm.ref<!hal.command_buffer>, i32, i32, i32) -> ()
      vm.call @hal.command_buffer.end(%ref_3) : (!vm.ref<!hal.command_buffer>) -> ()
      vm.call @hal.ex.submit_and_wait(%ref, %ref_3) : (!vm.ref<!hal.device>, !vm.ref<!hal.command_buffer>) -> ()
      vm.return %ref_1 : !vm.ref<!hal.buffer>
    ^bb2:  // pred: ^bb0
      vm.fail %c2, "device not supported in the compiled configuration"
    }
    vm.func @predict$async(%arg0: !vm.ref<!hal.semaphore>, %arg1: i32, %arg2: !vm.ref<!hal.buffer_view>, %arg3: !vm.ref<!hal.semaphore>, %arg4: i32) -> !vm.ref<!hal.buffer_view> {
      %c1 = vm.const.i32 1 : i32
      %c10 = vm.const.i32 10 : i32
      %c50331680 = vm.const.i32 50331680 : i32
      %0 = vm.call @hal.semaphore.await(%arg0, %arg1) : (!vm.ref<!hal.semaphore>, i32) -> i32
      vm.cond_br %0, ^bb2(%0 : i32), ^bb1
    ^bb1:  // pred: ^bb0
      %ref = vm.call @hal.buffer_view.buffer(%arg2) : (!vm.ref<!hal.buffer_view>) -> !vm.ref<!hal.buffer>
      %ref_0 = vm.call @predict(%ref) : (!vm.ref<!hal.buffer>) -> !vm.ref<!hal.buffer>
      %ref_1 = vm.call.variadic @hal.buffer_view.create(%ref_0, %c50331680, [%c1, %c10]) : (!vm.ref<!hal.buffer>, i32, i32 ...) -> !vm.ref<!hal.buffer_view>
      vm.call @hal.semaphore.signal(%arg3, %arg4) : (!vm.ref<!hal.semaphore>, i32) -> ()
      vm.return %ref_1 : !vm.ref<!hal.buffer_view>
    ^bb2(%1: i32):  // pred: ^bb0
      vm.fail %1, "semaphore wait failed"
    }
    vm.export @predict$async
    vm.import @hal.ex.shared_device() -> !vm.ref<!hal.device> attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.ex.submit_and_wait(%device : !vm.ref<!hal.device>, %command_buffer : !vm.ref<!hal.command_buffer>) attributes {sym_visibility = "private"}
    vm.import @hal.allocator.allocate(%allocator : !vm.ref<!hal.allocator>, %memory_types : i32, %buffer_usage : i32, %allocation_size : i32) -> !vm.ref<!hal.buffer> attributes {sym_visibility = "private"}
    vm.import @hal.allocator.wrap.byte_buffer(%allocator : !vm.ref<!hal.allocator>, %memory_types : i32, %buffer_usage : i32, %source : !vm.buffer, %offset : i32, %length : i32) -> !vm.ref<!hal.buffer> attributes {sym_visibility = "private"}
    vm.import @hal.buffer.allocator(%buffer : !vm.ref<!hal.buffer>) -> !vm.ref<!hal.allocator> attributes {sym_visibility = "private"}
    vm.import @hal.buffer.subspan(%source_buffer : !vm.ref<!hal.buffer>, %source_offset : i32, %length : i32) -> !vm.ref<!hal.buffer> attributes {sym_visibility = "private"}
    vm.import @hal.buffer.load(%source_buffer : !vm.ref<!hal.buffer>, %source_offset : i32, %length : i32) -> i32 attributes {sym_visibility = "private"}
    vm.import @hal.buffer.store(%value : i32, %target_buffer : !vm.ref<!hal.buffer>, %target_offset : i32, %length : i32) attributes {sym_visibility = "private"}
    vm.import @hal.buffer_view.create(%buffer : !vm.ref<!hal.buffer>, %element_type : i32, %shape : i32 ...) -> !vm.ref<!hal.buffer_view> attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.buffer_view.buffer(%buffer_view : !vm.ref<!hal.buffer_view>) -> !vm.ref<!hal.buffer> attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.buffer_view.byte_length(%buffer_view : !vm.ref<!hal.buffer_view>) -> i32 attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.buffer_view.element_type(%buffer_view : !vm.ref<!hal.buffer_view>) -> i32 attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.buffer_view.rank(%buffer_view : !vm.ref<!hal.buffer_view>) -> i32 attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.buffer_view.dim(%buffer_view : !vm.ref<!hal.buffer_view>, %index : i32) -> i32 attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.buffer_view.trace(%key : !vm.buffer, %operands : !vm.ref<!hal.buffer_view> ...) attributes {sym_visibility = "private"}
    vm.import @hal.command_buffer.create(%device : !vm.ref<!hal.device>, %modes : i32, %command_categories : i32) -> !vm.ref<!hal.command_buffer> attributes {sym_visibility = "private"}
    vm.import @hal.command_buffer.begin(%command_buffer : !vm.ref<!hal.command_buffer>) attributes {sym_visibility = "private"}
    vm.import @hal.command_buffer.end(%command_buffer : !vm.ref<!hal.command_buffer>) attributes {sym_visibility = "private"}
    vm.import @hal.command_buffer.execution_barrier(%command_buffer : !vm.ref<!hal.command_buffer>, %source_stage_mask : i32, %target_stage_mask : i32, %flags : i32) attributes {sym_visibility = "private"}
    vm.import @hal.command_buffer.fill_buffer(%command_buffer : !vm.ref<!hal.command_buffer>, %target_buffer : !vm.ref<!hal.buffer>, %target_offset : i32, %length : i32, %pattern : i32) attributes {sym_visibility = "private"}
    vm.import @hal.command_buffer.copy_buffer(%command_buffer : !vm.ref<!hal.command_buffer>, %source_buffer : !vm.ref<!hal.buffer>, %source_offset : i32, %target_buffer : !vm.ref<!hal.buffer>, %target_offset : i32, %length : i32) attributes {sym_visibility = "private"}
    vm.import @hal.command_buffer.push_constants(%command_buffer : !vm.ref<!hal.command_buffer>, %executable_layout : !vm.ref<!hal.executable_layout>, %offset : i32, %values : i32 ...) attributes {sym_visibility = "private"}
    vm.import @hal.command_buffer.push_descriptor_set(%command_buffer : !vm.ref<!hal.command_buffer>, %executable_layout : !vm.ref<!hal.executable_layout>, %set : i32, %bindings : tuple<i32, !vm.ref<!hal.buffer>, i32, i32> ...) attributes {sym_visibility = "private"}
    vm.import @hal.command_buffer.bind_descriptor_set(%command_buffer : !vm.ref<!hal.command_buffer>, %executable_layout : !vm.ref<!hal.executable_layout>, %set : i32, %descriptor_set : !vm.ref<!hal.descriptor_set>, %dynamic_offsets : i32 ...) attributes {sym_visibility = "private"}
    vm.import @hal.command_buffer.dispatch(%command_buffer : !vm.ref<!hal.command_buffer>, %executable : !vm.ref<!hal.executable>, %entry_point : i32, %workgroup_x : i32, %workgroup_y : i32, %workgroup_z : i32) attributes {sym_visibility = "private"}
    vm.import @hal.command_buffer.dispatch.indirect(%command_buffer : !vm.ref<!hal.command_buffer>, %executable : !vm.ref<!hal.executable>, %entry_point : i32, %workgroups_buffer : !vm.ref<!hal.buffer>, %workgroups_offset : i32) attributes {sym_visibility = "private"}
    vm.import @hal.descriptor_set.create(%device : !vm.ref<!hal.device>, %set_layout : !vm.ref<!hal.descriptor_set_layout>, %bindings : tuple<i32, !vm.ref<!hal.buffer>, i32, i32> ...) -> !vm.ref<!hal.descriptor_set> attributes {sym_visibility = "private"}
    vm.import @hal.descriptor_set_layout.create(%device : !vm.ref<!hal.device>, %usage_type : i32, %bindings : tuple<i32, i32, i32> ...) -> !vm.ref<!hal.descriptor_set_layout> attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.device.allocator(%device : !vm.ref<!hal.device>) -> !vm.ref<!hal.allocator> attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.device.query.i32(%device : !vm.ref<!hal.device>, %key : !vm.buffer) -> (i32, i32) attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.device.match.id(%device : !vm.ref<!hal.device>, %pattern : !vm.buffer) -> i32 attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.executable.create(%device : !vm.ref<!hal.device>, %executable_format : !vm.buffer, %executable_data : !vm.buffer, %executable_layouts : !vm.ref<!hal.executable_layout> ...) -> !vm.ref<!hal.executable> attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.executable_layout.create(%device : !vm.ref<!hal.device>, %push_constants : i32, %set_layouts : !vm.ref<!hal.descriptor_set_layout> ...) -> !vm.ref<!hal.executable_layout> attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.semaphore.create(%device : !vm.ref<!hal.device>, %initial_value : i32) -> !vm.ref<!hal.semaphore> attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.semaphore.query(%semaphore : !vm.ref<!hal.semaphore>) -> (i32, i32) attributes {sym_visibility = "private"}
    vm.import @hal.semaphore.signal(%semaphore : !vm.ref<!hal.semaphore>, %new_value : i32) attributes {sym_visibility = "private"}
    vm.import @hal.semaphore.fail(%semaphore : !vm.ref<!hal.semaphore>, %status : i32) attributes {sym_visibility = "private"}
    vm.import @hal.semaphore.await(%semaphore : !vm.ref<!hal.semaphore>, %min_value : i32) -> i32 attributes {sym_visibility = "private"}
    vm.func @predict$sync(%arg0: !vm.ref<!hal.buffer_view>) -> !vm.ref<!hal.buffer_view> attributes {iree.reflection = {abi = "sip", abiv = 1 : i32, f = "I15!B11!d1d28d28d1R9!B6!d1d10", fv = "1", sip = "I8!S5!k0_0R3!_0"}} {
      %zero = vm.const.i32.zero : i32
      %c1 = vm.const.i32 1 : i32
      %c10 = vm.const.i32 10 : i32
      %c50331680 = vm.const.i32 50331680 : i32
      %ref = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
      %ref_0 = vm.call @hal.semaphore.create(%ref, %zero) : (!vm.ref<!hal.device>, i32) -> !vm.ref<!hal.semaphore>
      %0 = vm.call @hal.semaphore.await(%ref_0, %zero) : (!vm.ref<!hal.semaphore>, i32) -> i32
      vm.cond_br %0, ^bb2(%0 : i32), ^bb1
    ^bb1:  // pred: ^bb0
      %ref_1 = vm.call @hal.buffer_view.buffer(%arg0) : (!vm.ref<!hal.buffer_view>) -> !vm.ref<!hal.buffer>
      %ref_2 = vm.call @predict(%ref_1) : (!vm.ref<!hal.buffer>) -> !vm.ref<!hal.buffer>
      %ref_3 = vm.call.variadic @hal.buffer_view.create(%ref_2, %c50331680, [%c1, %c10]) : (!vm.ref<!hal.buffer>, i32, i32 ...) -> !vm.ref<!hal.buffer_view>
      vm.call @hal.semaphore.signal(%ref_0, %c1) : (!vm.ref<!hal.semaphore>, i32) -> ()
      %1 = vm.call @hal.semaphore.await(%ref_0, %c1) : (!vm.ref<!hal.semaphore>, i32) -> i32
      vm.cond_br %1, ^bb2(%1 : i32), ^bb3
    ^bb2(%2: i32):  // 2 preds: ^bb0, ^bb1
      vm.fail %2, "semaphore wait failed"
    ^bb3:  // pred: ^bb1
      vm.return %ref_3 : !vm.ref<!hal.buffer_view>
    }
    vm.export @predict$sync as("predict")
    vm.func @__init() {
      %c2 = vm.const.i32 2 : i32
      %c1 = vm.const.i32 1 : i32
      %c3 = vm.const.i32 3 : i32
      %c7 = vm.const.i32 7 : i32
      %c6 = vm.const.i32 6 : i32
      %null = vm.const.ref.zero : !vm.ref<!hal.executable>
      %zero = vm.const.i32.zero : i32
      %c407040 = vm.const.i32 407040 : i32
      %c50 = vm.const.i32 50 : i32
      %c15 = vm.const.i32 15 : i32
      %ref = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
      %_utf8_dylib_971286B245550E6D = vm.const.ref.rodata @_utf8_dylib_971286B245550E6D : !vm.buffer
      %0 = vm.call @hal.device.match.id(%ref, %_utf8_dylib_971286B245550E6D) : (!vm.ref<!hal.device>, !vm.buffer) -> i32
      vm.global.store.i32 %0, @_device_match_id_0 : i32
      %ref_0 = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
      %ref_1 = vm.call.variadic @hal.descriptor_set_layout.create(%ref_0, %c1, [(%zero, %c7, %c1), (%c1, %c7, %c1), (%c2, %c7, %c6)]) : (!vm.ref<!hal.device>, i32, tuple<i32, i32, i32> ...) -> !vm.ref<!hal.descriptor_set_layout>
      vm.global.store.ref %ref_1, @_descriptor_set_layout_0 : !vm.ref<!hal.descriptor_set_layout>
      %_descriptor_set_layout_0 = vm.global.load.ref @_descriptor_set_layout_0 : !vm.ref<!hal.descriptor_set_layout>
      %ref_2 = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
      %ref_3 = vm.call.variadic @hal.executable_layout.create(%ref_2, %zero, [%_descriptor_set_layout_0]) : (!vm.ref<!hal.device>, i32, !vm.ref<!hal.descriptor_set_layout> ...) -> !vm.ref<!hal.executable_layout>
      vm.global.store.ref %ref_3, @_executable_layout_0 : !vm.ref<!hal.executable_layout>
      %ref_4 = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
      %ref_5 = vm.call.variadic @hal.descriptor_set_layout.create(%ref_4, %c1, [(%zero, %c7, %c1), (%c1, %c7, %c6)]) : (!vm.ref<!hal.device>, i32, tuple<i32, i32, i32> ...) -> !vm.ref<!hal.descriptor_set_layout>
      vm.global.store.ref %ref_5, @_descriptor_set_layout_1 : !vm.ref<!hal.descriptor_set_layout>
      %_descriptor_set_layout_1 = vm.global.load.ref @_descriptor_set_layout_1 : !vm.ref<!hal.descriptor_set_layout>
      %ref_6 = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
      %ref_7 = vm.call.variadic @hal.executable_layout.create(%ref_6, %zero, [%_descriptor_set_layout_1]) : (!vm.ref<!hal.device>, i32, !vm.ref<!hal.descriptor_set_layout> ...) -> !vm.ref<!hal.executable_layout>
      vm.global.store.ref %ref_7, @_executable_layout_1 : !vm.ref<!hal.executable_layout>
      %ref_8 = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
      %ref_9 = vm.call.variadic @hal.descriptor_set_layout.create(%ref_8, %c1, [(%zero, %c7, %c1), (%c1, %c7, %c1), (%c2, %c7, %c1), (%c3, %c7, %c6)]) : (!vm.ref<!hal.device>, i32, tuple<i32, i32, i32> ...) -> !vm.ref<!hal.descriptor_set_layout>
      vm.global.store.ref %ref_9, @_descriptor_set_layout_2 : !vm.ref<!hal.descriptor_set_layout>
      %_descriptor_set_layout_2 = vm.global.load.ref @_descriptor_set_layout_2 : !vm.ref<!hal.descriptor_set_layout>
      %ref_10 = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
      %ref_11 = vm.call.variadic @hal.executable_layout.create(%ref_10, %zero, [%_descriptor_set_layout_2]) : (!vm.ref<!hal.device>, i32, !vm.ref<!hal.descriptor_set_layout> ...) -> !vm.ref<!hal.executable_layout>
      vm.global.store.ref %ref_11, @_executable_layout_2 : !vm.ref<!hal.executable_layout>
      %ref_12 = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
      %_device_match_id_0 = vm.global.load.i32 @_device_match_id_0 : i32
      vm.cond_br %_device_match_id_0, ^bb1, ^bb2
    ^bb1:  // pred: ^bb0
      %_executable_layout_0 = vm.global.load.ref @_executable_layout_0 : !vm.ref<!hal.executable_layout>
      %_executable_layout_1 = vm.global.load.ref @_executable_layout_1 : !vm.ref<!hal.executable_layout>
      %_executable_layout_2 = vm.global.load.ref @_executable_layout_2 : !vm.ref<!hal.executable_layout>
      %_utf8_dlib_F45B9BA87AEFAACB = vm.const.ref.rodata @_utf8_dlib_F45B9BA87AEFAACB : !vm.buffer
      %_mnist_linked_llvm_aot_llvm_aot_binary_dlib = vm.const.ref.rodata @_mnist_linked_llvm_aot_llvm_aot_binary_dlib : !vm.buffer
      %ref_13 = vm.call.variadic @hal.executable.create(%ref_12, %_utf8_dlib_F45B9BA87AEFAACB, %_mnist_linked_llvm_aot_llvm_aot_binary_dlib, [%_executable_layout_0, %_executable_layout_0, %_executable_layout_0, %_executable_layout_1, %_executable_layout_1, %_executable_layout_0, %_executable_layout_1, %_executable_layout_2]) : (!vm.ref<!hal.device>, !vm.buffer, !vm.buffer, !vm.ref<!hal.executable_layout> ...) -> !vm.ref<!hal.executable>
      vm.br ^bb3(%ref_13 : !vm.ref<!hal.executable>)
    ^bb2:  // pred: ^bb0
      vm.br ^bb3(%null : !vm.ref<!hal.executable>)
    ^bb3(%1: !vm.ref<!hal.executable>):  // 2 preds: ^bb1, ^bb2
      vm.global.store.ref %1, @_executable_mnist_linked_llvm_aot : !vm.ref<!hal.executable>
      %ref_14 = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
      %ref_15 = vm.call @hal.device.allocator(%ref_14) : (!vm.ref<!hal.device>) -> !vm.ref<!hal.allocator>
      %_const_pool_storage = vm.const.ref.rodata @_const_pool_storage : !vm.buffer
      %ref_16 = vm.call @hal.allocator.wrap.byte_buffer(%ref_15, %c50, %c15, %_const_pool_storage, %zero, %c407040) : (!vm.ref<!hal.allocator>, i32, i32, !vm.buffer, i32, i32) -> !vm.ref<!hal.buffer>
      vm.global.store.ref %ref_16, @_const_pool_storage_buffer : !vm.ref<!hal.buffer>
      vm.return
    }
    vm.export @__init
  }
}


// *** IR Dump After SymbolDCE ***
module  {
  vm.module @module {
    vm.global.i32 @_device_match_id_0 mutable : i32
    vm.rodata @_utf8_dylib_971286B245550E6D dense<[100, 121, 108, 105, 98, 42]> : vector<6xi8>
    vm.global.ref @_descriptor_set_layout_0 mutable : !vm.ref<!hal.descriptor_set_layout>
    vm.global.ref @_executable_layout_0 mutable : !vm.ref<!hal.executable_layout>
    vm.global.ref @_descriptor_set_layout_1 mutable : !vm.ref<!hal.descriptor_set_layout>
    vm.global.ref @_executable_layout_1 mutable : !vm.ref<!hal.executable_layout>
    vm.global.ref @_descriptor_set_layout_2 mutable : !vm.ref<!hal.descriptor_set_layout>
    vm.global.ref @_executable_layout_2 mutable : !vm.ref<!hal.executable_layout>
    vm.global.ref @_executable_mnist_linked_llvm_aot mutable : !vm.ref<!hal.executable>
    vm.rodata @_mnist_linked_llvm_aot_llvm_aot_binary_dlib opaque<"_", "0xDEADBEEF"> : vector<136794xi8>
    vm.rodata @_utf8_dlib_F45B9BA87AEFAACB dense<[68, 76, 73, 66]> : vector<4xi8>
    vm.rodata @_const_pool_storage opaque<"_", "0xDEADBEEF"> : vector<407040xi8>
    vm.global.ref @_const_pool_storage_buffer mutable : !vm.ref<!hal.buffer>
    vm.func @predict(%arg0: !vm.ref<!hal.buffer>) -> !vm.ref<!hal.buffer> attributes {noinline} {
      %c3136 = vm.const.i32 3136 : i32
      %c401408 = vm.const.i32 401408 : i32
      %c401920 = vm.const.i32 401920 : i32
      %c5120 = vm.const.i32 5120 : i32
      %c40 = vm.const.i32 40 : i32
      %c512 = vm.const.i32 512 : i32
      %c96 = vm.const.i32 96 : i32
      %c112 = vm.const.i32 112 : i32
      %c1024 = vm.const.i32 1024 : i32
      %c50 = vm.const.i32 50 : i32
      %c14 = vm.const.i32 14 : i32
      %c48 = vm.const.i32 48 : i32
      %c10 = vm.const.i32 10 : i32
      %c17 = vm.const.i32 17 : i32
      %c1 = vm.const.i32 1 : i32
      %c3 = vm.const.i32 3 : i32
      %c4 = vm.const.i32 4 : i32
      %c6 = vm.const.i32 6 : i32
      %c7 = vm.const.i32 7 : i32
      %c20 = vm.const.i32 20 : i32
      %c5 = vm.const.i32 5 : i32
      %zero = vm.const.i32.zero : i32
      %c2 = vm.const.i32 2 : i32
      %ref = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
      %ref_0 = vm.call @hal.device.allocator(%ref) : (!vm.ref<!hal.device>) -> !vm.ref<!hal.allocator>
      %ref_1 = vm.call @hal.allocator.allocate(%ref_0, %c50, %c14, %c40) : (!vm.ref<!hal.allocator>, i32, i32, i32) -> !vm.ref<!hal.buffer>
      %_const_pool_storage_buffer = vm.global.load.ref @_const_pool_storage_buffer : !vm.ref<!hal.buffer>
      %ref_2 = vm.call @hal.allocator.allocate(%ref_0, %c48, %c10, %c1024) : (!vm.ref<!hal.allocator>, i32, i32, i32) -> !vm.ref<!hal.buffer>
      %ref_3 = vm.call @hal.command_buffer.create(%ref, %c17, %c3) : (!vm.ref<!hal.device>, i32, i32) -> !vm.ref<!hal.command_buffer>
      vm.call @hal.command_buffer.begin(%ref_3) : (!vm.ref<!hal.command_buffer>) -> ()
      %_executable_layout_0 = vm.global.load.ref @_executable_layout_0 : !vm.ref<!hal.executable_layout>
      vm.call.variadic @hal.command_buffer.push_descriptor_set(%ref_3, %_executable_layout_0, %zero, [(%zero, %_const_pool_storage_buffer, %c512, %c401408), (%c1, %arg0, %zero, %c3136), (%c2, %ref_2, %zero, %c512)]) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable_layout>, i32, tuple<i32, !vm.ref<!hal.buffer>, i32, i32> ...)
      %_device_match_id_0 = vm.global.load.i32 @_device_match_id_0 : i32
      vm.cond_br %_device_match_id_0, ^bb1, ^bb2
    ^bb1:  // pred: ^bb0
      %_executable_mnist_linked_llvm_aot = vm.global.load.ref @_executable_mnist_linked_llvm_aot : !vm.ref<!hal.executable>
      vm.call @hal.command_buffer.dispatch(%ref_3, %_executable_mnist_linked_llvm_aot, %zero, %c2, %c1, %c1) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable>, i32, i32, i32, i32) -> ()
      vm.call @hal.command_buffer.execution_barrier(%ref_3, %c20, %c5, %zero) : (!vm.ref<!hal.command_buffer>, i32, i32, i32) -> ()
      vm.call.variadic @hal.command_buffer.push_descriptor_set(%ref_3, %_executable_layout_0, %zero, [(%zero, %_const_pool_storage_buffer, %zero, %c512), (%c1, %ref_2, %zero, %c512), (%c2, %ref_2, %c512, %c512)]) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable_layout>, i32, tuple<i32, !vm.ref<!hal.buffer>, i32, i32> ...)
      vm.call @hal.command_buffer.dispatch(%ref_3, %_executable_mnist_linked_llvm_aot, %c1, %c1, %c1, %c1) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable>, i32, i32, i32, i32) -> ()
      vm.call @hal.command_buffer.execution_barrier(%ref_3, %c20, %c5, %zero) : (!vm.ref<!hal.command_buffer>, i32, i32, i32) -> ()
      vm.call.variadic @hal.command_buffer.push_descriptor_set(%ref_3, %_executable_layout_0, %zero, [(%zero, %_const_pool_storage_buffer, %c401920, %c5120), (%c1, %ref_2, %c512, %c512), (%c2, %ref_2, %zero, %c40)]) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable_layout>, i32, tuple<i32, !vm.ref<!hal.buffer>, i32, i32> ...)
      vm.call @hal.command_buffer.dispatch(%ref_3, %_executable_mnist_linked_llvm_aot, %c2, %c1, %c1, %c1) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable>, i32, i32, i32, i32) -> ()
      vm.call @hal.command_buffer.execution_barrier(%ref_3, %c20, %c5, %zero) : (!vm.ref<!hal.command_buffer>, i32, i32, i32) -> ()
      %_executable_layout_1 = vm.global.load.ref @_executable_layout_1 : !vm.ref<!hal.executable_layout>
      vm.call.variadic @hal.command_buffer.push_descriptor_set(%ref_3, %_executable_layout_1, %zero, [(%zero, %ref_2, %zero, %c40), (%c1, %ref_2, %c48, %c40)]) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable_layout>, i32, tuple<i32, !vm.ref<!hal.buffer>, i32, i32> ...)
      vm.call @hal.command_buffer.dispatch(%ref_3, %_executable_mnist_linked_llvm_aot, %c3, %c1, %c1, %c1) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable>, i32, i32, i32, i32) -> ()
      vm.call @hal.command_buffer.execution_barrier(%ref_3, %c20, %c5, %zero) : (!vm.ref<!hal.command_buffer>, i32, i32, i32) -> ()
      vm.call.variadic @hal.command_buffer.push_descriptor_set(%ref_3, %_executable_layout_1, %zero, [(%zero, %ref_2, %c48, %c40), (%c1, %ref_2, %c96, %c4)]) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable_layout>, i32, tuple<i32, !vm.ref<!hal.buffer>, i32, i32> ...)
      vm.call @hal.command_buffer.dispatch(%ref_3, %_executable_mnist_linked_llvm_aot, %c4, %c1, %c1, %c1) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable>, i32, i32, i32, i32) -> ()
      vm.call @hal.command_buffer.execution_barrier(%ref_3, %c20, %c5, %zero) : (!vm.ref<!hal.command_buffer>, i32, i32, i32) -> ()
      vm.call.variadic @hal.command_buffer.push_descriptor_set(%ref_3, %_executable_layout_0, %zero, [(%zero, %ref_2, %zero, %c40), (%c1, %ref_2, %c96, %c4), (%c2, %ref_2, %c48, %c40)]) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable_layout>, i32, tuple<i32, !vm.ref<!hal.buffer>, i32, i32> ...)
      vm.call @hal.command_buffer.dispatch(%ref_3, %_executable_mnist_linked_llvm_aot, %c5, %c1, %c1, %c1) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable>, i32, i32, i32, i32) -> ()
      vm.call @hal.command_buffer.execution_barrier(%ref_3, %c20, %c5, %zero) : (!vm.ref<!hal.command_buffer>, i32, i32, i32) -> ()
      vm.call.variadic @hal.command_buffer.push_descriptor_set(%ref_3, %_executable_layout_1, %zero, [(%zero, %ref_2, %c48, %c40), (%c1, %ref_2, %c112, %c4)]) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable_layout>, i32, tuple<i32, !vm.ref<!hal.buffer>, i32, i32> ...)
      vm.call @hal.command_buffer.dispatch(%ref_3, %_executable_mnist_linked_llvm_aot, %c6, %c1, %c1, %c1) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable>, i32, i32, i32, i32) -> ()
      vm.call @hal.command_buffer.execution_barrier(%ref_3, %c20, %c5, %zero) : (!vm.ref<!hal.command_buffer>, i32, i32, i32) -> ()
      %_executable_layout_2 = vm.global.load.ref @_executable_layout_2 : !vm.ref<!hal.executable_layout>
      vm.call.variadic @hal.command_buffer.push_descriptor_set(%ref_3, %_executable_layout_2, %zero, [(%zero, %ref_2, %zero, %c40), (%c1, %ref_2, %c96, %c4), (%c2, %ref_2, %c112, %c4), (%c3, %ref_1, %zero, %c40)]) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable_layout>, i32, tuple<i32, !vm.ref<!hal.buffer>, i32, i32> ...)
      vm.call @hal.command_buffer.dispatch(%ref_3, %_executable_mnist_linked_llvm_aot, %c7, %c1, %c1, %c1) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable>, i32, i32, i32, i32) -> ()
      vm.call @hal.command_buffer.execution_barrier(%ref_3, %c20, %c5, %zero) : (!vm.ref<!hal.command_buffer>, i32, i32, i32) -> ()
      vm.call @hal.command_buffer.end(%ref_3) : (!vm.ref<!hal.command_buffer>) -> ()
      vm.call @hal.ex.submit_and_wait(%ref, %ref_3) : (!vm.ref<!hal.device>, !vm.ref<!hal.command_buffer>) -> ()
      vm.return %ref_1 : !vm.ref<!hal.buffer>
    ^bb2:  // pred: ^bb0
      vm.fail %c2, "device not supported in the compiled configuration"
    }
    vm.func @predict$async(%arg0: !vm.ref<!hal.semaphore>, %arg1: i32, %arg2: !vm.ref<!hal.buffer_view>, %arg3: !vm.ref<!hal.semaphore>, %arg4: i32) -> !vm.ref<!hal.buffer_view> {
      %c1 = vm.const.i32 1 : i32
      %c10 = vm.const.i32 10 : i32
      %c50331680 = vm.const.i32 50331680 : i32
      %0 = vm.call @hal.semaphore.await(%arg0, %arg1) : (!vm.ref<!hal.semaphore>, i32) -> i32
      vm.cond_br %0, ^bb2(%0 : i32), ^bb1
    ^bb1:  // pred: ^bb0
      %ref = vm.call @hal.buffer_view.buffer(%arg2) : (!vm.ref<!hal.buffer_view>) -> !vm.ref<!hal.buffer>
      %ref_0 = vm.call @predict(%ref) : (!vm.ref<!hal.buffer>) -> !vm.ref<!hal.buffer>
      %ref_1 = vm.call.variadic @hal.buffer_view.create(%ref_0, %c50331680, [%c1, %c10]) : (!vm.ref<!hal.buffer>, i32, i32 ...) -> !vm.ref<!hal.buffer_view>
      vm.call @hal.semaphore.signal(%arg3, %arg4) : (!vm.ref<!hal.semaphore>, i32) -> ()
      vm.return %ref_1 : !vm.ref<!hal.buffer_view>
    ^bb2(%1: i32):  // pred: ^bb0
      vm.fail %1, "semaphore wait failed"
    }
    vm.export @predict$async
    vm.import @hal.ex.shared_device() -> !vm.ref<!hal.device> attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.ex.submit_and_wait(%device : !vm.ref<!hal.device>, %command_buffer : !vm.ref<!hal.command_buffer>) attributes {sym_visibility = "private"}
    vm.import @hal.allocator.allocate(%allocator : !vm.ref<!hal.allocator>, %memory_types : i32, %buffer_usage : i32, %allocation_size : i32) -> !vm.ref<!hal.buffer> attributes {sym_visibility = "private"}
    vm.import @hal.allocator.wrap.byte_buffer(%allocator : !vm.ref<!hal.allocator>, %memory_types : i32, %buffer_usage : i32, %source : !vm.buffer, %offset : i32, %length : i32) -> !vm.ref<!hal.buffer> attributes {sym_visibility = "private"}
    vm.import @hal.buffer_view.create(%buffer : !vm.ref<!hal.buffer>, %element_type : i32, %shape : i32 ...) -> !vm.ref<!hal.buffer_view> attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.buffer_view.buffer(%buffer_view : !vm.ref<!hal.buffer_view>) -> !vm.ref<!hal.buffer> attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.command_buffer.create(%device : !vm.ref<!hal.device>, %modes : i32, %command_categories : i32) -> !vm.ref<!hal.command_buffer> attributes {sym_visibility = "private"}
    vm.import @hal.command_buffer.begin(%command_buffer : !vm.ref<!hal.command_buffer>) attributes {sym_visibility = "private"}
    vm.import @hal.command_buffer.end(%command_buffer : !vm.ref<!hal.command_buffer>) attributes {sym_visibility = "private"}
    vm.import @hal.command_buffer.execution_barrier(%command_buffer : !vm.ref<!hal.command_buffer>, %source_stage_mask : i32, %target_stage_mask : i32, %flags : i32) attributes {sym_visibility = "private"}
    vm.import @hal.command_buffer.push_descriptor_set(%command_buffer : !vm.ref<!hal.command_buffer>, %executable_layout : !vm.ref<!hal.executable_layout>, %set : i32, %bindings : tuple<i32, !vm.ref<!hal.buffer>, i32, i32> ...) attributes {sym_visibility = "private"}
    vm.import @hal.command_buffer.dispatch(%command_buffer : !vm.ref<!hal.command_buffer>, %executable : !vm.ref<!hal.executable>, %entry_point : i32, %workgroup_x : i32, %workgroup_y : i32, %workgroup_z : i32) attributes {sym_visibility = "private"}
    vm.import @hal.descriptor_set_layout.create(%device : !vm.ref<!hal.device>, %usage_type : i32, %bindings : tuple<i32, i32, i32> ...) -> !vm.ref<!hal.descriptor_set_layout> attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.device.allocator(%device : !vm.ref<!hal.device>) -> !vm.ref<!hal.allocator> attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.device.match.id(%device : !vm.ref<!hal.device>, %pattern : !vm.buffer) -> i32 attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.executable.create(%device : !vm.ref<!hal.device>, %executable_format : !vm.buffer, %executable_data : !vm.buffer, %executable_layouts : !vm.ref<!hal.executable_layout> ...) -> !vm.ref<!hal.executable> attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.executable_layout.create(%device : !vm.ref<!hal.device>, %push_constants : i32, %set_layouts : !vm.ref<!hal.descriptor_set_layout> ...) -> !vm.ref<!hal.executable_layout> attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.semaphore.create(%device : !vm.ref<!hal.device>, %initial_value : i32) -> !vm.ref<!hal.semaphore> attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.semaphore.signal(%semaphore : !vm.ref<!hal.semaphore>, %new_value : i32) attributes {sym_visibility = "private"}
    vm.import @hal.semaphore.await(%semaphore : !vm.ref<!hal.semaphore>, %min_value : i32) -> i32 attributes {sym_visibility = "private"}
    vm.func @predict$sync(%arg0: !vm.ref<!hal.buffer_view>) -> !vm.ref<!hal.buffer_view> attributes {iree.reflection = {abi = "sip", abiv = 1 : i32, f = "I15!B11!d1d28d28d1R9!B6!d1d10", fv = "1", sip = "I8!S5!k0_0R3!_0"}} {
      %zero = vm.const.i32.zero : i32
      %c1 = vm.const.i32 1 : i32
      %c10 = vm.const.i32 10 : i32
      %c50331680 = vm.const.i32 50331680 : i32
      %ref = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
      %ref_0 = vm.call @hal.semaphore.create(%ref, %zero) : (!vm.ref<!hal.device>, i32) -> !vm.ref<!hal.semaphore>
      %0 = vm.call @hal.semaphore.await(%ref_0, %zero) : (!vm.ref<!hal.semaphore>, i32) -> i32
      vm.cond_br %0, ^bb2(%0 : i32), ^bb1
    ^bb1:  // pred: ^bb0
      %ref_1 = vm.call @hal.buffer_view.buffer(%arg0) : (!vm.ref<!hal.buffer_view>) -> !vm.ref<!hal.buffer>
      %ref_2 = vm.call @predict(%ref_1) : (!vm.ref<!hal.buffer>) -> !vm.ref<!hal.buffer>
      %ref_3 = vm.call.variadic @hal.buffer_view.create(%ref_2, %c50331680, [%c1, %c10]) : (!vm.ref<!hal.buffer>, i32, i32 ...) -> !vm.ref<!hal.buffer_view>
      vm.call @hal.semaphore.signal(%ref_0, %c1) : (!vm.ref<!hal.semaphore>, i32) -> ()
      %1 = vm.call @hal.semaphore.await(%ref_0, %c1) : (!vm.ref<!hal.semaphore>, i32) -> i32
      vm.cond_br %1, ^bb2(%1 : i32), ^bb3
    ^bb2(%2: i32):  // 2 preds: ^bb0, ^bb1
      vm.fail %2, "semaphore wait failed"
    ^bb3:  // pred: ^bb1
      vm.return %ref_3 : !vm.ref<!hal.buffer_view>
    }
    vm.export @predict$sync as("predict")
    vm.func @__init() {
      %c2 = vm.const.i32 2 : i32
      %c1 = vm.const.i32 1 : i32
      %c3 = vm.const.i32 3 : i32
      %c7 = vm.const.i32 7 : i32
      %c6 = vm.const.i32 6 : i32
      %null = vm.const.ref.zero : !vm.ref<!hal.executable>
      %zero = vm.const.i32.zero : i32
      %c407040 = vm.const.i32 407040 : i32
      %c50 = vm.const.i32 50 : i32
      %c15 = vm.const.i32 15 : i32
      %ref = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
      %_utf8_dylib_971286B245550E6D = vm.const.ref.rodata @_utf8_dylib_971286B245550E6D : !vm.buffer
      %0 = vm.call @hal.device.match.id(%ref, %_utf8_dylib_971286B245550E6D) : (!vm.ref<!hal.device>, !vm.buffer) -> i32
      vm.global.store.i32 %0, @_device_match_id_0 : i32
      %ref_0 = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
      %ref_1 = vm.call.variadic @hal.descriptor_set_layout.create(%ref_0, %c1, [(%zero, %c7, %c1), (%c1, %c7, %c1), (%c2, %c7, %c6)]) : (!vm.ref<!hal.device>, i32, tuple<i32, i32, i32> ...) -> !vm.ref<!hal.descriptor_set_layout>
      vm.global.store.ref %ref_1, @_descriptor_set_layout_0 : !vm.ref<!hal.descriptor_set_layout>
      %_descriptor_set_layout_0 = vm.global.load.ref @_descriptor_set_layout_0 : !vm.ref<!hal.descriptor_set_layout>
      %ref_2 = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
      %ref_3 = vm.call.variadic @hal.executable_layout.create(%ref_2, %zero, [%_descriptor_set_layout_0]) : (!vm.ref<!hal.device>, i32, !vm.ref<!hal.descriptor_set_layout> ...) -> !vm.ref<!hal.executable_layout>
      vm.global.store.ref %ref_3, @_executable_layout_0 : !vm.ref<!hal.executable_layout>
      %ref_4 = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
      %ref_5 = vm.call.variadic @hal.descriptor_set_layout.create(%ref_4, %c1, [(%zero, %c7, %c1), (%c1, %c7, %c6)]) : (!vm.ref<!hal.device>, i32, tuple<i32, i32, i32> ...) -> !vm.ref<!hal.descriptor_set_layout>
      vm.global.store.ref %ref_5, @_descriptor_set_layout_1 : !vm.ref<!hal.descriptor_set_layout>
      %_descriptor_set_layout_1 = vm.global.load.ref @_descriptor_set_layout_1 : !vm.ref<!hal.descriptor_set_layout>
      %ref_6 = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
      %ref_7 = vm.call.variadic @hal.executable_layout.create(%ref_6, %zero, [%_descriptor_set_layout_1]) : (!vm.ref<!hal.device>, i32, !vm.ref<!hal.descriptor_set_layout> ...) -> !vm.ref<!hal.executable_layout>
      vm.global.store.ref %ref_7, @_executable_layout_1 : !vm.ref<!hal.executable_layout>
      %ref_8 = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
      %ref_9 = vm.call.variadic @hal.descriptor_set_layout.create(%ref_8, %c1, [(%zero, %c7, %c1), (%c1, %c7, %c1), (%c2, %c7, %c1), (%c3, %c7, %c6)]) : (!vm.ref<!hal.device>, i32, tuple<i32, i32, i32> ...) -> !vm.ref<!hal.descriptor_set_layout>
      vm.global.store.ref %ref_9, @_descriptor_set_layout_2 : !vm.ref<!hal.descriptor_set_layout>
      %_descriptor_set_layout_2 = vm.global.load.ref @_descriptor_set_layout_2 : !vm.ref<!hal.descriptor_set_layout>
      %ref_10 = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
      %ref_11 = vm.call.variadic @hal.executable_layout.create(%ref_10, %zero, [%_descriptor_set_layout_2]) : (!vm.ref<!hal.device>, i32, !vm.ref<!hal.descriptor_set_layout> ...) -> !vm.ref<!hal.executable_layout>
      vm.global.store.ref %ref_11, @_executable_layout_2 : !vm.ref<!hal.executable_layout>
      %ref_12 = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
      %_device_match_id_0 = vm.global.load.i32 @_device_match_id_0 : i32
      vm.cond_br %_device_match_id_0, ^bb1, ^bb2
    ^bb1:  // pred: ^bb0
      %_executable_layout_0 = vm.global.load.ref @_executable_layout_0 : !vm.ref<!hal.executable_layout>
      %_executable_layout_1 = vm.global.load.ref @_executable_layout_1 : !vm.ref<!hal.executable_layout>
      %_executable_layout_2 = vm.global.load.ref @_executable_layout_2 : !vm.ref<!hal.executable_layout>
      %_utf8_dlib_F45B9BA87AEFAACB = vm.const.ref.rodata @_utf8_dlib_F45B9BA87AEFAACB : !vm.buffer
      %_mnist_linked_llvm_aot_llvm_aot_binary_dlib = vm.const.ref.rodata @_mnist_linked_llvm_aot_llvm_aot_binary_dlib : !vm.buffer
      %ref_13 = vm.call.variadic @hal.executable.create(%ref_12, %_utf8_dlib_F45B9BA87AEFAACB, %_mnist_linked_llvm_aot_llvm_aot_binary_dlib, [%_executable_layout_0, %_executable_layout_0, %_executable_layout_0, %_executable_layout_1, %_executable_layout_1, %_executable_layout_0, %_executable_layout_1, %_executable_layout_2]) : (!vm.ref<!hal.device>, !vm.buffer, !vm.buffer, !vm.ref<!hal.executable_layout> ...) -> !vm.ref<!hal.executable>
      vm.br ^bb3(%ref_13 : !vm.ref<!hal.executable>)
    ^bb2:  // pred: ^bb0
      vm.br ^bb3(%null : !vm.ref<!hal.executable>)
    ^bb3(%1: !vm.ref<!hal.executable>):  // 2 preds: ^bb1, ^bb2
      vm.global.store.ref %1, @_executable_mnist_linked_llvm_aot : !vm.ref<!hal.executable>
      %ref_14 = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
      %ref_15 = vm.call @hal.device.allocator(%ref_14) : (!vm.ref<!hal.device>) -> !vm.ref<!hal.allocator>
      %_const_pool_storage = vm.const.ref.rodata @_const_pool_storage : !vm.buffer
      %ref_16 = vm.call @hal.allocator.wrap.byte_buffer(%ref_15, %c50, %c15, %_const_pool_storage, %zero, %c407040) : (!vm.ref<!hal.allocator>, i32, i32, !vm.buffer, i32, i32) -> !vm.ref<!hal.buffer>
      vm.global.store.ref %ref_16, @_const_pool_storage_buffer : !vm.ref<!hal.buffer>
      vm.return
    }
    vm.export @__init
  }
}


// *** IR Dump After mlir::iree_compiler::IREE::VM::SinkDefiningOpsPass ***
vm.module @module {
  vm.global.i32 @_device_match_id_0 mutable : i32
  vm.rodata @_utf8_dylib_971286B245550E6D dense<[100, 121, 108, 105, 98, 42]> : vector<6xi8>
  vm.global.ref @_descriptor_set_layout_0 mutable : !vm.ref<!hal.descriptor_set_layout>
  vm.global.ref @_executable_layout_0 mutable : !vm.ref<!hal.executable_layout>
  vm.global.ref @_descriptor_set_layout_1 mutable : !vm.ref<!hal.descriptor_set_layout>
  vm.global.ref @_executable_layout_1 mutable : !vm.ref<!hal.executable_layout>
  vm.global.ref @_descriptor_set_layout_2 mutable : !vm.ref<!hal.descriptor_set_layout>
  vm.global.ref @_executable_layout_2 mutable : !vm.ref<!hal.executable_layout>
  vm.global.ref @_executable_mnist_linked_llvm_aot mutable : !vm.ref<!hal.executable>
  vm.rodata @_mnist_linked_llvm_aot_llvm_aot_binary_dlib opaque<"_", "0xDEADBEEF"> : vector<136794xi8>
  vm.rodata @_utf8_dlib_F45B9BA87AEFAACB dense<[68, 76, 73, 66]> : vector<4xi8>
  vm.rodata @_const_pool_storage opaque<"_", "0xDEADBEEF"> : vector<407040xi8>
  vm.global.ref @_const_pool_storage_buffer mutable : !vm.ref<!hal.buffer>
  vm.func @predict(%arg0: !vm.ref<!hal.buffer>) -> !vm.ref<!hal.buffer> attributes {noinline} {
    %ref = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
    %ref_0 = vm.call @hal.device.allocator(%ref) : (!vm.ref<!hal.device>) -> !vm.ref<!hal.allocator>
    %c40 = vm.const.i32 40 : i32
    %c50 = vm.const.i32 50 : i32
    %c14 = vm.const.i32 14 : i32
    %ref_1 = vm.call @hal.allocator.allocate(%ref_0, %c50, %c14, %c40) : (!vm.ref<!hal.allocator>, i32, i32, i32) -> !vm.ref<!hal.buffer>
    %_const_pool_storage_buffer = vm.global.load.ref @_const_pool_storage_buffer : !vm.ref<!hal.buffer>
    %c1024 = vm.const.i32 1024 : i32
    %c48 = vm.const.i32 48 : i32
    %c10 = vm.const.i32 10 : i32
    %ref_2 = vm.call @hal.allocator.allocate(%ref_0, %c48, %c10, %c1024) : (!vm.ref<!hal.allocator>, i32, i32, i32) -> !vm.ref<!hal.buffer>
    %c17 = vm.const.i32 17 : i32
    %c3 = vm.const.i32 3 : i32
    %ref_3 = vm.call @hal.command_buffer.create(%ref, %c17, %c3) : (!vm.ref<!hal.device>, i32, i32) -> !vm.ref<!hal.command_buffer>
    vm.call @hal.command_buffer.begin(%ref_3) : (!vm.ref<!hal.command_buffer>) -> ()
    %_executable_layout_0 = vm.global.load.ref @_executable_layout_0 : !vm.ref<!hal.executable_layout>
    %c3136 = vm.const.i32 3136 : i32
    %c401408 = vm.const.i32 401408 : i32
    %c512 = vm.const.i32 512 : i32
    %c1 = vm.const.i32 1 : i32
    %zero = vm.const.i32.zero : i32
    %c2 = vm.const.i32 2 : i32
    vm.call.variadic @hal.command_buffer.push_descriptor_set(%ref_3, %_executable_layout_0, %zero, [(%zero, %_const_pool_storage_buffer, %c512, %c401408), (%c1, %arg0, %zero, %c3136), (%c2, %ref_2, %zero, %c512)]) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable_layout>, i32, tuple<i32, !vm.ref<!hal.buffer>, i32, i32> ...)
    %_device_match_id_0 = vm.global.load.i32 @_device_match_id_0 : i32
    vm.cond_br %_device_match_id_0, ^bb1, ^bb2
  ^bb1:  // pred: ^bb0
    %_executable_mnist_linked_llvm_aot = vm.global.load.ref @_executable_mnist_linked_llvm_aot : !vm.ref<!hal.executable>
    vm.call @hal.command_buffer.dispatch(%ref_3, %_executable_mnist_linked_llvm_aot, %zero, %c2, %c1, %c1) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable>, i32, i32, i32, i32) -> ()
    %c20 = vm.const.i32 20 : i32
    %c5 = vm.const.i32 5 : i32
    vm.call @hal.command_buffer.execution_barrier(%ref_3, %c20, %c5, %zero) : (!vm.ref<!hal.command_buffer>, i32, i32, i32) -> ()
    vm.call.variadic @hal.command_buffer.push_descriptor_set(%ref_3, %_executable_layout_0, %zero, [(%zero, %_const_pool_storage_buffer, %zero, %c512), (%c1, %ref_2, %zero, %c512), (%c2, %ref_2, %c512, %c512)]) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable_layout>, i32, tuple<i32, !vm.ref<!hal.buffer>, i32, i32> ...)
    vm.call @hal.command_buffer.dispatch(%ref_3, %_executable_mnist_linked_llvm_aot, %c1, %c1, %c1, %c1) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable>, i32, i32, i32, i32) -> ()
    vm.call @hal.command_buffer.execution_barrier(%ref_3, %c20, %c5, %zero) : (!vm.ref<!hal.command_buffer>, i32, i32, i32) -> ()
    %c401920 = vm.const.i32 401920 : i32
    %c5120 = vm.const.i32 5120 : i32
    vm.call.variadic @hal.command_buffer.push_descriptor_set(%ref_3, %_executable_layout_0, %zero, [(%zero, %_const_pool_storage_buffer, %c401920, %c5120), (%c1, %ref_2, %c512, %c512), (%c2, %ref_2, %zero, %c40)]) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable_layout>, i32, tuple<i32, !vm.ref<!hal.buffer>, i32, i32> ...)
    vm.call @hal.command_buffer.dispatch(%ref_3, %_executable_mnist_linked_llvm_aot, %c2, %c1, %c1, %c1) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable>, i32, i32, i32, i32) -> ()
    vm.call @hal.command_buffer.execution_barrier(%ref_3, %c20, %c5, %zero) : (!vm.ref<!hal.command_buffer>, i32, i32, i32) -> ()
    %_executable_layout_1 = vm.global.load.ref @_executable_layout_1 : !vm.ref<!hal.executable_layout>
    vm.call.variadic @hal.command_buffer.push_descriptor_set(%ref_3, %_executable_layout_1, %zero, [(%zero, %ref_2, %zero, %c40), (%c1, %ref_2, %c48, %c40)]) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable_layout>, i32, tuple<i32, !vm.ref<!hal.buffer>, i32, i32> ...)
    vm.call @hal.command_buffer.dispatch(%ref_3, %_executable_mnist_linked_llvm_aot, %c3, %c1, %c1, %c1) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable>, i32, i32, i32, i32) -> ()
    vm.call @hal.command_buffer.execution_barrier(%ref_3, %c20, %c5, %zero) : (!vm.ref<!hal.command_buffer>, i32, i32, i32) -> ()
    %c96 = vm.const.i32 96 : i32
    %c4 = vm.const.i32 4 : i32
    vm.call.variadic @hal.command_buffer.push_descriptor_set(%ref_3, %_executable_layout_1, %zero, [(%zero, %ref_2, %c48, %c40), (%c1, %ref_2, %c96, %c4)]) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable_layout>, i32, tuple<i32, !vm.ref<!hal.buffer>, i32, i32> ...)
    vm.call @hal.command_buffer.dispatch(%ref_3, %_executable_mnist_linked_llvm_aot, %c4, %c1, %c1, %c1) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable>, i32, i32, i32, i32) -> ()
    vm.call @hal.command_buffer.execution_barrier(%ref_3, %c20, %c5, %zero) : (!vm.ref<!hal.command_buffer>, i32, i32, i32) -> ()
    vm.call.variadic @hal.command_buffer.push_descriptor_set(%ref_3, %_executable_layout_0, %zero, [(%zero, %ref_2, %zero, %c40), (%c1, %ref_2, %c96, %c4), (%c2, %ref_2, %c48, %c40)]) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable_layout>, i32, tuple<i32, !vm.ref<!hal.buffer>, i32, i32> ...)
    vm.call @hal.command_buffer.dispatch(%ref_3, %_executable_mnist_linked_llvm_aot, %c5, %c1, %c1, %c1) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable>, i32, i32, i32, i32) -> ()
    vm.call @hal.command_buffer.execution_barrier(%ref_3, %c20, %c5, %zero) : (!vm.ref<!hal.command_buffer>, i32, i32, i32) -> ()
    %c112 = vm.const.i32 112 : i32
    vm.call.variadic @hal.command_buffer.push_descriptor_set(%ref_3, %_executable_layout_1, %zero, [(%zero, %ref_2, %c48, %c40), (%c1, %ref_2, %c112, %c4)]) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable_layout>, i32, tuple<i32, !vm.ref<!hal.buffer>, i32, i32> ...)
    %c6 = vm.const.i32 6 : i32
    vm.call @hal.command_buffer.dispatch(%ref_3, %_executable_mnist_linked_llvm_aot, %c6, %c1, %c1, %c1) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable>, i32, i32, i32, i32) -> ()
    vm.call @hal.command_buffer.execution_barrier(%ref_3, %c20, %c5, %zero) : (!vm.ref<!hal.command_buffer>, i32, i32, i32) -> ()
    %_executable_layout_2 = vm.global.load.ref @_executable_layout_2 : !vm.ref<!hal.executable_layout>
    vm.call.variadic @hal.command_buffer.push_descriptor_set(%ref_3, %_executable_layout_2, %zero, [(%zero, %ref_2, %zero, %c40), (%c1, %ref_2, %c96, %c4), (%c2, %ref_2, %c112, %c4), (%c3, %ref_1, %zero, %c40)]) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable_layout>, i32, tuple<i32, !vm.ref<!hal.buffer>, i32, i32> ...)
    %c7 = vm.const.i32 7 : i32
    vm.call @hal.command_buffer.dispatch(%ref_3, %_executable_mnist_linked_llvm_aot, %c7, %c1, %c1, %c1) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable>, i32, i32, i32, i32) -> ()
    vm.call @hal.command_buffer.execution_barrier(%ref_3, %c20, %c5, %zero) : (!vm.ref<!hal.command_buffer>, i32, i32, i32) -> ()
    vm.call @hal.command_buffer.end(%ref_3) : (!vm.ref<!hal.command_buffer>) -> ()
    vm.call @hal.ex.submit_and_wait(%ref, %ref_3) : (!vm.ref<!hal.device>, !vm.ref<!hal.command_buffer>) -> ()
    vm.return %ref_1 : !vm.ref<!hal.buffer>
  ^bb2:  // pred: ^bb0
    vm.fail %c2, "device not supported in the compiled configuration"
  }
  vm.func @predict$async(%arg0: !vm.ref<!hal.semaphore>, %arg1: i32, %arg2: !vm.ref<!hal.buffer_view>, %arg3: !vm.ref<!hal.semaphore>, %arg4: i32) -> !vm.ref<!hal.buffer_view> {
    %0 = vm.call @hal.semaphore.await(%arg0, %arg1) : (!vm.ref<!hal.semaphore>, i32) -> i32
    vm.cond_br %0, ^bb2(%0 : i32), ^bb1
  ^bb1:  // pred: ^bb0
    %ref = vm.call @hal.buffer_view.buffer(%arg2) : (!vm.ref<!hal.buffer_view>) -> !vm.ref<!hal.buffer>
    %ref_0 = vm.call @predict(%ref) : (!vm.ref<!hal.buffer>) -> !vm.ref<!hal.buffer>
    %c1 = vm.const.i32 1 : i32
    %c10 = vm.const.i32 10 : i32
    %c50331680 = vm.const.i32 50331680 : i32
    %ref_1 = vm.call.variadic @hal.buffer_view.create(%ref_0, %c50331680, [%c1, %c10]) : (!vm.ref<!hal.buffer>, i32, i32 ...) -> !vm.ref<!hal.buffer_view>
    vm.call @hal.semaphore.signal(%arg3, %arg4) : (!vm.ref<!hal.semaphore>, i32) -> ()
    vm.return %ref_1 : !vm.ref<!hal.buffer_view>
  ^bb2(%1: i32):  // pred: ^bb0
    vm.fail %1, "semaphore wait failed"
  }
  vm.export @predict$async
  vm.import @hal.ex.shared_device() -> !vm.ref<!hal.device> attributes {nosideeffects, sym_visibility = "private"}
  vm.import @hal.ex.submit_and_wait(%device : !vm.ref<!hal.device>, %command_buffer : !vm.ref<!hal.command_buffer>) attributes {sym_visibility = "private"}
  vm.import @hal.allocator.allocate(%allocator : !vm.ref<!hal.allocator>, %memory_types : i32, %buffer_usage : i32, %allocation_size : i32) -> !vm.ref<!hal.buffer> attributes {sym_visibility = "private"}
  vm.import @hal.allocator.wrap.byte_buffer(%allocator : !vm.ref<!hal.allocator>, %memory_types : i32, %buffer_usage : i32, %source : !vm.buffer, %offset : i32, %length : i32) -> !vm.ref<!hal.buffer> attributes {sym_visibility = "private"}
  vm.import @hal.buffer_view.create(%buffer : !vm.ref<!hal.buffer>, %element_type : i32, %shape : i32 ...) -> !vm.ref<!hal.buffer_view> attributes {nosideeffects, sym_visibility = "private"}
  vm.import @hal.buffer_view.buffer(%buffer_view : !vm.ref<!hal.buffer_view>) -> !vm.ref<!hal.buffer> attributes {nosideeffects, sym_visibility = "private"}
  vm.import @hal.command_buffer.create(%device : !vm.ref<!hal.device>, %modes : i32, %command_categories : i32) -> !vm.ref<!hal.command_buffer> attributes {sym_visibility = "private"}
  vm.import @hal.command_buffer.begin(%command_buffer : !vm.ref<!hal.command_buffer>) attributes {sym_visibility = "private"}
  vm.import @hal.command_buffer.end(%command_buffer : !vm.ref<!hal.command_buffer>) attributes {sym_visibility = "private"}
  vm.import @hal.command_buffer.execution_barrier(%command_buffer : !vm.ref<!hal.command_buffer>, %source_stage_mask : i32, %target_stage_mask : i32, %flags : i32) attributes {sym_visibility = "private"}
  vm.import @hal.command_buffer.push_descriptor_set(%command_buffer : !vm.ref<!hal.command_buffer>, %executable_layout : !vm.ref<!hal.executable_layout>, %set : i32, %bindings : tuple<i32, !vm.ref<!hal.buffer>, i32, i32> ...) attributes {sym_visibility = "private"}
  vm.import @hal.command_buffer.dispatch(%command_buffer : !vm.ref<!hal.command_buffer>, %executable : !vm.ref<!hal.executable>, %entry_point : i32, %workgroup_x : i32, %workgroup_y : i32, %workgroup_z : i32) attributes {sym_visibility = "private"}
  vm.import @hal.descriptor_set_layout.create(%device : !vm.ref<!hal.device>, %usage_type : i32, %bindings : tuple<i32, i32, i32> ...) -> !vm.ref<!hal.descriptor_set_layout> attributes {nosideeffects, sym_visibility = "private"}
  vm.import @hal.device.allocator(%device : !vm.ref<!hal.device>) -> !vm.ref<!hal.allocator> attributes {nosideeffects, sym_visibility = "private"}
  vm.import @hal.device.match.id(%device : !vm.ref<!hal.device>, %pattern : !vm.buffer) -> i32 attributes {nosideeffects, sym_visibility = "private"}
  vm.import @hal.executable.create(%device : !vm.ref<!hal.device>, %executable_format : !vm.buffer, %executable_data : !vm.buffer, %executable_layouts : !vm.ref<!hal.executable_layout> ...) -> !vm.ref<!hal.executable> attributes {nosideeffects, sym_visibility = "private"}
  vm.import @hal.executable_layout.create(%device : !vm.ref<!hal.device>, %push_constants : i32, %set_layouts : !vm.ref<!hal.descriptor_set_layout> ...) -> !vm.ref<!hal.executable_layout> attributes {nosideeffects, sym_visibility = "private"}
  vm.import @hal.semaphore.create(%device : !vm.ref<!hal.device>, %initial_value : i32) -> !vm.ref<!hal.semaphore> attributes {nosideeffects, sym_visibility = "private"}
  vm.import @hal.semaphore.signal(%semaphore : !vm.ref<!hal.semaphore>, %new_value : i32) attributes {sym_visibility = "private"}
  vm.import @hal.semaphore.await(%semaphore : !vm.ref<!hal.semaphore>, %min_value : i32) -> i32 attributes {sym_visibility = "private"}
  vm.func @predict$sync(%arg0: !vm.ref<!hal.buffer_view>) -> !vm.ref<!hal.buffer_view> attributes {iree.reflection = {abi = "sip", abiv = 1 : i32, f = "I15!B11!d1d28d28d1R9!B6!d1d10", fv = "1", sip = "I8!S5!k0_0R3!_0"}} {
    %ref = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
    %zero = vm.const.i32.zero : i32
    %ref_0 = vm.call @hal.semaphore.create(%ref, %zero) : (!vm.ref<!hal.device>, i32) -> !vm.ref<!hal.semaphore>
    %0 = vm.call @hal.semaphore.await(%ref_0, %zero) : (!vm.ref<!hal.semaphore>, i32) -> i32
    vm.cond_br %0, ^bb2(%0 : i32), ^bb1
  ^bb1:  // pred: ^bb0
    %ref_1 = vm.call @hal.buffer_view.buffer(%arg0) : (!vm.ref<!hal.buffer_view>) -> !vm.ref<!hal.buffer>
    %ref_2 = vm.call @predict(%ref_1) : (!vm.ref<!hal.buffer>) -> !vm.ref<!hal.buffer>
    %c1 = vm.const.i32 1 : i32
    %c10 = vm.const.i32 10 : i32
    %c50331680 = vm.const.i32 50331680 : i32
    %ref_3 = vm.call.variadic @hal.buffer_view.create(%ref_2, %c50331680, [%c1, %c10]) : (!vm.ref<!hal.buffer>, i32, i32 ...) -> !vm.ref<!hal.buffer_view>
    vm.call @hal.semaphore.signal(%ref_0, %c1) : (!vm.ref<!hal.semaphore>, i32) -> ()
    %1 = vm.call @hal.semaphore.await(%ref_0, %c1) : (!vm.ref<!hal.semaphore>, i32) -> i32
    vm.cond_br %1, ^bb2(%1 : i32), ^bb3
  ^bb2(%2: i32):  // 2 preds: ^bb0, ^bb1
    vm.fail %2, "semaphore wait failed"
  ^bb3:  // pred: ^bb1
    vm.return %ref_3 : !vm.ref<!hal.buffer_view>
  }
  vm.export @predict$sync as("predict")
  vm.func @__init() {
    %ref = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
    %_utf8_dylib_971286B245550E6D = vm.const.ref.rodata @_utf8_dylib_971286B245550E6D : !vm.buffer
    %0 = vm.call @hal.device.match.id(%ref, %_utf8_dylib_971286B245550E6D) : (!vm.ref<!hal.device>, !vm.buffer) -> i32
    vm.global.store.i32 %0, @_device_match_id_0 : i32
    %ref_0 = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
    %c2 = vm.const.i32 2 : i32
    %c1 = vm.const.i32 1 : i32
    %c7 = vm.const.i32 7 : i32
    %c6 = vm.const.i32 6 : i32
    %zero = vm.const.i32.zero : i32
    %ref_1 = vm.call.variadic @hal.descriptor_set_layout.create(%ref_0, %c1, [(%zero, %c7, %c1), (%c1, %c7, %c1), (%c2, %c7, %c6)]) : (!vm.ref<!hal.device>, i32, tuple<i32, i32, i32> ...) -> !vm.ref<!hal.descriptor_set_layout>
    vm.global.store.ref %ref_1, @_descriptor_set_layout_0 : !vm.ref<!hal.descriptor_set_layout>
    %_descriptor_set_layout_0 = vm.global.load.ref @_descriptor_set_layout_0 : !vm.ref<!hal.descriptor_set_layout>
    %ref_2 = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
    %ref_3 = vm.call.variadic @hal.executable_layout.create(%ref_2, %zero, [%_descriptor_set_layout_0]) : (!vm.ref<!hal.device>, i32, !vm.ref<!hal.descriptor_set_layout> ...) -> !vm.ref<!hal.executable_layout>
    vm.global.store.ref %ref_3, @_executable_layout_0 : !vm.ref<!hal.executable_layout>
    %ref_4 = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
    %ref_5 = vm.call.variadic @hal.descriptor_set_layout.create(%ref_4, %c1, [(%zero, %c7, %c1), (%c1, %c7, %c6)]) : (!vm.ref<!hal.device>, i32, tuple<i32, i32, i32> ...) -> !vm.ref<!hal.descriptor_set_layout>
    vm.global.store.ref %ref_5, @_descriptor_set_layout_1 : !vm.ref<!hal.descriptor_set_layout>
    %_descriptor_set_layout_1 = vm.global.load.ref @_descriptor_set_layout_1 : !vm.ref<!hal.descriptor_set_layout>
    %ref_6 = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
    %ref_7 = vm.call.variadic @hal.executable_layout.create(%ref_6, %zero, [%_descriptor_set_layout_1]) : (!vm.ref<!hal.device>, i32, !vm.ref<!hal.descriptor_set_layout> ...) -> !vm.ref<!hal.executable_layout>
    vm.global.store.ref %ref_7, @_executable_layout_1 : !vm.ref<!hal.executable_layout>
    %ref_8 = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
    %c3 = vm.const.i32 3 : i32
    %ref_9 = vm.call.variadic @hal.descriptor_set_layout.create(%ref_8, %c1, [(%zero, %c7, %c1), (%c1, %c7, %c1), (%c2, %c7, %c1), (%c3, %c7, %c6)]) : (!vm.ref<!hal.device>, i32, tuple<i32, i32, i32> ...) -> !vm.ref<!hal.descriptor_set_layout>
    vm.global.store.ref %ref_9, @_descriptor_set_layout_2 : !vm.ref<!hal.descriptor_set_layout>
    %_descriptor_set_layout_2 = vm.global.load.ref @_descriptor_set_layout_2 : !vm.ref<!hal.descriptor_set_layout>
    %ref_10 = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
    %ref_11 = vm.call.variadic @hal.executable_layout.create(%ref_10, %zero, [%_descriptor_set_layout_2]) : (!vm.ref<!hal.device>, i32, !vm.ref<!hal.descriptor_set_layout> ...) -> !vm.ref<!hal.executable_layout>
    vm.global.store.ref %ref_11, @_executable_layout_2 : !vm.ref<!hal.executable_layout>
    %ref_12 = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
    %_device_match_id_0 = vm.global.load.i32 @_device_match_id_0 : i32
    vm.cond_br %_device_match_id_0, ^bb1, ^bb2
  ^bb1:  // pred: ^bb0
    %_executable_layout_0 = vm.global.load.ref @_executable_layout_0 : !vm.ref<!hal.executable_layout>
    %_executable_layout_1 = vm.global.load.ref @_executable_layout_1 : !vm.ref<!hal.executable_layout>
    %_executable_layout_2 = vm.global.load.ref @_executable_layout_2 : !vm.ref<!hal.executable_layout>
    %_utf8_dlib_F45B9BA87AEFAACB = vm.const.ref.rodata @_utf8_dlib_F45B9BA87AEFAACB : !vm.buffer
    %_mnist_linked_llvm_aot_llvm_aot_binary_dlib = vm.const.ref.rodata @_mnist_linked_llvm_aot_llvm_aot_binary_dlib : !vm.buffer
    %ref_13 = vm.call.variadic @hal.executable.create(%ref_12, %_utf8_dlib_F45B9BA87AEFAACB, %_mnist_linked_llvm_aot_llvm_aot_binary_dlib, [%_executable_layout_0, %_executable_layout_0, %_executable_layout_0, %_executable_layout_1, %_executable_layout_1, %_executable_layout_0, %_executable_layout_1, %_executable_layout_2]) : (!vm.ref<!hal.device>, !vm.buffer, !vm.buffer, !vm.ref<!hal.executable_layout> ...) -> !vm.ref<!hal.executable>
    vm.br ^bb3(%ref_13 : !vm.ref<!hal.executable>)
  ^bb2:  // pred: ^bb0
    %null = vm.const.ref.zero : !vm.ref<!hal.executable>
    vm.br ^bb3(%null : !vm.ref<!hal.executable>)
  ^bb3(%1: !vm.ref<!hal.executable>):  // 2 preds: ^bb1, ^bb2
    vm.global.store.ref %1, @_executable_mnist_linked_llvm_aot : !vm.ref<!hal.executable>
    %ref_14 = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
    %ref_15 = vm.call @hal.device.allocator(%ref_14) : (!vm.ref<!hal.device>) -> !vm.ref<!hal.allocator>
    %_const_pool_storage = vm.const.ref.rodata @_const_pool_storage : !vm.buffer
    %c407040 = vm.const.i32 407040 : i32
    %c50 = vm.const.i32 50 : i32
    %c15 = vm.const.i32 15 : i32
    %ref_16 = vm.call @hal.allocator.wrap.byte_buffer(%ref_15, %c50, %c15, %_const_pool_storage, %zero, %c407040) : (!vm.ref<!hal.allocator>, i32, i32, !vm.buffer, i32, i32) -> !vm.ref<!hal.buffer>
    vm.global.store.ref %ref_16, @_const_pool_storage_buffer : !vm.ref<!hal.buffer>
    vm.return
  }
  vm.export @__init
}

// *** IR Dump After mlir::iree_compiler::IREE::DropCompilerHintsPass ***
module  {
  vm.module @module {
    vm.global.i32 @_device_match_id_0 mutable : i32
    vm.rodata @_utf8_dylib_971286B245550E6D dense<[100, 121, 108, 105, 98, 42]> : vector<6xi8>
    vm.global.ref @_descriptor_set_layout_0 mutable : !vm.ref<!hal.descriptor_set_layout>
    vm.global.ref @_executable_layout_0 mutable : !vm.ref<!hal.executable_layout>
    vm.global.ref @_descriptor_set_layout_1 mutable : !vm.ref<!hal.descriptor_set_layout>
    vm.global.ref @_executable_layout_1 mutable : !vm.ref<!hal.executable_layout>
    vm.global.ref @_descriptor_set_layout_2 mutable : !vm.ref<!hal.descriptor_set_layout>
    vm.global.ref @_executable_layout_2 mutable : !vm.ref<!hal.executable_layout>
    vm.global.ref @_executable_mnist_linked_llvm_aot mutable : !vm.ref<!hal.executable>
    vm.rodata @_mnist_linked_llvm_aot_llvm_aot_binary_dlib opaque<"_", "0xDEADBEEF"> : vector<136794xi8>
    vm.rodata @_utf8_dlib_F45B9BA87AEFAACB dense<[68, 76, 73, 66]> : vector<4xi8>
    vm.rodata @_const_pool_storage opaque<"_", "0xDEADBEEF"> : vector<407040xi8>
    vm.global.ref @_const_pool_storage_buffer mutable : !vm.ref<!hal.buffer>
    vm.func @predict(%arg0: !vm.ref<!hal.buffer>) -> !vm.ref<!hal.buffer> attributes {noinline} {
      %ref = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
      %ref_0 = vm.call @hal.device.allocator(%ref) : (!vm.ref<!hal.device>) -> !vm.ref<!hal.allocator>
      %c40 = vm.const.i32 40 : i32
      %c50 = vm.const.i32 50 : i32
      %c14 = vm.const.i32 14 : i32
      %ref_1 = vm.call @hal.allocator.allocate(%ref_0, %c50, %c14, %c40) : (!vm.ref<!hal.allocator>, i32, i32, i32) -> !vm.ref<!hal.buffer>
      %_const_pool_storage_buffer = vm.global.load.ref @_const_pool_storage_buffer : !vm.ref<!hal.buffer>
      %c1024 = vm.const.i32 1024 : i32
      %c48 = vm.const.i32 48 : i32
      %c10 = vm.const.i32 10 : i32
      %ref_2 = vm.call @hal.allocator.allocate(%ref_0, %c48, %c10, %c1024) : (!vm.ref<!hal.allocator>, i32, i32, i32) -> !vm.ref<!hal.buffer>
      %c17 = vm.const.i32 17 : i32
      %c3 = vm.const.i32 3 : i32
      %ref_3 = vm.call @hal.command_buffer.create(%ref, %c17, %c3) : (!vm.ref<!hal.device>, i32, i32) -> !vm.ref<!hal.command_buffer>
      vm.call @hal.command_buffer.begin(%ref_3) : (!vm.ref<!hal.command_buffer>) -> ()
      %_executable_layout_0 = vm.global.load.ref @_executable_layout_0 : !vm.ref<!hal.executable_layout>
      %c3136 = vm.const.i32 3136 : i32
      %c401408 = vm.const.i32 401408 : i32
      %c512 = vm.const.i32 512 : i32
      %c1 = vm.const.i32 1 : i32
      %zero = vm.const.i32.zero : i32
      %c2 = vm.const.i32 2 : i32
      vm.call.variadic @hal.command_buffer.push_descriptor_set(%ref_3, %_executable_layout_0, %zero, [(%zero, %_const_pool_storage_buffer, %c512, %c401408), (%c1, %arg0, %zero, %c3136), (%c2, %ref_2, %zero, %c512)]) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable_layout>, i32, tuple<i32, !vm.ref<!hal.buffer>, i32, i32> ...)
      %_device_match_id_0 = vm.global.load.i32 @_device_match_id_0 : i32
      vm.cond_br %_device_match_id_0, ^bb1, ^bb2
    ^bb1:  // pred: ^bb0
      %_executable_mnist_linked_llvm_aot = vm.global.load.ref @_executable_mnist_linked_llvm_aot : !vm.ref<!hal.executable>
      vm.call @hal.command_buffer.dispatch(%ref_3, %_executable_mnist_linked_llvm_aot, %zero, %c2, %c1, %c1) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable>, i32, i32, i32, i32) -> ()
      %c20 = vm.const.i32 20 : i32
      %c5 = vm.const.i32 5 : i32
      vm.call @hal.command_buffer.execution_barrier(%ref_3, %c20, %c5, %zero) : (!vm.ref<!hal.command_buffer>, i32, i32, i32) -> ()
      vm.call.variadic @hal.command_buffer.push_descriptor_set(%ref_3, %_executable_layout_0, %zero, [(%zero, %_const_pool_storage_buffer, %zero, %c512), (%c1, %ref_2, %zero, %c512), (%c2, %ref_2, %c512, %c512)]) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable_layout>, i32, tuple<i32, !vm.ref<!hal.buffer>, i32, i32> ...)
      vm.call @hal.command_buffer.dispatch(%ref_3, %_executable_mnist_linked_llvm_aot, %c1, %c1, %c1, %c1) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable>, i32, i32, i32, i32) -> ()
      vm.call @hal.command_buffer.execution_barrier(%ref_3, %c20, %c5, %zero) : (!vm.ref<!hal.command_buffer>, i32, i32, i32) -> ()
      %c401920 = vm.const.i32 401920 : i32
      %c5120 = vm.const.i32 5120 : i32
      vm.call.variadic @hal.command_buffer.push_descriptor_set(%ref_3, %_executable_layout_0, %zero, [(%zero, %_const_pool_storage_buffer, %c401920, %c5120), (%c1, %ref_2, %c512, %c512), (%c2, %ref_2, %zero, %c40)]) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable_layout>, i32, tuple<i32, !vm.ref<!hal.buffer>, i32, i32> ...)
      vm.call @hal.command_buffer.dispatch(%ref_3, %_executable_mnist_linked_llvm_aot, %c2, %c1, %c1, %c1) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable>, i32, i32, i32, i32) -> ()
      vm.call @hal.command_buffer.execution_barrier(%ref_3, %c20, %c5, %zero) : (!vm.ref<!hal.command_buffer>, i32, i32, i32) -> ()
      %_executable_layout_1 = vm.global.load.ref @_executable_layout_1 : !vm.ref<!hal.executable_layout>
      vm.call.variadic @hal.command_buffer.push_descriptor_set(%ref_3, %_executable_layout_1, %zero, [(%zero, %ref_2, %zero, %c40), (%c1, %ref_2, %c48, %c40)]) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable_layout>, i32, tuple<i32, !vm.ref<!hal.buffer>, i32, i32> ...)
      vm.call @hal.command_buffer.dispatch(%ref_3, %_executable_mnist_linked_llvm_aot, %c3, %c1, %c1, %c1) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable>, i32, i32, i32, i32) -> ()
      vm.call @hal.command_buffer.execution_barrier(%ref_3, %c20, %c5, %zero) : (!vm.ref<!hal.command_buffer>, i32, i32, i32) -> ()
      %c96 = vm.const.i32 96 : i32
      %c4 = vm.const.i32 4 : i32
      vm.call.variadic @hal.command_buffer.push_descriptor_set(%ref_3, %_executable_layout_1, %zero, [(%zero, %ref_2, %c48, %c40), (%c1, %ref_2, %c96, %c4)]) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable_layout>, i32, tuple<i32, !vm.ref<!hal.buffer>, i32, i32> ...)
      vm.call @hal.command_buffer.dispatch(%ref_3, %_executable_mnist_linked_llvm_aot, %c4, %c1, %c1, %c1) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable>, i32, i32, i32, i32) -> ()
      vm.call @hal.command_buffer.execution_barrier(%ref_3, %c20, %c5, %zero) : (!vm.ref<!hal.command_buffer>, i32, i32, i32) -> ()
      vm.call.variadic @hal.command_buffer.push_descriptor_set(%ref_3, %_executable_layout_0, %zero, [(%zero, %ref_2, %zero, %c40), (%c1, %ref_2, %c96, %c4), (%c2, %ref_2, %c48, %c40)]) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable_layout>, i32, tuple<i32, !vm.ref<!hal.buffer>, i32, i32> ...)
      vm.call @hal.command_buffer.dispatch(%ref_3, %_executable_mnist_linked_llvm_aot, %c5, %c1, %c1, %c1) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable>, i32, i32, i32, i32) -> ()
      vm.call @hal.command_buffer.execution_barrier(%ref_3, %c20, %c5, %zero) : (!vm.ref<!hal.command_buffer>, i32, i32, i32) -> ()
      %c112 = vm.const.i32 112 : i32
      vm.call.variadic @hal.command_buffer.push_descriptor_set(%ref_3, %_executable_layout_1, %zero, [(%zero, %ref_2, %c48, %c40), (%c1, %ref_2, %c112, %c4)]) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable_layout>, i32, tuple<i32, !vm.ref<!hal.buffer>, i32, i32> ...)
      %c6 = vm.const.i32 6 : i32
      vm.call @hal.command_buffer.dispatch(%ref_3, %_executable_mnist_linked_llvm_aot, %c6, %c1, %c1, %c1) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable>, i32, i32, i32, i32) -> ()
      vm.call @hal.command_buffer.execution_barrier(%ref_3, %c20, %c5, %zero) : (!vm.ref<!hal.command_buffer>, i32, i32, i32) -> ()
      %_executable_layout_2 = vm.global.load.ref @_executable_layout_2 : !vm.ref<!hal.executable_layout>
      vm.call.variadic @hal.command_buffer.push_descriptor_set(%ref_3, %_executable_layout_2, %zero, [(%zero, %ref_2, %zero, %c40), (%c1, %ref_2, %c96, %c4), (%c2, %ref_2, %c112, %c4), (%c3, %ref_1, %zero, %c40)]) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable_layout>, i32, tuple<i32, !vm.ref<!hal.buffer>, i32, i32> ...)
      %c7 = vm.const.i32 7 : i32
      vm.call @hal.command_buffer.dispatch(%ref_3, %_executable_mnist_linked_llvm_aot, %c7, %c1, %c1, %c1) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable>, i32, i32, i32, i32) -> ()
      vm.call @hal.command_buffer.execution_barrier(%ref_3, %c20, %c5, %zero) : (!vm.ref<!hal.command_buffer>, i32, i32, i32) -> ()
      vm.call @hal.command_buffer.end(%ref_3) : (!vm.ref<!hal.command_buffer>) -> ()
      vm.call @hal.ex.submit_and_wait(%ref, %ref_3) : (!vm.ref<!hal.device>, !vm.ref<!hal.command_buffer>) -> ()
      vm.return %ref_1 : !vm.ref<!hal.buffer>
    ^bb2:  // pred: ^bb0
      vm.fail %c2, "device not supported in the compiled configuration"
    }
    vm.func @predict$async(%arg0: !vm.ref<!hal.semaphore>, %arg1: i32, %arg2: !vm.ref<!hal.buffer_view>, %arg3: !vm.ref<!hal.semaphore>, %arg4: i32) -> !vm.ref<!hal.buffer_view> {
      %0 = vm.call @hal.semaphore.await(%arg0, %arg1) : (!vm.ref<!hal.semaphore>, i32) -> i32
      vm.cond_br %0, ^bb2(%0 : i32), ^bb1
    ^bb1:  // pred: ^bb0
      %ref = vm.call @hal.buffer_view.buffer(%arg2) : (!vm.ref<!hal.buffer_view>) -> !vm.ref<!hal.buffer>
      %ref_0 = vm.call @predict(%ref) : (!vm.ref<!hal.buffer>) -> !vm.ref<!hal.buffer>
      %c1 = vm.const.i32 1 : i32
      %c10 = vm.const.i32 10 : i32
      %c50331680 = vm.const.i32 50331680 : i32
      %ref_1 = vm.call.variadic @hal.buffer_view.create(%ref_0, %c50331680, [%c1, %c10]) : (!vm.ref<!hal.buffer>, i32, i32 ...) -> !vm.ref<!hal.buffer_view>
      vm.call @hal.semaphore.signal(%arg3, %arg4) : (!vm.ref<!hal.semaphore>, i32) -> ()
      vm.return %ref_1 : !vm.ref<!hal.buffer_view>
    ^bb2(%1: i32):  // pred: ^bb0
      vm.fail %1, "semaphore wait failed"
    }
    vm.export @predict$async
    vm.import @hal.ex.shared_device() -> !vm.ref<!hal.device> attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.ex.submit_and_wait(%device : !vm.ref<!hal.device>, %command_buffer : !vm.ref<!hal.command_buffer>) attributes {sym_visibility = "private"}
    vm.import @hal.allocator.allocate(%allocator : !vm.ref<!hal.allocator>, %memory_types : i32, %buffer_usage : i32, %allocation_size : i32) -> !vm.ref<!hal.buffer> attributes {sym_visibility = "private"}
    vm.import @hal.allocator.wrap.byte_buffer(%allocator : !vm.ref<!hal.allocator>, %memory_types : i32, %buffer_usage : i32, %source : !vm.buffer, %offset : i32, %length : i32) -> !vm.ref<!hal.buffer> attributes {sym_visibility = "private"}
    vm.import @hal.buffer_view.create(%buffer : !vm.ref<!hal.buffer>, %element_type : i32, %shape : i32 ...) -> !vm.ref<!hal.buffer_view> attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.buffer_view.buffer(%buffer_view : !vm.ref<!hal.buffer_view>) -> !vm.ref<!hal.buffer> attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.command_buffer.create(%device : !vm.ref<!hal.device>, %modes : i32, %command_categories : i32) -> !vm.ref<!hal.command_buffer> attributes {sym_visibility = "private"}
    vm.import @hal.command_buffer.begin(%command_buffer : !vm.ref<!hal.command_buffer>) attributes {sym_visibility = "private"}
    vm.import @hal.command_buffer.end(%command_buffer : !vm.ref<!hal.command_buffer>) attributes {sym_visibility = "private"}
    vm.import @hal.command_buffer.execution_barrier(%command_buffer : !vm.ref<!hal.command_buffer>, %source_stage_mask : i32, %target_stage_mask : i32, %flags : i32) attributes {sym_visibility = "private"}
    vm.import @hal.command_buffer.push_descriptor_set(%command_buffer : !vm.ref<!hal.command_buffer>, %executable_layout : !vm.ref<!hal.executable_layout>, %set : i32, %bindings : tuple<i32, !vm.ref<!hal.buffer>, i32, i32> ...) attributes {sym_visibility = "private"}
    vm.import @hal.command_buffer.dispatch(%command_buffer : !vm.ref<!hal.command_buffer>, %executable : !vm.ref<!hal.executable>, %entry_point : i32, %workgroup_x : i32, %workgroup_y : i32, %workgroup_z : i32) attributes {sym_visibility = "private"}
    vm.import @hal.descriptor_set_layout.create(%device : !vm.ref<!hal.device>, %usage_type : i32, %bindings : tuple<i32, i32, i32> ...) -> !vm.ref<!hal.descriptor_set_layout> attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.device.allocator(%device : !vm.ref<!hal.device>) -> !vm.ref<!hal.allocator> attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.device.match.id(%device : !vm.ref<!hal.device>, %pattern : !vm.buffer) -> i32 attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.executable.create(%device : !vm.ref<!hal.device>, %executable_format : !vm.buffer, %executable_data : !vm.buffer, %executable_layouts : !vm.ref<!hal.executable_layout> ...) -> !vm.ref<!hal.executable> attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.executable_layout.create(%device : !vm.ref<!hal.device>, %push_constants : i32, %set_layouts : !vm.ref<!hal.descriptor_set_layout> ...) -> !vm.ref<!hal.executable_layout> attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.semaphore.create(%device : !vm.ref<!hal.device>, %initial_value : i32) -> !vm.ref<!hal.semaphore> attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.semaphore.signal(%semaphore : !vm.ref<!hal.semaphore>, %new_value : i32) attributes {sym_visibility = "private"}
    vm.import @hal.semaphore.await(%semaphore : !vm.ref<!hal.semaphore>, %min_value : i32) -> i32 attributes {sym_visibility = "private"}
    vm.func @predict$sync(%arg0: !vm.ref<!hal.buffer_view>) -> !vm.ref<!hal.buffer_view> attributes {iree.reflection = {abi = "sip", abiv = 1 : i32, f = "I15!B11!d1d28d28d1R9!B6!d1d10", fv = "1", sip = "I8!S5!k0_0R3!_0"}} {
      %ref = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
      %zero = vm.const.i32.zero : i32
      %ref_0 = vm.call @hal.semaphore.create(%ref, %zero) : (!vm.ref<!hal.device>, i32) -> !vm.ref<!hal.semaphore>
      %0 = vm.call @hal.semaphore.await(%ref_0, %zero) : (!vm.ref<!hal.semaphore>, i32) -> i32
      vm.cond_br %0, ^bb2(%0 : i32), ^bb1
    ^bb1:  // pred: ^bb0
      %ref_1 = vm.call @hal.buffer_view.buffer(%arg0) : (!vm.ref<!hal.buffer_view>) -> !vm.ref<!hal.buffer>
      %ref_2 = vm.call @predict(%ref_1) : (!vm.ref<!hal.buffer>) -> !vm.ref<!hal.buffer>
      %c1 = vm.const.i32 1 : i32
      %c10 = vm.const.i32 10 : i32
      %c50331680 = vm.const.i32 50331680 : i32
      %ref_3 = vm.call.variadic @hal.buffer_view.create(%ref_2, %c50331680, [%c1, %c10]) : (!vm.ref<!hal.buffer>, i32, i32 ...) -> !vm.ref<!hal.buffer_view>
      vm.call @hal.semaphore.signal(%ref_0, %c1) : (!vm.ref<!hal.semaphore>, i32) -> ()
      %1 = vm.call @hal.semaphore.await(%ref_0, %c1) : (!vm.ref<!hal.semaphore>, i32) -> i32
      vm.cond_br %1, ^bb2(%1 : i32), ^bb3
    ^bb2(%2: i32):  // 2 preds: ^bb0, ^bb1
      vm.fail %2, "semaphore wait failed"
    ^bb3:  // pred: ^bb1
      vm.return %ref_3 : !vm.ref<!hal.buffer_view>
    }
    vm.export @predict$sync as("predict")
    vm.func @__init() {
      %ref = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
      %_utf8_dylib_971286B245550E6D = vm.const.ref.rodata @_utf8_dylib_971286B245550E6D : !vm.buffer
      %0 = vm.call @hal.device.match.id(%ref, %_utf8_dylib_971286B245550E6D) : (!vm.ref<!hal.device>, !vm.buffer) -> i32
      vm.global.store.i32 %0, @_device_match_id_0 : i32
      %ref_0 = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
      %c2 = vm.const.i32 2 : i32
      %c1 = vm.const.i32 1 : i32
      %c7 = vm.const.i32 7 : i32
      %c6 = vm.const.i32 6 : i32
      %zero = vm.const.i32.zero : i32
      %ref_1 = vm.call.variadic @hal.descriptor_set_layout.create(%ref_0, %c1, [(%zero, %c7, %c1), (%c1, %c7, %c1), (%c2, %c7, %c6)]) : (!vm.ref<!hal.device>, i32, tuple<i32, i32, i32> ...) -> !vm.ref<!hal.descriptor_set_layout>
      vm.global.store.ref %ref_1, @_descriptor_set_layout_0 : !vm.ref<!hal.descriptor_set_layout>
      %_descriptor_set_layout_0 = vm.global.load.ref @_descriptor_set_layout_0 : !vm.ref<!hal.descriptor_set_layout>
      %ref_2 = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
      %ref_3 = vm.call.variadic @hal.executable_layout.create(%ref_2, %zero, [%_descriptor_set_layout_0]) : (!vm.ref<!hal.device>, i32, !vm.ref<!hal.descriptor_set_layout> ...) -> !vm.ref<!hal.executable_layout>
      vm.global.store.ref %ref_3, @_executable_layout_0 : !vm.ref<!hal.executable_layout>
      %ref_4 = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
      %ref_5 = vm.call.variadic @hal.descriptor_set_layout.create(%ref_4, %c1, [(%zero, %c7, %c1), (%c1, %c7, %c6)]) : (!vm.ref<!hal.device>, i32, tuple<i32, i32, i32> ...) -> !vm.ref<!hal.descriptor_set_layout>
      vm.global.store.ref %ref_5, @_descriptor_set_layout_1 : !vm.ref<!hal.descriptor_set_layout>
      %_descriptor_set_layout_1 = vm.global.load.ref @_descriptor_set_layout_1 : !vm.ref<!hal.descriptor_set_layout>
      %ref_6 = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
      %ref_7 = vm.call.variadic @hal.executable_layout.create(%ref_6, %zero, [%_descriptor_set_layout_1]) : (!vm.ref<!hal.device>, i32, !vm.ref<!hal.descriptor_set_layout> ...) -> !vm.ref<!hal.executable_layout>
      vm.global.store.ref %ref_7, @_executable_layout_1 : !vm.ref<!hal.executable_layout>
      %ref_8 = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
      %c3 = vm.const.i32 3 : i32
      %ref_9 = vm.call.variadic @hal.descriptor_set_layout.create(%ref_8, %c1, [(%zero, %c7, %c1), (%c1, %c7, %c1), (%c2, %c7, %c1), (%c3, %c7, %c6)]) : (!vm.ref<!hal.device>, i32, tuple<i32, i32, i32> ...) -> !vm.ref<!hal.descriptor_set_layout>
      vm.global.store.ref %ref_9, @_descriptor_set_layout_2 : !vm.ref<!hal.descriptor_set_layout>
      %_descriptor_set_layout_2 = vm.global.load.ref @_descriptor_set_layout_2 : !vm.ref<!hal.descriptor_set_layout>
      %ref_10 = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
      %ref_11 = vm.call.variadic @hal.executable_layout.create(%ref_10, %zero, [%_descriptor_set_layout_2]) : (!vm.ref<!hal.device>, i32, !vm.ref<!hal.descriptor_set_layout> ...) -> !vm.ref<!hal.executable_layout>
      vm.global.store.ref %ref_11, @_executable_layout_2 : !vm.ref<!hal.executable_layout>
      %ref_12 = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
      %_device_match_id_0 = vm.global.load.i32 @_device_match_id_0 : i32
      vm.cond_br %_device_match_id_0, ^bb1, ^bb2
    ^bb1:  // pred: ^bb0
      %_executable_layout_0 = vm.global.load.ref @_executable_layout_0 : !vm.ref<!hal.executable_layout>
      %_executable_layout_1 = vm.global.load.ref @_executable_layout_1 : !vm.ref<!hal.executable_layout>
      %_executable_layout_2 = vm.global.load.ref @_executable_layout_2 : !vm.ref<!hal.executable_layout>
      %_utf8_dlib_F45B9BA87AEFAACB = vm.const.ref.rodata @_utf8_dlib_F45B9BA87AEFAACB : !vm.buffer
      %_mnist_linked_llvm_aot_llvm_aot_binary_dlib = vm.const.ref.rodata @_mnist_linked_llvm_aot_llvm_aot_binary_dlib : !vm.buffer
      %ref_13 = vm.call.variadic @hal.executable.create(%ref_12, %_utf8_dlib_F45B9BA87AEFAACB, %_mnist_linked_llvm_aot_llvm_aot_binary_dlib, [%_executable_layout_0, %_executable_layout_0, %_executable_layout_0, %_executable_layout_1, %_executable_layout_1, %_executable_layout_0, %_executable_layout_1, %_executable_layout_2]) : (!vm.ref<!hal.device>, !vm.buffer, !vm.buffer, !vm.ref<!hal.executable_layout> ...) -> !vm.ref<!hal.executable>
      vm.br ^bb3(%ref_13 : !vm.ref<!hal.executable>)
    ^bb2:  // pred: ^bb0
      %null = vm.const.ref.zero : !vm.ref<!hal.executable>
      vm.br ^bb3(%null : !vm.ref<!hal.executable>)
    ^bb3(%1: !vm.ref<!hal.executable>):  // 2 preds: ^bb1, ^bb2
      vm.global.store.ref %1, @_executable_mnist_linked_llvm_aot : !vm.ref<!hal.executable>
      %ref_14 = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
      %ref_15 = vm.call @hal.device.allocator(%ref_14) : (!vm.ref<!hal.device>) -> !vm.ref<!hal.allocator>
      %_const_pool_storage = vm.const.ref.rodata @_const_pool_storage : !vm.buffer
      %c407040 = vm.const.i32 407040 : i32
      %c50 = vm.const.i32 50 : i32
      %c15 = vm.const.i32 15 : i32
      %ref_16 = vm.call @hal.allocator.wrap.byte_buffer(%ref_15, %c50, %c15, %_const_pool_storage, %zero, %c407040) : (!vm.ref<!hal.allocator>, i32, i32, !vm.buffer, i32, i32) -> !vm.ref<!hal.buffer>
      vm.global.store.ref %ref_16, @_const_pool_storage_buffer : !vm.ref<!hal.buffer>
      vm.return
    }
    vm.export @__init
  }
}


